var _C = Object.defineProperty;
var MC = (e, t, n) => t in e ? _C(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var ze = (e, t, n) => MC(e, typeof t != "symbol" ? t + "" : t, n);
import { reactive as zt, computed as k, ref as Y, watch as pe, onMounted as rt, onUnmounted as ni, onScopeDispose as Xn, effectScope as n2, shallowRef as Ve, watchEffect as jt, toRefs as Tr, capitalize as js, unref as X, Fragment as ge, isVNode as VC, Comment as TC, warn as Ad, getCurrentInstance as Pl, inject as ct, provide as Tt, defineComponent as Sn, h as G, camelize as W4, toRaw as At, createVNode as p, mergeProps as fe, onBeforeUnmount as mn, readonly as a2, onDeactivated as q4, onActivated as LC, nextTick as et, isRef as Mi, resolveDynamicComponent as Lr, toRef as ue, TransitionGroup as i2, Transition as Jn, Teleport as zs, withDirectives as Ct, vShow as Dn, resolveDirective as xa, resolveComponent as Pe, render as Ec, onBeforeMount as U4, onUpdated as QC, Text as AC, markRaw as DC, cloneVNode as RC, createTextVNode as Ee, onBeforeUpdate as G4, withModifiers as $t, toDisplayString as xe, vModelText as IC, useSlots as Rl, createBlock as Ce, openBlock as N, createSlots as Xt, withCtx as re, renderSlot as ke, createElementBlock as ee, createElementVNode as ie, mergeModels as Nc, useModel as l2, createCommentVNode as de, renderList as Ge, normalizeClass as Ie, normalizeStyle as Ot, toValue as nn, useAttrs as K4, toHandlers as BC, normalizeProps as Pt, guardReactiveProps as Jt, createStaticVNode as ZC, withKeys as Fi, getCurrentScope as EC } from "vue";
var Fs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Xs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var J4 = { exports: {} };
(function(e, t) {
  (function(n, a) {
    e.exports = a();
  })(Fs, function() {
    var n = 1e3, a = 6e4, i = 36e5, l = "millisecond", r = "second", s = "minute", o = "hour", u = "day", c = "week", d = "month", f = "quarter", h = "year", m = "date", g = "Invalid Date", v = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(L) {
      var A = ["th", "st", "nd", "rd"], D = L % 100;
      return "[" + L + (A[(D - 20) % 10] || A[D] || A[0]) + "]";
    } }, C = function(L, A, D) {
      var B = String(L);
      return !B || B.length >= A ? L : "" + Array(A + 1 - B.length).join(D) + L;
    }, S = { s: C, z: function(L) {
      var A = -L.utcOffset(), D = Math.abs(A), B = Math.floor(D / 60), j = D % 60;
      return (A <= 0 ? "+" : "-") + C(B, 2, "0") + ":" + C(j, 2, "0");
    }, m: function L(A, D) {
      if (A.date() < D.date()) return -L(D, A);
      var B = 12 * (D.year() - A.year()) + (D.month() - A.month()), j = A.clone().add(B, d), I = D - j < 0, Z = A.clone().add(B + (I ? -1 : 1), d);
      return +(-(B + (D - j) / (I ? j - Z : Z - j)) || 0);
    }, a: function(L) {
      return L < 0 ? Math.ceil(L) || 0 : Math.floor(L);
    }, p: function(L) {
      return { M: d, y: h, w: c, d: u, D: m, h: o, m: s, s: r, ms: l, Q: f }[L] || String(L || "").toLowerCase().replace(/s$/, "");
    }, u: function(L) {
      return L === void 0;
    } }, x = "en", w = {};
    w[x] = b;
    var V = "$isDayjsObject", _ = function(L) {
      return L instanceof M || !(!L || !L[V]);
    }, O = function L(A, D, B) {
      var j;
      if (!A) return x;
      if (typeof A == "string") {
        var I = A.toLowerCase();
        w[I] && (j = I), D && (w[I] = D, j = I);
        var Z = A.split("-");
        if (!j && Z.length > 1) return L(Z[0]);
      } else {
        var R = A.name;
        w[R] = A, j = R;
      }
      return !B && j && (x = j), j || !B && x;
    }, $ = function(L, A) {
      if (_(L)) return L.clone();
      var D = typeof A == "object" ? A : {};
      return D.date = L, D.args = arguments, new M(D);
    }, P = S;
    P.l = O, P.i = _, P.w = function(L, A) {
      return $(L, { locale: A.$L, utc: A.$u, x: A.$x, $offset: A.$offset });
    };
    var M = function() {
      function L(D) {
        this.$L = O(D.locale, null, !0), this.parse(D), this.$x = this.$x || D.x || {}, this[V] = !0;
      }
      var A = L.prototype;
      return A.parse = function(D) {
        this.$d = function(B) {
          var j = B.date, I = B.utc;
          if (j === null) return /* @__PURE__ */ new Date(NaN);
          if (P.u(j)) return /* @__PURE__ */ new Date();
          if (j instanceof Date) return new Date(j);
          if (typeof j == "string" && !/Z$/i.test(j)) {
            var Z = j.match(v);
            if (Z) {
              var R = Z[2] - 1 || 0, J = (Z[7] || "0").substring(0, 3);
              return I ? new Date(Date.UTC(Z[1], R, Z[3] || 1, Z[4] || 0, Z[5] || 0, Z[6] || 0, J)) : new Date(Z[1], R, Z[3] || 1, Z[4] || 0, Z[5] || 0, Z[6] || 0, J);
            }
          }
          return new Date(j);
        }(D), this.init();
      }, A.init = function() {
        var D = this.$d;
        this.$y = D.getFullYear(), this.$M = D.getMonth(), this.$D = D.getDate(), this.$W = D.getDay(), this.$H = D.getHours(), this.$m = D.getMinutes(), this.$s = D.getSeconds(), this.$ms = D.getMilliseconds();
      }, A.$utils = function() {
        return P;
      }, A.isValid = function() {
        return this.$d.toString() !== g;
      }, A.isSame = function(D, B) {
        var j = $(D);
        return this.startOf(B) <= j && j <= this.endOf(B);
      }, A.isAfter = function(D, B) {
        return $(D) < this.startOf(B);
      }, A.isBefore = function(D, B) {
        return this.endOf(B) < $(D);
      }, A.$g = function(D, B, j) {
        return P.u(D) ? this[B] : this.set(j, D);
      }, A.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, A.valueOf = function() {
        return this.$d.getTime();
      }, A.startOf = function(D, B) {
        var j = this, I = !!P.u(B) || B, Z = P.p(D), R = function(se, Se) {
          var U = P.w(j.$u ? Date.UTC(j.$y, Se, se) : new Date(j.$y, Se, se), j);
          return I ? U : U.endOf(u);
        }, J = function(se, Se) {
          return P.w(j.toDate()[se].apply(j.toDate("s"), (I ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Se)), j);
        }, F = this.$W, q = this.$M, z = this.$D, E = "set" + (this.$u ? "UTC" : "");
        switch (Z) {
          case h:
            return I ? R(1, 0) : R(31, 11);
          case d:
            return I ? R(1, q) : R(0, q + 1);
          case c:
            var Q = this.$locale().weekStart || 0, W = (F < Q ? F + 7 : F) - Q;
            return R(I ? z - W : z + (6 - W), q);
          case u:
          case m:
            return J(E + "Hours", 0);
          case o:
            return J(E + "Minutes", 1);
          case s:
            return J(E + "Seconds", 2);
          case r:
            return J(E + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, A.endOf = function(D) {
        return this.startOf(D, !1);
      }, A.$set = function(D, B) {
        var j, I = P.p(D), Z = "set" + (this.$u ? "UTC" : ""), R = (j = {}, j[u] = Z + "Date", j[m] = Z + "Date", j[d] = Z + "Month", j[h] = Z + "FullYear", j[o] = Z + "Hours", j[s] = Z + "Minutes", j[r] = Z + "Seconds", j[l] = Z + "Milliseconds", j)[I], J = I === u ? this.$D + (B - this.$W) : B;
        if (I === d || I === h) {
          var F = this.clone().set(m, 1);
          F.$d[R](J), F.init(), this.$d = F.set(m, Math.min(this.$D, F.daysInMonth())).$d;
        } else R && this.$d[R](J);
        return this.init(), this;
      }, A.set = function(D, B) {
        return this.clone().$set(D, B);
      }, A.get = function(D) {
        return this[P.p(D)]();
      }, A.add = function(D, B) {
        var j, I = this;
        D = Number(D);
        var Z = P.p(B), R = function(q) {
          var z = $(I);
          return P.w(z.date(z.date() + Math.round(q * D)), I);
        };
        if (Z === d) return this.set(d, this.$M + D);
        if (Z === h) return this.set(h, this.$y + D);
        if (Z === u) return R(1);
        if (Z === c) return R(7);
        var J = (j = {}, j[s] = a, j[o] = i, j[r] = n, j)[Z] || 1, F = this.$d.getTime() + D * J;
        return P.w(F, this);
      }, A.subtract = function(D, B) {
        return this.add(-1 * D, B);
      }, A.format = function(D) {
        var B = this, j = this.$locale();
        if (!this.isValid()) return j.invalidDate || g;
        var I = D || "YYYY-MM-DDTHH:mm:ssZ", Z = P.z(this), R = this.$H, J = this.$m, F = this.$M, q = j.weekdays, z = j.months, E = j.meridiem, Q = function(Se, U, ne, K) {
          return Se && (Se[U] || Se(B, I)) || ne[U].slice(0, K);
        }, W = function(Se) {
          return P.s(R % 12 || 12, Se, "0");
        }, se = E || function(Se, U, ne) {
          var K = Se < 12 ? "AM" : "PM";
          return ne ? K.toLowerCase() : K;
        };
        return I.replace(y, function(Se, U) {
          return U || function(ne) {
            switch (ne) {
              case "YY":
                return String(B.$y).slice(-2);
              case "YYYY":
                return P.s(B.$y, 4, "0");
              case "M":
                return F + 1;
              case "MM":
                return P.s(F + 1, 2, "0");
              case "MMM":
                return Q(j.monthsShort, F, z, 3);
              case "MMMM":
                return Q(z, F);
              case "D":
                return B.$D;
              case "DD":
                return P.s(B.$D, 2, "0");
              case "d":
                return String(B.$W);
              case "dd":
                return Q(j.weekdaysMin, B.$W, q, 2);
              case "ddd":
                return Q(j.weekdaysShort, B.$W, q, 3);
              case "dddd":
                return q[B.$W];
              case "H":
                return String(R);
              case "HH":
                return P.s(R, 2, "0");
              case "h":
                return W(1);
              case "hh":
                return W(2);
              case "a":
                return se(R, J, !0);
              case "A":
                return se(R, J, !1);
              case "m":
                return String(J);
              case "mm":
                return P.s(J, 2, "0");
              case "s":
                return String(B.$s);
              case "ss":
                return P.s(B.$s, 2, "0");
              case "SSS":
                return P.s(B.$ms, 3, "0");
              case "Z":
                return Z;
            }
            return null;
          }(Se) || Z.replace(":", "");
        });
      }, A.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, A.diff = function(D, B, j) {
        var I, Z = this, R = P.p(B), J = $(D), F = (J.utcOffset() - this.utcOffset()) * a, q = this - J, z = function() {
          return P.m(Z, J);
        };
        switch (R) {
          case h:
            I = z() / 12;
            break;
          case d:
            I = z();
            break;
          case f:
            I = z() / 3;
            break;
          case c:
            I = (q - F) / 6048e5;
            break;
          case u:
            I = (q - F) / 864e5;
            break;
          case o:
            I = q / i;
            break;
          case s:
            I = q / a;
            break;
          case r:
            I = q / n;
            break;
          default:
            I = q;
        }
        return j ? I : P.a(I);
      }, A.daysInMonth = function() {
        return this.endOf(d).$D;
      }, A.$locale = function() {
        return w[this.$L];
      }, A.locale = function(D, B) {
        if (!D) return this.$L;
        var j = this.clone(), I = O(D, B, !0);
        return I && (j.$L = I), j;
      }, A.clone = function() {
        return P.w(this.$d, this);
      }, A.toDate = function() {
        return new Date(this.valueOf());
      }, A.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, A.toISOString = function() {
        return this.$d.toISOString();
      }, A.toString = function() {
        return this.$d.toUTCString();
      }, L;
    }(), T = M.prototype;
    return $.prototype = T, [["$ms", l], ["$s", r], ["$m", s], ["$H", o], ["$W", u], ["$M", d], ["$y", h], ["$D", m]].forEach(function(L) {
      T[L[1]] = function(A) {
        return this.$g(A, L[0], L[1]);
      };
    }), $.extend = function(L, A) {
      return L.$i || (L(A, M, $), L.$i = !0), $;
    }, $.locale = O, $.isDayjs = _, $.unix = function(L) {
      return $(1e3 * L);
    }, $.en = w[x], $.Ls = w, $.p = {}, $;
  });
})(J4);
var NC = J4.exports;
const Li = /* @__PURE__ */ Xs(NC);
var e5 = { exports: {} };
(function(e, t) {
  (function(n, a) {
    e.exports = a();
  })(Fs, function() {
    return function(n, a) {
      a.prototype.isSameOrAfter = function(i, l) {
        return this.isSame(i, l) || this.isAfter(i, l);
      };
    };
  });
})(e5);
var HC = e5.exports;
const jC = /* @__PURE__ */ Xs(HC);
var t5 = { exports: {} };
(function(e, t) {
  (function(n, a) {
    e.exports = a();
  })(Fs, function() {
    return function(n, a) {
      a.prototype.isSameOrBefore = function(i, l) {
        return this.isSame(i, l) || this.isBefore(i, l);
      };
    };
  });
})(t5);
var zC = t5.exports;
const FC = /* @__PURE__ */ Xs(zC);
var n5 = { exports: {} };
(function(e, t) {
  (function(n, a) {
    e.exports = a();
  })(Fs, function() {
    var n = "minute", a = /[+-]\d\d(?::?\d\d)?/g, i = /([+-]|\d\d)/g;
    return function(l, r, s) {
      var o = r.prototype;
      s.utc = function(g) {
        var v = { date: g, utc: !0, args: arguments };
        return new r(v);
      }, o.utc = function(g) {
        var v = s(this.toDate(), { locale: this.$L, utc: !0 });
        return g ? v.add(this.utcOffset(), n) : v;
      }, o.local = function() {
        return s(this.toDate(), { locale: this.$L, utc: !1 });
      };
      var u = o.parse;
      o.parse = function(g) {
        g.utc && (this.$u = !0), this.$utils().u(g.$offset) || (this.$offset = g.$offset), u.call(this, g);
      };
      var c = o.init;
      o.init = function() {
        if (this.$u) {
          var g = this.$d;
          this.$y = g.getUTCFullYear(), this.$M = g.getUTCMonth(), this.$D = g.getUTCDate(), this.$W = g.getUTCDay(), this.$H = g.getUTCHours(), this.$m = g.getUTCMinutes(), this.$s = g.getUTCSeconds(), this.$ms = g.getUTCMilliseconds();
        } else c.call(this);
      };
      var d = o.utcOffset;
      o.utcOffset = function(g, v) {
        var y = this.$utils().u;
        if (y(g)) return this.$u ? 0 : y(this.$offset) ? d.call(this) : this.$offset;
        if (typeof g == "string" && (g = function(x) {
          x === void 0 && (x = "");
          var w = x.match(a);
          if (!w) return null;
          var V = ("" + w[0]).match(i) || ["-", 0, 0], _ = V[0], O = 60 * +V[1] + +V[2];
          return O === 0 ? 0 : _ === "+" ? O : -O;
        }(g), g === null)) return this;
        var b = Math.abs(g) <= 16 ? 60 * g : g, C = this;
        if (v) return C.$offset = b, C.$u = g === 0, C;
        if (g !== 0) {
          var S = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (C = this.local().add(b + S, n)).$offset = b, C.$x.$localOffset = S;
        } else C = this.utc();
        return C;
      };
      var f = o.format;
      o.format = function(g) {
        var v = g || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return f.call(this, v);
      }, o.valueOf = function() {
        var g = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * g;
      }, o.isUTC = function() {
        return !!this.$u;
      }, o.toISOString = function() {
        return this.toDate().toISOString();
      }, o.toString = function() {
        return this.toDate().toUTCString();
      };
      var h = o.toDate;
      o.toDate = function(g) {
        return g === "s" && this.$offset ? s(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : h.call(this);
      };
      var m = o.diff;
      o.diff = function(g, v, y) {
        if (g && this.$u === g.$u) return m.call(this, g, v, y);
        var b = this.local(), C = s(g).local();
        return m.call(b, C, v, y);
      };
    };
  });
})(n5);
var XC = n5.exports;
const YC = /* @__PURE__ */ Xs(XC);
var a5 = { exports: {} };
(function(e, t) {
  (function(n, a) {
    e.exports = a();
  })(Fs, function() {
    var n = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, a = {};
    return function(i, l, r) {
      var s, o = function(f, h, m) {
        m === void 0 && (m = {});
        var g = new Date(f), v = function(y, b) {
          b === void 0 && (b = {});
          var C = b.timeZoneName || "short", S = y + "|" + C, x = a[S];
          return x || (x = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: y, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: C }), a[S] = x), x;
        }(h, m);
        return v.formatToParts(g);
      }, u = function(f, h) {
        for (var m = o(f, h), g = [], v = 0; v < m.length; v += 1) {
          var y = m[v], b = y.type, C = y.value, S = n[b];
          S >= 0 && (g[S] = parseInt(C, 10));
        }
        var x = g[3], w = x === 24 ? 0 : x, V = g[0] + "-" + g[1] + "-" + g[2] + " " + w + ":" + g[4] + ":" + g[5] + ":000", _ = +f;
        return (r.utc(V).valueOf() - (_ -= _ % 1e3)) / 6e4;
      }, c = l.prototype;
      c.tz = function(f, h) {
        f === void 0 && (f = s);
        var m, g = this.utcOffset(), v = this.toDate(), y = v.toLocaleString("en-US", { timeZone: f }), b = Math.round((v - new Date(y)) / 1e3 / 60), C = 15 * -Math.round(v.getTimezoneOffset() / 15) - b;
        if (!Number(C)) m = this.utcOffset(0, h);
        else if (m = r(y, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(C, !0), h) {
          var S = m.utcOffset();
          m = m.add(g - S, "minute");
        }
        return m.$x.$timezone = f, m;
      }, c.offsetName = function(f) {
        var h = this.$x.$timezone || r.tz.guess(), m = o(this.valueOf(), h, { timeZoneName: f }).find(function(g) {
          return g.type.toLowerCase() === "timezonename";
        });
        return m && m.value;
      };
      var d = c.startOf;
      c.startOf = function(f, h) {
        if (!this.$x || !this.$x.$timezone) return d.call(this, f, h);
        var m = r(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
        return d.call(m, f, h).tz(this.$x.$timezone, !0);
      }, r.tz = function(f, h, m) {
        var g = m && h, v = m || h || s, y = u(+r(), v);
        if (typeof f != "string") return r(f).tz(v);
        var b = function(w, V, _) {
          var O = w - 60 * V * 1e3, $ = u(O, _);
          if (V === $) return [O, V];
          var P = u(O -= 60 * ($ - V) * 1e3, _);
          return $ === P ? [O, $] : [w - 60 * Math.min($, P) * 1e3, Math.max($, P)];
        }(r.utc(f, g).valueOf(), y, v), C = b[0], S = b[1], x = r(C).utcOffset(S);
        return x.$x.$timezone = v, x;
      }, r.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, r.tz.setDefault = function(f) {
        s = f;
      };
    };
  });
})(a5);
var WC = a5.exports;
const qC = /* @__PURE__ */ Xs(WC);
var i5 = { exports: {} };
(function(e, t) {
  (function(n, a) {
    e.exports = a();
  })(Fs, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, a = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, i = /\d/, l = /\d\d/, r = /\d\d?/, s = /\d*[^-_:/,()\s\d]+/, o = {}, u = function(v) {
      return (v = +v) + (v > 68 ? 1900 : 2e3);
    }, c = function(v) {
      return function(y) {
        this[v] = +y;
      };
    }, d = [/[+-]\d\d:?(\d\d)?|Z/, function(v) {
      (this.zone || (this.zone = {})).offset = function(y) {
        if (!y || y === "Z") return 0;
        var b = y.match(/([+-]|\d\d)/g), C = 60 * b[1] + (+b[2] || 0);
        return C === 0 ? 0 : b[0] === "+" ? -C : C;
      }(v);
    }], f = function(v) {
      var y = o[v];
      return y && (y.indexOf ? y : y.s.concat(y.f));
    }, h = function(v, y) {
      var b, C = o.meridiem;
      if (C) {
        for (var S = 1; S <= 24; S += 1) if (v.indexOf(C(S, 0, y)) > -1) {
          b = S > 12;
          break;
        }
      } else b = v === (y ? "pm" : "PM");
      return b;
    }, m = { A: [s, function(v) {
      this.afternoon = h(v, !1);
    }], a: [s, function(v) {
      this.afternoon = h(v, !0);
    }], Q: [i, function(v) {
      this.month = 3 * (v - 1) + 1;
    }], S: [i, function(v) {
      this.milliseconds = 100 * +v;
    }], SS: [l, function(v) {
      this.milliseconds = 10 * +v;
    }], SSS: [/\d{3}/, function(v) {
      this.milliseconds = +v;
    }], s: [r, c("seconds")], ss: [r, c("seconds")], m: [r, c("minutes")], mm: [r, c("minutes")], H: [r, c("hours")], h: [r, c("hours")], HH: [r, c("hours")], hh: [r, c("hours")], D: [r, c("day")], DD: [l, c("day")], Do: [s, function(v) {
      var y = o.ordinal, b = v.match(/\d+/);
      if (this.day = b[0], y) for (var C = 1; C <= 31; C += 1) y(C).replace(/\[|\]/g, "") === v && (this.day = C);
    }], w: [r, c("week")], ww: [l, c("week")], M: [r, c("month")], MM: [l, c("month")], MMM: [s, function(v) {
      var y = f("months"), b = (f("monthsShort") || y.map(function(C) {
        return C.slice(0, 3);
      })).indexOf(v) + 1;
      if (b < 1) throw new Error();
      this.month = b % 12 || b;
    }], MMMM: [s, function(v) {
      var y = f("months").indexOf(v) + 1;
      if (y < 1) throw new Error();
      this.month = y % 12 || y;
    }], Y: [/[+-]?\d+/, c("year")], YY: [l, function(v) {
      this.year = u(v);
    }], YYYY: [/\d{4}/, c("year")], Z: d, ZZ: d };
    function g(v) {
      var y, b;
      y = v, b = o && o.formats;
      for (var C = (v = y.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function($, P, M) {
        var T = M && M.toUpperCase();
        return P || b[M] || n[M] || b[T].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(L, A, D) {
          return A || D.slice(1);
        });
      })).match(a), S = C.length, x = 0; x < S; x += 1) {
        var w = C[x], V = m[w], _ = V && V[0], O = V && V[1];
        C[x] = O ? { regex: _, parser: O } : w.replace(/^\[|\]$/g, "");
      }
      return function($) {
        for (var P = {}, M = 0, T = 0; M < S; M += 1) {
          var L = C[M];
          if (typeof L == "string") T += L.length;
          else {
            var A = L.regex, D = L.parser, B = $.slice(T), j = A.exec(B)[0];
            D.call(P, j), $ = $.replace(j, "");
          }
        }
        return function(I) {
          var Z = I.afternoon;
          if (Z !== void 0) {
            var R = I.hours;
            Z ? R < 12 && (I.hours += 12) : R === 12 && (I.hours = 0), delete I.afternoon;
          }
        }(P), P;
      };
    }
    return function(v, y, b) {
      b.p.customParseFormat = !0, v && v.parseTwoDigitYear && (u = v.parseTwoDigitYear);
      var C = y.prototype, S = C.parse;
      C.parse = function(x) {
        var w = x.date, V = x.utc, _ = x.args;
        this.$u = V;
        var O = _[1];
        if (typeof O == "string") {
          var $ = _[2] === !0, P = _[3] === !0, M = $ || P, T = _[2];
          P && (T = _[2]), o = this.$locale(), !$ && T && (o = b.Ls[T]), this.$d = function(B, j, I, Z) {
            try {
              if (["x", "X"].indexOf(j) > -1) return new Date((j === "X" ? 1e3 : 1) * B);
              var R = g(j)(B), J = R.year, F = R.month, q = R.day, z = R.hours, E = R.minutes, Q = R.seconds, W = R.milliseconds, se = R.zone, Se = R.week, U = /* @__PURE__ */ new Date(), ne = q || (J || F ? 1 : U.getDate()), K = J || U.getFullYear(), te = 0;
              J && !F || (te = F > 0 ? F - 1 : U.getMonth());
              var H, ce = z || 0, he = E || 0, Oe = Q || 0, je = W || 0;
              return se ? new Date(Date.UTC(K, te, ne, ce, he, Oe, je + 60 * se.offset * 1e3)) : I ? new Date(Date.UTC(K, te, ne, ce, he, Oe, je)) : (H = new Date(K, te, ne, ce, he, Oe, je), Se && (H = Z(H).week(Se).toDate()), H);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }(w, O, V, b), this.init(), T && T !== !0 && (this.$L = this.locale(T).$L), M && w != this.format(O) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
        } else if (O instanceof Array) for (var L = O.length, A = 1; A <= L; A += 1) {
          _[1] = O[A - 1];
          var D = b.apply(this, _);
          if (D.isValid()) {
            this.$d = D.$d, this.$L = D.$L, this.init();
            break;
          }
          A === L && (this.$d = /* @__PURE__ */ new Date(""));
        }
        else S.call(this, x);
      };
    };
  });
})(i5);
var UC = i5.exports;
const GC = /* @__PURE__ */ Xs(UC);
Li.extend(YC);
Li.extend(qC);
Li.extend(GC);
Li.extend(jC);
Li.extend(FC);
const KC = ["YYYY-MM-DD", "YYYY/MM/DD", "YYYYMMDD", "YYYY-MM-DD HH:mm:ss", "YYYY-MM-DDTHH:mm:ss"];
let Dd = "Asia/Seoul";
const Rd = "YYYY-MM-DD";
function JC(e) {
  e.timezone && (Dd = e.timezone);
}
const ew = (e) => {
  const t = Li(e);
  return t.isValid() ? t : null;
};
function tw(e = Rd) {
  return Li().tz(Dd).format(e);
}
function nw(e, t, n, a = Rd) {
  return Li(e).tz(Dd).add(t, n).format(a);
}
function aw(e, t = Rd) {
  return e ? Li(e).tz(Dd).format(t) : (console.error("날짜를 입력해주세요."), null);
}
function iw(e, t = KC) {
  if (typeof e != "string" || !t || t.length === 0)
    return !1;
  for (const n of t)
    if (Li(e, n, !0).isValid())
      return !0;
  return !1;
}
const Ma = {
  defaultDateFormat: Rd,
  setDateConfig: JC,
  parseDate: ew,
  getCurrentDate: tw,
  calculateDate: nw,
  getFormattedDate: aw,
  isValidDateFormat: iw
}, lw = /^[a-zA-Z]+$/, rw = /^[a-zA-Z0-9-]+$/, sw = /[^a-zA-Z0-9!@#$%^&*(),.?":;{}|<>~`'[\]\\/\-_+=]/g, ow = /[\u3131-\u318E\uAC00-\uD7A3]/g, uw = /(?:www\.)?([a-zA-Z0-9-]+)\.([a-zA-Z]{2,})(?:\.[a-zA-Z]{2,})?$/, cw = { REG_ALLOW_ENG: lw, REG_ALLOW_ENG_NUM_HYPHEN: rw, REG_ALLOW_ENG_NUM_AND_SPECIAL_CHARS: sw, REG_ALLOW_KOR: ow, REG_DOMAIN: uw }, dw = [void 0, null, "", "undefined"], fw = (e) => {
  var n;
  const t = (n = e == null ? void 0 : e.toString()) == null ? void 0 : n.trim();
  return !!dw.includes(t);
}, hw = (e) => {
  if (typeof e != "string")
    throw Error("Invalid stringData type");
  return e.replace(cw.REG_ALLOW_KOR, "");
}, mw = (e, t) => e.replace(/{([a-zA-Z]+)}/g, (n, a) => t[a]), l5 = {
  isEmpty: fw,
  removeKoreanCharacters: hw,
  resolvePathVariable: mw
}, Pv = ["get", "post", "put", "delete", "patch"], vw = (e, t, n) => {
  let a = e;
  return t || (a = a.replace(/\/accounts\/\{accountId\}/, "")), n || (a = a.replace(/\/tenants\/\{tenantId\}/, "")), a = a.replace(/\{(\w+)\}/g, (i, l) => ({
    accountId: t,
    tenantId: n
  })[l] ?? `{${l}}`), a;
}, xee = (e, t, n, a) => {
  if (!Pv.includes(t))
    throw new Error(`Unsupported HTTP method: ${t}. Supported methods are: ${Pv.join(", ")}`);
  return (i, ...l) => {
    const r = vw(i, n, a);
    return e[t](r, ...l);
  };
}, $v = ["new", "detail", "update"], Pee = (e) => {
  const t = zt({
    open: !1,
    mode: "",
    data: null
  }), n = ({ mode: r, data: s }) => {
    if (!$v.includes(r))
      throw Error("invalid modalType");
    t.open = !0, t.mode = r, t.data = s;
  }, a = () => {
    t.open = !1, t.mode = "", t.data = null;
  }, i = (r) => {
    if (!$v.includes(r))
      throw Error("invalid modalType");
    t.mode = r;
  };
  return { modalProps: k(() => ({
    ...t,
    closeModal: a,
    changeMode: i,
    getDatas: e
  })), openModal: n, closeModal: a };
}, _v = Object.freeze({
  SERVICE_GROUP_UUID: "STRATO_SG_UUID",
  SERVICE_GROUP_NAME: "STRATO_SG_NAME",
  PROJECT: "STRATO_INFRA_PROJECT",
  // project
  PER_PAGES: "STRATO_PER_PAGES"
}), $ee = Object.freeze({
  STRATO_SERVICE_MENUS: "STRATO_SG_MENUS",
  STRATO_INFRA_MENU: "STRATO_INFRA_MENU",
  STRATO_INFRA_MENU_FLAT: "STRATO_INFRA_MENU_FLAT",
  STRATO_TENANT_SELECTABLE: "STRATO_TENANT_SELECTABLE"
}), _ee = Object.freeze({
  LOCAL_ACCESS: "local_access_token",
  LOCAL_REFRESH: "local_refresh_token"
}), Mv = {
  SLIDE_PANEL: "SLIDE_PANEL"
}, gw = Object.freeze([
  { text: "10", value: 10 },
  { text: "15", value: 15 },
  { text: "20", value: 20 }
]), Mee = (e) => {
  const t = Y(1), n = Y([]), a = Y(localStorage.getItem(_v.PER_PAGES) || gw[0].value), i = Y([]), l = (c) => {
    t.value = c;
  }, r = (c) => {
    a.value = c;
  }, s = (c) => {
    console.log(c), i.value = c;
  }, o = () => {
    l(1), e == null || e(), s([]);
  };
  return pe(a, (c) => {
    localStorage.setItem(_v.PER_PAGES, c);
  }), rt(() => {
    e && typeof e == "function" && e().then();
  }), { pageNum: t, searchs: n, perPages: a, checkedList: i, setPage: l, setPerPages: r, setCheckedList: s, onRefresh: o };
};
function Vee(e) {
  const t = Y(!1), n = Y(!1), a = () => {
    t.value = !0;
  }, i = () => {
    t.value = !1, n.value = !1;
  }, l = (r) => {
    n.value = r;
  };
  return {
    slidePanelProps: k(() => ({
      ...e,
      isOpen: t.value,
      isMinimized: n.value,
      onClose: i,
      "onUpdate:isMinimized": l
    })),
    openSlidePanel: a,
    closeSlidePanel: i
  };
}
const r5 = (e, t, n, a = null) => {
  const i = (s) => {
    const o = a && a.value && a.value.contains(s.target);
    e.value && !e.value.contains(s.target) && !o && t();
  }, l = () => {
    window.addEventListener("mousedown", i);
  }, r = () => {
    window.removeEventListener("mousedown", i);
  };
  pe(n, (s) => {
    s ? l() : r();
  }), ni(() => {
    r();
  });
}, pw = {
  badge: "Badge",
  open: "Open",
  close: "Close",
  dismiss: "Dismiss",
  confirmEdit: {
    ok: "OK",
    cancel: "Cancel"
  },
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    }
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more",
    today: "Today"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM",
    title: "Select Time"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  stepper: {
    next: "Next",
    prev: "Previous"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "Loading...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  }
}, yw = {
  badge: "배지",
  open: "Open",
  close: "닫기",
  dismiss: "Dismiss",
  confirmEdit: {
    ok: "OK",
    cancel: "Cancel"
  },
  dataIterator: {
    noResultsText: "일치하는 항목이 없습니다.",
    loadingText: "불러오는 중..."
  },
  dataTable: {
    itemsPerPageText: "페이지 당 행 수:",
    ariaLabel: {
      sortDescending: "내림차순 정렬.",
      sortAscending: "오름차순 정렬.",
      sortNone: "정렬하지 않음.",
      activateNone: "정렬을 취소하려면 활성화하세요.",
      activateDescending: "내림차순 정렬을 위해 활성화하세요.",
      activateAscending: "오름차순 정렬을 위해 활성화하세요."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "페이지 당 항목 수:",
    itemsPerPageAll: "전체",
    nextPage: "다음 페이지",
    prevPage: "이전 페이지",
    firstPage: "첫 페이지",
    lastPage: "마지막 페이지",
    pageText: "{2} 중 {0}-{1}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    }
  },
  noDataText: "데이터가 없습니다.",
  carousel: {
    prev: "이전 화면",
    next: "다음 화면",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} 더보기",
    today: "오늘"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "오전",
    pm: "오후",
    title: "시간을 선택하세요."
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "다음 페이지",
      previous: "이전 페이지",
      page: "{0} 페이지로 이동",
      currentPage: "현재 페이지, 페이지 {0}",
      first: "첫 페이지",
      last: "마지막 페이지"
    }
  },
  stepper: {
    next: "다음",
    prev: "이전"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "불러오는 중...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  }
};
function la(e, t) {
  let n;
  function a() {
    n = n2(), n.run(() => t.length ? t(() => {
      n == null || n.stop(), a();
    }) : t());
  }
  pe(e, (i) => {
    i && !n ? a() : i || (n == null || n.stop(), n = void 0);
  }, {
    immediate: !0
  }), Xn(() => {
    n == null || n.stop();
  });
}
const bt = typeof window < "u", r2 = bt && "IntersectionObserver" in window, Ow = bt && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0), Vv = bt && "EyeDropper" in window;
function Tv(e, t, n) {
  bw(e, t), t.set(e, n);
}
function bw(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Cw(e, t, n) {
  return e.set(s5(e, t), n), n;
}
function Yl(e, t) {
  return e.get(s5(e, t));
}
function s5(e, t, n) {
  if (typeof e == "function" ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function o5(e, t, n) {
  const a = t.length - 1;
  if (a < 0) return e === void 0 ? n : e;
  for (let i = 0; i < a; i++) {
    if (e == null)
      return n;
    e = e[t[i]];
  }
  return e == null || e[t[a]] === void 0 ? n : e[t[a]];
}
function Qi(e, t) {
  if (e === t) return !0;
  if (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime() || e !== Object(e) || t !== Object(t))
    return !1;
  const n = Object.keys(e);
  return n.length !== Object.keys(t).length ? !1 : n.every((a) => Qi(e[a], t[a]));
}
function gr(e, t, n) {
  return e == null || !t || typeof t != "string" ? n : e[t] !== void 0 ? e[t] : (t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, ""), o5(e, t.split("."), n));
}
function bn(e, t, n) {
  if (t === !0) return e === void 0 ? n : e;
  if (t == null || typeof t == "boolean") return n;
  if (e !== Object(e)) {
    if (typeof t != "function") return n;
    const i = t(e, n);
    return typeof i > "u" ? n : i;
  }
  if (typeof t == "string") return gr(e, t, n);
  if (Array.isArray(t)) return o5(e, t, n);
  if (typeof t != "function") return n;
  const a = t(e, n);
  return typeof a > "u" ? n : a;
}
function bi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length: e
  }, (n, a) => t + a);
}
function Qe(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (!(e == null || e === ""))
    return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0;
}
function s2(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function Lv(e) {
  let t;
  return e !== null && typeof e == "object" && ((t = Object.getPrototypeOf(e)) === Object.prototype || t === null);
}
function o2(e) {
  if (e && "$el" in e) {
    const t = e.$el;
    return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE ? t.nextElementSibling : t;
  }
  return e;
}
const Qv = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
}), Uf = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function u5(e) {
  return Object.keys(e);
}
function er(e, t) {
  return t.every((n) => e.hasOwnProperty(n));
}
function u2(e, t) {
  const n = {}, a = new Set(Object.keys(e));
  for (const i of t)
    a.has(i) && (n[i] = e[i]);
  return n;
}
function Gf(e, t, n) {
  const a = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  for (const l in e)
    t.some((r) => r instanceof RegExp ? r.test(l) : r === l) ? a[l] = e[l] : i[l] = e[l];
  return [a, i];
}
function hn(e, t) {
  const n = {
    ...e
  };
  return t.forEach((a) => delete n[a]), n;
}
function Id(e, t) {
  const n = {};
  return t.forEach((a) => n[a] = e[a]), n;
}
const c5 = /^on[^a-z]/, Bd = (e) => c5.test(e), ww = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"], kw = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
function Sw(e) {
  return e.isComposing && kw.includes(e.key);
}
function Il(e) {
  const [t, n] = Gf(e, [c5]), a = hn(t, ww), [i, l] = Gf(n, ["class", "style", "id", /^data-/]);
  return Object.assign(i, t), Object.assign(l, a), [i, l];
}
function Ht(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function xw(e, t) {
  let n = 0;
  const a = function() {
    for (var i = arguments.length, l = new Array(i), r = 0; r < i; r++)
      l[r] = arguments[r];
    clearTimeout(n), n = setTimeout(() => e(...l), X(t));
  };
  return a.clear = () => {
    clearTimeout(n);
  }, a.immediate = e, a;
}
function ln(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(t, Math.min(n, e));
}
function Av(e) {
  const t = e.toString().trim();
  return t.includes(".") ? t.length - t.indexOf(".") - 1 : 0;
}
function Dv(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return e + n.repeat(Math.max(0, t - e.length));
}
function Rv(e, t) {
  return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0").repeat(Math.max(0, t - e.length)) + e;
}
function Pw(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const n = [];
  let a = 0;
  for (; a < e.length; )
    n.push(e.substr(a, t)), a += t;
  return n;
}
function Iv(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
  if (e < t)
    return `${e} B`;
  const n = t === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
  let a = -1;
  for (; Math.abs(e) >= t && a < n.length - 1; )
    e /= t, ++a;
  return `${e.toFixed(1)} ${n[a]}B`;
}
function Gn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  const a = {};
  for (const i in e)
    a[i] = e[i];
  for (const i in t) {
    const l = e[i], r = t[i];
    if (Lv(l) && Lv(r)) {
      a[i] = Gn(l, r, n);
      continue;
    }
    if (n && Array.isArray(l) && Array.isArray(r)) {
      a[i] = n(l, r);
      continue;
    }
    a[i] = r;
  }
  return a;
}
function d5(e) {
  return e.map((t) => t.type === ge ? d5(t.children) : t).flat();
}
function sr() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (sr.cache.has(e)) return sr.cache.get(e);
  const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return sr.cache.set(e, t), t;
}
sr.cache = /* @__PURE__ */ new Map();
function is(e, t) {
  if (!t || typeof t != "object") return [];
  if (Array.isArray(t))
    return t.map((n) => is(e, n)).flat(1);
  if (t.suspense)
    return is(e, t.ssContent);
  if (Array.isArray(t.children))
    return t.children.map((n) => is(e, n)).flat(1);
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e))
      return [t.component];
    if (t.component.subTree)
      return is(e, t.component.subTree).flat(1);
  }
  return [];
}
var ju = /* @__PURE__ */ new WeakMap(), Xr = /* @__PURE__ */ new WeakMap();
class $w {
  constructor(t) {
    Tv(this, ju, []), Tv(this, Xr, 0), this.size = t;
  }
  push(t) {
    Yl(ju, this)[Yl(Xr, this)] = t, Cw(Xr, this, (Yl(Xr, this) + 1) % this.size);
  }
  values() {
    return Yl(ju, this).slice(Yl(Xr, this)).concat(Yl(ju, this).slice(0, Yl(Xr, this)));
  }
}
function _w(e) {
  return "touches" in e ? {
    clientX: e.touches[0].clientX,
    clientY: e.touches[0].clientY
  } : {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function c2(e) {
  const t = zt({}), n = k(e);
  return jt(() => {
    for (const a in n.value)
      t[a] = n.value[a];
  }, {
    flush: "sync"
  }), Tr(t);
}
function Hc(e, t) {
  return e.includes(t);
}
function f5(e) {
  return e[2].toLowerCase() + e.slice(3);
}
const Rn = () => [Function, Array];
function Bv(e, t) {
  return t = "on" + js(t), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`]);
}
function d2(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    n[a - 1] = arguments[a];
  if (Array.isArray(e))
    for (const i of e)
      i(...n);
  else typeof e == "function" && e(...n);
}
function Do(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((a) => `${a}${t ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...e.querySelectorAll(n)];
}
function h5(e, t, n) {
  let a, i = e.indexOf(document.activeElement);
  const l = t === "next" ? 1 : -1;
  do
    i += l, a = e[i];
  while ((!a || a.offsetParent == null || !((n == null ? void 0 : n(a)) ?? !0)) && i < e.length && i >= 0);
  return a;
}
function or(e, t) {
  var a, i, l, r;
  const n = Do(e);
  if (!t)
    (e === document.activeElement || !e.contains(document.activeElement)) && ((a = n[0]) == null || a.focus());
  else if (t === "first")
    (i = n[0]) == null || i.focus();
  else if (t === "last")
    (l = n.at(-1)) == null || l.focus();
  else if (typeof t == "number")
    (r = n[t]) == null || r.focus();
  else {
    const s = h5(n, t);
    s ? s.focus() : or(e, t === "next" ? "first" : "last");
  }
}
function zu(e) {
  return e == null || typeof e == "string" && e.trim() === "";
}
function m5() {
}
function ys(e, t) {
  if (!(bt && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${t})`))) return null;
  try {
    return !!e && e.matches(t);
  } catch {
    return null;
  }
}
function Zd(e) {
  return e.some((t) => VC(t) ? t.type === TC ? !1 : t.type !== ge || Zd(t.children) : !0) ? e : null;
}
function Mw(e, t) {
  if (!bt || e === 0)
    return t(), () => {
    };
  const n = window.setTimeout(t, e);
  return () => window.clearTimeout(n);
}
function Vw(e, t) {
  const n = e.clientX, a = e.clientY, i = t.getBoundingClientRect(), l = i.left, r = i.top, s = i.right, o = i.bottom;
  return n >= l && n <= s && a >= r && a <= o;
}
function jc() {
  const e = Ve(), t = (n) => {
    e.value = n;
  };
  return Object.defineProperty(t, "value", {
    enumerable: !0,
    get: () => e.value,
    set: (n) => e.value = n
  }), Object.defineProperty(t, "el", {
    enumerable: !0,
    get: () => o2(e.value)
  }), t;
}
function zc(e) {
  const t = e.key.length === 1, n = !e.ctrlKey && !e.metaKey && !e.altKey;
  return t && n;
}
const v5 = ["top", "bottom"], Tw = ["start", "end", "left", "right"];
function Kf(e, t) {
  let [n, a] = e.split(" ");
  return a || (a = Hc(v5, n) ? "start" : Hc(Tw, n) ? "top" : "center"), {
    side: Jf(n, t),
    align: Jf(a, t)
  };
}
function Jf(e, t) {
  return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e;
}
function F1(e) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.side],
    align: e.align
  };
}
function X1(e) {
  return {
    side: e.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.align]
  };
}
function Zv(e) {
  return {
    side: e.align,
    align: e.side
  };
}
function Ev(e) {
  return Hc(v5, e.side) ? "y" : "x";
}
class ur {
  constructor(t) {
    let {
      x: n,
      y: a,
      width: i,
      height: l
    } = t;
    this.x = n, this.y = a, this.width = i, this.height = l;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function Nv(e, t) {
  return {
    x: {
      before: Math.max(0, t.left - e.left),
      after: Math.max(0, e.right - t.right)
    },
    y: {
      before: Math.max(0, t.top - e.top),
      after: Math.max(0, e.bottom - t.bottom)
    }
  };
}
function g5(e) {
  return Array.isArray(e) ? new ur({
    x: e[0],
    y: e[1],
    width: 0,
    height: 0
  }) : e.getBoundingClientRect();
}
function f2(e) {
  const t = e.getBoundingClientRect(), n = getComputedStyle(e), a = n.transform;
  if (a) {
    let i, l, r, s, o;
    if (a.startsWith("matrix3d("))
      i = a.slice(9, -1).split(/, /), l = +i[0], r = +i[5], s = +i[12], o = +i[13];
    else if (a.startsWith("matrix("))
      i = a.slice(7, -1).split(/, /), l = +i[0], r = +i[3], s = +i[4], o = +i[5];
    else
      return new ur(t);
    const u = n.transformOrigin, c = t.x - s - (1 - l) * parseFloat(u), d = t.y - o - (1 - r) * parseFloat(u.slice(u.indexOf(" ") + 1)), f = l ? t.width / l : e.offsetWidth + 1, h = r ? t.height / r : e.offsetHeight + 1;
    return new ur({
      x: c,
      y: d,
      width: f,
      height: h
    });
  } else
    return new ur(t);
}
function tr(e, t, n) {
  if (typeof e.animate > "u") return {
    finished: Promise.resolve()
  };
  let a;
  try {
    a = e.animate(t, n);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof a.finished > "u" && (a.finished = new Promise((i) => {
    a.onfinish = () => {
      i(a);
    };
  })), a;
}
const wc = /* @__PURE__ */ new WeakMap();
function Lw(e, t) {
  Object.keys(t).forEach((n) => {
    if (Bd(n)) {
      const a = f5(n), i = wc.get(e);
      if (t[n] == null)
        i == null || i.forEach((l) => {
          const [r, s] = l;
          r === a && (e.removeEventListener(a, s), i.delete(l));
        });
      else if (!i || ![...i].some((l) => l[0] === a && l[1] === t[n])) {
        e.addEventListener(a, t[n]);
        const l = i || /* @__PURE__ */ new Set();
        l.add([a, t[n]]), wc.has(e) || wc.set(e, l);
      }
    } else
      t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n]);
  });
}
function Qw(e, t) {
  Object.keys(t).forEach((n) => {
    if (Bd(n)) {
      const a = f5(n), i = wc.get(e);
      i == null || i.forEach((l) => {
        const [r, s] = l;
        r === a && (e.removeEventListener(a, s), i.delete(l));
      });
    } else
      e.removeAttribute(n);
  });
}
const Yr = 2.4, Hv = 0.2126729, jv = 0.7151522, zv = 0.072175, Aw = 0.55, Dw = 0.58, Rw = 0.57, Iw = 0.62, Fu = 0.03, Fv = 1.45, Bw = 5e-4, Zw = 1.25, Ew = 1.25, Nw = 0.078, Xv = 12.82051282051282, Xu = 0.06, Hw = 1e-3;
function Yv(e, t) {
  const n = (e.r / 255) ** Yr, a = (e.g / 255) ** Yr, i = (e.b / 255) ** Yr, l = (t.r / 255) ** Yr, r = (t.g / 255) ** Yr, s = (t.b / 255) ** Yr;
  let o = n * Hv + a * jv + i * zv, u = l * Hv + r * jv + s * zv;
  if (o <= Fu && (o += (Fu - o) ** Fv), u <= Fu && (u += (Fu - u) ** Fv), Math.abs(u - o) < Bw) return 0;
  let c;
  if (u > o) {
    const d = (u ** Aw - o ** Dw) * Zw;
    c = d < Hw ? 0 : d < Nw ? d - d * Xv * Xu : d - Xu;
  } else {
    const d = (u ** Iw - o ** Rw) * Ew;
    c = d > -1e-3 ? 0 : d > -0.078 ? d - d * Xv * Xu : d + Xu;
  }
  return c * 100;
}
function Wa(e) {
  Ad(`Vuetify: ${e}`);
}
function Fc(e) {
  Ad(`Vuetify error: ${e}`);
}
function jw(e, t) {
  t = Array.isArray(t) ? t.slice(0, -1).map((n) => `'${n}'`).join(", ") + ` or '${t.at(-1)}'` : `'${t}'`, Ad(`[Vuetify UPGRADE] '${e}' is deprecated, use ${t} instead.`);
}
const Xc = 0.20689655172413793, zw = (e) => e > Xc ** 3 ? Math.cbrt(e) : e / (3 * Xc ** 2) + 4 / 29, Fw = (e) => e > Xc ? e ** 3 : 3 * Xc ** 2 * (e - 4 / 29);
function p5(e) {
  const t = zw, n = t(e[1]);
  return [116 * n - 16, 500 * (t(e[0] / 0.95047) - n), 200 * (n - t(e[2] / 1.08883))];
}
function y5(e) {
  const t = Fw, n = (e[0] + 16) / 116;
  return [t(n + e[1] / 500) * 0.95047, t(n), t(n - e[2] / 200) * 1.08883];
}
const Xw = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]], Yw = (e) => e <= 31308e-7 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - 0.055, Ww = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], qw = (e) => e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
function O5(e) {
  const t = Array(3), n = Yw, a = Xw;
  for (let i = 0; i < 3; ++i)
    t[i] = Math.round(ln(n(a[i][0] * e[0] + a[i][1] * e[1] + a[i][2] * e[2])) * 255);
  return {
    r: t[0],
    g: t[1],
    b: t[2]
  };
}
function h2(e) {
  let {
    r: t,
    g: n,
    b: a
  } = e;
  const i = [0, 0, 0], l = qw, r = Ww;
  t = l(t / 255), n = l(n / 255), a = l(a / 255);
  for (let s = 0; s < 3; ++s)
    i[s] = r[s][0] * t + r[s][1] * n + r[s][2] * a;
  return i;
}
function eh(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e);
}
function Uw(e) {
  return eh(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e);
}
const Wv = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, Gw = {
  rgb: (e, t, n, a) => ({
    r: e,
    g: t,
    b: n,
    a
  }),
  rgba: (e, t, n, a) => ({
    r: e,
    g: t,
    b: n,
    a
  }),
  hsl: (e, t, n, a) => qv({
    h: e,
    s: t,
    l: n,
    a
  }),
  hsla: (e, t, n, a) => qv({
    h: e,
    s: t,
    l: n,
    a
  }),
  hsv: (e, t, n, a) => Yi({
    h: e,
    s: t,
    v: n,
    a
  }),
  hsva: (e, t, n, a) => Yi({
    h: e,
    s: t,
    v: n,
    a
  })
};
function Ta(e) {
  if (typeof e == "number")
    return (isNaN(e) || e < 0 || e > 16777215) && Wa(`'${e}' is not a valid hex color`), {
      r: (e & 16711680) >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  if (typeof e == "string" && Wv.test(e)) {
    const {
      groups: t
    } = e.match(Wv), {
      fn: n,
      values: a
    } = t, i = a.split(/,\s*/).map((l) => l.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(l) / 100 : parseFloat(l));
    return Gw[n](...i);
  } else if (typeof e == "string") {
    let t = e.startsWith("#") ? e.slice(1) : e;
    [3, 4].includes(t.length) ? t = t.split("").map((a) => a + a).join("") : [6, 8].includes(t.length) || Wa(`'${e}' is not a valid hex(a) color`);
    const n = parseInt(t, 16);
    return (isNaN(n) || n < 0 || n > 4294967295) && Wa(`'${e}' is not a valid hex(a) color`), S5(t);
  } else if (typeof e == "object") {
    if (er(e, ["r", "g", "b"]))
      return e;
    if (er(e, ["h", "s", "l"]))
      return Yi(m2(e));
    if (er(e, ["h", "s", "v"]))
      return Yi(e);
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function Yi(e) {
  const {
    h: t,
    s: n,
    v: a,
    a: i
  } = e, l = (s) => {
    const o = (s + t / 60) % 6;
    return a - a * n * Math.max(Math.min(o, 4 - o, 1), 0);
  }, r = [l(5), l(3), l(1)].map((s) => Math.round(s * 255));
  return {
    r: r[0],
    g: r[1],
    b: r[2],
    a: i
  };
}
function qv(e) {
  return Yi(m2(e));
}
function Ed(e) {
  if (!e) return {
    h: 0,
    s: 1,
    v: 1,
    a: 1
  };
  const t = e.r / 255, n = e.g / 255, a = e.b / 255, i = Math.max(t, n, a), l = Math.min(t, n, a);
  let r = 0;
  i !== l && (i === t ? r = 60 * (0 + (n - a) / (i - l)) : i === n ? r = 60 * (2 + (a - t) / (i - l)) : i === a && (r = 60 * (4 + (t - n) / (i - l)))), r < 0 && (r = r + 360);
  const s = i === 0 ? 0 : (i - l) / i, o = [r, s, i];
  return {
    h: o[0],
    s: o[1],
    v: o[2],
    a: e.a
  };
}
function b5(e) {
  const {
    h: t,
    s: n,
    v: a,
    a: i
  } = e, l = a - a * n / 2, r = l === 1 || l === 0 ? 0 : (a - l) / Math.min(l, 1 - l);
  return {
    h: t,
    s: r,
    l,
    a: i
  };
}
function m2(e) {
  const {
    h: t,
    s: n,
    l: a,
    a: i
  } = e, l = a + n * Math.min(a, 1 - a), r = l === 0 ? 0 : 2 - 2 * a / l;
  return {
    h: t,
    s: r,
    v: l,
    a: i
  };
}
function C5(e) {
  let {
    r: t,
    g: n,
    b: a,
    a: i
  } = e;
  return i === void 0 ? `rgb(${t}, ${n}, ${a})` : `rgba(${t}, ${n}, ${a}, ${i})`;
}
function w5(e) {
  return C5(Yi(e));
}
function Yu(e) {
  const t = Math.round(e).toString(16);
  return ("00".substr(0, 2 - t.length) + t).toUpperCase();
}
function k5(e) {
  let {
    r: t,
    g: n,
    b: a,
    a: i
  } = e;
  return `#${[Yu(t), Yu(n), Yu(a), i !== void 0 ? Yu(Math.round(i * 255)) : ""].join("")}`;
}
function S5(e) {
  e = Kw(e);
  let [t, n, a, i] = Pw(e, 2).map((l) => parseInt(l, 16));
  return i = i === void 0 ? i : i / 255, {
    r: t,
    g: n,
    b: a,
    a: i
  };
}
function x5(e) {
  const t = S5(e);
  return Ed(t);
}
function P5(e) {
  return k5(Yi(e));
}
function Kw(e) {
  return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map((t) => t + t).join("")), e.length !== 6 && (e = Dv(Dv(e, 6), 8, "F")), e;
}
function Jw(e, t) {
  const n = p5(h2(e));
  return n[0] = n[0] + t * 10, O5(y5(n));
}
function ek(e, t) {
  const n = p5(h2(e));
  return n[0] = n[0] - t * 10, O5(y5(n));
}
function th(e) {
  const t = Ta(e);
  return h2(t)[1];
}
function tk(e, t) {
  const n = th(e), a = th(t), i = Math.max(n, a), l = Math.min(n, a);
  return (i + 0.05) / (l + 0.05);
}
function $5(e) {
  const t = Math.abs(Yv(Ta(0), Ta(e)));
  return Math.abs(Yv(Ta(16777215), Ta(e))) > Math.min(t, 50) ? "#fff" : "#000";
}
function le(e, t) {
  return (n) => Object.keys(e).reduce((a, i) => {
    const r = typeof e[i] == "object" && e[i] != null && !Array.isArray(e[i]) ? e[i] : {
      type: e[i]
    };
    return n && i in n ? a[i] = {
      ...r,
      default: n[i]
    } : a[i] = r, t && !a[i].source && (a[i].source = t), a;
  }, {});
}
const Ae = le({
  class: [String, Array, Object],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component");
function Wt(e, t) {
  const n = Pl();
  if (!n)
    throw new Error(`[Vuetify] ${e} must be called from inside a setup function`);
  return n;
}
function Ai() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const t = Wt(e).type;
  return sr((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name));
}
let _5 = 0, kc = /* @__PURE__ */ new WeakMap();
function Bn() {
  const e = Wt("getUid");
  if (kc.has(e)) return kc.get(e);
  {
    const t = _5++;
    return kc.set(e, t), t;
  }
}
Bn.reset = () => {
  _5 = 0, kc = /* @__PURE__ */ new WeakMap();
};
function nk(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wt("injectSelf");
  const {
    provides: n
  } = t;
  if (n && e in n)
    return n[e];
}
const Os = Symbol.for("vuetify:defaults");
function ak(e) {
  return Y(e);
}
function v2() {
  const e = ct(Os);
  if (!e) throw new Error("[Vuetify] Could not find defaults instance");
  return e;
}
function Yt(e, t) {
  const n = v2(), a = Y(e), i = k(() => {
    if (X(t == null ? void 0 : t.disabled)) return n.value;
    const r = X(t == null ? void 0 : t.scoped), s = X(t == null ? void 0 : t.reset), o = X(t == null ? void 0 : t.root);
    if (a.value == null && !(r || s || o)) return n.value;
    let u = Gn(a.value, {
      prev: n.value
    });
    if (r) return u;
    if (s || o) {
      const c = Number(s || 1 / 0);
      for (let d = 0; d <= c && !(!u || !("prev" in u)); d++)
        u = u.prev;
      return u && typeof o == "string" && o in u && (u = Gn(Gn(u, {
        prev: u
      }), u[o])), u;
    }
    return u.prev ? Gn(u.prev, u) : u;
  });
  return Tt(Os, i), i;
}
function ik(e, t) {
  var n, a;
  return typeof ((n = e.props) == null ? void 0 : n[t]) < "u" || typeof ((a = e.props) == null ? void 0 : a[sr(t)]) < "u";
}
function lk() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : v2();
  const a = Wt("useDefaults");
  if (t = t ?? a.type.name ?? a.type.__name, !t)
    throw new Error("[Vuetify] Could not determine component name");
  const i = k(() => {
    var o;
    return (o = n.value) == null ? void 0 : o[e._as ?? t];
  }), l = new Proxy(e, {
    get(o, u) {
      var d, f, h, m, g, v, y;
      const c = Reflect.get(o, u);
      return u === "class" || u === "style" ? [(d = i.value) == null ? void 0 : d[u], c].filter((b) => b != null) : typeof u == "string" && !ik(a.vnode, u) ? ((f = i.value) == null ? void 0 : f[u]) !== void 0 ? (h = i.value) == null ? void 0 : h[u] : ((g = (m = n.value) == null ? void 0 : m.global) == null ? void 0 : g[u]) !== void 0 ? (y = (v = n.value) == null ? void 0 : v.global) == null ? void 0 : y[u] : c : c;
    }
  }), r = Ve();
  jt(() => {
    if (i.value) {
      const o = Object.entries(i.value).filter((u) => {
        let [c] = u;
        return c.startsWith(c[0].toUpperCase());
      });
      r.value = o.length ? Object.fromEntries(o) : void 0;
    } else
      r.value = void 0;
  });
  function s() {
    const o = nk(Os, a);
    Tt(Os, k(() => r.value ? Gn((o == null ? void 0 : o.value) ?? {}, r.value) : o == null ? void 0 : o.value));
  }
  return {
    props: l,
    provideSubDefaults: s
  };
}
function Pa(e) {
  if (e._setup = e._setup ?? e.setup, !e.name)
    return Wa("The component is missing an explicit name, unable to generate default prop value"), e;
  if (e._setup) {
    e.props = le(e.props ?? {}, e.name)();
    const t = Object.keys(e.props).filter((n) => n !== "class" && n !== "style");
    e.filterProps = function(a) {
      return u2(a, t);
    }, e.props._as = String, e.setup = function(a, i) {
      const l = v2();
      if (!l.value) return e._setup(a, i);
      const {
        props: r,
        provideSubDefaults: s
      } = lk(a, a._as ?? e.name, l), o = e._setup(r, i);
      return s(), o;
    };
  }
  return e;
}
function ve() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (t) => (e ? Pa : Sn)(t);
}
function rk(e, t) {
  return t.props = e, t;
}
function Di(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", n = arguments.length > 2 ? arguments[2] : void 0;
  return ve()({
    name: n ?? js(W4(e.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: t
      },
      ...Ae()
    },
    setup(a, i) {
      let {
        slots: l
      } = i;
      return () => {
        var r;
        return G(a.tag, {
          class: [e, a.class],
          style: a.style
        }, (r = l.default) == null ? void 0 : r.call(l));
      };
    }
  });
}
function M5(e) {
  if (typeof e.getRootNode != "function") {
    for (; e.parentNode; ) e = e.parentNode;
    return e !== document ? null : document;
  }
  const t = e.getRootNode();
  return t !== document && t.getRootNode({
    composed: !0
  }) !== document ? null : t;
}
const Ro = "cubic-bezier(0.4, 0, 0.2, 1)", sk = "cubic-bezier(0.0, 0, 0.2, 1)", ok = "cubic-bezier(0.4, 0, 1, 1)";
function Uv(e, t, n) {
  return Object.keys(e).filter((a) => Bd(a) && a.endsWith(t)).reduce((a, i) => (a[i.slice(0, -t.length)] = (l) => e[i](l, n(l)), a), {});
}
function g2(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  for (; e; ) {
    if (t ? uk(e) : p2(e)) return e;
    e = e.parentElement;
  }
  return document.scrollingElement;
}
function Yc(e, t) {
  const n = [];
  if (t && e && !t.contains(e)) return n;
  for (; e && (p2(e) && n.push(e), e !== t); )
    e = e.parentElement;
  return n;
}
function p2(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
  const t = window.getComputedStyle(e);
  return t.overflowY === "scroll" || t.overflowY === "auto" && e.scrollHeight > e.clientHeight;
}
function uk(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
  const t = window.getComputedStyle(e);
  return ["scroll", "auto"].includes(t.overflowY);
}
function ck(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === "fixed")
      return !0;
    e = e.offsetParent;
  }
  return !1;
}
function ye(e) {
  const t = Wt("useRender");
  t.render = e;
}
function Fe(e, t, n) {
  let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d;
  const l = Wt("useProxiedModel"), r = Y(e[t] !== void 0 ? e[t] : n), s = sr(t), u = s !== t ? k(() => {
    var d, f, h, m;
    return e[t], !!(((d = l.vnode.props) != null && d.hasOwnProperty(t) || (f = l.vnode.props) != null && f.hasOwnProperty(s)) && ((h = l.vnode.props) != null && h.hasOwnProperty(`onUpdate:${t}`) || (m = l.vnode.props) != null && m.hasOwnProperty(`onUpdate:${s}`)));
  }) : k(() => {
    var d, f;
    return e[t], !!((d = l.vnode.props) != null && d.hasOwnProperty(t) && ((f = l.vnode.props) != null && f.hasOwnProperty(`onUpdate:${t}`)));
  });
  la(() => !u.value, () => {
    pe(() => e[t], (d) => {
      r.value = d;
    });
  });
  const c = k({
    get() {
      const d = e[t];
      return a(u.value ? d : r.value);
    },
    set(d) {
      const f = i(d), h = At(u.value ? e[t] : r.value);
      h === f || a(h) === d || (r.value = f, l == null || l.emit(`update:${t}`, f));
    }
  });
  return Object.defineProperty(c, "externalValue", {
    get: () => u.value ? e[t] : r.value
  }), c;
}
const Gv = "$vuetify.", Kv = (e, t) => e.replace(/\{(\d+)\}/g, (n, a) => String(t[+a])), V5 = (e, t, n) => function(a) {
  for (var i = arguments.length, l = new Array(i > 1 ? i - 1 : 0), r = 1; r < i; r++)
    l[r - 1] = arguments[r];
  if (!a.startsWith(Gv))
    return Kv(a, l);
  const s = a.replace(Gv, ""), o = e.value && n.value[e.value], u = t.value && n.value[t.value];
  let c = gr(o, s, null);
  return c || (Wa(`Translation key "${a}" not found in "${e.value}", trying fallback locale`), c = gr(u, s, null)), c || (Fc(`Translation key "${a}" not found in fallback`), c = a), typeof c != "string" && (Fc(`Translation key "${a}" has a non-string value`), c = a), Kv(c, l);
};
function T5(e, t) {
  return (n, a) => new Intl.NumberFormat([e.value, t.value], a).format(n);
}
function Y1(e, t, n) {
  const a = Fe(e, t, e[t] ?? n.value);
  return a.value = e[t] ?? n.value, pe(n, (i) => {
    e[t] == null && (a.value = n.value);
  }), a;
}
function L5(e) {
  return (t) => {
    const n = Y1(t, "locale", e.current), a = Y1(t, "fallback", e.fallback), i = Y1(t, "messages", e.messages);
    return {
      name: "vuetify",
      current: n,
      fallback: a,
      messages: i,
      t: V5(n, a, i),
      n: T5(n, a),
      provide: L5({
        current: n,
        fallback: a,
        messages: i
      })
    };
  };
}
function dk(e) {
  const t = Ve((e == null ? void 0 : e.locale) ?? "en"), n = Ve((e == null ? void 0 : e.fallback) ?? "en"), a = Y({
    en: pw,
    ...e == null ? void 0 : e.messages
  });
  return {
    name: "vuetify",
    current: t,
    fallback: n,
    messages: a,
    t: V5(t, n, a),
    n: T5(t, n),
    provide: L5({
      current: t,
      fallback: n,
      messages: a
    })
  };
}
const bs = Symbol.for("vuetify:locale");
function fk(e) {
  return e.name != null;
}
function hk(e) {
  const t = e != null && e.adapter && fk(e == null ? void 0 : e.adapter) ? e == null ? void 0 : e.adapter : dk(e), n = gk(t, e);
  return {
    ...t,
    ...n
  };
}
function tn() {
  const e = ct(bs);
  if (!e) throw new Error("[Vuetify] Could not find injected locale instance");
  return e;
}
function mk(e) {
  const t = ct(bs);
  if (!t) throw new Error("[Vuetify] Could not find injected locale instance");
  const n = t.provide(e), a = pk(n, t.rtl, e), i = {
    ...n,
    ...a
  };
  return Tt(bs, i), i;
}
function vk() {
  return {
    af: !1,
    ar: !0,
    bg: !1,
    ca: !1,
    ckb: !1,
    cs: !1,
    de: !1,
    el: !1,
    en: !1,
    es: !1,
    et: !1,
    fa: !0,
    fi: !1,
    fr: !1,
    hr: !1,
    hu: !1,
    he: !0,
    id: !1,
    it: !1,
    ja: !1,
    km: !1,
    ko: !1,
    lv: !1,
    lt: !1,
    nl: !1,
    no: !1,
    pl: !1,
    pt: !1,
    ro: !1,
    ru: !1,
    sk: !1,
    sl: !1,
    srCyrl: !1,
    srLatn: !1,
    sv: !1,
    th: !1,
    tr: !1,
    az: !1,
    uk: !1,
    vi: !1,
    zhHans: !1,
    zhHant: !1
  };
}
function gk(e, t) {
  const n = Y((t == null ? void 0 : t.rtl) ?? vk()), a = k(() => n.value[e.current.value] ?? !1);
  return {
    isRtl: a,
    rtl: n,
    rtlClasses: k(() => `v-locale--is-${a.value ? "rtl" : "ltr"}`)
  };
}
function pk(e, t, n) {
  const a = k(() => n.rtl ?? t.value[e.current.value] ?? !1);
  return {
    isRtl: a,
    rtl: t,
    rtlClasses: k(() => `v-locale--is-${a.value ? "rtl" : "ltr"}`)
  };
}
function xn() {
  const e = ct(bs);
  if (!e) throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: e.isRtl,
    rtlClasses: e.rtlClasses
  };
}
const Nd = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  "GB-alt-variant": 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0
};
function yk(e, t, n) {
  const a = [];
  let i = [];
  const l = Q5(e), r = A5(e), s = n ?? Nd[t.slice(-2).toUpperCase()] ?? 0, o = (l.getDay() - s + 7) % 7, u = (r.getDay() - s + 7) % 7;
  for (let c = 0; c < o; c++) {
    const d = new Date(l);
    d.setDate(d.getDate() - (o - c)), i.push(d);
  }
  for (let c = 1; c <= r.getDate(); c++) {
    const d = new Date(e.getFullYear(), e.getMonth(), c);
    i.push(d), i.length === 7 && (a.push(i), i = []);
  }
  for (let c = 1; c < 7 - u; c++) {
    const d = new Date(r);
    d.setDate(d.getDate() + c), i.push(d);
  }
  return i.length > 0 && a.push(i), a;
}
function Ok(e, t, n) {
  const a = n ?? Nd[t.slice(-2).toUpperCase()] ?? 0, i = new Date(e);
  for (; i.getDay() !== a; )
    i.setDate(i.getDate() - 1);
  return i;
}
function bk(e, t) {
  const n = new Date(e), a = ((Nd[t.slice(-2).toUpperCase()] ?? 0) + 6) % 7;
  for (; n.getDay() !== a; )
    n.setDate(n.getDate() + 1);
  return n;
}
function Q5(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1);
}
function A5(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 0);
}
function Ck(e) {
  const t = e.split("-").map(Number);
  return new Date(t[0], t[1] - 1, t[2]);
}
const wk = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
function D5(e) {
  if (e == null) return /* @__PURE__ */ new Date();
  if (e instanceof Date) return e;
  if (typeof e == "string") {
    let t;
    if (wk.test(e))
      return Ck(e);
    if (t = Date.parse(e), !isNaN(t)) return new Date(t);
  }
  return null;
}
const Jv = new Date(2e3, 0, 2);
function kk(e, t) {
  const n = t ?? Nd[e.slice(-2).toUpperCase()] ?? 0;
  return bi(7).map((a) => {
    const i = new Date(Jv);
    return i.setDate(Jv.getDate() + n + a), new Intl.DateTimeFormat(e, {
      weekday: "narrow"
    }).format(i);
  });
}
function Sk(e, t, n, a) {
  const i = D5(e) ?? /* @__PURE__ */ new Date(), l = a == null ? void 0 : a[t];
  if (typeof l == "function")
    return l(i, t, n);
  let r = {};
  switch (t) {
    case "fullDate":
      r = {
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "fullDateWithWeekday":
      r = {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "normalDate":
      const s = i.getDate(), o = new Intl.DateTimeFormat(n, {
        month: "long"
      }).format(i);
      return `${s} ${o}`;
    case "normalDateWithWeekday":
      r = {
        weekday: "short",
        day: "numeric",
        month: "short"
      };
      break;
    case "shortDate":
      r = {
        month: "short",
        day: "numeric"
      };
      break;
    case "year":
      r = {
        year: "numeric"
      };
      break;
    case "month":
      r = {
        month: "long"
      };
      break;
    case "monthShort":
      r = {
        month: "short"
      };
      break;
    case "monthAndYear":
      r = {
        month: "long",
        year: "numeric"
      };
      break;
    case "monthAndDate":
      r = {
        month: "long",
        day: "numeric"
      };
      break;
    case "weekday":
      r = {
        weekday: "long"
      };
      break;
    case "weekdayShort":
      r = {
        weekday: "short"
      };
      break;
    case "dayOfMonth":
      return new Intl.NumberFormat(n).format(i.getDate());
    case "hours12h":
      r = {
        hour: "numeric",
        hour12: !0
      };
      break;
    case "hours24h":
      r = {
        hour: "numeric",
        hour12: !1
      };
      break;
    case "minutes":
      r = {
        minute: "numeric"
      };
      break;
    case "seconds":
      r = {
        second: "numeric"
      };
      break;
    case "fullTime":
      r = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullTime12h":
      r = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullTime24h":
      r = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "fullDateTime":
      r = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime12h":
      r = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime24h":
      r = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDate":
      r = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      };
      break;
    case "keyboardDateTime":
      r = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDateTime12h":
      r = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "keyboardDateTime24h":
      r = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    default:
      r = l ?? {
        timeZone: "UTC",
        timeZoneName: "short"
      };
  }
  return new Intl.DateTimeFormat(n, r).format(i);
}
function xk(e, t) {
  const n = e.toJsDate(t), a = n.getFullYear(), i = Rv(String(n.getMonth() + 1), 2, "0"), l = Rv(String(n.getDate()), 2, "0");
  return `${a}-${i}-${l}`;
}
function Pk(e) {
  const [t, n, a] = e.split("-").map(Number);
  return new Date(t, n - 1, a);
}
function $k(e, t) {
  const n = new Date(e);
  return n.setMinutes(n.getMinutes() + t), n;
}
function _k(e, t) {
  const n = new Date(e);
  return n.setHours(n.getHours() + t), n;
}
function Mk(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t), n;
}
function Vk(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t * 7), n;
}
function Tk(e, t) {
  const n = new Date(e);
  return n.setDate(1), n.setMonth(n.getMonth() + t), n;
}
function Lk(e) {
  return e.getFullYear();
}
function Qk(e) {
  return e.getMonth();
}
function Ak(e) {
  return e.getDate();
}
function Dk(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 1);
}
function Rk(e) {
  return new Date(e.getFullYear(), e.getMonth() - 1, 1);
}
function Ik(e) {
  return e.getHours();
}
function Bk(e) {
  return e.getMinutes();
}
function Zk(e) {
  return new Date(e.getFullYear(), 0, 1);
}
function Ek(e) {
  return new Date(e.getFullYear(), 11, 31);
}
function Nk(e, t) {
  return Wc(e, t[0]) && zk(e, t[1]);
}
function Hk(e) {
  const t = new Date(e);
  return t instanceof Date && !isNaN(t.getTime());
}
function Wc(e, t) {
  return e.getTime() > t.getTime();
}
function jk(e, t) {
  return Wc(nh(e), nh(t));
}
function zk(e, t) {
  return e.getTime() < t.getTime();
}
function eg(e, t) {
  return e.getTime() === t.getTime();
}
function Fk(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function Xk(e, t) {
  return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function Yk(e, t) {
  return e.getFullYear() === t.getFullYear();
}
function Wk(e, t, n) {
  const a = new Date(e), i = new Date(t);
  switch (n) {
    case "years":
      return a.getFullYear() - i.getFullYear();
    case "quarters":
      return Math.floor((a.getMonth() - i.getMonth() + (a.getFullYear() - i.getFullYear()) * 12) / 4);
    case "months":
      return a.getMonth() - i.getMonth() + (a.getFullYear() - i.getFullYear()) * 12;
    case "weeks":
      return Math.floor((a.getTime() - i.getTime()) / (1e3 * 60 * 60 * 24 * 7));
    case "days":
      return Math.floor((a.getTime() - i.getTime()) / (1e3 * 60 * 60 * 24));
    case "hours":
      return Math.floor((a.getTime() - i.getTime()) / (1e3 * 60 * 60));
    case "minutes":
      return Math.floor((a.getTime() - i.getTime()) / (1e3 * 60));
    case "seconds":
      return Math.floor((a.getTime() - i.getTime()) / 1e3);
    default:
      return a.getTime() - i.getTime();
  }
}
function qk(e, t) {
  const n = new Date(e);
  return n.setHours(t), n;
}
function Uk(e, t) {
  const n = new Date(e);
  return n.setMinutes(t), n;
}
function Gk(e, t) {
  const n = new Date(e);
  return n.setMonth(t), n;
}
function Kk(e, t) {
  const n = new Date(e);
  return n.setDate(t), n;
}
function Jk(e, t) {
  const n = new Date(e);
  return n.setFullYear(t), n;
}
function nh(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0);
}
function eS(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999);
}
class tS {
  constructor(t) {
    this.locale = t.locale, this.formats = t.formats;
  }
  date(t) {
    return D5(t);
  }
  toJsDate(t) {
    return t;
  }
  toISO(t) {
    return xk(this, t);
  }
  parseISO(t) {
    return Pk(t);
  }
  addMinutes(t, n) {
    return $k(t, n);
  }
  addHours(t, n) {
    return _k(t, n);
  }
  addDays(t, n) {
    return Mk(t, n);
  }
  addWeeks(t, n) {
    return Vk(t, n);
  }
  addMonths(t, n) {
    return Tk(t, n);
  }
  getWeekArray(t, n) {
    return yk(t, this.locale, n ? Number(n) : void 0);
  }
  startOfWeek(t, n) {
    return Ok(t, this.locale, n ? Number(n) : void 0);
  }
  endOfWeek(t) {
    return bk(t, this.locale);
  }
  startOfMonth(t) {
    return Q5(t);
  }
  endOfMonth(t) {
    return A5(t);
  }
  format(t, n) {
    return Sk(t, n, this.locale, this.formats);
  }
  isEqual(t, n) {
    return eg(t, n);
  }
  isValid(t) {
    return Hk(t);
  }
  isWithinRange(t, n) {
    return Nk(t, n);
  }
  isAfter(t, n) {
    return Wc(t, n);
  }
  isAfterDay(t, n) {
    return jk(t, n);
  }
  isBefore(t, n) {
    return !Wc(t, n) && !eg(t, n);
  }
  isSameDay(t, n) {
    return Fk(t, n);
  }
  isSameMonth(t, n) {
    return Xk(t, n);
  }
  isSameYear(t, n) {
    return Yk(t, n);
  }
  setMinutes(t, n) {
    return Uk(t, n);
  }
  setHours(t, n) {
    return qk(t, n);
  }
  setMonth(t, n) {
    return Gk(t, n);
  }
  setDate(t, n) {
    return Kk(t, n);
  }
  setYear(t, n) {
    return Jk(t, n);
  }
  getDiff(t, n, a) {
    return Wk(t, n, a);
  }
  getWeekdays(t) {
    return kk(this.locale, t ? Number(t) : void 0);
  }
  getYear(t) {
    return Lk(t);
  }
  getMonth(t) {
    return Qk(t);
  }
  getDate(t) {
    return Ak(t);
  }
  getNextMonth(t) {
    return Dk(t);
  }
  getPreviousMonth(t) {
    return Rk(t);
  }
  getHours(t) {
    return Ik(t);
  }
  getMinutes(t) {
    return Bk(t);
  }
  startOfDay(t) {
    return nh(t);
  }
  endOfDay(t) {
    return eS(t);
  }
  startOfYear(t) {
    return Zk(t);
  }
  endOfYear(t) {
    return Ek(t);
  }
}
const R5 = Symbol.for("vuetify:date-options"), tg = Symbol.for("vuetify:date-adapter");
function nS(e, t) {
  const n = Gn({
    adapter: tS,
    locale: {
      af: "af-ZA",
      // ar: '', # not the same value for all variants
      bg: "bg-BG",
      ca: "ca-ES",
      ckb: "",
      cs: "cs-CZ",
      de: "de-DE",
      el: "el-GR",
      en: "en-US",
      // es: '', # not the same value for all variants
      et: "et-EE",
      fa: "fa-IR",
      fi: "fi-FI",
      // fr: '', #not the same value for all variants
      hr: "hr-HR",
      hu: "hu-HU",
      he: "he-IL",
      id: "id-ID",
      it: "it-IT",
      ja: "ja-JP",
      ko: "ko-KR",
      lv: "lv-LV",
      lt: "lt-LT",
      nl: "nl-NL",
      no: "no-NO",
      pl: "pl-PL",
      pt: "pt-PT",
      ro: "ro-RO",
      ru: "ru-RU",
      sk: "sk-SK",
      sl: "sl-SI",
      srCyrl: "sr-SP",
      srLatn: "sr-SP",
      sv: "sv-SE",
      th: "th-TH",
      tr: "tr-TR",
      az: "az-AZ",
      uk: "uk-UA",
      vi: "vi-VN",
      zhHans: "zh-CN",
      zhHant: "zh-TW"
    }
  }, e);
  return {
    options: n,
    instance: I5(n, t)
  };
}
function I5(e, t) {
  const n = zt(typeof e.adapter == "function" ? new e.adapter({
    locale: e.locale[t.current.value] ?? t.current.value,
    formats: e.formats
  }) : e.adapter);
  return pe(t.current, (a) => {
    n.locale = e.locale[a] ?? a ?? n.locale;
  }), n;
}
function gu() {
  const e = ct(R5);
  if (!e) throw new Error("[Vuetify] Could not find injected date options");
  const t = tn();
  return I5(e, t);
}
function aS(e, t) {
  const n = e.toJsDate(t);
  let a = n.getFullYear(), i = new Date(a, 0, 1);
  if (n < i)
    a = a - 1, i = new Date(a, 0, 1);
  else {
    const s = new Date(a + 1, 0, 1);
    n >= s && (a = a + 1, i = s);
  }
  const l = Math.abs(n.getTime() - i.getTime()), r = Math.ceil(l / (1e3 * 60 * 60 * 24));
  return Math.floor(r / 7) + 1;
}
const Hd = ["sm", "md", "lg", "xl", "xxl"], ah = Symbol.for("vuetify:display"), ng = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
}, iS = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ng;
  return Gn(ng, e);
};
function ag(e) {
  return bt && !e ? window.innerWidth : typeof e == "object" && e.clientWidth || 0;
}
function ig(e) {
  return bt && !e ? window.innerHeight : typeof e == "object" && e.clientHeight || 0;
}
function lg(e) {
  const t = bt && !e ? window.navigator.userAgent : "ssr";
  function n(m) {
    return !!t.match(m);
  }
  const a = n(/android/i), i = n(/iphone|ipad|ipod/i), l = n(/cordova/i), r = n(/electron/i), s = n(/chrome/i), o = n(/edge/i), u = n(/firefox/i), c = n(/opera/i), d = n(/win/i), f = n(/mac/i), h = n(/linux/i);
  return {
    android: a,
    ios: i,
    cordova: l,
    electron: r,
    chrome: s,
    edge: o,
    firefox: u,
    opera: c,
    win: d,
    mac: f,
    linux: h,
    touch: Ow,
    ssr: t === "ssr"
  };
}
function lS(e, t) {
  const {
    thresholds: n,
    mobileBreakpoint: a
  } = iS(e), i = Ve(ig(t)), l = Ve(lg(t)), r = zt({}), s = Ve(ag(t));
  function o() {
    i.value = ig(), s.value = ag();
  }
  function u() {
    o(), l.value = lg();
  }
  return jt(() => {
    const c = s.value < n.sm, d = s.value < n.md && !c, f = s.value < n.lg && !(d || c), h = s.value < n.xl && !(f || d || c), m = s.value < n.xxl && !(h || f || d || c), g = s.value >= n.xxl, v = c ? "xs" : d ? "sm" : f ? "md" : h ? "lg" : m ? "xl" : "xxl", y = typeof a == "number" ? a : n[a], b = s.value < y;
    r.xs = c, r.sm = d, r.md = f, r.lg = h, r.xl = m, r.xxl = g, r.smAndUp = !c, r.mdAndUp = !(c || d), r.lgAndUp = !(c || d || f), r.xlAndUp = !(c || d || f || h), r.smAndDown = !(f || h || m || g), r.mdAndDown = !(h || m || g), r.lgAndDown = !(m || g), r.xlAndDown = !g, r.name = v, r.height = i.value, r.width = s.value, r.mobile = b, r.mobileBreakpoint = a, r.platform = l.value, r.thresholds = n;
  }), bt && window.addEventListener("resize", o, {
    passive: !0
  }), {
    ...Tr(r),
    update: u,
    ssr: !!t
  };
}
const Qr = le({
  mobile: {
    type: Boolean,
    default: !1
  },
  mobileBreakpoint: [Number, String]
}, "display");
function Za() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  const n = ct(ah);
  if (!n) throw new Error("Could not find Vuetify display injection");
  const a = k(() => {
    if (e.mobile != null) return e.mobile;
    if (!e.mobileBreakpoint) return n.mobile.value;
    const l = typeof e.mobileBreakpoint == "number" ? e.mobileBreakpoint : n.thresholds.value[e.mobileBreakpoint];
    return n.width.value < l;
  }), i = k(() => t ? {
    [`${t}--mobile`]: a.value
  } : {});
  return {
    ...n,
    displayClasses: i,
    mobile: a
  };
}
const B5 = Symbol.for("vuetify:goto");
function Z5() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: "easeInOutCubic",
    patterns: {
      linear: (e) => e,
      easeInQuad: (e) => e ** 2,
      easeOutQuad: (e) => e * (2 - e),
      easeInOutQuad: (e) => e < 0.5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e,
      easeInCubic: (e) => e ** 3,
      easeOutCubic: (e) => --e ** 3 + 1,
      easeInOutCubic: (e) => e < 0.5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
      easeInQuart: (e) => e ** 4,
      easeOutQuart: (e) => 1 - --e ** 4,
      easeInOutQuart: (e) => e < 0.5 ? 8 * e ** 4 : 1 - 8 * --e ** 4,
      easeInQuint: (e) => e ** 5,
      easeOutQuint: (e) => 1 + --e ** 5,
      easeInOutQuint: (e) => e < 0.5 ? 16 * e ** 5 : 1 + 16 * --e ** 5
    }
  };
}
function rS(e) {
  return y2(e) ?? (document.scrollingElement || document.body);
}
function y2(e) {
  return typeof e == "string" ? document.querySelector(e) : o2(e);
}
function W1(e, t, n) {
  if (typeof e == "number") return t && n ? -e : e;
  let a = y2(e), i = 0;
  for (; a; )
    i += t ? a.offsetLeft : a.offsetTop, a = a.offsetParent;
  return i;
}
function sS(e, t) {
  return {
    rtl: t.isRtl,
    options: Gn(Z5(), e)
  };
}
async function rg(e, t, n, a) {
  const i = n ? "scrollLeft" : "scrollTop", l = Gn((a == null ? void 0 : a.options) ?? Z5(), t), r = a == null ? void 0 : a.rtl.value, s = (typeof e == "number" ? e : y2(e)) ?? 0, o = l.container === "parent" && s instanceof HTMLElement ? s.parentElement : rS(l.container), u = typeof l.easing == "function" ? l.easing : l.patterns[l.easing];
  if (!u) throw new TypeError(`Easing function "${l.easing}" not found.`);
  let c;
  if (typeof s == "number")
    c = W1(s, n, r);
  else if (c = W1(s, n, r) - W1(o, n, r), l.layout) {
    const m = window.getComputedStyle(s).getPropertyValue("--v-layout-top");
    m && (c -= parseInt(m, 10));
  }
  c += l.offset, c = uS(o, c, !!r, !!n);
  const d = o[i] ?? 0;
  if (c === d) return Promise.resolve(c);
  const f = performance.now();
  return new Promise((h) => requestAnimationFrame(function m(g) {
    const y = (g - f) / l.duration, b = Math.floor(d + (c - d) * u(ln(y, 0, 1)));
    if (o[i] = b, y >= 1 && Math.abs(b - o[i]) < 10)
      return h(c);
    if (y > 2)
      return Wa("Scroll target is not reachable"), h(o[i]);
    requestAnimationFrame(m);
  }));
}
function oS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = ct(B5), {
    isRtl: n
  } = xn();
  if (!t) throw new Error("[Vuetify] Could not find injected goto instance");
  const a = {
    ...t,
    // can be set via VLocaleProvider
    rtl: k(() => t.rtl.value || n.value)
  };
  async function i(l, r) {
    return rg(l, Gn(e, r), !1, a);
  }
  return i.horizontal = async (l, r) => rg(l, Gn(e, r), !0, a), i;
}
function uS(e, t, n, a) {
  const {
    scrollWidth: i,
    scrollHeight: l
  } = e, [r, s] = e === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [e.offsetWidth, e.offsetHeight];
  let o, u;
  return a ? n ? (o = -(i - r), u = 0) : (o = 0, u = i - r) : (o = 0, u = l + -s), Math.max(Math.min(t, u), o);
}
const E5 = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  // delete (e.g. v-chip close)
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  // for carousel
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus",
  calendar: "mdi-calendar",
  treeviewCollapse: "mdi-menu-down",
  treeviewExpand: "mdi-menu-right",
  eyeDropper: "mdi-eyedropper"
}, N5 = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: (e) => G(b2, {
    ...e,
    class: "mdi"
  })
}, Ue = [String, Function, Object, Array], ih = Symbol.for("vuetify:icons"), jd = le({
  icon: {
    type: Ue
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: !0
  }
}, "icon"), lh = ve()({
  name: "VComponentIcon",
  props: jd(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      const a = e.icon;
      return p(e.tag, null, {
        default: () => {
          var i;
          return [e.icon ? p(a, null, null) : (i = n.default) == null ? void 0 : i.call(n)];
        }
      });
    };
  }
}), O2 = Pa({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: jd(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => p(e.tag, fe(n, {
      style: null
    }), {
      default: () => [p("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [Array.isArray(e.icon) ? e.icon.map((a) => Array.isArray(a) ? p("path", {
        d: a[0],
        "fill-opacity": a[1]
      }, null) : p("path", {
        d: a
      }, null)) : p("path", {
        d: e.icon
      }, null)])]
    });
  }
}), cS = Pa({
  name: "VLigatureIcon",
  props: jd(),
  setup(e) {
    return () => p(e.tag, null, {
      default: () => [e.icon]
    });
  }
}), b2 = Pa({
  name: "VClassIcon",
  props: jd(),
  setup(e) {
    return () => p(e.tag, {
      class: e.icon
    }, null);
  }
});
function dS() {
  return {
    svg: {
      component: O2
    },
    class: {
      component: b2
    }
  };
}
function fS(e) {
  const t = dS(), n = (e == null ? void 0 : e.defaultSet) ?? "mdi";
  return n === "mdi" && !t.mdi && (t.mdi = N5), Gn({
    defaultSet: n,
    sets: t,
    aliases: {
      ...E5,
      /* eslint-disable max-len */
      vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
      "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
      "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", 0.6]]
      /* eslint-enable max-len */
    }
  }, e);
}
const hS = (e) => {
  const t = ct(ih);
  if (!t) throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: k(() => {
      var o;
      const a = X(e);
      if (!a) return {
        component: lh
      };
      let i = a;
      if (typeof i == "string" && (i = i.trim(), i.startsWith("$") && (i = (o = t.aliases) == null ? void 0 : o[i.slice(1)])), i || Wa(`Could not find aliased icon "${a}"`), Array.isArray(i))
        return {
          component: O2,
          icon: i
        };
      if (typeof i != "string")
        return {
          component: lh,
          icon: i
        };
      const l = Object.keys(t.sets).find((u) => typeof i == "string" && i.startsWith(`${u}:`)), r = l ? i.slice(l.length + 1) : i;
      return {
        component: t.sets[l ?? t.defaultSet].component,
        icon: r
      };
    })
  };
}, Io = Symbol.for("vuetify:theme"), dt = le({
  theme: String
}, "theme");
function sg() {
  return {
    defaultTheme: "light",
    variations: {
      colors: [],
      lighten: 0,
      darken: 0
    },
    themes: {
      light: {
        dark: !1,
        colors: {
          background: "#FFFFFF",
          surface: "#FFFFFF",
          "surface-bright": "#FFFFFF",
          "surface-light": "#EEEEEE",
          "surface-variant": "#424242",
          "on-surface-variant": "#EEEEEE",
          primary: "#1867C0",
          "primary-darken-1": "#1F5592",
          secondary: "#48A9A6",
          "secondary-darken-1": "#018786",
          error: "#B00020",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#000000",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 0.87,
          "medium-emphasis-opacity": 0.6,
          "disabled-opacity": 0.38,
          "idle-opacity": 0.04,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.12,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#F5F5F5",
          "theme-on-code": "#000000"
        }
      },
      dark: {
        dark: !0,
        colors: {
          background: "#121212",
          surface: "#212121",
          "surface-bright": "#ccbfd6",
          "surface-light": "#424242",
          "surface-variant": "#a3a3a3",
          "on-surface-variant": "#424242",
          primary: "#2196F3",
          "primary-darken-1": "#277CC1",
          secondary: "#54B6B2",
          "secondary-darken-1": "#48A9A6",
          error: "#CF6679",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#FFFFFF",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 1,
          "medium-emphasis-opacity": 0.7,
          "disabled-opacity": 0.5,
          "idle-opacity": 0.1,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.16,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#343434",
          "theme-on-code": "#CCCCCC"
        }
      }
    }
  };
}
function mS() {
  var a, i;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : sg();
  const t = sg();
  if (!e) return {
    ...t,
    isDisabled: !0
  };
  const n = {};
  for (const [l, r] of Object.entries(e.themes ?? {})) {
    const s = r.dark || l === "dark" ? (a = t.themes) == null ? void 0 : a.dark : (i = t.themes) == null ? void 0 : i.light;
    n[l] = Gn(s, r);
  }
  return Gn(t, {
    ...e,
    themes: n
  });
}
function vS(e) {
  const t = mS(e), n = Y(t.defaultTheme), a = Y(t.themes), i = k(() => {
    const c = {};
    for (const [d, f] of Object.entries(a.value)) {
      const h = c[d] = {
        ...f,
        colors: {
          ...f.colors
        }
      };
      if (t.variations)
        for (const m of t.variations.colors) {
          const g = h.colors[m];
          if (g)
            for (const v of ["lighten", "darken"]) {
              const y = v === "lighten" ? Jw : ek;
              for (const b of bi(t.variations[v], 1))
                h.colors[`${m}-${v}-${b}`] = k5(y(Ta(g), b));
            }
        }
      for (const m of Object.keys(h.colors)) {
        if (/^on-[a-z]/.test(m) || h.colors[`on-${m}`]) continue;
        const g = `on-${m}`, v = Ta(h.colors[m]);
        h.colors[g] = $5(v);
      }
    }
    return c;
  }), l = k(() => i.value[n.value]), r = k(() => {
    var m;
    const c = [];
    (m = l.value) != null && m.dark && Wl(c, ":root", ["color-scheme: dark"]), Wl(c, ":root", og(l.value));
    for (const [g, v] of Object.entries(i.value))
      Wl(c, `.v-theme--${g}`, [`color-scheme: ${v.dark ? "dark" : "normal"}`, ...og(v)]);
    const d = [], f = [], h = new Set(Object.values(i.value).flatMap((g) => Object.keys(g.colors)));
    for (const g of h)
      /^on-[a-z]/.test(g) ? Wl(f, `.${g}`, [`color: rgb(var(--v-theme-${g})) !important`]) : (Wl(d, `.bg-${g}`, [`--v-theme-overlay-multiplier: var(--v-theme-${g}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${g})) !important`, `color: rgb(var(--v-theme-on-${g})) !important`]), Wl(f, `.text-${g}`, [`color: rgb(var(--v-theme-${g})) !important`]), Wl(f, `.border-${g}`, [`--v-border-color: var(--v-theme-${g})`]));
    return c.push(...d, ...f), c.map((g, v) => v === 0 ? g : `    ${g}`).join("");
  });
  function s() {
    return {
      style: [{
        children: r.value,
        id: "vuetify-theme-stylesheet",
        nonce: t.cspNonce || !1
      }]
    };
  }
  function o(c) {
    if (t.isDisabled) return;
    const d = c._context.provides.usehead;
    if (d)
      if (d.push) {
        const f = d.push(s);
        bt && pe(r, () => {
          f.patch(s);
        });
      } else
        bt ? (d.addHeadObjs(k(s)), jt(() => d.updateDOM())) : d.addHeadObjs(s());
    else {
      let h = function() {
        if (typeof document < "u" && !f) {
          const m = document.createElement("style");
          m.type = "text/css", m.id = "vuetify-theme-stylesheet", t.cspNonce && m.setAttribute("nonce", t.cspNonce), f = m, document.head.appendChild(f);
        }
        f && (f.innerHTML = r.value);
      }, f = bt ? document.getElementById("vuetify-theme-stylesheet") : null;
      bt ? pe(r, h, {
        immediate: !0
      }) : h();
    }
  }
  const u = k(() => t.isDisabled ? void 0 : `v-theme--${n.value}`);
  return {
    install: o,
    isDisabled: t.isDisabled,
    name: n,
    themes: a,
    current: l,
    computedThemes: i,
    themeClasses: u,
    styles: r,
    global: {
      name: n,
      current: l
    }
  };
}
function yt(e) {
  Wt("provideTheme");
  const t = ct(Io, null);
  if (!t) throw new Error("Could not find Vuetify theme injection");
  const n = k(() => e.theme ?? t.name.value), a = k(() => t.themes.value[n.value]), i = k(() => t.isDisabled ? void 0 : `v-theme--${n.value}`), l = {
    ...t,
    name: n,
    current: a,
    themeClasses: i
  };
  return Tt(Io, l), l;
}
function H5() {
  Wt("useTheme");
  const e = ct(Io, null);
  if (!e) throw new Error("Could not find Vuetify theme injection");
  return e;
}
function Wl(e, t, n) {
  e.push(`${t} {
`, ...n.map((a) => `  ${a};
`), `}
`);
}
function og(e) {
  const t = e.dark ? 2 : 1, n = e.dark ? 1 : 2, a = [];
  for (const [i, l] of Object.entries(e.colors)) {
    const r = Ta(l);
    a.push(`--v-theme-${i}: ${r.r},${r.g},${r.b}`), i.startsWith("on-") || a.push(`--v-theme-${i}-overlay-multiplier: ${th(l) > 0.18 ? t : n}`);
  }
  for (const [i, l] of Object.entries(e.variables)) {
    const r = typeof l == "string" && l.startsWith("#") ? Ta(l) : void 0, s = r ? `${r.r}, ${r.g}, ${r.b}` : void 0;
    a.push(`--v-${i}: ${s ?? l}`);
  }
  return a;
}
function Ga(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const n = jc(), a = Y();
  if (bt) {
    const i = new ResizeObserver((l) => {
      e == null || e(l, i), l.length && (t === "content" ? a.value = l[0].contentRect : a.value = l[0].target.getBoundingClientRect());
    });
    mn(() => {
      i.disconnect();
    }), pe(() => n.el, (l, r) => {
      r && (i.unobserve(r), a.value = void 0), l && i.observe(l);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef: n,
    contentRect: a2(a)
  };
}
const Bo = Symbol.for("vuetify:layout"), j5 = Symbol.for("vuetify:layout-item"), ug = 1e3, z5 = le({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout"), Ar = le({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function F5() {
  const e = ct(Bo);
  if (!e) throw new Error("[Vuetify] Could not find injected layout");
  return {
    getLayoutItem: e.getLayoutItem,
    mainRect: e.mainRect,
    mainStyles: e.mainStyles
  };
}
function Dr(e) {
  const t = ct(Bo);
  if (!t) throw new Error("[Vuetify] Could not find injected layout");
  const n = e.id ?? `layout-item-${Bn()}`, a = Wt("useLayoutItem");
  Tt(j5, {
    id: n
  });
  const i = Ve(!1);
  q4(() => i.value = !0), LC(() => i.value = !1);
  const {
    layoutItemStyles: l,
    layoutItemScrimStyles: r
  } = t.register(a, {
    ...e,
    active: k(() => i.value ? !1 : e.active.value),
    id: n
  });
  return mn(() => t.unregister(n)), {
    layoutItemStyles: l,
    layoutRect: t.layoutRect,
    layoutItemScrimStyles: r
  };
}
const gS = (e, t, n, a) => {
  let i = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const l = [{
    id: "",
    layer: {
      ...i
    }
  }];
  for (const r of e) {
    const s = t.get(r), o = n.get(r), u = a.get(r);
    if (!s || !o || !u) continue;
    const c = {
      ...i,
      [s.value]: parseInt(i[s.value], 10) + (u.value ? parseInt(o.value, 10) : 0)
    };
    l.push({
      id: r,
      layer: c
    }), i = c;
  }
  return l;
};
function X5(e) {
  const t = ct(Bo, null), n = k(() => t ? t.rootZIndex.value - 100 : ug), a = Y([]), i = zt(/* @__PURE__ */ new Map()), l = zt(/* @__PURE__ */ new Map()), r = zt(/* @__PURE__ */ new Map()), s = zt(/* @__PURE__ */ new Map()), o = zt(/* @__PURE__ */ new Map()), {
    resizeRef: u,
    contentRect: c
  } = Ga(), d = k(() => {
    const w = /* @__PURE__ */ new Map(), V = e.overlaps ?? [];
    for (const _ of V.filter((O) => O.includes(":"))) {
      const [O, $] = _.split(":");
      if (!a.value.includes(O) || !a.value.includes($)) continue;
      const P = i.get(O), M = i.get($), T = l.get(O), L = l.get($);
      !P || !M || !T || !L || (w.set($, {
        position: P.value,
        amount: parseInt(T.value, 10)
      }), w.set(O, {
        position: M.value,
        amount: -parseInt(L.value, 10)
      }));
    }
    return w;
  }), f = k(() => {
    const w = [...new Set([...r.values()].map((_) => _.value))].sort((_, O) => _ - O), V = [];
    for (const _ of w) {
      const O = a.value.filter(($) => {
        var P;
        return ((P = r.get($)) == null ? void 0 : P.value) === _;
      });
      V.push(...O);
    }
    return gS(V, i, l, s);
  }), h = k(() => !Array.from(o.values()).some((w) => w.value)), m = k(() => f.value[f.value.length - 1].layer), g = k(() => ({
    "--v-layout-left": Qe(m.value.left),
    "--v-layout-right": Qe(m.value.right),
    "--v-layout-top": Qe(m.value.top),
    "--v-layout-bottom": Qe(m.value.bottom),
    ...h.value ? void 0 : {
      transition: "none"
    }
  })), v = k(() => f.value.slice(1).map((w, V) => {
    let {
      id: _
    } = w;
    const {
      layer: O
    } = f.value[V], $ = l.get(_), P = i.get(_);
    return {
      id: _,
      ...O,
      size: Number($.value),
      position: P.value
    };
  })), y = (w) => v.value.find((V) => V.id === w), b = Wt("createLayout"), C = Ve(!1);
  rt(() => {
    C.value = !0;
  }), Tt(Bo, {
    register: (w, V) => {
      let {
        id: _,
        order: O,
        position: $,
        layoutSize: P,
        elementSize: M,
        active: T,
        disableTransitions: L,
        absolute: A
      } = V;
      r.set(_, O), i.set(_, $), l.set(_, P), s.set(_, T), L && o.set(_, L);
      const B = is(j5, b == null ? void 0 : b.vnode).indexOf(w);
      B > -1 ? a.value.splice(B, 0, _) : a.value.push(_);
      const j = k(() => v.value.findIndex((J) => J.id === _)), I = k(() => n.value + f.value.length * 2 - j.value * 2), Z = k(() => {
        const J = $.value === "left" || $.value === "right", F = $.value === "right", q = $.value === "bottom", z = M.value ?? P.value, E = z === 0 ? "%" : "px", Q = {
          [$.value]: 0,
          zIndex: I.value,
          transform: `translate${J ? "X" : "Y"}(${(T.value ? 0 : -(z === 0 ? 100 : z)) * (F || q ? -1 : 1)}${E})`,
          position: A.value || n.value !== ug ? "absolute" : "fixed",
          ...h.value ? void 0 : {
            transition: "none"
          }
        };
        if (!C.value) return Q;
        const W = v.value[j.value];
        if (!W) throw new Error(`[Vuetify] Could not find layout item "${_}"`);
        const se = d.value.get(_);
        return se && (W[se.position] += se.amount), {
          ...Q,
          height: J ? `calc(100% - ${W.top}px - ${W.bottom}px)` : M.value ? `${M.value}px` : void 0,
          left: F ? void 0 : `${W.left}px`,
          right: F ? `${W.right}px` : void 0,
          top: $.value !== "bottom" ? `${W.top}px` : void 0,
          bottom: $.value !== "top" ? `${W.bottom}px` : void 0,
          width: J ? M.value ? `${M.value}px` : void 0 : `calc(100% - ${W.left}px - ${W.right}px)`
        };
      }), R = k(() => ({
        zIndex: I.value - 1
      }));
      return {
        layoutItemStyles: Z,
        layoutItemScrimStyles: R,
        zIndex: I
      };
    },
    unregister: (w) => {
      r.delete(w), i.delete(w), l.delete(w), s.delete(w), o.delete(w), a.value = a.value.filter((V) => V !== w);
    },
    mainRect: m,
    mainStyles: g,
    getLayoutItem: y,
    items: v,
    layoutRect: c,
    rootZIndex: n
  });
  const S = k(() => ["v-layout", {
    "v-layout--full-height": e.fullHeight
  }]), x = k(() => ({
    zIndex: t ? n.value : void 0,
    position: t ? "relative" : void 0,
    overflow: t ? "hidden" : void 0
  }));
  return {
    layoutClasses: S,
    layoutStyles: x,
    getLayoutItem: y,
    items: v,
    layoutRect: c,
    layoutRef: u
  };
}
function Y5() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint: t,
    ...n
  } = e, a = Gn(t, n), {
    aliases: i = {},
    components: l = {},
    directives: r = {}
  } = a, s = ak(a.defaults), o = lS(a.display, a.ssr), u = vS(a.theme), c = fS(a.icons), d = hk(a.locale), f = nS(a.date, d), h = sS(a.goTo, d);
  return {
    install: (g) => {
      for (const v in r)
        g.directive(v, r[v]);
      for (const v in l)
        g.component(v, l[v]);
      for (const v in i)
        g.component(v, Pa({
          ...i[v],
          name: v,
          aliasName: i[v].name
        }));
      if (u.install(g), g.provide(Os, s), g.provide(ah, o), g.provide(Io, u), g.provide(ih, c), g.provide(bs, d), g.provide(R5, f.options), g.provide(tg, f.instance), g.provide(B5, h), bt && a.ssr)
        if (g.$nuxt)
          g.$nuxt.hook("app:suspense:resolve", () => {
            o.update();
          });
        else {
          const {
            mount: v
          } = g;
          g.mount = function() {
            const y = v(...arguments);
            return et(() => o.update()), g.mount = v, y;
          };
        }
      Bn.reset(), g.mixin({
        computed: {
          $vuetify() {
            return zt({
              defaults: Wr.call(this, Os),
              display: Wr.call(this, ah),
              theme: Wr.call(this, Io),
              icons: Wr.call(this, ih),
              locale: Wr.call(this, bs),
              date: Wr.call(this, tg)
            });
          }
        }
      });
    },
    defaults: s,
    display: o,
    theme: u,
    icons: c,
    locale: d,
    date: f,
    goTo: h
  };
}
const pS = "3.7.1";
Y5.version = pS;
function Wr(e) {
  var a, i;
  const t = this.$, n = ((a = t.parent) == null ? void 0 : a.provides) ?? ((i = t.vnode.appContext) == null ? void 0 : i.provides);
  if (n && e in n)
    return n[e];
}
function yS() {
  return !0;
}
function W5(e, t, n) {
  if (!e || q5(e, n) === !1) return !1;
  const a = M5(t);
  if (typeof ShadowRoot < "u" && a instanceof ShadowRoot && a.host === e.target) return !1;
  const i = (typeof n.value == "object" && n.value.include || (() => []))();
  return i.push(t), !i.some((l) => l == null ? void 0 : l.contains(e.target));
}
function q5(e, t) {
  return (typeof t.value == "object" && t.value.closeConditional || yS)(e);
}
function OS(e, t, n) {
  const a = typeof n.value == "function" ? n.value : n.value.handler;
  e.shadowTarget = e.target, t._clickOutside.lastMousedownWasOutside && W5(e, t, n) && setTimeout(() => {
    q5(e, n) && a && a(e);
  }, 0);
}
function cg(e, t) {
  const n = M5(e);
  t(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && t(n);
}
const U5 = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(e, t) {
    const n = (i) => OS(i, e, t), a = (i) => {
      e._clickOutside.lastMousedownWasOutside = W5(i, e, t);
    };
    cg(e, (i) => {
      i.addEventListener("click", n, !0), i.addEventListener("mousedown", a, !0);
    }), e._clickOutside || (e._clickOutside = {
      lastMousedownWasOutside: !1
    }), e._clickOutside[t.instance.$.uid] = {
      onClick: n,
      onMousedown: a
    };
  },
  beforeUnmount(e, t) {
    e._clickOutside && (cg(e, (n) => {
      var l;
      if (!n || !((l = e._clickOutside) != null && l[t.instance.$.uid])) return;
      const {
        onClick: a,
        onMousedown: i
      } = e._clickOutside[t.instance.$.uid];
      n.removeEventListener("click", a, !0), n.removeEventListener("mousedown", i, !0);
    }), delete e._clickOutside[t.instance.$.uid]);
  }
};
function bS(e, t) {
  if (!r2) return;
  const n = t.modifiers || {}, a = t.value, {
    handler: i,
    options: l
  } = typeof a == "object" ? a : {
    handler: a,
    options: {}
  }, r = new IntersectionObserver(function() {
    var d;
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], o = arguments.length > 1 ? arguments[1] : void 0;
    const u = (d = e._observe) == null ? void 0 : d[t.instance.$.uid];
    if (!u) return;
    const c = s.some((f) => f.isIntersecting);
    i && (!n.quiet || u.init) && (!n.once || c || u.init) && i(c, s, o), c && n.once ? G5(e, t) : u.init = !0;
  }, l);
  e._observe = Object(e._observe), e._observe[t.instance.$.uid] = {
    init: !1,
    observer: r
  }, r.observe(e);
}
function G5(e, t) {
  var a;
  const n = (a = e._observe) == null ? void 0 : a[t.instance.$.uid];
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid]);
}
const pu = {
  mounted: bS,
  unmounted: G5
};
function CS(e, t) {
  const n = t.modifiers || {}, a = t.value, {
    once: i,
    immediate: l,
    ...r
  } = n, s = !Object.keys(r).length, {
    handler: o,
    options: u
  } = typeof a == "object" ? a : {
    handler: a,
    options: {
      attributes: (r == null ? void 0 : r.attr) ?? s,
      characterData: (r == null ? void 0 : r.char) ?? s,
      childList: (r == null ? void 0 : r.child) ?? s,
      subtree: (r == null ? void 0 : r.sub) ?? s
    }
  }, c = new MutationObserver(function() {
    let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], f = arguments.length > 1 ? arguments[1] : void 0;
    o == null || o(d, f), i && K5(e, t);
  });
  l && (o == null || o([], c)), e._mutate = Object(e._mutate), e._mutate[t.instance.$.uid] = {
    observer: c
  }, c.observe(e, u);
}
function K5(e, t) {
  var n;
  (n = e._mutate) != null && n[t.instance.$.uid] && (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid]);
}
const wS = {
  mounted: CS,
  unmounted: K5
};
function kS(e, t) {
  var i, l;
  const n = t.value, a = {
    passive: !((i = t.modifiers) != null && i.active)
  };
  window.addEventListener("resize", n, a), e._onResize = Object(e._onResize), e._onResize[t.instance.$.uid] = {
    handler: n,
    options: a
  }, (l = t.modifiers) != null && l.quiet || n();
}
function SS(e, t) {
  var i;
  if (!((i = e._onResize) != null && i[t.instance.$.uid])) return;
  const {
    handler: n,
    options: a
  } = e._onResize[t.instance.$.uid];
  window.removeEventListener("resize", n, a), delete e._onResize[t.instance.$.uid];
}
const xS = {
  mounted: kS,
  unmounted: SS
}, rh = Symbol("rippleStop"), PS = 80;
function dg(e, t) {
  e.style.transform = t, e.style.webkitTransform = t;
}
function sh(e) {
  return e.constructor.name === "TouchEvent";
}
function J5(e) {
  return e.constructor.name === "KeyboardEvent";
}
const $S = function(e, t) {
  var d;
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = 0, i = 0;
  if (!J5(e)) {
    const f = t.getBoundingClientRect(), h = sh(e) ? e.touches[e.touches.length - 1] : e;
    a = h.clientX - f.left, i = h.clientY - f.top;
  }
  let l = 0, r = 0.3;
  (d = t._ripple) != null && d.circle ? (r = 0.15, l = t.clientWidth / 2, l = n.center ? l : l + Math.sqrt((a - l) ** 2 + (i - l) ** 2) / 4) : l = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
  const s = `${(t.clientWidth - l * 2) / 2}px`, o = `${(t.clientHeight - l * 2) / 2}px`, u = n.center ? s : `${a - l}px`, c = n.center ? o : `${i - l}px`;
  return {
    radius: l,
    scale: r,
    x: u,
    y: c,
    centerX: s,
    centerY: o
  };
}, qc = {
  /* eslint-disable max-statements */
  show(e, t) {
    var h;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!((h = t == null ? void 0 : t._ripple) != null && h.enabled))
      return;
    const a = document.createElement("span"), i = document.createElement("span");
    a.appendChild(i), a.className = "v-ripple__container", n.class && (a.className += ` ${n.class}`);
    const {
      radius: l,
      scale: r,
      x: s,
      y: o,
      centerX: u,
      centerY: c
    } = $S(e, t, n), d = `${l * 2}px`;
    i.className = "v-ripple__animation", i.style.width = d, i.style.height = d, t.appendChild(a);
    const f = window.getComputedStyle(t);
    f && f.position === "static" && (t.style.position = "relative", t.dataset.previousPosition = "static"), i.classList.add("v-ripple__animation--enter"), i.classList.add("v-ripple__animation--visible"), dg(i, `translate(${s}, ${o}) scale3d(${r},${r},${r})`), i.dataset.activated = String(performance.now()), setTimeout(() => {
      i.classList.remove("v-ripple__animation--enter"), i.classList.add("v-ripple__animation--in"), dg(i, `translate(${u}, ${c}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(e) {
    var l;
    if (!((l = e == null ? void 0 : e._ripple) != null && l.enabled)) return;
    const t = e.getElementsByClassName("v-ripple__animation");
    if (t.length === 0) return;
    const n = t[t.length - 1];
    if (n.dataset.isHiding) return;
    n.dataset.isHiding = "true";
    const a = performance.now() - Number(n.dataset.activated), i = Math.max(250 - a, 0);
    setTimeout(() => {
      n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => {
        var s;
        e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), ((s = n.parentNode) == null ? void 0 : s.parentNode) === e && e.removeChild(n.parentNode);
      }, 300);
    }, i);
  }
};
function e3(e) {
  return typeof e > "u" || !!e;
}
function Zo(e) {
  const t = {}, n = e.currentTarget;
  if (!(!(n != null && n._ripple) || n._ripple.touched || e[rh])) {
    if (e[rh] = !0, sh(e))
      n._ripple.touched = !0, n._ripple.isTouch = !0;
    else if (n._ripple.isTouch) return;
    if (t.center = n._ripple.centered || J5(e), n._ripple.class && (t.class = n._ripple.class), sh(e)) {
      if (n._ripple.showTimerCommit) return;
      n._ripple.showTimerCommit = () => {
        qc.show(e, n, t);
      }, n._ripple.showTimer = window.setTimeout(() => {
        var a;
        (a = n == null ? void 0 : n._ripple) != null && a.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null);
      }, PS);
    } else
      qc.show(e, n, t);
  }
}
function fg(e) {
  e[rh] = !0;
}
function wa(e) {
  const t = e.currentTarget;
  if (t != null && t._ripple) {
    if (window.clearTimeout(t._ripple.showTimer), e.type === "touchend" && t._ripple.showTimerCommit) {
      t._ripple.showTimerCommit(), t._ripple.showTimerCommit = null, t._ripple.showTimer = window.setTimeout(() => {
        wa(e);
      });
      return;
    }
    window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1);
    }), qc.hide(t);
  }
}
function t3(e) {
  const t = e.currentTarget;
  t != null && t._ripple && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer));
}
let Eo = !1;
function n3(e) {
  !Eo && (e.keyCode === Qv.enter || e.keyCode === Qv.space) && (Eo = !0, Zo(e));
}
function a3(e) {
  Eo = !1, wa(e);
}
function i3(e) {
  Eo && (Eo = !1, wa(e));
}
function l3(e, t, n) {
  const {
    value: a,
    modifiers: i
  } = t, l = e3(a);
  if (l || qc.hide(e), e._ripple = e._ripple ?? {}, e._ripple.enabled = l, e._ripple.centered = i.center, e._ripple.circle = i.circle, s2(a) && a.class && (e._ripple.class = a.class), l && !n) {
    if (i.stop) {
      e.addEventListener("touchstart", fg, {
        passive: !0
      }), e.addEventListener("mousedown", fg);
      return;
    }
    e.addEventListener("touchstart", Zo, {
      passive: !0
    }), e.addEventListener("touchend", wa, {
      passive: !0
    }), e.addEventListener("touchmove", t3, {
      passive: !0
    }), e.addEventListener("touchcancel", wa), e.addEventListener("mousedown", Zo), e.addEventListener("mouseup", wa), e.addEventListener("mouseleave", wa), e.addEventListener("keydown", n3), e.addEventListener("keyup", a3), e.addEventListener("blur", i3), e.addEventListener("dragstart", wa, {
      passive: !0
    });
  } else !l && n && r3(e);
}
function r3(e) {
  e.removeEventListener("mousedown", Zo), e.removeEventListener("touchstart", Zo), e.removeEventListener("touchend", wa), e.removeEventListener("touchmove", t3), e.removeEventListener("touchcancel", wa), e.removeEventListener("mouseup", wa), e.removeEventListener("mouseleave", wa), e.removeEventListener("keydown", n3), e.removeEventListener("keyup", a3), e.removeEventListener("dragstart", wa), e.removeEventListener("blur", i3);
}
function _S(e, t) {
  l3(e, t, !1);
}
function MS(e) {
  delete e._ripple, r3(e);
}
function VS(e, t) {
  if (t.value === t.oldValue)
    return;
  const n = e3(t.oldValue);
  l3(e, t, n);
}
const nl = {
  mounted: _S,
  unmounted: MS,
  updated: VS
};
function s3(e, t) {
  const {
    self: n = !1
  } = t.modifiers ?? {}, a = t.value, i = typeof a == "object" && a.options || {
    passive: !0
  }, l = typeof a == "function" || "handleEvent" in a ? a : a.handler, r = n ? e : t.arg ? document.querySelector(t.arg) : window;
  r && (r.addEventListener("scroll", l, i), e._onScroll = Object(e._onScroll), e._onScroll[t.instance.$.uid] = {
    handler: l,
    options: i,
    // Don't reference self
    target: n ? void 0 : r
  });
}
function o3(e, t) {
  var l;
  if (!((l = e._onScroll) != null && l[t.instance.$.uid])) return;
  const {
    handler: n,
    options: a,
    target: i = e
  } = e._onScroll[t.instance.$.uid];
  i.removeEventListener("scroll", n, a), delete e._onScroll[t.instance.$.uid];
}
function TS(e, t) {
  t.value !== t.oldValue && (o3(e, t), s3(e, t));
}
const LS = {
  mounted: s3,
  unmounted: o3,
  updated: TS
}, QS = (e) => {
  const {
    touchstartX: t,
    touchendX: n,
    touchstartY: a,
    touchendY: i
  } = e, l = 0.5, r = 16;
  e.offsetX = n - t, e.offsetY = i - a, Math.abs(e.offsetY) < l * Math.abs(e.offsetX) && (e.left && n < t - r && e.left(e), e.right && n > t + r && e.right(e)), Math.abs(e.offsetX) < l * Math.abs(e.offsetY) && (e.up && i < a - r && e.up(e), e.down && i > a + r && e.down(e));
};
function AS(e, t) {
  var a;
  const n = e.changedTouches[0];
  t.touchstartX = n.clientX, t.touchstartY = n.clientY, (a = t.start) == null || a.call(t, {
    originalEvent: e,
    ...t
  });
}
function DS(e, t) {
  var a;
  const n = e.changedTouches[0];
  t.touchendX = n.clientX, t.touchendY = n.clientY, (a = t.end) == null || a.call(t, {
    originalEvent: e,
    ...t
  }), QS(t);
}
function RS(e, t) {
  var a;
  const n = e.changedTouches[0];
  t.touchmoveX = n.clientX, t.touchmoveY = n.clientY, (a = t.move) == null || a.call(t, {
    originalEvent: e,
    ...t
  });
}
function IS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end
  };
  return {
    touchstart: (n) => AS(n, t),
    touchend: (n) => DS(n, t),
    touchmove: (n) => RS(n, t)
  };
}
function BS(e, t) {
  var s;
  const n = t.value, a = n != null && n.parent ? e.parentElement : e, i = (n == null ? void 0 : n.options) ?? {
    passive: !0
  }, l = (s = t.instance) == null ? void 0 : s.$.uid;
  if (!a || !l) return;
  const r = IS(t.value);
  a._touchHandlers = a._touchHandlers ?? /* @__PURE__ */ Object.create(null), a._touchHandlers[l] = r, u5(r).forEach((o) => {
    a.addEventListener(o, r[o], i);
  });
}
function ZS(e, t) {
  var l, r;
  const n = (l = t.value) != null && l.parent ? e.parentElement : e, a = (r = t.instance) == null ? void 0 : r.$.uid;
  if (!(n != null && n._touchHandlers) || !a) return;
  const i = n._touchHandlers[a];
  u5(i).forEach((s) => {
    n.removeEventListener(s, i[s]);
  }), delete n._touchHandlers[a];
}
const C2 = {
  mounted: BS,
  unmounted: ZS
};
function q1(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}
function ES(e, t) {
  return {
    x: e.x - t.x,
    y: e.y - t.y
  };
}
function hg(e, t) {
  if (e.side === "top" || e.side === "bottom") {
    const {
      side: n,
      align: a
    } = e, i = a === "left" ? 0 : a === "center" ? t.width / 2 : a === "right" ? t.width : a, l = n === "top" ? 0 : n === "bottom" ? t.height : n;
    return q1({
      x: i,
      y: l
    }, t);
  } else if (e.side === "left" || e.side === "right") {
    const {
      side: n,
      align: a
    } = e, i = n === "left" ? 0 : n === "right" ? t.width : n, l = a === "top" ? 0 : a === "center" ? t.height / 2 : a === "bottom" ? t.height : a;
    return q1({
      x: i,
      y: l
    }, t);
  }
  return q1({
    x: t.width / 2,
    y: t.height / 2
  }, t);
}
const u3 = {
  static: jS,
  // specific viewport position, usually centered
  connected: FS
  // connected to a certain element
}, NS = le({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (e) => typeof e == "function" || e in u3
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function HS(e, t) {
  const n = Y({}), a = Y();
  bt && la(() => !!(t.isActive.value && e.locationStrategy), (l) => {
    var r, s;
    pe(() => e.locationStrategy, l), Xn(() => {
      window.removeEventListener("resize", i), a.value = void 0;
    }), window.addEventListener("resize", i, {
      passive: !0
    }), typeof e.locationStrategy == "function" ? a.value = (r = e.locationStrategy(t, e, n)) == null ? void 0 : r.updateLocation : a.value = (s = u3[e.locationStrategy](t, e, n)) == null ? void 0 : s.updateLocation;
  });
  function i(l) {
    var r;
    (r = a.value) == null || r.call(a, l);
  }
  return {
    contentStyles: n,
    updateLocation: a
  };
}
function jS() {
}
function zS(e, t) {
  const n = f2(e);
  return t ? n.x += parseFloat(e.style.right || 0) : n.x -= parseFloat(e.style.left || 0), n.y -= parseFloat(e.style.top || 0), n;
}
function FS(e, t, n) {
  (Array.isArray(e.target.value) || ck(e.target.value)) && Object.assign(n.value, {
    position: "fixed",
    top: 0,
    [e.isRtl.value ? "right" : "left"]: 0
  });
  const {
    preferredAnchor: i,
    preferredOrigin: l
  } = c2(() => {
    const m = Kf(t.location, e.isRtl.value), g = t.origin === "overlap" ? m : t.origin === "auto" ? F1(m) : Kf(t.origin, e.isRtl.value);
    return m.side === g.side && m.align === X1(g).align ? {
      preferredAnchor: Zv(m),
      preferredOrigin: Zv(g)
    } : {
      preferredAnchor: m,
      preferredOrigin: g
    };
  }), [r, s, o, u] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((m) => k(() => {
    const g = parseFloat(t[m]);
    return isNaN(g) ? 1 / 0 : g;
  })), c = k(() => {
    if (Array.isArray(t.offset))
      return t.offset;
    if (typeof t.offset == "string") {
      const m = t.offset.split(" ").map(parseFloat);
      return m.length < 2 && m.push(0), m;
    }
    return typeof t.offset == "number" ? [t.offset, 0] : [0, 0];
  });
  let d = !1;
  const f = new ResizeObserver(() => {
    d && h();
  });
  pe([e.target, e.contentEl], (m, g) => {
    let [v, y] = m, [b, C] = g;
    b && !Array.isArray(b) && f.unobserve(b), v && !Array.isArray(v) && f.observe(v), C && f.unobserve(C), y && f.observe(y);
  }, {
    immediate: !0
  }), Xn(() => {
    f.disconnect();
  });
  function h() {
    if (d = !1, requestAnimationFrame(() => d = !0), !e.target.value || !e.contentEl.value) return;
    const m = g5(e.target.value), g = zS(e.contentEl.value, e.isRtl.value), v = Yc(e.contentEl.value), y = 12;
    v.length || (v.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (g.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), g.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
    const b = v.reduce((P, M) => {
      const T = M.getBoundingClientRect(), L = new ur({
        x: M === document.documentElement ? 0 : T.x,
        y: M === document.documentElement ? 0 : T.y,
        width: M.clientWidth,
        height: M.clientHeight
      });
      return P ? new ur({
        x: Math.max(P.left, L.left),
        y: Math.max(P.top, L.top),
        width: Math.min(P.right, L.right) - Math.max(P.left, L.left),
        height: Math.min(P.bottom, L.bottom) - Math.max(P.top, L.top)
      }) : L;
    }, void 0);
    b.x += y, b.y += y, b.width -= y * 2, b.height -= y * 2;
    let C = {
      anchor: i.value,
      origin: l.value
    };
    function S(P) {
      const M = new ur(g), T = hg(P.anchor, m), L = hg(P.origin, M);
      let {
        x: A,
        y: D
      } = ES(T, L);
      switch (P.anchor.side) {
        case "top":
          D -= c.value[0];
          break;
        case "bottom":
          D += c.value[0];
          break;
        case "left":
          A -= c.value[0];
          break;
        case "right":
          A += c.value[0];
          break;
      }
      switch (P.anchor.align) {
        case "top":
          D -= c.value[1];
          break;
        case "bottom":
          D += c.value[1];
          break;
        case "left":
          A -= c.value[1];
          break;
        case "right":
          A += c.value[1];
          break;
      }
      return M.x += A, M.y += D, M.width = Math.min(M.width, o.value), M.height = Math.min(M.height, u.value), {
        overflows: Nv(M, b),
        x: A,
        y: D
      };
    }
    let x = 0, w = 0;
    const V = {
      x: 0,
      y: 0
    }, _ = {
      x: !1,
      y: !1
    };
    let O = -1;
    for (; ; ) {
      if (O++ > 10) {
        Fc("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: P,
        y: M,
        overflows: T
      } = S(C);
      x += P, w += M, g.x += P, g.y += M;
      {
        const L = Ev(C.anchor), A = T.x.before || T.x.after, D = T.y.before || T.y.after;
        let B = !1;
        if (["x", "y"].forEach((j) => {
          if (j === "x" && A && !_.x || j === "y" && D && !_.y) {
            const I = {
              anchor: {
                ...C.anchor
              },
              origin: {
                ...C.origin
              }
            }, Z = j === "x" ? L === "y" ? X1 : F1 : L === "y" ? F1 : X1;
            I.anchor = Z(I.anchor), I.origin = Z(I.origin);
            const {
              overflows: R
            } = S(I);
            (R[j].before <= T[j].before && R[j].after <= T[j].after || R[j].before + R[j].after < (T[j].before + T[j].after) / 2) && (C = I, B = _[j] = !0);
          }
        }), B) continue;
      }
      T.x.before && (x += T.x.before, g.x += T.x.before), T.x.after && (x -= T.x.after, g.x -= T.x.after), T.y.before && (w += T.y.before, g.y += T.y.before), T.y.after && (w -= T.y.after, g.y -= T.y.after);
      {
        const L = Nv(g, b);
        V.x = b.width - L.x.before - L.x.after, V.y = b.height - L.y.before - L.y.after, x += L.x.before, g.x += L.x.before, w += L.y.before, g.y += L.y.before;
      }
      break;
    }
    const $ = Ev(C.anchor);
    return Object.assign(n.value, {
      "--v-overlay-anchor-origin": `${C.anchor.side} ${C.anchor.align}`,
      transformOrigin: `${C.origin.side} ${C.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: Qe(U1(w)),
      left: e.isRtl.value ? void 0 : Qe(U1(x)),
      right: e.isRtl.value ? Qe(U1(-x)) : void 0,
      minWidth: Qe($ === "y" ? Math.min(r.value, m.width) : r.value),
      maxWidth: Qe(mg(ln(V.x, r.value === 1 / 0 ? 0 : r.value, o.value))),
      maxHeight: Qe(mg(ln(V.y, s.value === 1 / 0 ? 0 : s.value, u.value)))
    }), {
      available: V,
      contentBox: g
    };
  }
  return pe(() => [i.value, l.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight], () => h()), et(() => {
    const m = h();
    if (!m) return;
    const {
      available: g,
      contentBox: v
    } = m;
    v.height > g.y && requestAnimationFrame(() => {
      h(), requestAnimationFrame(() => {
        h();
      });
    });
  }), {
    updateLocation: h
  };
}
function U1(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio;
}
function mg(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio;
}
let oh = !0;
const Uc = [];
function XS(e) {
  !oh || Uc.length ? (Uc.push(e), uh()) : (oh = !1, e(), uh());
}
let vg = -1;
function uh() {
  cancelAnimationFrame(vg), vg = requestAnimationFrame(() => {
    const e = Uc.shift();
    e && e(), Uc.length ? uh() : oh = !0;
  });
}
const Sc = {
  none: null,
  close: qS,
  block: US,
  reposition: GS
}, YS = le({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (e) => typeof e == "function" || e in Sc
  }
}, "VOverlay-scroll-strategies");
function WS(e, t) {
  if (!bt) return;
  let n;
  jt(async () => {
    n == null || n.stop(), t.isActive.value && e.scrollStrategy && (n = n2(), await new Promise((a) => setTimeout(a)), n.active && n.run(() => {
      var a;
      typeof e.scrollStrategy == "function" ? e.scrollStrategy(t, e, n) : (a = Sc[e.scrollStrategy]) == null || a.call(Sc, t, e, n);
    }));
  }), Xn(() => {
    n == null || n.stop();
  });
}
function qS(e) {
  function t(n) {
    e.isActive.value = !1;
  }
  c3(e.targetEl.value ?? e.contentEl.value, t);
}
function US(e, t) {
  var r;
  const n = (r = e.root.value) == null ? void 0 : r.offsetParent, a = [.../* @__PURE__ */ new Set([...Yc(e.targetEl.value, t.contained ? n : void 0), ...Yc(e.contentEl.value, t.contained ? n : void 0)])].filter((s) => !s.classList.contains("v-overlay-scroll-blocked")), i = window.innerWidth - document.documentElement.offsetWidth, l = ((s) => p2(s) && s)(n || document.documentElement);
  l && e.root.value.classList.add("v-overlay--scroll-blocked"), a.forEach((s, o) => {
    s.style.setProperty("--v-body-scroll-x", Qe(-s.scrollLeft)), s.style.setProperty("--v-body-scroll-y", Qe(-s.scrollTop)), s !== document.documentElement && s.style.setProperty("--v-scrollbar-offset", Qe(i)), s.classList.add("v-overlay-scroll-blocked");
  }), Xn(() => {
    a.forEach((s, o) => {
      const u = parseFloat(s.style.getPropertyValue("--v-body-scroll-x")), c = parseFloat(s.style.getPropertyValue("--v-body-scroll-y")), d = s.style.scrollBehavior;
      s.style.scrollBehavior = "auto", s.style.removeProperty("--v-body-scroll-x"), s.style.removeProperty("--v-body-scroll-y"), s.style.removeProperty("--v-scrollbar-offset"), s.classList.remove("v-overlay-scroll-blocked"), s.scrollLeft = -u, s.scrollTop = -c, s.style.scrollBehavior = d;
    }), l && e.root.value.classList.remove("v-overlay--scroll-blocked");
  });
}
function GS(e, t, n) {
  let a = !1, i = -1, l = -1;
  function r(s) {
    XS(() => {
      var c, d;
      const o = performance.now();
      (d = (c = e.updateLocation).value) == null || d.call(c, s), a = (performance.now() - o) / (1e3 / 60) > 2;
    });
  }
  l = (typeof requestIdleCallback > "u" ? (s) => s() : requestIdleCallback)(() => {
    n.run(() => {
      c3(e.targetEl.value ?? e.contentEl.value, (s) => {
        a ? (cancelAnimationFrame(i), i = requestAnimationFrame(() => {
          i = requestAnimationFrame(() => {
            r(s);
          });
        })) : r(s);
      });
    });
  }), Xn(() => {
    typeof cancelIdleCallback < "u" && cancelIdleCallback(l), cancelAnimationFrame(i);
  });
}
function c3(e, t) {
  const n = [document, ...Yc(e)];
  n.forEach((a) => {
    a.addEventListener("scroll", t, {
      passive: !0
    });
  }), Xn(() => {
    n.forEach((a) => {
      a.removeEventListener("scroll", t);
    });
  });
}
const ch = Symbol.for("vuetify:v-menu"), w2 = le({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function k2(e, t) {
  let n = () => {
  };
  function a(r) {
    n == null || n();
    const s = Number(r ? e.openDelay : e.closeDelay);
    return new Promise((o) => {
      n = Mw(s, () => {
        t == null || t(r), o(r);
      });
    });
  }
  function i() {
    return a(!0);
  }
  function l() {
    return a(!1);
  }
  return {
    clearDelay: n,
    runOpenDelay: i,
    runCloseDelay: l
  };
}
const KS = le({
  target: [String, Object],
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...w2()
}, "VOverlay-activator");
function JS(e, t) {
  let {
    isActive: n,
    isTop: a,
    contentEl: i
  } = t;
  const l = Wt("useActivator"), r = Y();
  let s = !1, o = !1, u = !0;
  const c = k(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover), d = k(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !c.value), {
    runOpenDelay: f,
    runCloseDelay: h
  } = k2(e, (_) => {
    _ === (e.openOnHover && s || c.value && o) && !(e.openOnHover && n.value && !a.value) && (n.value !== _ && (u = !0), n.value = _);
  }), m = Y(), g = {
    onClick: (_) => {
      _.stopPropagation(), r.value = _.currentTarget || _.target, n.value || (m.value = [_.clientX, _.clientY]), n.value = !n.value;
    },
    onMouseenter: (_) => {
      var O;
      (O = _.sourceCapabilities) != null && O.firesTouchEvents || (s = !0, r.value = _.currentTarget || _.target, f());
    },
    onMouseleave: (_) => {
      s = !1, h();
    },
    onFocus: (_) => {
      ys(_.target, ":focus-visible") !== !1 && (o = !0, _.stopPropagation(), r.value = _.currentTarget || _.target, f());
    },
    onBlur: (_) => {
      o = !1, _.stopPropagation(), h();
    }
  }, v = k(() => {
    const _ = {};
    return d.value && (_.onClick = g.onClick), e.openOnHover && (_.onMouseenter = g.onMouseenter, _.onMouseleave = g.onMouseleave), c.value && (_.onFocus = g.onFocus, _.onBlur = g.onBlur), _;
  }), y = k(() => {
    const _ = {};
    if (e.openOnHover && (_.onMouseenter = () => {
      s = !0, f();
    }, _.onMouseleave = () => {
      s = !1, h();
    }), c.value && (_.onFocusin = () => {
      o = !0, f();
    }, _.onFocusout = () => {
      o = !1, h();
    }), e.closeOnContentClick) {
      const O = ct(ch, null);
      _.onClick = () => {
        n.value = !1, O == null || O.closeParents();
      };
    }
    return _;
  }), b = k(() => {
    const _ = {};
    return e.openOnHover && (_.onMouseenter = () => {
      u && (s = !0, u = !1, f());
    }, _.onMouseleave = () => {
      s = !1, h();
    }), _;
  });
  pe(a, (_) => {
    var O;
    _ && (e.openOnHover && !s && (!c.value || !o) || c.value && !o && (!e.openOnHover || !s)) && !((O = i.value) != null && O.contains(document.activeElement)) && (n.value = !1);
  }), pe(n, (_) => {
    _ || setTimeout(() => {
      m.value = void 0;
    });
  }, {
    flush: "post"
  });
  const C = jc();
  jt(() => {
    C.value && et(() => {
      r.value = C.el;
    });
  });
  const S = jc(), x = k(() => e.target === "cursor" && m.value ? m.value : S.value ? S.el : d3(e.target, l) || r.value), w = k(() => Array.isArray(x.value) ? void 0 : x.value);
  let V;
  return pe(() => !!e.activator, (_) => {
    _ && bt ? (V = n2(), V.run(() => {
      ex(e, l, {
        activatorEl: r,
        activatorEvents: v
      });
    })) : V && V.stop();
  }, {
    flush: "post",
    immediate: !0
  }), Xn(() => {
    V == null || V.stop();
  }), {
    activatorEl: r,
    activatorRef: C,
    target: x,
    targetEl: w,
    targetRef: S,
    activatorEvents: v,
    contentEvents: y,
    scrimEvents: b
  };
}
function ex(e, t, n) {
  let {
    activatorEl: a,
    activatorEvents: i
  } = n;
  pe(() => e.activator, (o, u) => {
    if (u && o !== u) {
      const c = s(u);
      c && r(c);
    }
    o && et(() => l());
  }, {
    immediate: !0
  }), pe(() => e.activatorProps, () => {
    l();
  }), Xn(() => {
    r();
  });
  function l() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : s(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    o && Lw(o, fe(i.value, u));
  }
  function r() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : s(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    o && Qw(o, fe(i.value, u));
  }
  function s() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator;
    const u = d3(o, t);
    return a.value = (u == null ? void 0 : u.nodeType) === Node.ELEMENT_NODE ? u : void 0, a.value;
  }
}
function d3(e, t) {
  var a, i;
  if (!e) return;
  let n;
  if (e === "parent") {
    let l = (i = (a = t == null ? void 0 : t.proxy) == null ? void 0 : a.$el) == null ? void 0 : i.parentNode;
    for (; l != null && l.hasAttribute("data-no-activator"); )
      l = l.parentNode;
    n = l;
  } else typeof e == "string" ? n = document.querySelector(e) : "$el" in e ? n = e.$el : n = e;
  return n;
}
function S2(e) {
  return c2(() => {
    const t = [], n = {};
    if (e.value.background)
      if (eh(e.value.background)) {
        if (n.backgroundColor = e.value.background, !e.value.text && Uw(e.value.background)) {
          const a = Ta(e.value.background);
          if (a.a == null || a.a === 1) {
            const i = $5(a);
            n.color = i, n.caretColor = i;
          }
        }
      } else
        t.push(`bg-${e.value.background}`);
    return e.value.text && (eh(e.value.text) ? (n.color = e.value.text, n.caretColor = e.value.text) : t.push(`text-${e.value.text}`)), {
      colorClasses: t,
      colorStyles: n
    };
  });
}
function zn(e, t) {
  const n = k(() => ({
    text: Mi(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: a,
    colorStyles: i
  } = S2(n);
  return {
    textColorClasses: a,
    textColorStyles: i
  };
}
function kt(e, t) {
  const n = k(() => ({
    background: Mi(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: a,
    colorStyles: i
  } = S2(n);
  return {
    backgroundColorClasses: a,
    backgroundColorStyles: i
  };
}
const vn = le({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function gn(e) {
  return {
    dimensionStyles: k(() => {
      const n = {}, a = Qe(e.height), i = Qe(e.maxHeight), l = Qe(e.maxWidth), r = Qe(e.minHeight), s = Qe(e.minWidth), o = Qe(e.width);
      return a != null && (n.height = a), i != null && (n.maxHeight = i), l != null && (n.maxWidth = l), r != null && (n.minHeight = r), s != null && (n.minWidth = s), o != null && (n.width = o), n;
    })
  };
}
function f3() {
  if (!bt) return Ve(!1);
  const {
    ssr: e
  } = Za();
  if (e) {
    const t = Ve(!1);
    return rt(() => {
      t.value = !0;
    }), t;
  } else
    return Ve(!0);
}
const x2 = le({
  eager: Boolean
}, "lazy");
function P2(e, t) {
  const n = Ve(!1), a = k(() => n.value || e.eager || t.value);
  pe(t, () => n.value = !0);
  function i() {
    e.eager || (n.value = !1);
  }
  return {
    isBooted: n,
    hasContent: a,
    onAfterLeave: i
  };
}
function tx() {
  const e = Wt("useRoute");
  return k(() => {
    var t;
    return (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$route;
  });
}
function h3() {
  var e, t;
  return (t = (e = Wt("useRouter")) == null ? void 0 : e.proxy) == null ? void 0 : t.$router;
}
function yu(e, t) {
  var u, c;
  const n = Lr("RouterLink"), a = k(() => !!(e.href || e.to)), i = k(() => (a == null ? void 0 : a.value) || Bv(t, "click") || Bv(e, "click"));
  if (typeof n == "string" || !("useLink" in n))
    return {
      isLink: a,
      isClickable: i,
      href: ue(e, "href")
    };
  const l = k(() => ({
    ...e,
    to: ue(() => e.to || "")
  })), r = n.useLink(l.value), s = k(() => e.to ? r : void 0), o = tx();
  return {
    isLink: a,
    isClickable: i,
    route: (u = s.value) == null ? void 0 : u.route,
    navigate: (c = s.value) == null ? void 0 : c.navigate,
    isActive: k(() => {
      var d, f, h;
      return s.value ? e.exact ? o.value ? ((h = s.value.isExactActive) == null ? void 0 : h.value) && Qi(s.value.route.value.query, o.value.query) : ((f = s.value.isExactActive) == null ? void 0 : f.value) ?? !1 : ((d = s.value.isActive) == null ? void 0 : d.value) ?? !1 : !1;
    }),
    href: k(() => {
      var d;
      return e.to ? (d = s.value) == null ? void 0 : d.route.value.href : e.href;
    })
  };
}
const Ou = le({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let G1 = !1;
function nx(e, t) {
  let n = !1, a, i;
  bt && (et(() => {
    window.addEventListener("popstate", l), a = e == null ? void 0 : e.beforeEach((r, s, o) => {
      G1 ? n ? t(o) : o() : setTimeout(() => n ? t(o) : o()), G1 = !0;
    }), i = e == null ? void 0 : e.afterEach(() => {
      G1 = !1;
    });
  }), Xn(() => {
    window.removeEventListener("popstate", l), a == null || a(), i == null || i();
  }));
  function l(r) {
    var s;
    (s = r.state) != null && s.replaced || (n = !0, setTimeout(() => n = !1));
  }
}
function Rr() {
  const t = Wt("useScopeId").vnode.scopeId;
  return {
    scopeId: t ? {
      [t]: ""
    } : void 0
  };
}
const gg = Symbol.for("vuetify:stack"), lo = zt([]);
function ax(e, t, n) {
  const a = Wt("useStack"), i = !n, l = ct(gg, void 0), r = zt({
    activeChildren: /* @__PURE__ */ new Set()
  });
  Tt(gg, r);
  const s = Ve(+t.value);
  la(e, () => {
    var d;
    const c = (d = lo.at(-1)) == null ? void 0 : d[1];
    s.value = c ? c + 10 : +t.value, i && lo.push([a.uid, s.value]), l == null || l.activeChildren.add(a.uid), Xn(() => {
      if (i) {
        const f = At(lo).findIndex((h) => h[0] === a.uid);
        lo.splice(f, 1);
      }
      l == null || l.activeChildren.delete(a.uid);
    });
  });
  const o = Ve(!0);
  i && jt(() => {
    var d;
    const c = ((d = lo.at(-1)) == null ? void 0 : d[0]) === a.uid;
    setTimeout(() => o.value = c);
  });
  const u = k(() => !r.activeChildren.size);
  return {
    globalTop: a2(o),
    localTop: u,
    stackStyles: k(() => ({
      zIndex: s.value
    }))
  };
}
function ix(e) {
  return {
    teleportTarget: k(() => {
      const n = e();
      if (n === !0 || !bt) return;
      const a = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n;
      if (a == null) {
        Ad(`Unable to locate target ${n}`);
        return;
      }
      let i = [...a.children].find((l) => l.matches(".v-overlay-container"));
      return i || (i = document.createElement("div"), i.className = "v-overlay-container", a.appendChild(i)), i;
    })
  };
}
const ai = le({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (e) => e !== !0
  }
}, "transition"), Kn = (e, t) => {
  let {
    slots: n
  } = t;
  const {
    transition: a,
    disabled: i,
    group: l,
    ...r
  } = e, {
    component: s = l ? i2 : Jn,
    ...o
  } = typeof a == "object" ? a : {};
  return G(s, fe(typeof a == "string" ? {
    name: i ? "" : a
  } : o, typeof a == "string" ? {} : Object.fromEntries(Object.entries({
    disabled: i,
    group: l
  }).filter((u) => {
    let [c, d] = u;
    return d !== void 0;
  })), r), n);
};
function lx(e) {
  const {
    modelValue: t,
    color: n,
    ...a
  } = e;
  return p(Jn, {
    name: "fade-transition",
    appear: !0
  }, {
    default: () => [e.modelValue && p("div", fe({
      class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
      style: e.color.backgroundColorStyles.value
    }, a), null)]
  });
}
const bu = le({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: !0
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  opacity: [Number, String],
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...KS(),
  ...Ae(),
  ...vn(),
  ...x2(),
  ...NS(),
  ...YS(),
  ...dt(),
  ...ai()
}, "VOverlay"), Ka = ve()({
  name: "VOverlay",
  directives: {
    ClickOutside: U5
  },
  inheritAttrs: !1,
  props: {
    _disableGlobalStack: Boolean,
    ...bu()
  },
  emits: {
    "click:outside": (e) => !0,
    "update:modelValue": (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: a,
      emit: i
    } = t;
    const l = Wt("VOverlay"), r = Y(), s = Y(), o = Y(), u = Fe(e, "modelValue"), c = k({
      get: () => u.value,
      set: (E) => {
        E && e.disabled || (u.value = E);
      }
    }), {
      themeClasses: d
    } = yt(e), {
      rtlClasses: f,
      isRtl: h
    } = xn(), {
      hasContent: m,
      onAfterLeave: g
    } = P2(e, c), v = kt(k(() => typeof e.scrim == "string" ? e.scrim : null)), {
      globalTop: y,
      localTop: b,
      stackStyles: C
    } = ax(c, ue(e, "zIndex"), e._disableGlobalStack), {
      activatorEl: S,
      activatorRef: x,
      target: w,
      targetEl: V,
      targetRef: _,
      activatorEvents: O,
      contentEvents: $,
      scrimEvents: P
    } = JS(e, {
      isActive: c,
      isTop: b,
      contentEl: o
    }), {
      teleportTarget: M
    } = ix(() => {
      var W, se, Se;
      const E = e.attach || e.contained;
      if (E) return E;
      const Q = ((W = S == null ? void 0 : S.value) == null ? void 0 : W.getRootNode()) || ((Se = (se = l.proxy) == null ? void 0 : se.$el) == null ? void 0 : Se.getRootNode());
      return Q instanceof ShadowRoot ? Q : !1;
    }), {
      dimensionStyles: T
    } = gn(e), L = f3(), {
      scopeId: A
    } = Rr();
    pe(() => e.disabled, (E) => {
      E && (c.value = !1);
    });
    const {
      contentStyles: D,
      updateLocation: B
    } = HS(e, {
      isRtl: h,
      contentEl: o,
      target: w,
      isActive: c
    });
    WS(e, {
      root: r,
      contentEl: o,
      targetEl: V,
      isActive: c,
      updateLocation: B
    });
    function j(E) {
      i("click:outside", E), e.persistent ? F() : c.value = !1;
    }
    function I(E) {
      return c.value && y.value && // If using scrim, only close if clicking on it rather than anything opened on top
      (!e.scrim || E.target === s.value || E instanceof MouseEvent && E.shadowTarget === s.value);
    }
    bt && pe(c, (E) => {
      E ? window.addEventListener("keydown", Z) : window.removeEventListener("keydown", Z);
    }, {
      immediate: !0
    }), mn(() => {
      bt && window.removeEventListener("keydown", Z);
    });
    function Z(E) {
      var Q, W;
      E.key === "Escape" && y.value && (e.persistent ? F() : (c.value = !1, (Q = o.value) != null && Q.contains(document.activeElement) && ((W = S.value) == null || W.focus())));
    }
    const R = h3();
    la(() => e.closeOnBack, () => {
      nx(R, (E) => {
        y.value && c.value ? (E(!1), e.persistent ? F() : c.value = !1) : E();
      });
    });
    const J = Y();
    pe(() => c.value && (e.absolute || e.contained) && M.value == null, (E) => {
      if (E) {
        const Q = g2(r.value);
        Q && Q !== document.scrollingElement && (J.value = Q.scrollTop);
      }
    });
    function F() {
      e.noClickAnimation || o.value && tr(o.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: Ro
      });
    }
    function q() {
      i("afterEnter");
    }
    function z() {
      g(), i("afterLeave");
    }
    return ye(() => {
      var E;
      return p(ge, null, [(E = n.activator) == null ? void 0 : E.call(n, {
        isActive: c.value,
        targetRef: _,
        props: fe({
          ref: x
        }, O.value, e.activatorProps)
      }), L.value && m.value && p(zs, {
        disabled: !M.value,
        to: M.value
      }, {
        default: () => [p("div", fe({
          class: ["v-overlay", {
            "v-overlay--absolute": e.absolute || e.contained,
            "v-overlay--active": c.value,
            "v-overlay--contained": e.contained
          }, d.value, f.value, e.class],
          style: [C.value, {
            "--v-overlay-opacity": e.opacity,
            top: Qe(J.value)
          }, e.style],
          ref: r
        }, A, a), [p(lx, fe({
          color: v,
          modelValue: c.value && !!e.scrim,
          ref: s
        }, P.value), null), p(Kn, {
          appear: !0,
          persisted: !0,
          transition: e.transition,
          target: w.value,
          onAfterEnter: q,
          onAfterLeave: z
        }, {
          default: () => {
            var Q;
            return [Ct(p("div", fe({
              ref: o,
              class: ["v-overlay__content", e.contentClass],
              style: [T.value, D.value]
            }, $.value, e.contentProps), [(Q = n.default) == null ? void 0 : Q.call(n, {
              isActive: c
            })]), [[Dn, c.value], [xa("click-outside"), {
              handler: j,
              closeConditional: I,
              include: () => [S.value]
            }]])];
          }
        })])]
      })]);
    }), {
      activatorEl: S,
      scrimEl: s,
      target: w,
      animateClick: F,
      contentEl: o,
      globalTop: y,
      localTop: b,
      updateLocation: B
    };
  }
}), K1 = Symbol("Forwarded refs");
function J1(e, t) {
  let n = e;
  for (; n; ) {
    const a = Reflect.getOwnPropertyDescriptor(n, t);
    if (a) return a;
    n = Object.getPrototypeOf(n);
  }
}
function Ea(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    n[a - 1] = arguments[a];
  return e[K1] = n, new Proxy(e, {
    get(i, l) {
      if (Reflect.has(i, l))
        return Reflect.get(i, l);
      if (!(typeof l == "symbol" || l.startsWith("$") || l.startsWith("__"))) {
        for (const r of n)
          if (r.value && Reflect.has(r.value, l)) {
            const s = Reflect.get(r.value, l);
            return typeof s == "function" ? s.bind(r.value) : s;
          }
      }
    },
    has(i, l) {
      if (Reflect.has(i, l))
        return !0;
      if (typeof l == "symbol" || l.startsWith("$") || l.startsWith("__")) return !1;
      for (const r of n)
        if (r.value && Reflect.has(r.value, l))
          return !0;
      return !1;
    },
    set(i, l, r) {
      if (Reflect.has(i, l))
        return Reflect.set(i, l, r);
      if (typeof l == "symbol" || l.startsWith("$") || l.startsWith("__")) return !1;
      for (const s of n)
        if (s.value && Reflect.has(s.value, l))
          return Reflect.set(s.value, l, r);
      return !1;
    },
    getOwnPropertyDescriptor(i, l) {
      var s;
      const r = Reflect.getOwnPropertyDescriptor(i, l);
      if (r) return r;
      if (!(typeof l == "symbol" || l.startsWith("$") || l.startsWith("__"))) {
        for (const o of n) {
          if (!o.value) continue;
          const u = J1(o.value, l) ?? ("_" in o.value ? J1((s = o.value._) == null ? void 0 : s.setupState, l) : void 0);
          if (u) return u;
        }
        for (const o of n) {
          const u = o.value && o.value[K1];
          if (!u) continue;
          const c = u.slice();
          for (; c.length; ) {
            const d = c.shift(), f = J1(d.value, l);
            if (f) return f;
            const h = d.value && d.value[K1];
            h && c.push(...h);
          }
        }
      }
    }
  });
}
const rx = le({
  id: String,
  text: String,
  ...hn(bu({
    closeOnBack: !1,
    location: "end",
    locationStrategy: "connected",
    eager: !0,
    minWidth: 0,
    offset: 10,
    openOnClick: !1,
    openOnHover: !0,
    origin: "auto",
    scrim: !1,
    scrollStrategy: "reposition",
    transition: !1
  }), ["absolute", "persistent"])
}, "VTooltip"), m3 = ve()({
  name: "VTooltip",
  props: rx(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), {
      scopeId: i
    } = Rr(), l = Bn(), r = k(() => e.id || `v-tooltip-${l}`), s = Y(), o = k(() => e.location.split(" ").length > 1 ? e.location : e.location + " center"), u = k(() => e.origin === "auto" || e.origin === "overlap" || e.origin.split(" ").length > 1 || e.location.split(" ").length > 1 ? e.origin : e.origin + " center"), c = k(() => e.transition ? e.transition : a.value ? "scale-transition" : "fade-transition"), d = k(() => fe({
      "aria-describedby": r.value
    }, e.activatorProps));
    return ye(() => {
      const f = Ka.filterProps(e);
      return p(Ka, fe({
        ref: s,
        class: ["v-tooltip", e.class],
        style: e.style,
        id: r.value
      }, f, {
        modelValue: a.value,
        "onUpdate:modelValue": (h) => a.value = h,
        transition: c.value,
        absolute: !0,
        location: o.value,
        origin: u.value,
        persistent: !0,
        role: "tooltip",
        activatorProps: d.value,
        _disableGlobalStack: !0
      }, i), {
        activator: n.activator,
        default: function() {
          var v;
          for (var h = arguments.length, m = new Array(h), g = 0; g < h; g++)
            m[g] = arguments[g];
          return ((v = n.default) == null ? void 0 : v.call(n, ...m)) ?? e.text;
        }
      });
    }), Ea({}, s);
  }
});
function sx(e, t) {
  const n = typeof e == "string" ? Pe(e) : e, a = ox(n, t);
  return {
    mounted: a,
    updated: a,
    unmounted(i) {
      Ec(null, i);
    }
  };
}
function ox(e, t) {
  return function(n, a, i) {
    var d, f, h;
    const l = typeof t == "function" ? t(a) : t, r = ((d = a.value) == null ? void 0 : d.text) ?? a.value ?? (l == null ? void 0 : l.text), s = s2(a.value) ? a.value : {}, o = () => r ?? n.innerHTML, u = (i.ctx === a.instance.$ ? (f = ux(i, a.instance.$)) == null ? void 0 : f.provides : (h = i.ctx) == null ? void 0 : h.provides) ?? a.instance.$.provides, c = G(e, fe(l, s), o);
    c.appContext = Object.assign(/* @__PURE__ */ Object.create(null), a.instance.$.appContext, {
      provides: u
    }), Ec(c, n);
  };
}
function ux(e, t) {
  const n = /* @__PURE__ */ new Set(), a = (l) => {
    var r, s;
    for (const o of l) {
      if (!o) continue;
      if (o === e)
        return !0;
      n.add(o);
      let u;
      if (o.suspense ? u = a([o.ssContent]) : Array.isArray(o.children) ? u = a(o.children) : (r = o.component) != null && r.vnode && (u = a([(s = o.component) == null ? void 0 : s.subTree])), u)
        return u;
      n.delete(o);
    }
    return !1;
  };
  if (!a([t.subTree]))
    throw new Error("Could not find original vnode");
  const i = Array.from(n).reverse();
  for (const l of i)
    if (l.component)
      return l.component;
  return t;
}
const cx = sx(m3, (e) => {
  var t;
  return {
    activator: "parent",
    location: ((t = e.arg) == null ? void 0 : t.replace("-", " ")) ?? "top",
    text: typeof e.value == "boolean" ? void 0 : e.value
  };
}), dx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClickOutside: U5,
  Intersect: pu,
  Mutate: wS,
  Resize: xS,
  Ripple: nl,
  Scroll: LS,
  Tooltip: cx,
  Touch: C2
}, Symbol.toStringTag, { value: "Module" })), fx = le({
  ...Ae(),
  ...z5({
    fullHeight: !0
  }),
  ...dt()
}, "VApp"), hx = ve()({
  name: "VApp",
  props: fx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = yt(e), {
      layoutClasses: i,
      getLayoutItem: l,
      items: r,
      layoutRef: s
    } = X5(e), {
      rtlClasses: o
    } = xn();
    return ye(() => {
      var u;
      return p("div", {
        ref: s,
        class: ["v-application", a.themeClasses.value, i.value, o.value, e.class],
        style: [e.style]
      }, [p("div", {
        class: "v-application__wrap"
      }, [(u = n.default) == null ? void 0 : u.call(n)])]);
    }), {
      getLayoutItem: l,
      items: r,
      theme: a
    };
  }
}), nt = le({
  tag: {
    type: String,
    default: "div"
  }
}, "tag"), v3 = le({
  text: String,
  ...Ae(),
  ...nt()
}, "VToolbarTitle"), $2 = ve()({
  name: "VToolbarTitle",
  props: v3(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => {
      const a = !!(n.default || n.text || e.text);
      return p(e.tag, {
        class: ["v-toolbar-title", e.class],
        style: e.style
      }, {
        default: () => {
          var i;
          return [a && p("div", {
            class: "v-toolbar-title__placeholder"
          }, [n.text ? n.text() : e.text, (i = n.default) == null ? void 0 : i.call(n)])];
        }
      });
    }), {};
  }
}), mx = le({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function $a(e, t, n) {
  return ve()({
    name: e,
    props: mx({
      mode: n,
      origin: t
    }),
    setup(a, i) {
      let {
        slots: l
      } = i;
      const r = {
        onBeforeEnter(s) {
          a.origin && (s.style.transformOrigin = a.origin);
        },
        onLeave(s) {
          if (a.leaveAbsolute) {
            const {
              offsetTop: o,
              offsetLeft: u,
              offsetWidth: c,
              offsetHeight: d
            } = s;
            s._transitionInitialStyles = {
              position: s.style.position,
              top: s.style.top,
              left: s.style.left,
              width: s.style.width,
              height: s.style.height
            }, s.style.position = "absolute", s.style.top = `${o}px`, s.style.left = `${u}px`, s.style.width = `${c}px`, s.style.height = `${d}px`;
          }
          a.hideOnLeave && s.style.setProperty("display", "none", "important");
        },
        onAfterLeave(s) {
          if (a.leaveAbsolute && (s != null && s._transitionInitialStyles)) {
            const {
              position: o,
              top: u,
              left: c,
              width: d,
              height: f
            } = s._transitionInitialStyles;
            delete s._transitionInitialStyles, s.style.position = o || "", s.style.top = u || "", s.style.left = c || "", s.style.width = d || "", s.style.height = f || "";
          }
        }
      };
      return () => {
        const s = a.group ? i2 : Jn;
        return G(s, {
          name: a.disabled ? "" : e,
          css: !a.disabled,
          ...a.group ? void 0 : {
            mode: a.mode
          },
          ...a.disabled ? {} : r
        }, l.default);
      };
    }
  });
}
function g3(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return ve()({
    name: e,
    props: {
      mode: {
        type: String,
        default: n
      },
      disabled: Boolean,
      group: Boolean
    },
    setup(a, i) {
      let {
        slots: l
      } = i;
      const r = a.group ? i2 : Jn;
      return () => G(r, {
        name: a.disabled ? "" : e,
        css: !a.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...a.disabled ? {} : t
      }, l.default);
    }
  });
}
function p3() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", a = W4(`offset-${n}`);
  return {
    onBeforeEnter(r) {
      r._parent = r.parentNode, r._initialStyle = {
        transition: r.style.transition,
        overflow: r.style.overflow,
        [n]: r.style[n]
      };
    },
    onEnter(r) {
      const s = r._initialStyle;
      r.style.setProperty("transition", "none", "important"), r.style.overflow = "hidden";
      const o = `${r[a]}px`;
      r.style[n] = "0", r.offsetHeight, r.style.transition = s.transition, e && r._parent && r._parent.classList.add(e), requestAnimationFrame(() => {
        r.style[n] = o;
      });
    },
    onAfterEnter: l,
    onEnterCancelled: l,
    onLeave(r) {
      r._initialStyle = {
        transition: "",
        overflow: r.style.overflow,
        [n]: r.style[n]
      }, r.style.overflow = "hidden", r.style[n] = `${r[a]}px`, r.offsetHeight, requestAnimationFrame(() => r.style[n] = "0");
    },
    onAfterLeave: i,
    onLeaveCancelled: i
  };
  function i(r) {
    e && r._parent && r._parent.classList.remove(e), l(r);
  }
  function l(r) {
    const s = r._initialStyle[n];
    r.style.overflow = r._initialStyle.overflow, s != null && (r.style[n] = s), delete r._initialStyle;
  }
}
const vx = le({
  target: [Object, Array]
}, "v-dialog-transition"), zd = ve()({
  name: "VDialogTransition",
  props: vx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = {
      onBeforeEnter(i) {
        i.style.pointerEvents = "none", i.style.visibility = "hidden";
      },
      async onEnter(i, l) {
        var f;
        await new Promise((h) => requestAnimationFrame(h)), await new Promise((h) => requestAnimationFrame(h)), i.style.visibility = "";
        const {
          x: r,
          y: s,
          sx: o,
          sy: u,
          speed: c
        } = yg(e.target, i), d = tr(i, [{
          transform: `translate(${r}px, ${s}px) scale(${o}, ${u})`,
          opacity: 0
        }, {}], {
          duration: 225 * c,
          easing: sk
        });
        (f = pg(i)) == null || f.forEach((h) => {
          tr(h, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * c,
            easing: Ro
          });
        }), d.finished.then(() => l());
      },
      onAfterEnter(i) {
        i.style.removeProperty("pointer-events");
      },
      onBeforeLeave(i) {
        i.style.pointerEvents = "none";
      },
      async onLeave(i, l) {
        var f;
        await new Promise((h) => requestAnimationFrame(h));
        const {
          x: r,
          y: s,
          sx: o,
          sy: u,
          speed: c
        } = yg(e.target, i);
        tr(i, [{}, {
          transform: `translate(${r}px, ${s}px) scale(${o}, ${u})`,
          opacity: 0
        }], {
          duration: 125 * c,
          easing: ok
        }).finished.then(() => l()), (f = pg(i)) == null || f.forEach((h) => {
          tr(h, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * c,
            easing: Ro
          });
        });
      },
      onAfterLeave(i) {
        i.style.removeProperty("pointer-events");
      }
    };
    return () => e.target ? p(Jn, fe({
      name: "dialog-transition"
    }, a, {
      css: !1
    }), n) : p(Jn, {
      name: "dialog-transition"
    }, n);
  }
});
function pg(e) {
  var n;
  const t = (n = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : n.children;
  return t && [...t];
}
function yg(e, t) {
  const n = g5(e), a = f2(t), [i, l] = getComputedStyle(t).transformOrigin.split(" ").map((y) => parseFloat(y)), [r, s] = getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let o = n.left + n.width / 2;
  r === "left" || s === "left" ? o -= n.width / 2 : (r === "right" || s === "right") && (o += n.width / 2);
  let u = n.top + n.height / 2;
  r === "top" || s === "top" ? u -= n.height / 2 : (r === "bottom" || s === "bottom") && (u += n.height / 2);
  const c = n.width / a.width, d = n.height / a.height, f = Math.max(1, c, d), h = c / f || 0, m = d / f || 0, g = a.width * a.height / (window.innerWidth * window.innerHeight), v = g > 0.12 ? Math.min(1.5, (g - 0.12) * 10 + 1) : 1;
  return {
    x: o - (i + a.left),
    y: u - (l + a.top),
    sx: h,
    sy: m,
    speed: v
  };
}
const gx = $a("fab-transition", "center center", "out-in"), px = $a("dialog-bottom-transition"), yx = $a("dialog-top-transition"), No = $a("fade-transition"), _2 = $a("scale-transition"), Ox = $a("scroll-x-transition"), bx = $a("scroll-x-reverse-transition"), Cx = $a("scroll-y-transition"), wx = $a("scroll-y-reverse-transition"), kx = $a("slide-x-transition"), Sx = $a("slide-x-reverse-transition"), M2 = $a("slide-y-transition"), xx = $a("slide-y-reverse-transition"), Fd = g3("expand-transition", p3()), V2 = g3("expand-x-transition", p3("", !0)), Px = le({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider"), lt = ve(!1)({
  name: "VDefaultsProvider",
  props: Px(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      defaults: a,
      disabled: i,
      reset: l,
      root: r,
      scoped: s
    } = Tr(e);
    return Yt(a, {
      reset: l,
      root: r,
      scoped: s,
      disabled: i
    }), () => {
      var o;
      return (o = n.default) == null ? void 0 : o.call(n);
    };
  }
});
function $x(e) {
  return {
    aspectStyles: k(() => {
      const t = Number(e.aspectRatio);
      return t ? {
        paddingBottom: String(1 / t * 100) + "%"
      } : void 0;
    })
  };
}
const y3 = le({
  aspectRatio: [String, Number],
  contentClass: null,
  inline: Boolean,
  ...Ae(),
  ...vn()
}, "VResponsive"), dh = ve()({
  name: "VResponsive",
  props: y3(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      aspectStyles: a
    } = $x(e), {
      dimensionStyles: i
    } = gn(e);
    return ye(() => {
      var l;
      return p("div", {
        class: ["v-responsive", {
          "v-responsive--inline": e.inline
        }, e.class],
        style: [i.value, e.style]
      }, [p("div", {
        class: "v-responsive__sizer",
        style: a.value
      }, null), (l = n.additional) == null ? void 0 : l.call(n), n.default && p("div", {
        class: ["v-responsive__content", e.contentClass]
      }, [n.default()])]);
    }), {};
  }
}), Dt = le({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  },
  tile: Boolean
}, "rounded");
function qt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  return {
    roundedClasses: k(() => {
      const a = Mi(e) ? e.value : e.rounded, i = Mi(e) ? e.value : e.tile, l = [];
      if (a === !0 || a === "")
        l.push(`${t}--rounded`);
      else if (typeof a == "string" || a === 0)
        for (const r of String(a).split(" "))
          l.push(`rounded-${r}`);
      else (i || a === !1) && l.push("rounded-0");
      return l;
    })
  };
}
const O3 = le({
  absolute: Boolean,
  alt: String,
  cover: Boolean,
  color: String,
  draggable: {
    type: [Boolean, String],
    default: void 0
  },
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  crossorigin: String,
  referrerpolicy: String,
  srcset: String,
  position: String,
  ...y3(),
  ...Ae(),
  ...Dt(),
  ...ai()
}, "VImg"), Wi = ve()({
  name: "VImg",
  directives: {
    intersect: pu
  },
  props: O3(),
  emits: {
    loadstart: (e) => !0,
    load: (e) => !0,
    error: (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = kt(ue(e, "color")), {
      roundedClasses: r
    } = qt(e), s = Wt("VImg"), o = Ve(""), u = Y(), c = Ve(e.eager ? "loading" : "idle"), d = Ve(), f = Ve(), h = k(() => e.src && typeof e.src == "object" ? {
      src: e.src.src,
      srcset: e.srcset || e.src.srcset,
      lazySrc: e.lazySrc || e.src.lazySrc,
      aspect: Number(e.aspectRatio || e.src.aspect || 0)
    } : {
      src: e.src,
      srcset: e.srcset,
      lazySrc: e.lazySrc,
      aspect: Number(e.aspectRatio || 0)
    }), m = k(() => h.value.aspect || d.value / f.value || 0);
    pe(() => e.src, () => {
      g(c.value !== "idle");
    }), pe(m, (M, T) => {
      !M && T && u.value && S(u.value);
    }), U4(() => g());
    function g(M) {
      if (!(e.eager && M) && !(r2 && !M && !e.eager)) {
        if (c.value = "loading", h.value.lazySrc) {
          const T = new Image();
          T.src = h.value.lazySrc, S(T, null);
        }
        h.value.src && et(() => {
          var T;
          n("loadstart", ((T = u.value) == null ? void 0 : T.currentSrc) || h.value.src), setTimeout(() => {
            var L;
            if (!s.isUnmounted)
              if ((L = u.value) != null && L.complete) {
                if (u.value.naturalWidth || y(), c.value === "error") return;
                m.value || S(u.value, null), c.value === "loading" && v();
              } else
                m.value || S(u.value), b();
          });
        });
      }
    }
    function v() {
      var M;
      s.isUnmounted || (b(), S(u.value), c.value = "loaded", n("load", ((M = u.value) == null ? void 0 : M.currentSrc) || h.value.src));
    }
    function y() {
      var M;
      s.isUnmounted || (c.value = "error", n("error", ((M = u.value) == null ? void 0 : M.currentSrc) || h.value.src));
    }
    function b() {
      const M = u.value;
      M && (o.value = M.currentSrc || M.src);
    }
    let C = -1;
    mn(() => {
      clearTimeout(C);
    });
    function S(M) {
      let T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const L = () => {
        if (clearTimeout(C), s.isUnmounted) return;
        const {
          naturalHeight: A,
          naturalWidth: D
        } = M;
        A || D ? (d.value = D, f.value = A) : !M.complete && c.value === "loading" && T != null ? C = window.setTimeout(L, T) : (M.currentSrc.endsWith(".svg") || M.currentSrc.startsWith("data:image/svg+xml")) && (d.value = 1, f.value = 1);
      };
      L();
    }
    const x = k(() => ({
      "v-img__img--cover": e.cover,
      "v-img__img--contain": !e.cover
    })), w = () => {
      var L;
      if (!h.value.src || c.value === "idle") return null;
      const M = p("img", {
        class: ["v-img__img", x.value],
        style: {
          objectPosition: e.position
        },
        src: h.value.src,
        srcset: h.value.srcset,
        alt: e.alt,
        crossorigin: e.crossorigin,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable,
        sizes: e.sizes,
        ref: u,
        onLoad: v,
        onError: y
      }, null), T = (L = a.sources) == null ? void 0 : L.call(a);
      return p(Kn, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => [Ct(T ? p("picture", {
          class: "v-img__picture"
        }, [T, M]) : M, [[Dn, c.value === "loaded"]])]
      });
    }, V = () => p(Kn, {
      transition: e.transition
    }, {
      default: () => [h.value.lazySrc && c.value !== "loaded" && p("img", {
        class: ["v-img__img", "v-img__img--preload", x.value],
        style: {
          objectPosition: e.position
        },
        src: h.value.lazySrc,
        alt: e.alt,
        crossorigin: e.crossorigin,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable
      }, null)]
    }), _ = () => a.placeholder ? p(Kn, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [(c.value === "loading" || c.value === "error" && !a.error) && p("div", {
        class: "v-img__placeholder"
      }, [a.placeholder()])]
    }) : null, O = () => a.error ? p(Kn, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [c.value === "error" && p("div", {
        class: "v-img__error"
      }, [a.error()])]
    }) : null, $ = () => e.gradient ? p("div", {
      class: "v-img__gradient",
      style: {
        backgroundImage: `linear-gradient(${e.gradient})`
      }
    }, null) : null, P = Ve(!1);
    {
      const M = pe(m, (T) => {
        T && (requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            P.value = !0;
          });
        }), M());
      });
    }
    return ye(() => {
      const M = dh.filterProps(e);
      return Ct(p(dh, fe({
        class: ["v-img", {
          "v-img--absolute": e.absolute,
          "v-img--booting": !P.value
        }, i.value, r.value, e.class],
        style: [{
          width: Qe(e.width === "auto" ? d.value : e.width)
        }, l.value, e.style]
      }, M, {
        aspectRatio: m.value,
        "aria-label": e.alt,
        role: e.alt ? "img" : void 0
      }), {
        additional: () => p(ge, null, [p(w, null, null), p(V, null, null), p($, null, null), p(_, null, null), p(O, null, null)]),
        default: a.default
      }), [[xa("intersect"), {
        handler: g,
        options: e.options
      }, null, {
        once: !0
      }]]);
    }), {
      currentSrc: o,
      image: u,
      state: c,
      naturalWidth: d,
      naturalHeight: f
    };
  }
}), ya = le({
  border: [Boolean, Number, String]
}, "border");
function _a(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  return {
    borderClasses: k(() => {
      const a = Mi(e) ? e.value : e.border, i = [];
      if (a === !0 || a === "")
        i.push(`${t}--border`);
      else if (typeof a == "string" || a === 0)
        for (const l of String(a).split(" "))
          i.push(`border-${l}`);
      return i;
    })
  };
}
const Pn = le({
  elevation: {
    type: [Number, String],
    validator(e) {
      const t = parseInt(e);
      return !isNaN(t) && t >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      t <= 24;
    }
  }
}, "elevation");
function Zn(e) {
  return {
    elevationClasses: k(() => {
      const n = Mi(e) ? e.value : e.elevation, a = [];
      return n == null || a.push(`elevation-${n}`), a;
    })
  };
}
const _x = [null, "prominent", "default", "comfortable", "compact"], b3 = le({
  absolute: Boolean,
  collapse: Boolean,
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (e) => _x.includes(e)
  },
  extended: Boolean,
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...ya(),
  ...Ae(),
  ...Pn(),
  ...Dt(),
  ...nt({
    tag: "header"
  }),
  ...dt()
}, "VToolbar"), fh = ve()({
  name: "VToolbar",
  props: b3(),
  setup(e, t) {
    var h;
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: i
    } = kt(ue(e, "color")), {
      borderClasses: l
    } = _a(e), {
      elevationClasses: r
    } = Zn(e), {
      roundedClasses: s
    } = qt(e), {
      themeClasses: o
    } = yt(e), {
      rtlClasses: u
    } = xn(), c = Ve(!!(e.extended || (h = n.extension) != null && h.call(n))), d = k(() => parseInt(Number(e.height) + (e.density === "prominent" ? Number(e.height) : 0) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0), 10)), f = k(() => c.value ? parseInt(Number(e.extensionHeight) + (e.density === "prominent" ? Number(e.extensionHeight) : 0) - (e.density === "comfortable" ? 4 : 0) - (e.density === "compact" ? 8 : 0), 10) : 0);
    return Yt({
      VBtn: {
        variant: "text"
      }
    }), ye(() => {
      var y;
      const m = !!(e.title || n.title), g = !!(n.image || e.image), v = (y = n.extension) == null ? void 0 : y.call(n);
      return c.value = !!(e.extended || v), p(e.tag, {
        class: ["v-toolbar", {
          "v-toolbar--absolute": e.absolute,
          "v-toolbar--collapse": e.collapse,
          "v-toolbar--flat": e.flat,
          "v-toolbar--floating": e.floating,
          [`v-toolbar--density-${e.density}`]: !0
        }, a.value, l.value, r.value, s.value, o.value, u.value, e.class],
        style: [i.value, e.style]
      }, {
        default: () => [g && p("div", {
          key: "image",
          class: "v-toolbar__image"
        }, [n.image ? p(lt, {
          key: "image-defaults",
          disabled: !e.image,
          defaults: {
            VImg: {
              cover: !0,
              src: e.image
            }
          }
        }, n.image) : p(Wi, {
          key: "image-img",
          cover: !0,
          src: e.image
        }, null)]), p(lt, {
          defaults: {
            VTabs: {
              height: Qe(d.value)
            }
          }
        }, {
          default: () => {
            var b, C, S;
            return [p("div", {
              class: "v-toolbar__content",
              style: {
                height: Qe(d.value)
              }
            }, [n.prepend && p("div", {
              class: "v-toolbar__prepend"
            }, [(b = n.prepend) == null ? void 0 : b.call(n)]), m && p($2, {
              key: "title",
              text: e.title
            }, {
              text: n.title
            }), (C = n.default) == null ? void 0 : C.call(n), n.append && p("div", {
              class: "v-toolbar__append"
            }, [(S = n.append) == null ? void 0 : S.call(n)])])];
          }
        }), p(lt, {
          defaults: {
            VTabs: {
              height: Qe(f.value)
            }
          }
        }, {
          default: () => [p(Fd, null, {
            default: () => [c.value && p("div", {
              class: "v-toolbar__extension",
              style: {
                height: Qe(f.value)
              }
            }, [v])]
          })]
        })]
      });
    }), {
      contentHeight: d,
      extensionHeight: f
    };
  }
}), Mx = le({
  scrollTarget: {
    type: String
  },
  scrollThreshold: {
    type: [String, Number],
    default: 300
  }
}, "scroll");
function Vx(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    canScroll: n
  } = t;
  let a = 0, i = 0;
  const l = Y(null), r = Ve(0), s = Ve(0), o = Ve(0), u = Ve(!1), c = Ve(!1), d = k(() => Number(e.scrollThreshold)), f = k(() => ln((d.value - r.value) / d.value || 0)), h = () => {
    const m = l.value;
    if (!m || n && !n.value) return;
    a = r.value, r.value = "window" in m ? m.pageYOffset : m.scrollTop;
    const g = m instanceof Window ? document.documentElement.scrollHeight : m.scrollHeight;
    if (i !== g) {
      i = g;
      return;
    }
    c.value = r.value < a, o.value = Math.abs(r.value - d.value);
  };
  return pe(c, () => {
    s.value = s.value || r.value;
  }), pe(u, () => {
    s.value = 0;
  }), rt(() => {
    pe(() => e.scrollTarget, (m) => {
      var v;
      const g = m ? document.querySelector(m) : window;
      if (!g) {
        Wa(`Unable to locate element with identifier ${m}`);
        return;
      }
      g !== l.value && ((v = l.value) == null || v.removeEventListener("scroll", h), l.value = g, l.value.addEventListener("scroll", h, {
        passive: !0
      }));
    }, {
      immediate: !0
    });
  }), mn(() => {
    var m;
    (m = l.value) == null || m.removeEventListener("scroll", h);
  }), n && pe(n, h, {
    immediate: !0
  }), {
    scrollThreshold: d,
    currentScroll: r,
    currentThreshold: o,
    isScrollActive: u,
    scrollRatio: f,
    // required only for testing
    // probably can be removed
    // later (2 chars chlng)
    isScrollingUp: c,
    savedScroll: s
  };
}
function Ir() {
  const e = Ve(!1);
  return rt(() => {
    window.requestAnimationFrame(() => {
      e.value = !0;
    });
  }), {
    ssrBootStyles: k(() => e.value ? void 0 : {
      transition: "none !important"
    }),
    isBooted: a2(e)
  };
}
const Tx = le({
  scrollBehavior: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  location: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ...b3(),
  ...Ar(),
  ...Mx(),
  height: {
    type: [Number, String],
    default: 64
  }
}, "VAppBar"), Lx = ve()({
  name: "VAppBar",
  props: Tx(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Y(), i = Fe(e, "modelValue"), l = k(() => {
      var C;
      const b = new Set(((C = e.scrollBehavior) == null ? void 0 : C.split(" ")) ?? []);
      return {
        hide: b.has("hide"),
        fullyHide: b.has("fully-hide"),
        inverted: b.has("inverted"),
        collapse: b.has("collapse"),
        elevate: b.has("elevate"),
        fadeImage: b.has("fade-image")
        // shrink: behavior.has('shrink'),
      };
    }), r = k(() => {
      const b = l.value;
      return b.hide || b.fullyHide || b.inverted || b.collapse || b.elevate || b.fadeImage || // behavior.shrink ||
      !i.value;
    }), {
      currentScroll: s,
      scrollThreshold: o,
      isScrollingUp: u,
      scrollRatio: c
    } = Vx(e, {
      canScroll: r
    }), d = k(() => l.value.hide || l.value.fullyHide), f = k(() => e.collapse || l.value.collapse && (l.value.inverted ? c.value > 0 : c.value === 0)), h = k(() => e.flat || l.value.fullyHide && !i.value || l.value.elevate && (l.value.inverted ? s.value > 0 : s.value === 0)), m = k(() => l.value.fadeImage ? l.value.inverted ? 1 - c.value : c.value : void 0), g = k(() => {
      var S, x;
      if (l.value.hide && l.value.inverted) return 0;
      const b = ((S = a.value) == null ? void 0 : S.contentHeight) ?? 0, C = ((x = a.value) == null ? void 0 : x.extensionHeight) ?? 0;
      return d.value ? s.value < o.value || l.value.fullyHide ? b + C : b : b + C;
    });
    la(k(() => !!e.scrollBehavior), () => {
      jt(() => {
        d.value ? l.value.inverted ? i.value = s.value > o.value : i.value = u.value || s.value < o.value : i.value = !0;
      });
    });
    const {
      ssrBootStyles: v
    } = Ir(), {
      layoutItemStyles: y
    } = Dr({
      id: e.name,
      order: k(() => parseInt(e.order, 10)),
      position: ue(e, "location"),
      layoutSize: g,
      elementSize: Ve(void 0),
      active: i,
      absolute: ue(e, "absolute")
    });
    return ye(() => {
      const b = fh.filterProps(e);
      return p(fh, fe({
        ref: a,
        class: ["v-app-bar", {
          "v-app-bar--bottom": e.location === "bottom"
        }, e.class],
        style: [{
          ...y.value,
          "--v-toolbar-image-opacity": m.value,
          height: void 0,
          ...v.value
        }, e.style]
      }, b, {
        collapse: f.value,
        flat: h.value
      }), n);
    }), {};
  }
}), Qx = [null, "default", "comfortable", "compact"], Ln = le({
  density: {
    type: String,
    default: "default",
    validator: (e) => Qx.includes(e)
  }
}, "density");
function ea(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  return {
    densityClasses: k(() => `${t}--density-${e.density}`)
  };
}
const Ax = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function Bl(e, t) {
  return p(ge, null, [e && p("span", {
    key: "overlay",
    class: `${t}__overlay`
  }, null), p("span", {
    key: "underlay",
    class: `${t}__underlay`
  }, null)]);
}
const Na = le({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (e) => Ax.includes(e)
  }
}, "variant");
function Br(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  const n = k(() => {
    const {
      variant: l
    } = X(e);
    return `${t}--variant-${l}`;
  }), {
    colorClasses: a,
    colorStyles: i
  } = S2(k(() => {
    const {
      variant: l,
      color: r
    } = X(e);
    return {
      [["elevated", "flat"].includes(l) ? "background" : "text"]: r
    };
  }));
  return {
    colorClasses: a,
    colorStyles: i,
    variantClasses: n
  };
}
const C3 = le({
  baseColor: String,
  divided: Boolean,
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...Pn(),
  ...Dt(),
  ...nt(),
  ...dt(),
  ...Na()
}, "VBtnGroup"), hh = ve()({
  name: "VBtnGroup",
  props: C3(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e), {
      densityClasses: i
    } = ea(e), {
      borderClasses: l
    } = _a(e), {
      elevationClasses: r
    } = Zn(e), {
      roundedClasses: s
    } = qt(e);
    Yt({
      VBtn: {
        height: "auto",
        baseColor: ue(e, "baseColor"),
        color: ue(e, "color"),
        density: ue(e, "density"),
        flat: !0,
        variant: ue(e, "variant")
      }
    }), ye(() => p(e.tag, {
      class: ["v-btn-group", {
        "v-btn-group--divided": e.divided
      }, a.value, l.value, i.value, r.value, s.value, e.class],
      style: e.style
    }, n));
  }
}), Zr = le({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group"), Er = le({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function Nr(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const a = Wt("useGroupItem");
  if (!a)
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  const i = Bn();
  Tt(Symbol.for(`${t.description}:id`), i);
  const l = ct(t, null);
  if (!l) {
    if (!n) return l;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`);
  }
  const r = ue(e, "value"), s = k(() => !!(l.disabled.value || e.disabled));
  l.register({
    id: i,
    value: r,
    disabled: s
  }, a), mn(() => {
    l.unregister(i);
  });
  const o = k(() => l.isSelected(i)), u = k(() => l.items.value[0].id === i), c = k(() => l.items.value[l.items.value.length - 1].id === i), d = k(() => o.value && [l.selectedClass.value, e.selectedClass]);
  return pe(o, (f) => {
    a.emit("group:selected", {
      value: f
    });
  }, {
    flush: "sync"
  }), {
    id: i,
    isSelected: o,
    isFirst: u,
    isLast: c,
    toggle: () => l.select(i, !o.value),
    select: (f) => l.select(i, f),
    selectedClass: d,
    value: r,
    disabled: s,
    group: l
  };
}
function Zl(e, t) {
  let n = !1;
  const a = zt([]), i = Fe(e, "modelValue", [], (f) => f == null ? [] : w3(a, Ht(f)), (f) => {
    const h = Rx(a, f);
    return e.multiple ? h : h[0];
  }), l = Wt("useGroup");
  function r(f, h) {
    const m = f, g = Symbol.for(`${t.description}:id`), y = is(g, l == null ? void 0 : l.vnode).indexOf(h);
    X(m.value) == null && (m.value = y, m.useIndexAsValue = !0), y > -1 ? a.splice(y, 0, m) : a.push(m);
  }
  function s(f) {
    if (n) return;
    o();
    const h = a.findIndex((m) => m.id === f);
    a.splice(h, 1);
  }
  function o() {
    const f = a.find((h) => !h.disabled);
    f && e.mandatory === "force" && !i.value.length && (i.value = [f.id]);
  }
  rt(() => {
    o();
  }), mn(() => {
    n = !0;
  }), QC(() => {
    for (let f = 0; f < a.length; f++)
      a[f].useIndexAsValue && (a[f].value = f);
  });
  function u(f, h) {
    const m = a.find((g) => g.id === f);
    if (!(h && (m != null && m.disabled)))
      if (e.multiple) {
        const g = i.value.slice(), v = g.findIndex((b) => b === f), y = ~v;
        if (h = h ?? !y, y && e.mandatory && g.length <= 1 || !y && e.max != null && g.length + 1 > e.max) return;
        v < 0 && h ? g.push(f) : v >= 0 && !h && g.splice(v, 1), i.value = g;
      } else {
        const g = i.value.includes(f);
        if (e.mandatory && g) return;
        i.value = h ?? !g ? [f] : [];
      }
  }
  function c(f) {
    if (e.multiple && Wa('This method is not supported when using "multiple" prop'), i.value.length) {
      const h = i.value[0], m = a.findIndex((y) => y.id === h);
      let g = (m + f) % a.length, v = a[g];
      for (; v.disabled && g !== m; )
        g = (g + f) % a.length, v = a[g];
      if (v.disabled) return;
      i.value = [a[g].id];
    } else {
      const h = a.find((m) => !m.disabled);
      h && (i.value = [h.id]);
    }
  }
  const d = {
    register: r,
    unregister: s,
    selected: i,
    select: u,
    disabled: ue(e, "disabled"),
    prev: () => c(a.length - 1),
    next: () => c(1),
    isSelected: (f) => i.value.includes(f),
    selectedClass: k(() => e.selectedClass),
    items: k(() => a),
    getItemIndex: (f) => Dx(a, f)
  };
  return Tt(t, d), d;
}
function Dx(e, t) {
  const n = w3(e, [t]);
  return n.length ? e.findIndex((a) => a.id === n[0]) : -1;
}
function w3(e, t) {
  const n = [];
  return t.forEach((a) => {
    const i = e.find((r) => Qi(a, r.value)), l = e[a];
    (i == null ? void 0 : i.value) != null ? n.push(i.id) : l != null && n.push(l.id);
  }), n;
}
function Rx(e, t) {
  const n = [];
  return t.forEach((a) => {
    const i = e.findIndex((l) => l.id === a);
    if (~i) {
      const l = e[i];
      n.push(l.value != null ? l.value : i);
    }
  }), n;
}
const T2 = Symbol.for("vuetify:v-btn-toggle"), Ix = le({
  ...C3(),
  ...Zr()
}, "VBtnToggle"), Bx = ve()({
  name: "VBtnToggle",
  props: Ix(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: a,
      next: i,
      prev: l,
      select: r,
      selected: s
    } = Zl(e, T2);
    return ye(() => {
      const o = hh.filterProps(e);
      return p(hh, fe({
        class: ["v-btn-toggle", e.class]
      }, o, {
        style: e.style
      }), {
        default: () => {
          var u;
          return [(u = n.default) == null ? void 0 : u.call(n, {
            isSelected: a,
            next: i,
            prev: l,
            select: r,
            selected: s
          })];
        }
      });
    }), {
      next: i,
      prev: l,
      select: r
    };
  }
}), Zx = ["x-small", "small", "default", "large", "x-large"], Ri = le({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function Ys(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  return c2(() => {
    let n, a;
    return Hc(Zx, e.size) ? n = `${t}--size-${e.size}` : e.size && (a = {
      width: Qe(e.size),
      height: Qe(e.size)
    }), {
      sizeClasses: n,
      sizeStyles: a
    };
  });
}
const Ex = le({
  color: String,
  disabled: Boolean,
  start: Boolean,
  end: Boolean,
  icon: Ue,
  ...Ae(),
  ...Ri(),
  ...nt({
    tag: "i"
  }),
  ...dt()
}, "VIcon"), vt = ve()({
  name: "VIcon",
  props: Ex(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const i = Y(), {
      themeClasses: l
    } = yt(e), {
      iconData: r
    } = hS(k(() => i.value || e.icon)), {
      sizeClasses: s
    } = Ys(e), {
      textColorClasses: o,
      textColorStyles: u
    } = zn(ue(e, "color"));
    return ye(() => {
      var f, h;
      const c = (f = a.default) == null ? void 0 : f.call(a);
      c && (i.value = (h = d5(c).filter((m) => m.type === AC && m.children && typeof m.children == "string")[0]) == null ? void 0 : h.children);
      const d = !!(n.onClick || n.onClickOnce);
      return p(r.value.component, {
        tag: e.tag,
        icon: r.value.icon,
        class: ["v-icon", "notranslate", l.value, s.value, o.value, {
          "v-icon--clickable": d,
          "v-icon--disabled": e.disabled,
          "v-icon--start": e.start,
          "v-icon--end": e.end
        }, e.class],
        style: [s.value ? void 0 : {
          fontSize: Qe(e.size),
          height: Qe(e.size),
          width: Qe(e.size)
        }, u.value, e.style],
        role: d ? "button" : void 0,
        "aria-hidden": !d,
        tabindex: d ? e.disabled ? -1 : 0 : void 0
      }, {
        default: () => [c]
      });
    }), {};
  }
});
function Xd(e, t) {
  const n = Y(), a = Ve(!1);
  if (r2) {
    const i = new IntersectionObserver((l) => {
      a.value = !!l.find((r) => r.isIntersecting);
    }, t);
    mn(() => {
      i.disconnect();
    }), pe(n, (l, r) => {
      r && (i.unobserve(r), a.value = !1), l && i.observe(l);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: n,
    isIntersecting: a
  };
}
const Nx = le({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...Ae(),
  ...Ri(),
  ...nt({
    tag: "div"
  }),
  ...dt()
}, "VProgressCircular"), Cs = ve()({
  name: "VProgressCircular",
  props: Nx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = 20, i = 2 * Math.PI * a, l = Y(), {
      themeClasses: r
    } = yt(e), {
      sizeClasses: s,
      sizeStyles: o
    } = Ys(e), {
      textColorClasses: u,
      textColorStyles: c
    } = zn(ue(e, "color")), {
      textColorClasses: d,
      textColorStyles: f
    } = zn(ue(e, "bgColor")), {
      intersectionRef: h,
      isIntersecting: m
    } = Xd(), {
      resizeRef: g,
      contentRect: v
    } = Ga(), y = k(() => Math.max(0, Math.min(100, parseFloat(e.modelValue)))), b = k(() => Number(e.width)), C = k(() => o.value ? Number(e.size) : v.value ? v.value.width : Math.max(b.value, 32)), S = k(() => a / (1 - b.value / C.value) * 2), x = k(() => b.value / C.value * S.value), w = k(() => Qe((100 - y.value) / 100 * i));
    return jt(() => {
      h.value = l.value, g.value = l.value;
    }), ye(() => p(e.tag, {
      ref: l,
      class: ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!e.indeterminate,
        "v-progress-circular--visible": m.value,
        "v-progress-circular--disable-shrink": e.indeterminate === "disable-shrink"
      }, r.value, s.value, u.value, e.class],
      style: [o.value, c.value, e.style],
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": e.indeterminate ? void 0 : y.value
    }, {
      default: () => [p("svg", {
        style: {
          transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))`
        },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${S.value} ${S.value}`
      }, [p("circle", {
        class: ["v-progress-circular__underlay", d.value],
        style: f.value,
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: a,
        "stroke-width": x.value,
        "stroke-dasharray": i,
        "stroke-dashoffset": 0
      }, null), p("circle", {
        class: "v-progress-circular__overlay",
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: a,
        "stroke-width": x.value,
        "stroke-dasharray": i,
        "stroke-dashoffset": w.value
      }, null)]), n.default && p("div", {
        class: "v-progress-circular__content"
      }, [n.default({
        value: y.value
      })])]
    })), {};
  }
}), Og = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, al = le({
  location: String
}, "location");
function Hr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: a
  } = xn();
  return {
    locationStyles: k(() => {
      if (!e.location) return {};
      const {
        side: l,
        align: r
      } = Kf(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, a.value);
      function s(u) {
        return n ? n(u) : 0;
      }
      const o = {};
      return l !== "center" && (t ? o[Og[l]] = `calc(100% - ${s(l)}px)` : o[l] = 0), r !== "center" ? t ? o[Og[r]] = `calc(100% - ${s(r)}px)` : o[r] = 0 : (l === "center" ? o.top = o.left = "50%" : o[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[l]] = "50%", o.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[l]), o;
    })
  };
}
const Hx = le({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: !0
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  bufferColor: String,
  bufferOpacity: [Number, String],
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  opacity: [Number, String],
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...Ae(),
  ...al({
    location: "top"
  }),
  ...Dt(),
  ...nt(),
  ...dt()
}, "VProgressLinear"), Yd = ve()({
  name: "VProgressLinear",
  props: Hx(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    var P;
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), {
      isRtl: i,
      rtlClasses: l
    } = xn(), {
      themeClasses: r
    } = yt(e), {
      locationStyles: s
    } = Hr(e), {
      textColorClasses: o,
      textColorStyles: u
    } = zn(e, "color"), {
      backgroundColorClasses: c,
      backgroundColorStyles: d
    } = kt(k(() => e.bgColor || e.color)), {
      backgroundColorClasses: f,
      backgroundColorStyles: h
    } = kt(k(() => e.bufferColor || e.bgColor || e.color)), {
      backgroundColorClasses: m,
      backgroundColorStyles: g
    } = kt(e, "color"), {
      roundedClasses: v
    } = qt(e), {
      intersectionRef: y,
      isIntersecting: b
    } = Xd(), C = k(() => parseFloat(e.max)), S = k(() => parseFloat(e.height)), x = k(() => ln(parseFloat(e.bufferValue) / C.value * 100, 0, 100)), w = k(() => ln(parseFloat(a.value) / C.value * 100, 0, 100)), V = k(() => i.value !== e.reverse), _ = k(() => e.indeterminate ? "fade-transition" : "slide-x-transition"), O = bt && ((P = window.matchMedia) == null ? void 0 : P.call(window, "(forced-colors: active)").matches);
    function $(M) {
      if (!y.value) return;
      const {
        left: T,
        right: L,
        width: A
      } = y.value.getBoundingClientRect(), D = V.value ? A - M.clientX + (L - A) : M.clientX - T;
      a.value = Math.round(D / A * C.value);
    }
    return ye(() => p(e.tag, {
      ref: y,
      class: ["v-progress-linear", {
        "v-progress-linear--absolute": e.absolute,
        "v-progress-linear--active": e.active && b.value,
        "v-progress-linear--reverse": V.value,
        "v-progress-linear--rounded": e.rounded,
        "v-progress-linear--rounded-bar": e.roundedBar,
        "v-progress-linear--striped": e.striped
      }, v.value, r.value, l.value, e.class],
      style: [{
        bottom: e.location === "bottom" ? 0 : void 0,
        top: e.location === "top" ? 0 : void 0,
        height: e.active ? Qe(S.value) : 0,
        "--v-progress-linear-height": Qe(S.value),
        ...e.absolute ? s.value : {}
      }, e.style],
      role: "progressbar",
      "aria-hidden": e.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      "aria-valuenow": e.indeterminate ? void 0 : w.value,
      onClick: e.clickable && $
    }, {
      default: () => [e.stream && p("div", {
        key: "stream",
        class: ["v-progress-linear__stream", o.value],
        style: {
          ...u.value,
          [V.value ? "left" : "right"]: Qe(-S.value),
          borderTop: `${Qe(S.value / 2)} dotted`,
          opacity: parseFloat(e.bufferOpacity),
          top: `calc(50% - ${Qe(S.value / 4)})`,
          width: Qe(100 - x.value, "%"),
          "--v-progress-linear-stream-to": Qe(S.value * (V.value ? 1 : -1))
        }
      }, null), p("div", {
        class: ["v-progress-linear__background", O ? void 0 : c.value],
        style: [d.value, {
          opacity: parseFloat(e.bgOpacity),
          width: e.stream ? 0 : void 0
        }]
      }, null), p("div", {
        class: ["v-progress-linear__buffer", O ? void 0 : f.value],
        style: [h.value, {
          opacity: parseFloat(e.bufferOpacity),
          width: Qe(x.value, "%")
        }]
      }, null), p(Jn, {
        name: _.value
      }, {
        default: () => [e.indeterminate ? p("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((M) => p("div", {
          key: M,
          class: ["v-progress-linear__indeterminate", M, O ? void 0 : m.value],
          style: g.value
        }, null))]) : p("div", {
          class: ["v-progress-linear__determinate", O ? void 0 : m.value],
          style: [g.value, {
            width: Qe(w.value, "%")
          }]
        }, null)]
      }), n.default && p("div", {
        class: "v-progress-linear__content"
      }, [n.default({
        value: w.value,
        buffer: x.value
      })])]
    })), {};
  }
}), Wd = le({
  loading: [Boolean, String]
}, "loader");
function Cu(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  return {
    loaderClasses: k(() => ({
      [`${t}--loading`]: e.loading
    }))
  };
}
function wu(e, t) {
  var a;
  let {
    slots: n
  } = t;
  return p("div", {
    class: `${e.name}__loader`
  }, [((a = n.default) == null ? void 0 : a.call(n, {
    color: e.color,
    isActive: e.active
  })) || p(Yd, {
    absolute: e.absolute,
    active: e.active,
    color: e.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const jx = ["static", "relative", "fixed", "absolute", "sticky"], Ws = le({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (e) => jx.includes(e)
    )
  }
}, "position");
function qs(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  return {
    positionClasses: k(() => e.position ? `${t}--${e.position}` : void 0)
  };
}
function zx(e, t) {
  pe(() => {
    var n;
    return (n = e.isActive) == null ? void 0 : n.value;
  }, (n) => {
    e.isLink.value && n && t && et(() => {
      t(!0);
    });
  }, {
    immediate: !0
  });
}
const qd = le({
  active: {
    type: Boolean,
    default: void 0
  },
  activeColor: String,
  baseColor: String,
  symbol: {
    type: null,
    default: T2
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: Ue,
  appendIcon: Ue,
  block: Boolean,
  readonly: Boolean,
  slim: Boolean,
  stacked: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: String,
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...vn(),
  ...Pn(),
  ...Er(),
  ...Wd(),
  ...al(),
  ...Ws(),
  ...Dt(),
  ...Ou(),
  ...Ri(),
  ...nt({
    tag: "button"
  }),
  ...dt(),
  ...Na({
    variant: "elevated"
  })
}, "VBtn"), pt = ve()({
  name: "VBtn",
  props: qd(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      themeClasses: i
    } = yt(e), {
      borderClasses: l
    } = _a(e), {
      densityClasses: r
    } = ea(e), {
      dimensionStyles: s
    } = gn(e), {
      elevationClasses: o
    } = Zn(e), {
      loaderClasses: u
    } = Cu(e), {
      locationStyles: c
    } = Hr(e), {
      positionClasses: d
    } = qs(e), {
      roundedClasses: f
    } = qt(e), {
      sizeClasses: h,
      sizeStyles: m
    } = Ys(e), g = Nr(e, e.symbol, !1), v = yu(e, n), y = k(() => {
      var P;
      return e.active !== void 0 ? e.active : v.isLink.value ? (P = v.isActive) == null ? void 0 : P.value : g == null ? void 0 : g.isSelected.value;
    }), b = k(() => y.value ? e.activeColor ?? e.color : e.color), C = k(() => {
      var M, T;
      return {
        color: (g == null ? void 0 : g.isSelected.value) && (!v.isLink.value || ((M = v.isActive) == null ? void 0 : M.value)) || !g || ((T = v.isActive) == null ? void 0 : T.value) ? b.value ?? e.baseColor : e.baseColor,
        variant: e.variant
      };
    }), {
      colorClasses: S,
      colorStyles: x,
      variantClasses: w
    } = Br(C), V = k(() => (g == null ? void 0 : g.disabled.value) || e.disabled), _ = k(() => e.variant === "elevated" && !(e.disabled || e.flat || e.border)), O = k(() => {
      if (!(e.value === void 0 || typeof e.value == "symbol"))
        return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value;
    });
    function $(P) {
      var M;
      V.value || v.isLink.value && (P.metaKey || P.ctrlKey || P.shiftKey || P.button !== 0 || n.target === "_blank") || ((M = v.navigate) == null || M.call(v, P), g == null || g.toggle());
    }
    return zx(v, g == null ? void 0 : g.select), ye(() => {
      const P = v.isLink.value ? "a" : e.tag, M = !!(e.prependIcon || a.prepend), T = !!(e.appendIcon || a.append), L = !!(e.icon && e.icon !== !0);
      return Ct(p(P, {
        type: P === "a" ? void 0 : "button",
        class: ["v-btn", g == null ? void 0 : g.selectedClass.value, {
          "v-btn--active": y.value,
          "v-btn--block": e.block,
          "v-btn--disabled": V.value,
          "v-btn--elevated": _.value,
          "v-btn--flat": e.flat,
          "v-btn--icon": !!e.icon,
          "v-btn--loading": e.loading,
          "v-btn--readonly": e.readonly,
          "v-btn--slim": e.slim,
          "v-btn--stacked": e.stacked
        }, i.value, l.value, S.value, r.value, o.value, u.value, d.value, f.value, h.value, w.value, e.class],
        style: [x.value, s.value, c.value, m.value, e.style],
        "aria-busy": e.loading ? !0 : void 0,
        disabled: V.value || void 0,
        href: v.href.value,
        tabindex: e.loading || e.readonly ? -1 : void 0,
        onClick: $,
        value: O.value
      }, {
        default: () => {
          var A;
          return [Bl(!0, "v-btn"), !e.icon && M && p("span", {
            key: "prepend",
            class: "v-btn__prepend"
          }, [a.prepend ? p(lt, {
            key: "prepend-defaults",
            disabled: !e.prependIcon,
            defaults: {
              VIcon: {
                icon: e.prependIcon
              }
            }
          }, a.prepend) : p(vt, {
            key: "prepend-icon",
            icon: e.prependIcon
          }, null)]), p("span", {
            class: "v-btn__content",
            "data-no-activator": ""
          }, [!a.default && L ? p(vt, {
            key: "content-icon",
            icon: e.icon
          }, null) : p(lt, {
            key: "content-defaults",
            disabled: !L,
            defaults: {
              VIcon: {
                icon: e.icon
              }
            }
          }, {
            default: () => {
              var D;
              return [((D = a.default) == null ? void 0 : D.call(a)) ?? e.text];
            }
          })]), !e.icon && T && p("span", {
            key: "append",
            class: "v-btn__append"
          }, [a.append ? p(lt, {
            key: "append-defaults",
            disabled: !e.appendIcon,
            defaults: {
              VIcon: {
                icon: e.appendIcon
              }
            }
          }, a.append) : p(vt, {
            key: "append-icon",
            icon: e.appendIcon
          }, null)]), !!e.loading && p("span", {
            key: "loader",
            class: "v-btn__loader"
          }, [((A = a.loader) == null ? void 0 : A.call(a)) ?? p(Cs, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            width: "2"
          }, null)])];
        }
      }), [[nl, !V.value && e.ripple, "", {
        center: !!e.icon
      }]]);
    }), {
      group: g
    };
  }
}), Fx = le({
  ...qd({
    icon: "$menu",
    variant: "text"
  })
}, "VAppBarNavIcon"), Xx = ve()({
  name: "VAppBarNavIcon",
  props: Fx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => p(pt, fe(e, {
      class: ["v-app-bar-nav-icon"]
    }), n)), {};
  }
}), Yx = ve()({
  name: "VAppBarTitle",
  props: v3(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => p($2, fe(e, {
      class: "v-app-bar-title"
    }), n)), {};
  }
}), k3 = Di("v-alert-title"), Wx = ["success", "info", "warning", "error"], qx = le({
  border: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["top", "end", "bottom", "start"].includes(e)
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: Ue,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (e) => Wx.includes(e)
  },
  ...Ae(),
  ...Ln(),
  ...vn(),
  ...Pn(),
  ...al(),
  ...Ws(),
  ...Dt(),
  ...nt(),
  ...dt(),
  ...Na({
    variant: "flat"
  })
}, "VAlert"), Ux = ve()({
  name: "VAlert",
  props: qx(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const i = Fe(e, "modelValue"), l = k(() => {
      if (e.icon !== !1)
        return e.type ? e.icon ?? `$${e.type}` : e.icon;
    }), r = k(() => ({
      color: e.color ?? e.type,
      variant: e.variant
    })), {
      themeClasses: s
    } = yt(e), {
      colorClasses: o,
      colorStyles: u,
      variantClasses: c
    } = Br(r), {
      densityClasses: d
    } = ea(e), {
      dimensionStyles: f
    } = gn(e), {
      elevationClasses: h
    } = Zn(e), {
      locationStyles: m
    } = Hr(e), {
      positionClasses: g
    } = qs(e), {
      roundedClasses: v
    } = qt(e), {
      textColorClasses: y,
      textColorStyles: b
    } = zn(ue(e, "borderColor")), {
      t: C
    } = tn(), S = k(() => ({
      "aria-label": C(e.closeLabel),
      onClick(x) {
        i.value = !1, n("click:close", x);
      }
    }));
    return () => {
      const x = !!(a.prepend || l.value), w = !!(a.title || e.title), V = !!(a.close || e.closable);
      return i.value && p(e.tag, {
        class: ["v-alert", e.border && {
          "v-alert--border": !!e.border,
          [`v-alert--border-${e.border === !0 ? "start" : e.border}`]: !0
        }, {
          "v-alert--prominent": e.prominent
        }, s.value, o.value, d.value, h.value, g.value, v.value, c.value, e.class],
        style: [u.value, f.value, m.value, e.style],
        role: "alert"
      }, {
        default: () => {
          var _, O;
          return [Bl(!1, "v-alert"), e.border && p("div", {
            key: "border",
            class: ["v-alert__border", y.value],
            style: b.value
          }, null), x && p("div", {
            key: "prepend",
            class: "v-alert__prepend"
          }, [a.prepend ? p(lt, {
            key: "prepend-defaults",
            disabled: !l.value,
            defaults: {
              VIcon: {
                density: e.density,
                icon: l.value,
                size: e.prominent ? 44 : 28
              }
            }
          }, a.prepend) : p(vt, {
            key: "prepend-icon",
            density: e.density,
            icon: l.value,
            size: e.prominent ? 44 : 28
          }, null)]), p("div", {
            class: "v-alert__content"
          }, [w && p(k3, {
            key: "title"
          }, {
            default: () => {
              var $;
              return [(($ = a.title) == null ? void 0 : $.call(a)) ?? e.title];
            }
          }), ((_ = a.text) == null ? void 0 : _.call(a)) ?? e.text, (O = a.default) == null ? void 0 : O.call(a)]), a.append && p("div", {
            key: "append",
            class: "v-alert__append"
          }, [a.append()]), V && p("div", {
            key: "close",
            class: "v-alert__close"
          }, [a.close ? p(lt, {
            key: "close-defaults",
            defaults: {
              VBtn: {
                icon: e.closeIcon,
                size: "x-small",
                variant: "text"
              }
            }
          }, {
            default: () => {
              var $;
              return [($ = a.close) == null ? void 0 : $.call(a, {
                props: S.value
              })];
            }
          }) : p(pt, fe({
            key: "close-btn",
            icon: e.closeIcon,
            size: "x-small",
            variant: "text"
          }, S.value), null)])];
        }
      });
    };
  }
}), Gx = le({
  start: Boolean,
  end: Boolean,
  icon: Ue,
  image: String,
  text: String,
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...Dt(),
  ...Ri(),
  ...nt(),
  ...dt(),
  ...Na({
    variant: "flat"
  })
}, "VAvatar"), Da = ve()({
  name: "VAvatar",
  props: Gx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e), {
      borderClasses: i
    } = _a(e), {
      colorClasses: l,
      colorStyles: r,
      variantClasses: s
    } = Br(e), {
      densityClasses: o
    } = ea(e), {
      roundedClasses: u
    } = qt(e), {
      sizeClasses: c,
      sizeStyles: d
    } = Ys(e);
    return ye(() => p(e.tag, {
      class: ["v-avatar", {
        "v-avatar--start": e.start,
        "v-avatar--end": e.end
      }, a.value, i.value, l.value, o.value, u.value, c.value, s.value, e.class],
      style: [r.value, d.value, e.style]
    }, {
      default: () => [n.default ? p(lt, {
        key: "content-defaults",
        defaults: {
          VImg: {
            cover: !0,
            src: e.image
          },
          VIcon: {
            icon: e.icon
          }
        }
      }, {
        default: () => [n.default()]
      }) : e.image ? p(Wi, {
        key: "image",
        src: e.image,
        alt: "",
        cover: !0
      }, null) : e.icon ? p(vt, {
        key: "icon",
        icon: e.icon
      }, null) : e.text, Bl(!1, "v-avatar")]
    })), {};
  }
}), Kx = le({
  text: String,
  onClick: Rn(),
  ...Ae(),
  ...dt()
}, "VLabel"), Us = ve()({
  name: "VLabel",
  props: Kx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => {
      var a;
      return p("label", {
        class: ["v-label", {
          "v-label--clickable": !!e.onClick
        }, e.class],
        style: e.style,
        onClick: e.onClick
      }, [e.text, (a = n.default) == null ? void 0 : a.call(n)]);
    }), {};
  }
}), S3 = Symbol.for("vuetify:selection-control-group"), L2 = le({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: Ue,
  trueIcon: Ue,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: {
    type: Boolean,
    default: null
  },
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: Qi
  },
  ...Ae(),
  ...Ln(),
  ...dt()
}, "SelectionControlGroup"), Jx = le({
  ...L2({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup"), x3 = ve()({
  name: "VSelectionControlGroup",
  props: Jx(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), i = Bn(), l = k(() => e.id || `v-selection-control-group-${i}`), r = k(() => e.name || l.value), s = /* @__PURE__ */ new Set();
    return Tt(S3, {
      modelValue: a,
      forceUpdate: () => {
        s.forEach((o) => o());
      },
      onForceUpdate: (o) => {
        s.add(o), Xn(() => {
          s.delete(o);
        });
      }
    }), Yt({
      [e.defaultsTarget]: {
        color: ue(e, "color"),
        disabled: ue(e, "disabled"),
        density: ue(e, "density"),
        error: ue(e, "error"),
        inline: ue(e, "inline"),
        modelValue: a,
        multiple: k(() => !!e.multiple || e.multiple == null && Array.isArray(a.value)),
        name: r,
        falseIcon: ue(e, "falseIcon"),
        trueIcon: ue(e, "trueIcon"),
        readonly: ue(e, "readonly"),
        ripple: ue(e, "ripple"),
        type: ue(e, "type"),
        valueComparator: ue(e, "valueComparator")
      }
    }), ye(() => {
      var o;
      return p("div", {
        class: ["v-selection-control-group", {
          "v-selection-control-group--inline": e.inline
        }, e.class],
        style: e.style,
        role: e.type === "radio" ? "radiogroup" : void 0
      }, [(o = n.default) == null ? void 0 : o.call(n)]);
    }), {};
  }
}), Ud = le({
  label: String,
  baseColor: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...Ae(),
  ...L2()
}, "VSelectionControl");
function eP(e) {
  const t = ct(S3, void 0), {
    densityClasses: n
  } = ea(e), a = Fe(e, "modelValue"), i = k(() => e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0), l = k(() => e.falseValue !== void 0 ? e.falseValue : !1), r = k(() => !!e.multiple || e.multiple == null && Array.isArray(a.value)), s = k({
    get() {
      const h = t ? t.modelValue.value : a.value;
      return r.value ? Ht(h).some((m) => e.valueComparator(m, i.value)) : e.valueComparator(h, i.value);
    },
    set(h) {
      if (e.readonly) return;
      const m = h ? i.value : l.value;
      let g = m;
      r.value && (g = h ? [...Ht(a.value), m] : Ht(a.value).filter((v) => !e.valueComparator(v, i.value))), t ? t.modelValue.value = g : a.value = g;
    }
  }), {
    textColorClasses: o,
    textColorStyles: u
  } = zn(k(() => {
    if (!(e.error || e.disabled))
      return s.value ? e.color : e.baseColor;
  })), {
    backgroundColorClasses: c,
    backgroundColorStyles: d
  } = kt(k(() => s.value && !e.error && !e.disabled ? e.color : e.baseColor)), f = k(() => s.value ? e.trueIcon : e.falseIcon);
  return {
    group: t,
    densityClasses: n,
    trueValue: i,
    falseValue: l,
    model: s,
    textColorClasses: o,
    textColorStyles: u,
    backgroundColorClasses: c,
    backgroundColorStyles: d,
    icon: f
  };
}
const $l = ve()({
  name: "VSelectionControl",
  directives: {
    Ripple: nl
  },
  inheritAttrs: !1,
  props: Ud(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      group: i,
      densityClasses: l,
      icon: r,
      model: s,
      textColorClasses: o,
      textColorStyles: u,
      backgroundColorClasses: c,
      backgroundColorStyles: d,
      trueValue: f
    } = eP(e), h = Bn(), m = Ve(!1), g = Ve(!1), v = Y(), y = k(() => e.id || `input-${h}`), b = k(() => !e.disabled && !e.readonly);
    i == null || i.onForceUpdate(() => {
      v.value && (v.value.checked = s.value);
    });
    function C(V) {
      b.value && (m.value = !0, ys(V.target, ":focus-visible") !== !1 && (g.value = !0));
    }
    function S() {
      m.value = !1, g.value = !1;
    }
    function x(V) {
      V.stopPropagation();
    }
    function w(V) {
      if (!b.value) {
        v.value && (v.value.checked = s.value);
        return;
      }
      e.readonly && i && et(() => i.forceUpdate()), s.value = V.target.checked;
    }
    return ye(() => {
      var P, M;
      const V = a.label ? a.label({
        label: e.label,
        props: {
          for: y.value
        }
      }) : e.label, [_, O] = Il(n), $ = p("input", fe({
        ref: v,
        checked: s.value,
        disabled: !!e.disabled,
        id: y.value,
        onBlur: S,
        onFocus: C,
        onInput: w,
        "aria-disabled": !!e.disabled,
        "aria-label": e.label,
        type: e.type,
        value: f.value,
        name: e.name,
        "aria-checked": e.type === "checkbox" ? s.value : void 0
      }, O), null);
      return p("div", fe({
        class: ["v-selection-control", {
          "v-selection-control--dirty": s.value,
          "v-selection-control--disabled": e.disabled,
          "v-selection-control--error": e.error,
          "v-selection-control--focused": m.value,
          "v-selection-control--focus-visible": g.value,
          "v-selection-control--inline": e.inline
        }, l.value, e.class]
      }, _, {
        style: e.style
      }), [p("div", {
        class: ["v-selection-control__wrapper", o.value],
        style: u.value
      }, [(P = a.default) == null ? void 0 : P.call(a, {
        backgroundColorClasses: c,
        backgroundColorStyles: d
      }), Ct(p("div", {
        class: ["v-selection-control__input"]
      }, [((M = a.input) == null ? void 0 : M.call(a, {
        model: s,
        textColorClasses: o,
        textColorStyles: u,
        backgroundColorClasses: c,
        backgroundColorStyles: d,
        inputNode: $,
        icon: r.value,
        props: {
          onFocus: C,
          onBlur: S,
          id: y.value
        }
      })) ?? p(ge, null, [r.value && p(vt, {
        key: "icon",
        icon: r.value
      }, null), $])]), [[xa("ripple"), e.ripple && [!e.disabled && !e.readonly, null, ["center", "circle"]]]])]), V && p(Us, {
        for: y.value,
        onClick: x
      }, {
        default: () => [V]
      })]);
    }), {
      isFocused: m,
      input: v
    };
  }
}), P3 = le({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: Ue,
    default: "$checkboxIndeterminate"
  },
  ...Ud({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn"), qi = ve()({
  name: "VCheckboxBtn",
  props: P3(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "indeterminate"), i = Fe(e, "modelValue");
    function l(o) {
      a.value && (a.value = !1);
    }
    const r = k(() => a.value ? e.indeterminateIcon : e.falseIcon), s = k(() => a.value ? e.indeterminateIcon : e.trueIcon);
    return ye(() => {
      const o = hn($l.filterProps(e), ["modelValue"]);
      return p($l, fe(o, {
        modelValue: i.value,
        "onUpdate:modelValue": [(u) => i.value = u, l],
        class: ["v-checkbox-btn", e.class],
        style: e.style,
        type: "checkbox",
        falseIcon: r.value,
        trueIcon: s.value,
        "aria-checked": a.value ? "mixed" : void 0
      }), n);
    }), {};
  }
});
function $3(e) {
  const {
    t
  } = tn();
  function n(a) {
    let {
      name: i
    } = a;
    const l = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[i], r = e[`onClick:${i}`], s = r && l ? t(`$vuetify.input.${l}`, e.label ?? "") : void 0;
    return p(vt, {
      icon: e[`${i}Icon`],
      "aria-label": s,
      onClick: r
    }, null);
  }
  return {
    InputIcon: n
  };
}
const tP = le({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...Ae(),
  ...ai({
    transition: {
      component: M2,
      leaveAbsolute: !0,
      group: !0
    }
  })
}, "VMessages"), _3 = ve()({
  name: "VMessages",
  props: tP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = k(() => Ht(e.messages)), {
      textColorClasses: i,
      textColorStyles: l
    } = zn(k(() => e.color));
    return ye(() => p(Kn, {
      transition: e.transition,
      tag: "div",
      class: ["v-messages", i.value, e.class],
      style: [l.value, e.style],
      role: "alert",
      "aria-live": "polite"
    }, {
      default: () => [e.active && a.value.map((r, s) => p("div", {
        class: "v-messages__message",
        key: `${s}-${a.value}`
      }, [n.message ? n.message({
        message: r
      }) : r]))]
    })), {};
  }
}), ku = le({
  focused: Boolean,
  "onUpdate:focused": Rn()
}, "focus");
function il(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai();
  const n = Fe(e, "focused"), a = k(() => ({
    [`${t}--focused`]: n.value
  }));
  function i() {
    n.value = !0;
  }
  function l() {
    n.value = !1;
  }
  return {
    focusClasses: a,
    isFocused: n,
    focus: i,
    blur: l
  };
}
const M3 = Symbol.for("vuetify:form"), nP = le({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function aP(e) {
  const t = Fe(e, "modelValue"), n = k(() => e.disabled), a = k(() => e.readonly), i = Ve(!1), l = Y([]), r = Y([]);
  async function s() {
    const c = [];
    let d = !0;
    r.value = [], i.value = !0;
    for (const f of l.value) {
      const h = await f.validate();
      if (h.length > 0 && (d = !1, c.push({
        id: f.id,
        errorMessages: h
      })), !d && e.fastFail) break;
    }
    return r.value = c, i.value = !1, {
      valid: d,
      errors: r.value
    };
  }
  function o() {
    l.value.forEach((c) => c.reset());
  }
  function u() {
    l.value.forEach((c) => c.resetValidation());
  }
  return pe(l, () => {
    let c = 0, d = 0;
    const f = [];
    for (const h of l.value)
      h.isValid === !1 ? (d++, f.push({
        id: h.id,
        errorMessages: h.errorMessages
      })) : h.isValid === !0 && c++;
    r.value = f, t.value = d > 0 ? !1 : c === l.value.length ? !0 : null;
  }, {
    deep: !0,
    flush: "post"
  }), Tt(M3, {
    register: (c) => {
      let {
        id: d,
        vm: f,
        validate: h,
        reset: m,
        resetValidation: g
      } = c;
      l.value.some((v) => v.id === d) && Wa(`Duplicate input name "${d}"`), l.value.push({
        id: d,
        validate: h,
        reset: m,
        resetValidation: g,
        vm: DC(f),
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (c) => {
      l.value = l.value.filter((d) => d.id !== c);
    },
    update: (c, d, f) => {
      const h = l.value.find((m) => m.id === c);
      h && (h.isValid = d, h.errorMessages = f);
    },
    isDisabled: n,
    isReadonly: a,
    isValidating: i,
    isValid: t,
    items: l,
    validateOn: ue(e, "validateOn")
  }), {
    errors: r,
    isDisabled: n,
    isReadonly: a,
    isValidating: i,
    isValid: t,
    items: l,
    validate: s,
    reset: o,
    resetValidation: u
  };
}
function Gd() {
  return ct(M3, null);
}
const V3 = le({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...ku()
}, "validation");
function T3(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Bn();
  const a = Fe(e, "modelValue"), i = k(() => e.validationValue === void 0 ? a.value : e.validationValue), l = Gd(), r = Y([]), s = Ve(!0), o = k(() => !!(Ht(a.value === "" ? null : a.value).length || Ht(i.value === "" ? null : i.value).length)), u = k(() => !!(e.disabled ?? (l == null ? void 0 : l.isDisabled.value))), c = k(() => !!(e.readonly ?? (l == null ? void 0 : l.isReadonly.value))), d = k(() => {
    var x;
    return (x = e.errorMessages) != null && x.length ? Ht(e.errorMessages).concat(r.value).slice(0, Math.max(0, +e.maxErrors)) : r.value;
  }), f = k(() => {
    let x = (e.validateOn ?? (l == null ? void 0 : l.validateOn.value)) || "input";
    x === "lazy" && (x = "input lazy"), x === "eager" && (x = "input eager");
    const w = new Set((x == null ? void 0 : x.split(" ")) ?? []);
    return {
      input: w.has("input"),
      blur: w.has("blur") || w.has("input") || w.has("invalid-input"),
      invalidInput: w.has("invalid-input"),
      lazy: w.has("lazy"),
      eager: w.has("eager")
    };
  }), h = k(() => {
    var x;
    return e.error || (x = e.errorMessages) != null && x.length ? !1 : e.rules.length ? s.value ? r.value.length || f.value.lazy ? null : !0 : !r.value.length : !0;
  }), m = Ve(!1), g = k(() => ({
    [`${t}--error`]: h.value === !1,
    [`${t}--dirty`]: o.value,
    [`${t}--disabled`]: u.value,
    [`${t}--readonly`]: c.value
  })), v = Wt("validation"), y = k(() => e.name ?? X(n));
  U4(() => {
    l == null || l.register({
      id: y.value,
      vm: v,
      validate: S,
      reset: b,
      resetValidation: C
    });
  }), mn(() => {
    l == null || l.unregister(y.value);
  }), rt(async () => {
    f.value.lazy || await S(!f.value.eager), l == null || l.update(y.value, h.value, d.value);
  }), la(() => f.value.input || f.value.invalidInput && h.value === !1, () => {
    pe(i, () => {
      if (i.value != null)
        S();
      else if (e.focused) {
        const x = pe(() => e.focused, (w) => {
          w || S(), x();
        });
      }
    });
  }), la(() => f.value.blur, () => {
    pe(() => e.focused, (x) => {
      x || S();
    });
  }), pe([h, d], () => {
    l == null || l.update(y.value, h.value, d.value);
  });
  async function b() {
    a.value = null, await et(), await C();
  }
  async function C() {
    s.value = !0, f.value.lazy ? r.value = [] : await S(!f.value.eager);
  }
  async function S() {
    let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const w = [];
    m.value = !0;
    for (const V of e.rules) {
      if (w.length >= +(e.maxErrors ?? 1))
        break;
      const O = await (typeof V == "function" ? V : () => V)(i.value);
      if (O !== !0) {
        if (O !== !1 && typeof O != "string") {
          console.warn(`${O} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        w.push(O || "");
      }
    }
    return r.value = w, m.value = !1, s.value = x, r.value;
  }
  return {
    errorMessages: d,
    isDirty: o,
    isDisabled: u,
    isReadonly: c,
    isPristine: s,
    isValid: h,
    isValidating: m,
    reset: b,
    resetValidation: C,
    validate: S,
    validationClasses: g
  };
}
const ll = le({
  id: String,
  appendIcon: Ue,
  centerAffix: {
    type: Boolean,
    default: !0
  },
  prependIcon: Ue,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["horizontal", "vertical"].includes(e)
  },
  "onClick:prepend": Rn(),
  "onClick:append": Rn(),
  ...Ae(),
  ...Ln(),
  ...Id(vn(), ["maxWidth", "minWidth", "width"]),
  ...dt(),
  ...V3()
}, "VInput"), Fn = ve()({
  name: "VInput",
  props: {
    ...ll()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a,
      emit: i
    } = t;
    const {
      densityClasses: l
    } = ea(e), {
      dimensionStyles: r
    } = gn(e), {
      themeClasses: s
    } = yt(e), {
      rtlClasses: o
    } = xn(), {
      InputIcon: u
    } = $3(e), c = Bn(), d = k(() => e.id || `input-${c}`), f = k(() => `${d.value}-messages`), {
      errorMessages: h,
      isDirty: m,
      isDisabled: g,
      isReadonly: v,
      isPristine: y,
      isValid: b,
      isValidating: C,
      reset: S,
      resetValidation: x,
      validate: w,
      validationClasses: V
    } = T3(e, "v-input", d), _ = k(() => ({
      id: d,
      messagesId: f,
      isDirty: m,
      isDisabled: g,
      isReadonly: v,
      isPristine: y,
      isValid: b,
      isValidating: C,
      reset: S,
      resetValidation: x,
      validate: w
    })), O = k(() => {
      var $;
      return ($ = e.errorMessages) != null && $.length || !y.value && h.value.length ? h.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages;
    });
    return ye(() => {
      var L, A, D, B;
      const $ = !!(a.prepend || e.prependIcon), P = !!(a.append || e.appendIcon), M = O.value.length > 0, T = !e.hideDetails || e.hideDetails === "auto" && (M || !!a.details);
      return p("div", {
        class: ["v-input", `v-input--${e.direction}`, {
          "v-input--center-affix": e.centerAffix,
          "v-input--hide-spin-buttons": e.hideSpinButtons
        }, l.value, s.value, o.value, V.value, e.class],
        style: [r.value, e.style]
      }, [$ && p("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [(L = a.prepend) == null ? void 0 : L.call(a, _.value), e.prependIcon && p(u, {
        key: "prepend-icon",
        name: "prepend"
      }, null)]), a.default && p("div", {
        class: "v-input__control"
      }, [(A = a.default) == null ? void 0 : A.call(a, _.value)]), P && p("div", {
        key: "append",
        class: "v-input__append"
      }, [e.appendIcon && p(u, {
        key: "append-icon",
        name: "append"
      }, null), (D = a.append) == null ? void 0 : D.call(a, _.value)]), T && p("div", {
        class: "v-input__details"
      }, [p(_3, {
        id: f.value,
        active: M,
        messages: O.value
      }, {
        message: a.message
      }), (B = a.details) == null ? void 0 : B.call(a, _.value)])]);
    }), {
      reset: S,
      resetValidation: x,
      validate: w,
      isValid: b,
      errorMessages: h
    };
  }
}), iP = le({
  ...ll(),
  ...hn(P3(), ["inline"])
}, "VCheckbox"), lP = ve()({
  name: "VCheckbox",
  inheritAttrs: !1,
  props: iP(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:focused": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const i = Fe(e, "modelValue"), {
      isFocused: l,
      focus: r,
      blur: s
    } = il(e), o = Bn(), u = k(() => e.id || `checkbox-${o}`);
    return ye(() => {
      const [c, d] = Il(n), f = Fn.filterProps(e), h = qi.filterProps(e);
      return p(Fn, fe({
        class: ["v-checkbox", e.class]
      }, c, f, {
        modelValue: i.value,
        "onUpdate:modelValue": (m) => i.value = m,
        id: u.value,
        focused: l.value,
        style: e.style
      }), {
        ...a,
        default: (m) => {
          let {
            id: g,
            messagesId: v,
            isDisabled: y,
            isReadonly: b,
            isValid: C
          } = m;
          return p(qi, fe(h, {
            id: g.value,
            "aria-describedby": v.value,
            disabled: y.value,
            readonly: b.value
          }, d, {
            error: C.value === !1,
            modelValue: i.value,
            "onUpdate:modelValue": (S) => i.value = S,
            onFocus: r,
            onBlur: s
          }), a);
        }
      });
    }), {};
  }
});
function rP(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isRtl: a,
    isHorizontal: i
  } = e;
  const l = Ho(i, n), r = L3(i, a, n), s = Ho(i, t), o = Q3(i, t), u = s * 0.4;
  return r > o ? o - u : r + l < o + s ? o - l + s + u : r;
}
function sP(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isHorizontal: a
  } = e;
  const i = Ho(a, n), l = Q3(a, t), r = Ho(a, t);
  return l - i / 2 + r / 2;
}
function bg(e, t) {
  const n = e ? "scrollWidth" : "scrollHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function oP(e, t) {
  const n = e ? "clientWidth" : "clientHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function L3(e, t, n) {
  if (!n)
    return 0;
  const {
    scrollLeft: a,
    offsetWidth: i,
    scrollWidth: l
  } = n;
  return e ? t ? l - i + a : a : n.scrollTop;
}
function Ho(e, t) {
  const n = e ? "offsetWidth" : "offsetHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function Q3(e, t) {
  const n = e ? "offsetLeft" : "offsetTop";
  return (t == null ? void 0 : t[n]) || 0;
}
const A3 = Symbol.for("vuetify:v-slide-group"), Q2 = le({
  centerActive: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: A3
  },
  nextIcon: {
    type: Ue,
    default: "$next"
  },
  prevIcon: {
    type: Ue,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["always", "desktop", "mobile"].includes(e)
  },
  ...Ae(),
  ...Qr({
    mobile: null
  }),
  ...nt(),
  ...Zr({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup"), jo = ve()({
  name: "VSlideGroup",
  props: Q2(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isRtl: a
    } = xn(), {
      displayClasses: i,
      mobile: l
    } = Za(e), r = Zl(e, e.symbol), s = Ve(!1), o = Ve(0), u = Ve(0), c = Ve(0), d = k(() => e.direction === "horizontal"), {
      resizeRef: f,
      contentRect: h
    } = Ga(), {
      resizeRef: m,
      contentRect: g
    } = Ga(), v = oS(), y = k(() => ({
      container: f.el,
      duration: 200,
      easing: "easeOutQuart"
    })), b = k(() => r.selected.value.length ? r.items.value.findIndex((Z) => Z.id === r.selected.value[0]) : -1), C = k(() => r.selected.value.length ? r.items.value.findIndex((Z) => Z.id === r.selected.value[r.selected.value.length - 1]) : -1);
    if (bt) {
      let Z = -1;
      pe(() => [r.selected.value, h.value, g.value, d.value], () => {
        cancelAnimationFrame(Z), Z = requestAnimationFrame(() => {
          if (h.value && g.value) {
            const R = d.value ? "width" : "height";
            u.value = h.value[R], c.value = g.value[R], s.value = u.value + 1 < c.value;
          }
          if (b.value >= 0 && m.el) {
            const R = m.el.children[C.value];
            x(R, e.centerActive);
          }
        });
      });
    }
    const S = Ve(!1);
    function x(Z, R) {
      let J = 0;
      R ? J = sP({
        containerElement: f.el,
        isHorizontal: d.value,
        selectedElement: Z
      }) : J = rP({
        containerElement: f.el,
        isHorizontal: d.value,
        isRtl: a.value,
        selectedElement: Z
      }), w(J);
    }
    function w(Z) {
      if (!bt || !f.el) return;
      const R = Ho(d.value, f.el), J = L3(d.value, a.value, f.el);
      if (!(bg(d.value, f.el) <= R || // Prevent scrolling by only a couple of pixels, which doesn't look smooth
      Math.abs(Z - J) < 16)) {
        if (d.value && a.value && f.el) {
          const {
            scrollWidth: q,
            offsetWidth: z
          } = f.el;
          Z = q - z - Z;
        }
        d.value ? v.horizontal(Z, y.value) : v(Z, y.value);
      }
    }
    function V(Z) {
      const {
        scrollTop: R,
        scrollLeft: J
      } = Z.target;
      o.value = d.value ? J : R;
    }
    function _(Z) {
      if (S.value = !0, !(!s.value || !m.el)) {
        for (const R of Z.composedPath())
          for (const J of m.el.children)
            if (J === R) {
              x(J);
              return;
            }
      }
    }
    function O(Z) {
      S.value = !1;
    }
    let $ = !1;
    function P(Z) {
      var R;
      !$ && !S.value && !(Z.relatedTarget && ((R = m.el) != null && R.contains(Z.relatedTarget))) && L(), $ = !1;
    }
    function M() {
      $ = !0;
    }
    function T(Z) {
      if (!m.el) return;
      function R(J) {
        Z.preventDefault(), L(J);
      }
      d.value ? Z.key === "ArrowRight" ? R(a.value ? "prev" : "next") : Z.key === "ArrowLeft" && R(a.value ? "next" : "prev") : Z.key === "ArrowDown" ? R("next") : Z.key === "ArrowUp" && R("prev"), Z.key === "Home" ? R("first") : Z.key === "End" && R("last");
    }
    function L(Z) {
      var J, F;
      if (!m.el) return;
      let R;
      if (!Z)
        R = Do(m.el)[0];
      else if (Z === "next") {
        if (R = (J = m.el.querySelector(":focus")) == null ? void 0 : J.nextElementSibling, !R) return L("first");
      } else if (Z === "prev") {
        if (R = (F = m.el.querySelector(":focus")) == null ? void 0 : F.previousElementSibling, !R) return L("last");
      } else Z === "first" ? R = m.el.firstElementChild : Z === "last" && (R = m.el.lastElementChild);
      R && R.focus({
        preventScroll: !0
      });
    }
    function A(Z) {
      const R = d.value && a.value ? -1 : 1, J = (Z === "prev" ? -R : R) * u.value;
      let F = o.value + J;
      if (d.value && a.value && f.el) {
        const {
          scrollWidth: q,
          offsetWidth: z
        } = f.el;
        F += q - z;
      }
      w(F);
    }
    const D = k(() => ({
      next: r.next,
      prev: r.prev,
      select: r.select,
      isSelected: r.isSelected
    })), B = k(() => {
      switch (e.showArrows) {
        case "always":
          return !0;
        case "desktop":
          return !l.value;
        case !0:
          return s.value || Math.abs(o.value) > 0;
        case "mobile":
          return l.value || s.value || Math.abs(o.value) > 0;
        default:
          return !l.value && (s.value || Math.abs(o.value) > 0);
      }
    }), j = k(() => Math.abs(o.value) > 1), I = k(() => {
      if (!f.value) return !1;
      const Z = bg(d.value, f.el), R = oP(d.value, f.el);
      return Z - R - Math.abs(o.value) > 1;
    });
    return ye(() => p(e.tag, {
      class: ["v-slide-group", {
        "v-slide-group--vertical": !d.value,
        "v-slide-group--has-affixes": B.value,
        "v-slide-group--is-overflowing": s.value
      }, i.value, e.class],
      style: e.style,
      tabindex: S.value || r.selected.value.length ? -1 : 0,
      onFocus: P
    }, {
      default: () => {
        var Z, R, J;
        return [B.value && p("div", {
          key: "prev",
          class: ["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !j.value
          }],
          onMousedown: M,
          onClick: () => j.value && A("prev")
        }, [((Z = n.prev) == null ? void 0 : Z.call(n, D.value)) ?? p(No, null, {
          default: () => [p(vt, {
            icon: a.value ? e.nextIcon : e.prevIcon
          }, null)]
        })]), p("div", {
          key: "container",
          ref: f,
          class: "v-slide-group__container",
          onScroll: V
        }, [p("div", {
          ref: m,
          class: "v-slide-group__content",
          onFocusin: _,
          onFocusout: O,
          onKeydown: T
        }, [(R = n.default) == null ? void 0 : R.call(n, D.value)])]), B.value && p("div", {
          key: "next",
          class: ["v-slide-group__next", {
            "v-slide-group__next--disabled": !I.value
          }],
          onMousedown: M,
          onClick: () => I.value && A("next")
        }, [((J = n.next) == null ? void 0 : J.call(n, D.value)) ?? p(No, null, {
          default: () => [p(vt, {
            icon: a.value ? e.prevIcon : e.nextIcon
          }, null)]
        })])];
      }
    })), {
      selected: r.selected,
      scrollTo: A,
      scrollOffset: o,
      focus: L,
      hasPrev: j,
      hasNext: I
    };
  }
}), D3 = Symbol.for("vuetify:v-chip-group"), uP = le({
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: Qi
  },
  ...Q2(),
  ...Ae(),
  ...Zr({
    selectedClass: "v-chip--selected"
  }),
  ...nt(),
  ...dt(),
  ...Na({
    variant: "tonal"
  })
}, "VChipGroup"), cP = ve()({
  name: "VChipGroup",
  props: uP(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e), {
      isSelected: i,
      select: l,
      next: r,
      prev: s,
      selected: o
    } = Zl(e, D3);
    return Yt({
      VChip: {
        color: ue(e, "color"),
        disabled: ue(e, "disabled"),
        filter: ue(e, "filter"),
        variant: ue(e, "variant")
      }
    }), ye(() => {
      const u = jo.filterProps(e);
      return p(jo, fe(u, {
        class: ["v-chip-group", {
          "v-chip-group--column": e.column
        }, a.value, e.class],
        style: e.style
      }), {
        default: () => {
          var c;
          return [(c = n.default) == null ? void 0 : c.call(n, {
            isSelected: i,
            select: l,
            next: r,
            prev: s,
            selected: o.value
          })];
        }
      });
    }), {};
  }
}), dP = le({
  activeClass: String,
  appendAvatar: String,
  appendIcon: Ue,
  closable: Boolean,
  closeIcon: {
    type: Ue,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: String,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: Ue,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  onClick: Rn(),
  onClickOnce: Rn(),
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...Pn(),
  ...Er(),
  ...Dt(),
  ...Ou(),
  ...Ri(),
  ...nt({
    tag: "span"
  }),
  ...dt(),
  ...Na({
    variant: "tonal"
  })
}, "VChip"), Gs = ve()({
  name: "VChip",
  directives: {
    Ripple: nl
  },
  props: dP(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0,
    "group:selected": (e) => !0,
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: i
    } = t;
    const {
      t: l
    } = tn(), {
      borderClasses: r
    } = _a(e), {
      colorClasses: s,
      colorStyles: o,
      variantClasses: u
    } = Br(e), {
      densityClasses: c
    } = ea(e), {
      elevationClasses: d
    } = Zn(e), {
      roundedClasses: f
    } = qt(e), {
      sizeClasses: h
    } = Ys(e), {
      themeClasses: m
    } = yt(e), g = Fe(e, "modelValue"), v = Nr(e, D3, !1), y = yu(e, n), b = k(() => e.link !== !1 && y.isLink.value), C = k(() => !e.disabled && e.link !== !1 && (!!v || e.link || y.isClickable.value)), S = k(() => ({
      "aria-label": l(e.closeLabel),
      onClick(V) {
        V.preventDefault(), V.stopPropagation(), g.value = !1, a("click:close", V);
      }
    }));
    function x(V) {
      var _;
      a("click", V), C.value && ((_ = y.navigate) == null || _.call(y, V), v == null || v.toggle());
    }
    function w(V) {
      (V.key === "Enter" || V.key === " ") && (V.preventDefault(), x(V));
    }
    return () => {
      const V = y.isLink.value ? "a" : e.tag, _ = !!(e.appendIcon || e.appendAvatar), O = !!(_ || i.append), $ = !!(i.close || e.closable), P = !!(i.filter || e.filter) && v, M = !!(e.prependIcon || e.prependAvatar), T = !!(M || i.prepend), L = !v || v.isSelected.value;
      return g.value && Ct(p(V, {
        class: ["v-chip", {
          "v-chip--disabled": e.disabled,
          "v-chip--label": e.label,
          "v-chip--link": C.value,
          "v-chip--filter": P,
          "v-chip--pill": e.pill
        }, m.value, r.value, L ? s.value : void 0, c.value, d.value, f.value, h.value, u.value, v == null ? void 0 : v.selectedClass.value, e.class],
        style: [L ? o.value : void 0, e.style],
        disabled: e.disabled || void 0,
        draggable: e.draggable,
        href: y.href.value,
        tabindex: C.value ? 0 : void 0,
        onClick: x,
        onKeydown: C.value && !b.value && w
      }, {
        default: () => {
          var A;
          return [Bl(C.value, "v-chip"), P && p(V2, {
            key: "filter"
          }, {
            default: () => [Ct(p("div", {
              class: "v-chip__filter"
            }, [i.filter ? p(lt, {
              key: "filter-defaults",
              disabled: !e.filterIcon,
              defaults: {
                VIcon: {
                  icon: e.filterIcon
                }
              }
            }, i.filter) : p(vt, {
              key: "filter-icon",
              icon: e.filterIcon
            }, null)]), [[Dn, v.isSelected.value]])]
          }), T && p("div", {
            key: "prepend",
            class: "v-chip__prepend"
          }, [i.prepend ? p(lt, {
            key: "prepend-defaults",
            disabled: !M,
            defaults: {
              VAvatar: {
                image: e.prependAvatar,
                start: !0
              },
              VIcon: {
                icon: e.prependIcon,
                start: !0
              }
            }
          }, i.prepend) : p(ge, null, [e.prependIcon && p(vt, {
            key: "prepend-icon",
            icon: e.prependIcon,
            start: !0
          }, null), e.prependAvatar && p(Da, {
            key: "prepend-avatar",
            image: e.prependAvatar,
            start: !0
          }, null)])]), p("div", {
            class: "v-chip__content",
            "data-no-activator": ""
          }, [((A = i.default) == null ? void 0 : A.call(i, {
            isSelected: v == null ? void 0 : v.isSelected.value,
            selectedClass: v == null ? void 0 : v.selectedClass.value,
            select: v == null ? void 0 : v.select,
            toggle: v == null ? void 0 : v.toggle,
            value: v == null ? void 0 : v.value.value,
            disabled: e.disabled
          })) ?? e.text]), O && p("div", {
            key: "append",
            class: "v-chip__append"
          }, [i.append ? p(lt, {
            key: "append-defaults",
            disabled: !_,
            defaults: {
              VAvatar: {
                end: !0,
                image: e.appendAvatar
              },
              VIcon: {
                end: !0,
                icon: e.appendIcon
              }
            }
          }, i.append) : p(ge, null, [e.appendIcon && p(vt, {
            key: "append-icon",
            end: !0,
            icon: e.appendIcon
          }, null), e.appendAvatar && p(Da, {
            key: "append-avatar",
            end: !0,
            image: e.appendAvatar
          }, null)])]), $ && p("button", fe({
            key: "close",
            class: "v-chip__close",
            type: "button"
          }, S.value), [i.close ? p(lt, {
            key: "close-defaults",
            defaults: {
              VIcon: {
                icon: e.closeIcon,
                size: "x-small"
              }
            }
          }, i.close) : p(vt, {
            key: "close-icon",
            icon: e.closeIcon,
            size: "x-small"
          }, null)])];
        }
      }), [[xa("ripple"), C.value && e.ripple, null]]);
    };
  }
}), mh = Symbol.for("vuetify:list");
function R3() {
  const e = ct(mh, {
    hasPrepend: Ve(!1),
    updateHasPrepend: () => null
  }), t = {
    hasPrepend: Ve(!1),
    updateHasPrepend: (n) => {
      n && (t.hasPrepend.value = n);
    }
  };
  return Tt(mh, t), e;
}
function I3() {
  return ct(mh, null);
}
const A2 = (e) => {
  const t = {
    activate: (n) => {
      let {
        id: a,
        value: i,
        activated: l
      } = n;
      return a = At(a), e && !i && l.size === 1 && l.has(a) || (i ? l.add(a) : l.delete(a)), l;
    },
    in: (n, a, i) => {
      let l = /* @__PURE__ */ new Set();
      if (n != null)
        for (const r of Ht(n))
          l = t.activate({
            id: r,
            value: !0,
            activated: new Set(l),
            children: a,
            parents: i
          });
      return l;
    },
    out: (n) => Array.from(n)
  };
  return t;
}, B3 = (e) => {
  const t = A2(e);
  return {
    activate: (a) => {
      let {
        activated: i,
        id: l,
        ...r
      } = a;
      l = At(l);
      const s = i.has(l) ? /* @__PURE__ */ new Set([l]) : /* @__PURE__ */ new Set();
      return t.activate({
        ...r,
        id: l,
        activated: s
      });
    },
    in: (a, i, l) => {
      let r = /* @__PURE__ */ new Set();
      if (a != null) {
        const s = Ht(a);
        s.length && (r = t.in(s.slice(0, 1), i, l));
      }
      return r;
    },
    out: (a, i, l) => t.out(a, i, l)
  };
}, fP = (e) => {
  const t = A2(e);
  return {
    activate: (a) => {
      let {
        id: i,
        activated: l,
        children: r,
        ...s
      } = a;
      return i = At(i), r.has(i) ? l : t.activate({
        id: i,
        activated: l,
        children: r,
        ...s
      });
    },
    in: t.in,
    out: t.out
  };
}, hP = (e) => {
  const t = B3(e);
  return {
    activate: (a) => {
      let {
        id: i,
        activated: l,
        children: r,
        ...s
      } = a;
      return i = At(i), r.has(i) ? l : t.activate({
        id: i,
        activated: l,
        children: r,
        ...s
      });
    },
    in: t.in,
    out: t.out
  };
}, mP = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: a,
      parents: i
    } = e;
    if (n) {
      const l = /* @__PURE__ */ new Set();
      l.add(t);
      let r = i.get(t);
      for (; r != null; )
        l.add(r), r = i.get(r);
      return l;
    } else
      return a.delete(t), a;
  },
  select: () => null
}, Z3 = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: a,
      parents: i
    } = e;
    if (n) {
      let l = At(i.get(t));
      for (a.add(t); l != null && l !== t; )
        a.add(l), l = At(i.get(l));
      return a;
    } else
      a.delete(t);
    return a;
  },
  select: () => null
}, vP = {
  open: Z3.open,
  select: (e) => {
    let {
      id: t,
      value: n,
      opened: a,
      parents: i
    } = e;
    if (!n) return a;
    const l = [];
    let r = i.get(t);
    for (; r != null; )
      l.push(r), r = i.get(r);
    return new Set(l);
  }
}, D2 = (e) => {
  const t = {
    select: (n) => {
      let {
        id: a,
        value: i,
        selected: l
      } = n;
      if (a = At(a), e && !i) {
        const r = Array.from(l.entries()).reduce((s, o) => {
          let [u, c] = o;
          return c === "on" && s.push(u), s;
        }, []);
        if (r.length === 1 && r[0] === a) return l;
      }
      return l.set(a, i ? "on" : "off"), l;
    },
    in: (n, a, i) => {
      let l = /* @__PURE__ */ new Map();
      for (const r of n || [])
        l = t.select({
          id: r,
          value: !0,
          selected: new Map(l),
          children: a,
          parents: i
        });
      return l;
    },
    out: (n) => {
      const a = [];
      for (const [i, l] of n.entries())
        l === "on" && a.push(i);
      return a;
    }
  };
  return t;
}, E3 = (e) => {
  const t = D2(e);
  return {
    select: (a) => {
      let {
        selected: i,
        id: l,
        ...r
      } = a;
      l = At(l);
      const s = i.has(l) ? /* @__PURE__ */ new Map([[l, i.get(l)]]) : /* @__PURE__ */ new Map();
      return t.select({
        ...r,
        id: l,
        selected: s
      });
    },
    in: (a, i, l) => {
      let r = /* @__PURE__ */ new Map();
      return a != null && a.length && (r = t.in(a.slice(0, 1), i, l)), r;
    },
    out: (a, i, l) => t.out(a, i, l)
  };
}, gP = (e) => {
  const t = D2(e);
  return {
    select: (a) => {
      let {
        id: i,
        selected: l,
        children: r,
        ...s
      } = a;
      return i = At(i), r.has(i) ? l : t.select({
        id: i,
        selected: l,
        children: r,
        ...s
      });
    },
    in: t.in,
    out: t.out
  };
}, pP = (e) => {
  const t = E3(e);
  return {
    select: (a) => {
      let {
        id: i,
        selected: l,
        children: r,
        ...s
      } = a;
      return i = At(i), r.has(i) ? l : t.select({
        id: i,
        selected: l,
        children: r,
        ...s
      });
    },
    in: t.in,
    out: t.out
  };
}, yP = (e) => {
  const t = {
    select: (n) => {
      let {
        id: a,
        value: i,
        selected: l,
        children: r,
        parents: s
      } = n;
      a = At(a);
      const o = new Map(l), u = [a];
      for (; u.length; ) {
        const d = u.shift();
        l.set(At(d), i ? "on" : "off"), r.has(d) && u.push(...r.get(d));
      }
      let c = At(s.get(a));
      for (; c; ) {
        const d = r.get(c), f = d.every((m) => l.get(At(m)) === "on"), h = d.every((m) => !l.has(At(m)) || l.get(At(m)) === "off");
        l.set(c, f ? "on" : h ? "off" : "indeterminate"), c = At(s.get(c));
      }
      return e && !i && Array.from(l.entries()).reduce((f, h) => {
        let [m, g] = h;
        return g === "on" && f.push(m), f;
      }, []).length === 0 ? o : l;
    },
    in: (n, a, i) => {
      let l = /* @__PURE__ */ new Map();
      for (const r of n || [])
        l = t.select({
          id: r,
          value: !0,
          selected: new Map(l),
          children: a,
          parents: i
        });
      return l;
    },
    out: (n, a) => {
      const i = [];
      for (const [l, r] of n.entries())
        r === "on" && !a.has(l) && i.push(l);
      return i;
    }
  };
  return t;
}, zo = Symbol.for("vuetify:nested"), N3 = {
  id: Ve(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: Y(/* @__PURE__ */ new Map()),
    children: Y(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    activate: () => null,
    select: () => null,
    activatable: Y(!1),
    selectable: Y(!1),
    opened: Y(/* @__PURE__ */ new Set()),
    activated: Y(/* @__PURE__ */ new Set()),
    selected: Y(/* @__PURE__ */ new Map()),
    selectedValues: Y([])
  }
}, OP = le({
  activatable: Boolean,
  selectable: Boolean,
  activeStrategy: [String, Function, Object],
  selectStrategy: [String, Function, Object],
  openStrategy: [String, Object],
  opened: null,
  activated: null,
  selected: null,
  mandatory: Boolean
}, "nested"), bP = (e) => {
  let t = !1;
  const n = Y(/* @__PURE__ */ new Map()), a = Y(/* @__PURE__ */ new Map()), i = Fe(e, "opened", e.opened, (h) => new Set(At(h)), (h) => [...h.values()]), l = k(() => {
    if (typeof e.activeStrategy == "object") return e.activeStrategy;
    if (typeof e.activeStrategy == "function") return e.activeStrategy(e.mandatory);
    switch (e.activeStrategy) {
      case "leaf":
        return fP(e.mandatory);
      case "single-leaf":
        return hP(e.mandatory);
      case "independent":
        return A2(e.mandatory);
      case "single-independent":
      default:
        return B3(e.mandatory);
    }
  }), r = k(() => {
    if (typeof e.selectStrategy == "object") return e.selectStrategy;
    if (typeof e.selectStrategy == "function") return e.selectStrategy(e.mandatory);
    switch (e.selectStrategy) {
      case "single-leaf":
        return pP(e.mandatory);
      case "leaf":
        return gP(e.mandatory);
      case "independent":
        return D2(e.mandatory);
      case "single-independent":
        return E3(e.mandatory);
      case "classic":
      default:
        return yP(e.mandatory);
    }
  }), s = k(() => {
    if (typeof e.openStrategy == "object") return e.openStrategy;
    switch (e.openStrategy) {
      case "list":
        return vP;
      case "single":
        return mP;
      case "multiple":
      default:
        return Z3;
    }
  }), o = Fe(e, "activated", e.activated, (h) => l.value.in(h, n.value, a.value), (h) => l.value.out(h, n.value, a.value)), u = Fe(e, "selected", e.selected, (h) => r.value.in(h, n.value, a.value), (h) => r.value.out(h, n.value, a.value));
  mn(() => {
    t = !0;
  });
  function c(h) {
    const m = [];
    let g = h;
    for (; g != null; )
      m.unshift(g), g = a.value.get(g);
    return m;
  }
  const d = Wt("nested"), f = {
    id: Ve(),
    root: {
      opened: i,
      activatable: ue(e, "activatable"),
      selectable: ue(e, "selectable"),
      activated: o,
      selected: u,
      selectedValues: k(() => {
        const h = [];
        for (const [m, g] of u.value.entries())
          g === "on" && h.push(m);
        return h;
      }),
      register: (h, m, g) => {
        m && h !== m && a.value.set(h, m), g && n.value.set(h, []), m != null && n.value.set(m, [...n.value.get(m) || [], h]);
      },
      unregister: (h) => {
        if (t) return;
        n.value.delete(h);
        const m = a.value.get(h);
        if (m) {
          const g = n.value.get(m) ?? [];
          n.value.set(m, g.filter((v) => v !== h));
        }
        a.value.delete(h);
      },
      open: (h, m, g) => {
        d.emit("click:open", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const v = s.value.open({
          id: h,
          value: m,
          opened: new Set(i.value),
          children: n.value,
          parents: a.value,
          event: g
        });
        v && (i.value = v);
      },
      openOnSelect: (h, m, g) => {
        const v = s.value.select({
          id: h,
          value: m,
          selected: new Map(u.value),
          opened: new Set(i.value),
          children: n.value,
          parents: a.value,
          event: g
        });
        v && (i.value = v);
      },
      select: (h, m, g) => {
        d.emit("click:select", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const v = r.value.select({
          id: h,
          value: m,
          selected: new Map(u.value),
          children: n.value,
          parents: a.value,
          event: g
        });
        v && (u.value = v), f.root.openOnSelect(h, m, g);
      },
      activate: (h, m, g) => {
        if (!e.activatable)
          return f.root.select(h, !0, g);
        d.emit("click:activate", {
          id: h,
          value: m,
          path: c(h),
          event: g
        });
        const v = l.value.activate({
          id: h,
          value: m,
          activated: new Set(o.value),
          children: n.value,
          parents: a.value,
          event: g
        });
        v && (o.value = v);
      },
      children: n,
      parents: a
    }
  };
  return Tt(zo, f), f.root;
}, H3 = (e, t) => {
  const n = ct(zo, N3), a = Symbol(Bn()), i = k(() => e.value !== void 0 ? e.value : a), l = {
    ...n,
    id: i,
    open: (r, s) => n.root.open(At(i.value), r, s),
    openOnSelect: (r, s) => n.root.openOnSelect(i.value, r, s),
    isOpen: k(() => n.root.opened.value.has(At(i.value))),
    parent: k(() => n.root.parents.value.get(i.value)),
    activate: (r, s) => n.root.activate(i.value, r, s),
    isActivated: k(() => n.root.activated.value.has(At(i.value))),
    select: (r, s) => n.root.select(i.value, r, s),
    isSelected: k(() => n.root.selected.value.get(At(i.value)) === "on"),
    isIndeterminate: k(() => n.root.selected.value.get(i.value) === "indeterminate"),
    isLeaf: k(() => !n.root.children.value.get(i.value)),
    isGroupActivator: n.isGroupActivator
  };
  return !n.isGroupActivator && n.root.register(i.value, n.id.value, t), mn(() => {
    !n.isGroupActivator && n.root.unregister(i.value);
  }), t && Tt(zo, l), l;
}, CP = () => {
  const e = ct(zo, N3);
  Tt(zo, {
    ...e,
    isGroupActivator: !0
  });
}, wP = Pa({
  name: "VListGroupActivator",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return CP(), () => {
      var a;
      return (a = n.default) == null ? void 0 : a.call(n);
    };
  }
}), kP = le({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: Ue,
    default: "$collapse"
  },
  expandIcon: {
    type: Ue,
    default: "$expand"
  },
  prependIcon: Ue,
  appendIcon: Ue,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...Ae(),
  ...nt()
}, "VListGroup"), vh = ve()({
  name: "VListGroup",
  props: kP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isOpen: a,
      open: i,
      id: l
    } = H3(ue(e, "value"), !0), r = k(() => `v-list-group--id-${String(l.value)}`), s = I3(), {
      isBooted: o
    } = Ir();
    function u(h) {
      h.stopPropagation(), i(!a.value, h);
    }
    const c = k(() => ({
      onClick: u,
      class: "v-list-group__header",
      id: r.value
    })), d = k(() => a.value ? e.collapseIcon : e.expandIcon), f = k(() => ({
      VListItem: {
        active: a.value,
        activeColor: e.activeColor,
        baseColor: e.baseColor,
        color: e.color,
        prependIcon: e.prependIcon || e.subgroup && d.value,
        appendIcon: e.appendIcon || !e.subgroup && d.value,
        title: e.title,
        value: e.value
      }
    }));
    return ye(() => p(e.tag, {
      class: ["v-list-group", {
        "v-list-group--prepend": s == null ? void 0 : s.hasPrepend.value,
        "v-list-group--fluid": e.fluid,
        "v-list-group--subgroup": e.subgroup,
        "v-list-group--open": a.value
      }, e.class],
      style: e.style
    }, {
      default: () => [n.activator && p(lt, {
        defaults: f.value
      }, {
        default: () => [p(wP, null, {
          default: () => [n.activator({
            props: c.value,
            isOpen: a.value
          })]
        })]
      }), p(Kn, {
        transition: {
          component: Fd
        },
        disabled: !o.value
      }, {
        default: () => {
          var h;
          return [Ct(p("div", {
            class: "v-list-group__items",
            role: "group",
            "aria-labelledby": r.value
          }, [(h = n.default) == null ? void 0 : h.call(n)]), [[Dn, a.value]])];
        }
      })]
    })), {
      isOpen: a
    };
  }
}), SP = le({
  opacity: [Number, String],
  ...Ae(),
  ...nt()
}, "VListItemSubtitle"), j3 = ve()({
  name: "VListItemSubtitle",
  props: SP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => p(e.tag, {
      class: ["v-list-item-subtitle", e.class],
      style: [{
        "--v-list-item-subtitle-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), z3 = Di("v-list-item-title"), xP = le({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: Ue,
  baseColor: String,
  disabled: Boolean,
  lines: [Boolean, String],
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: Ue,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  slim: Boolean,
  subtitle: [String, Number],
  title: [String, Number],
  value: null,
  onClick: Rn(),
  onClickOnce: Rn(),
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...vn(),
  ...Pn(),
  ...Dt(),
  ...Ou(),
  ...nt(),
  ...dt(),
  ...Na({
    variant: "text"
  })
}, "VListItem"), Ui = ve()({
  name: "VListItem",
  directives: {
    Ripple: nl
  },
  props: xP(),
  emits: {
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a,
      emit: i
    } = t;
    const l = yu(e, n), r = k(() => e.value === void 0 ? l.href.value : e.value), {
      activate: s,
      isActivated: o,
      select: u,
      isOpen: c,
      isSelected: d,
      isIndeterminate: f,
      isGroupActivator: h,
      root: m,
      parent: g,
      openOnSelect: v
    } = H3(r, !1), y = I3(), b = k(() => {
      var R;
      return e.active !== !1 && (e.active || ((R = l.isActive) == null ? void 0 : R.value) || (m.activatable.value ? o.value : d.value));
    }), C = k(() => e.link !== !1 && l.isLink.value), S = k(() => !e.disabled && e.link !== !1 && (e.link || l.isClickable.value || !!y && (m.selectable.value || m.activatable.value || e.value != null))), x = k(() => e.rounded || e.nav), w = k(() => e.color ?? e.activeColor), V = k(() => ({
      color: b.value ? w.value ?? e.baseColor : e.baseColor,
      variant: e.variant
    }));
    pe(() => {
      var R;
      return (R = l.isActive) == null ? void 0 : R.value;
    }, (R) => {
      R && g.value != null && m.open(g.value, !0), R && v(R);
    }, {
      immediate: !0
    });
    const {
      themeClasses: _
    } = yt(e), {
      borderClasses: O
    } = _a(e), {
      colorClasses: $,
      colorStyles: P,
      variantClasses: M
    } = Br(V), {
      densityClasses: T
    } = ea(e), {
      dimensionStyles: L
    } = gn(e), {
      elevationClasses: A
    } = Zn(e), {
      roundedClasses: D
    } = qt(x), B = k(() => e.lines ? `v-list-item--${e.lines}-line` : void 0), j = k(() => ({
      isActive: b.value,
      select: u,
      isOpen: c.value,
      isSelected: d.value,
      isIndeterminate: f.value
    }));
    function I(R) {
      var J;
      i("click", R), S.value && ((J = l.navigate) == null || J.call(l, R), !h && (m.activatable.value ? s(!o.value, R) : (m.selectable.value || e.value != null) && u(!d.value, R)));
    }
    function Z(R) {
      (R.key === "Enter" || R.key === " ") && (R.preventDefault(), R.target.dispatchEvent(new MouseEvent("click", R)));
    }
    return ye(() => {
      const R = C.value ? "a" : e.tag, J = a.title || e.title != null, F = a.subtitle || e.subtitle != null, q = !!(e.appendAvatar || e.appendIcon), z = !!(q || a.append), E = !!(e.prependAvatar || e.prependIcon), Q = !!(E || a.prepend);
      return y == null || y.updateHasPrepend(Q), e.activeColor && jw("active-color", ["color", "base-color"]), Ct(p(R, {
        class: ["v-list-item", {
          "v-list-item--active": b.value,
          "v-list-item--disabled": e.disabled,
          "v-list-item--link": S.value,
          "v-list-item--nav": e.nav,
          "v-list-item--prepend": !Q && (y == null ? void 0 : y.hasPrepend.value),
          "v-list-item--slim": e.slim,
          [`${e.activeClass}`]: e.activeClass && b.value
        }, _.value, O.value, $.value, T.value, A.value, B.value, D.value, M.value, e.class],
        style: [P.value, L.value, e.style],
        href: l.href.value,
        tabindex: S.value ? y ? -2 : 0 : void 0,
        onClick: I,
        onKeydown: S.value && !C.value && Z
      }, {
        default: () => {
          var W;
          return [Bl(S.value || b.value, "v-list-item"), Q && p("div", {
            key: "prepend",
            class: "v-list-item__prepend"
          }, [a.prepend ? p(lt, {
            key: "prepend-defaults",
            disabled: !E,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.prependAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.prependIcon
              },
              VListItemAction: {
                start: !0
              }
            }
          }, {
            default: () => {
              var se;
              return [(se = a.prepend) == null ? void 0 : se.call(a, j.value)];
            }
          }) : p(ge, null, [e.prependAvatar && p(Da, {
            key: "prepend-avatar",
            density: e.density,
            image: e.prependAvatar
          }, null), e.prependIcon && p(vt, {
            key: "prepend-icon",
            density: e.density,
            icon: e.prependIcon
          }, null)]), p("div", {
            class: "v-list-item__spacer"
          }, null)]), p("div", {
            class: "v-list-item__content",
            "data-no-activator": ""
          }, [J && p(z3, {
            key: "title"
          }, {
            default: () => {
              var se;
              return [((se = a.title) == null ? void 0 : se.call(a, {
                title: e.title
              })) ?? e.title];
            }
          }), F && p(j3, {
            key: "subtitle"
          }, {
            default: () => {
              var se;
              return [((se = a.subtitle) == null ? void 0 : se.call(a, {
                subtitle: e.subtitle
              })) ?? e.subtitle];
            }
          }), (W = a.default) == null ? void 0 : W.call(a, j.value)]), z && p("div", {
            key: "append",
            class: "v-list-item__append"
          }, [a.append ? p(lt, {
            key: "append-defaults",
            disabled: !q,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.appendAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.appendIcon
              },
              VListItemAction: {
                end: !0
              }
            }
          }, {
            default: () => {
              var se;
              return [(se = a.append) == null ? void 0 : se.call(a, j.value)];
            }
          }) : p(ge, null, [e.appendIcon && p(vt, {
            key: "append-icon",
            density: e.density,
            icon: e.appendIcon
          }, null), e.appendAvatar && p(Da, {
            key: "append-avatar",
            density: e.density,
            image: e.appendAvatar
          }, null)]), p("div", {
            class: "v-list-item__spacer"
          }, null)])];
        }
      }), [[xa("ripple"), S.value && e.ripple]]);
    }), {
      activate: s,
      isActivated: o,
      isGroupActivator: h,
      isSelected: d,
      list: y,
      select: u
    };
  }
}), PP = le({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...Ae(),
  ...nt()
}, "VListSubheader"), F3 = ve()({
  name: "VListSubheader",
  props: PP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: a,
      textColorStyles: i
    } = zn(ue(e, "color"));
    return ye(() => {
      const l = !!(n.default || e.title);
      return p(e.tag, {
        class: ["v-list-subheader", {
          "v-list-subheader--inset": e.inset,
          "v-list-subheader--sticky": e.sticky
        }, a.value, e.class],
        style: [{
          textColorStyles: i
        }, e.style]
      }, {
        default: () => {
          var r;
          return [l && p("div", {
            class: "v-list-subheader__text"
          }, [((r = n.default) == null ? void 0 : r.call(n)) ?? e.title])];
        }
      });
    }), {};
  }
}), $P = le({
  color: String,
  inset: Boolean,
  length: [Number, String],
  opacity: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...Ae(),
  ...dt()
}, "VDivider"), Su = ve()({
  name: "VDivider",
  props: $P(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      themeClasses: i
    } = yt(e), {
      textColorClasses: l,
      textColorStyles: r
    } = zn(ue(e, "color")), s = k(() => {
      const o = {};
      return e.length && (o[e.vertical ? "height" : "width"] = Qe(e.length)), e.thickness && (o[e.vertical ? "borderRightWidth" : "borderTopWidth"] = Qe(e.thickness)), o;
    });
    return ye(() => {
      const o = p("hr", {
        class: [{
          "v-divider": !0,
          "v-divider--inset": e.inset,
          "v-divider--vertical": e.vertical
        }, i.value, l.value, e.class],
        style: [s.value, r.value, {
          "--v-border-opacity": e.opacity
        }, e.style],
        "aria-orientation": !n.role || n.role === "separator" ? e.vertical ? "vertical" : "horizontal" : void 0,
        role: `${n.role || "separator"}`
      }, null);
      return a.default ? p("div", {
        class: ["v-divider__wrapper", {
          "v-divider__wrapper--vertical": e.vertical,
          "v-divider__wrapper--inset": e.inset
        }]
      }, [o, p("div", {
        class: "v-divider__content"
      }, [a.default()]), o]) : o;
    }), {};
  }
}), _P = le({
  items: Array,
  returnObject: Boolean
}, "VListChildren"), X3 = ve()({
  name: "VListChildren",
  props: _P(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return R3(), () => {
      var a, i;
      return ((a = n.default) == null ? void 0 : a.call(n)) ?? ((i = e.items) == null ? void 0 : i.map((l) => {
        var f, h;
        let {
          children: r,
          props: s,
          type: o,
          raw: u
        } = l;
        if (o === "divider")
          return ((f = n.divider) == null ? void 0 : f.call(n, {
            props: s
          })) ?? p(Su, s, null);
        if (o === "subheader")
          return ((h = n.subheader) == null ? void 0 : h.call(n, {
            props: s
          })) ?? p(F3, s, null);
        const c = {
          subtitle: n.subtitle ? (m) => {
            var g;
            return (g = n.subtitle) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          prepend: n.prepend ? (m) => {
            var g;
            return (g = n.prepend) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          append: n.append ? (m) => {
            var g;
            return (g = n.append) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0,
          title: n.title ? (m) => {
            var g;
            return (g = n.title) == null ? void 0 : g.call(n, {
              ...m,
              item: u
            });
          } : void 0
        }, d = vh.filterProps(s);
        return r ? p(vh, fe({
          value: s == null ? void 0 : s.value
        }, d), {
          activator: (m) => {
            let {
              props: g
            } = m;
            const v = {
              ...s,
              ...g,
              value: e.returnObject ? u : s.value
            };
            return n.header ? n.header({
              props: v
            }) : p(Ui, v, c);
          },
          default: () => p(X3, {
            items: r,
            returnObject: e.returnObject
          }, n)
        }) : n.item ? n.item({
          props: s
        }) : p(Ui, fe(s, {
          value: e.returnObject ? u : s.value
        }), c);
      }));
    };
  }
}), Y3 = le({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean,
  valueComparator: {
    type: Function,
    default: Qi
  }
}, "list-items");
function pl(e, t) {
  const n = bn(t, e.itemTitle, t), a = bn(t, e.itemValue, n), i = bn(t, e.itemChildren), l = e.itemProps === !0 ? typeof t == "object" && t != null && !Array.isArray(t) ? "children" in t ? hn(t, ["children"]) : t : void 0 : bn(t, e.itemProps), r = {
    title: n,
    value: a,
    ...l
  };
  return {
    title: String(r.title ?? ""),
    value: r.value,
    props: r,
    children: Array.isArray(i) ? W3(e, i) : void 0,
    raw: t
  };
}
function W3(e, t) {
  const n = [];
  for (const a of t)
    n.push(pl(e, a));
  return n;
}
function R2(e) {
  const t = k(() => W3(e, e.items)), n = k(() => t.value.some((l) => l.value === null));
  function a(l) {
    return n.value || (l = l.filter((r) => r !== null)), l.map((r) => e.returnObject && typeof r == "string" ? pl(e, r) : t.value.find((s) => e.valueComparator(r, s.value)) || pl(e, r));
  }
  function i(l) {
    return e.returnObject ? l.map((r) => {
      let {
        raw: s
      } = r;
      return s;
    }) : l.map((r) => {
      let {
        value: s
      } = r;
      return s;
    });
  }
  return {
    items: t,
    transformIn: a,
    transformOut: i
  };
}
function MP(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean";
}
function VP(e, t) {
  const n = bn(t, e.itemType, "item"), a = MP(t) ? t : bn(t, e.itemTitle), i = bn(t, e.itemValue, void 0), l = bn(t, e.itemChildren), r = e.itemProps === !0 ? hn(t, ["children"]) : bn(t, e.itemProps), s = {
    title: a,
    value: i,
    ...r
  };
  return {
    type: n,
    title: s.title,
    value: s.value,
    props: s,
    children: n === "item" && l ? q3(e, l) : void 0,
    raw: t
  };
}
function q3(e, t) {
  const n = [];
  for (const a of t)
    n.push(VP(e, a));
  return n;
}
function TP(e) {
  return {
    items: k(() => q3(e, e.items))
  };
}
const LP = le({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  expandIcon: String,
  collapseIcon: String,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  slim: Boolean,
  nav: Boolean,
  "onClick:open": Rn(),
  "onClick:select": Rn(),
  "onUpdate:opened": Rn(),
  ...OP({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...vn(),
  ...Pn(),
  itemType: {
    type: String,
    default: "type"
  },
  ...Y3(),
  ...Dt(),
  ...nt(),
  ...dt(),
  ...Na({
    variant: "text"
  })
}, "VList"), Kd = ve()({
  name: "VList",
  props: LP(),
  emits: {
    "update:selected": (e) => !0,
    "update:activated": (e) => !0,
    "update:opened": (e) => !0,
    "click:open": (e) => !0,
    "click:activate": (e) => !0,
    "click:select": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: a
    } = TP(e), {
      themeClasses: i
    } = yt(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: r
    } = kt(ue(e, "bgColor")), {
      borderClasses: s
    } = _a(e), {
      densityClasses: o
    } = ea(e), {
      dimensionStyles: u
    } = gn(e), {
      elevationClasses: c
    } = Zn(e), {
      roundedClasses: d
    } = qt(e), {
      children: f,
      open: h,
      parents: m,
      select: g
    } = bP(e), v = k(() => e.lines ? `v-list--${e.lines}-line` : void 0), y = ue(e, "activeColor"), b = ue(e, "baseColor"), C = ue(e, "color");
    R3(), Yt({
      VListGroup: {
        activeColor: y,
        baseColor: b,
        color: C,
        expandIcon: ue(e, "expandIcon"),
        collapseIcon: ue(e, "collapseIcon")
      },
      VListItem: {
        activeClass: ue(e, "activeClass"),
        activeColor: y,
        baseColor: b,
        color: C,
        density: ue(e, "density"),
        disabled: ue(e, "disabled"),
        lines: ue(e, "lines"),
        nav: ue(e, "nav"),
        slim: ue(e, "slim"),
        variant: ue(e, "variant")
      }
    });
    const S = Ve(!1), x = Y();
    function w(M) {
      S.value = !0;
    }
    function V(M) {
      S.value = !1;
    }
    function _(M) {
      var T;
      !S.value && !(M.relatedTarget && ((T = x.value) != null && T.contains(M.relatedTarget))) && P();
    }
    function O(M) {
      const T = M.target;
      if (!(!x.value || ["INPUT", "TEXTAREA"].includes(T.tagName))) {
        if (M.key === "ArrowDown")
          P("next");
        else if (M.key === "ArrowUp")
          P("prev");
        else if (M.key === "Home")
          P("first");
        else if (M.key === "End")
          P("last");
        else
          return;
        M.preventDefault();
      }
    }
    function $(M) {
      S.value = !0;
    }
    function P(M) {
      if (x.value)
        return or(x.value, M);
    }
    return ye(() => p(e.tag, {
      ref: x,
      class: ["v-list", {
        "v-list--disabled": e.disabled,
        "v-list--nav": e.nav,
        "v-list--slim": e.slim
      }, i.value, l.value, s.value, o.value, c.value, v.value, d.value, e.class],
      style: [r.value, u.value, e.style],
      tabindex: e.disabled || S.value ? -1 : 0,
      role: "listbox",
      "aria-activedescendant": void 0,
      onFocusin: w,
      onFocusout: V,
      onFocus: _,
      onKeydown: O,
      onMousedown: $
    }, {
      default: () => [p(X3, {
        items: a.value,
        returnObject: e.returnObject
      }, n)]
    })), {
      open: h,
      select: g,
      focus: P,
      children: f,
      parents: m
    };
  }
}), QP = Di("v-list-img"), AP = le({
  start: Boolean,
  end: Boolean,
  ...Ae(),
  ...nt()
}, "VListItemAction"), DP = ve()({
  name: "VListItemAction",
  props: AP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => p(e.tag, {
      class: ["v-list-item-action", {
        "v-list-item-action--start": e.start,
        "v-list-item-action--end": e.end
      }, e.class],
      style: e.style
    }, n)), {};
  }
}), RP = le({
  start: Boolean,
  end: Boolean,
  ...Ae(),
  ...nt()
}, "VListItemMedia"), IP = ve()({
  name: "VListItemMedia",
  props: RP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => p(e.tag, {
      class: ["v-list-item-media", {
        "v-list-item-media--start": e.start,
        "v-list-item-media--end": e.end
      }, e.class],
      style: e.style
    }, n)), {};
  }
}), U3 = le({
  // TODO
  // disableKeys: Boolean,
  id: String,
  submenu: Boolean,
  ...hn(bu({
    closeDelay: 250,
    closeOnContentClick: !0,
    locationStrategy: "connected",
    location: void 0,
    openDelay: 300,
    scrim: !1,
    scrollStrategy: "reposition",
    transition: {
      component: zd
    }
  }), ["absolute"])
}, "VMenu"), ws = ve()({
  name: "VMenu",
  props: U3(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), {
      scopeId: i
    } = Rr(), {
      isRtl: l
    } = xn(), r = Bn(), s = k(() => e.id || `v-menu-${r}`), o = Y(), u = ct(ch, null), c = Ve(/* @__PURE__ */ new Set());
    Tt(ch, {
      register() {
        c.value.add(r);
      },
      unregister() {
        c.value.delete(r);
      },
      closeParents(v) {
        setTimeout(() => {
          var y;
          !c.value.size && !e.persistent && (v == null || (y = o.value) != null && y.contentEl && !Vw(v, o.value.contentEl)) && (a.value = !1, u == null || u.closeParents());
        }, 40);
      }
    }), mn(() => u == null ? void 0 : u.unregister()), q4(() => a.value = !1);
    async function d(v) {
      var C, S, x;
      const y = v.relatedTarget, b = v.target;
      await et(), a.value && y !== b && ((C = o.value) != null && C.contentEl) && // We're the topmost menu
      ((S = o.value) != null && S.globalTop) && // It isn't the document or the menu body
      ![document, o.value.contentEl].includes(b) && // It isn't inside the menu body
      !o.value.contentEl.contains(b) && ((x = Do(o.value.contentEl)[0]) == null || x.focus());
    }
    pe(a, (v) => {
      v ? (u == null || u.register(), document.addEventListener("focusin", d, {
        once: !0
      })) : (u == null || u.unregister(), document.removeEventListener("focusin", d));
    });
    function f(v) {
      u == null || u.closeParents(v);
    }
    function h(v) {
      var y, b, C, S, x;
      if (!e.disabled)
        if (v.key === "Tab" || v.key === "Enter" && !e.closeOnContentClick) {
          if (v.key === "Enter" && (v.target instanceof HTMLTextAreaElement || v.target instanceof HTMLInputElement && v.target.closest("form"))) return;
          v.key === "Enter" && v.preventDefault(), h5(Do((y = o.value) == null ? void 0 : y.contentEl, !1), v.shiftKey ? "prev" : "next", (V) => V.tabIndex >= 0) || (a.value = !1, (C = (b = o.value) == null ? void 0 : b.activatorEl) == null || C.focus());
        } else e.submenu && v.key === (l.value ? "ArrowRight" : "ArrowLeft") && (a.value = !1, (x = (S = o.value) == null ? void 0 : S.activatorEl) == null || x.focus());
    }
    function m(v) {
      var b;
      if (e.disabled) return;
      const y = (b = o.value) == null ? void 0 : b.contentEl;
      y && a.value ? v.key === "ArrowDown" ? (v.preventDefault(), v.stopImmediatePropagation(), or(y, "next")) : v.key === "ArrowUp" ? (v.preventDefault(), v.stopImmediatePropagation(), or(y, "prev")) : e.submenu && (v.key === (l.value ? "ArrowRight" : "ArrowLeft") ? a.value = !1 : v.key === (l.value ? "ArrowLeft" : "ArrowRight") && (v.preventDefault(), or(y, "first"))) : (e.submenu ? v.key === (l.value ? "ArrowLeft" : "ArrowRight") : ["ArrowDown", "ArrowUp"].includes(v.key)) && (a.value = !0, v.preventDefault(), setTimeout(() => setTimeout(() => m(v))));
    }
    const g = k(() => fe({
      "aria-haspopup": "menu",
      "aria-expanded": String(a.value),
      "aria-owns": s.value,
      onKeydown: m
    }, e.activatorProps));
    return ye(() => {
      const v = Ka.filterProps(e);
      return p(Ka, fe({
        ref: o,
        id: s.value,
        class: ["v-menu", e.class],
        style: e.style
      }, v, {
        modelValue: a.value,
        "onUpdate:modelValue": (y) => a.value = y,
        absolute: !0,
        activatorProps: g.value,
        location: e.location ?? (e.submenu ? "end" : "bottom"),
        "onClick:outside": f,
        onKeydown: h
      }, i), {
        activator: n.activator,
        default: function() {
          for (var y = arguments.length, b = new Array(y), C = 0; C < y; C++)
            b[C] = arguments[C];
          return p(lt, {
            root: "VMenu"
          }, {
            default: () => {
              var S;
              return [(S = n.default) == null ? void 0 : S.call(n, ...b)];
            }
          });
        }
      });
    }), Ea({
      id: s,
      ΨopenChildren: c
    }, o);
  }
}), BP = le({
  active: Boolean,
  disabled: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...Ae(),
  ...ai({
    transition: {
      component: M2
    }
  })
}, "VCounter"), Jd = ve()({
  name: "VCounter",
  functional: !0,
  props: BP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = k(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
    return ye(() => p(Kn, {
      transition: e.transition
    }, {
      default: () => [Ct(p("div", {
        class: ["v-counter", {
          "text-error": e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max)
        }, e.class],
        style: e.style
      }, [n.default ? n.default({
        counter: a.value,
        max: e.max,
        value: e.value
      }) : a.value]), [[Dn, e.active]])]
    })), {};
  }
}), ZP = le({
  floating: Boolean,
  ...Ae()
}, "VFieldLabel"), go = ve()({
  name: "VFieldLabel",
  props: ZP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => p(Us, {
      class: ["v-field-label", {
        "v-field-label--floating": e.floating
      }, e.class],
      style: e.style,
      "aria-hidden": e.floating || void 0
    }, n)), {};
  }
}), EP = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], xu = le({
  appendInnerIcon: Ue,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: Ue,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  flat: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: Ue,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (e) => EP.includes(e)
  },
  "onClick:clear": Rn(),
  "onClick:appendInner": Rn(),
  "onClick:prependInner": Rn(),
  ...Ae(),
  ...Wd(),
  ...Dt(),
  ...dt()
}, "VField"), Ks = ve()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    ...ku(),
    ...xu()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: i
    } = t;
    const {
      themeClasses: l
    } = yt(e), {
      loaderClasses: r
    } = Cu(e), {
      focusClasses: s,
      isFocused: o,
      focus: u,
      blur: c
    } = il(e), {
      InputIcon: d
    } = $3(e), {
      roundedClasses: f
    } = qt(e), {
      rtlClasses: h
    } = xn(), m = k(() => e.dirty || e.active), g = k(() => !e.singleLine && !!(e.label || i.label)), v = Bn(), y = k(() => e.id || `input-${v}`), b = k(() => `${y.value}-messages`), C = Y(), S = Y(), x = Y(), w = k(() => ["plain", "underlined"].includes(e.variant)), {
      backgroundColorClasses: V,
      backgroundColorStyles: _
    } = kt(ue(e, "bgColor")), {
      textColorClasses: O,
      textColorStyles: $
    } = zn(k(() => e.error || e.disabled ? void 0 : m.value && o.value ? e.color : e.baseColor));
    pe(m, (L) => {
      if (g.value) {
        const A = C.value.$el, D = S.value.$el;
        requestAnimationFrame(() => {
          const B = f2(A), j = D.getBoundingClientRect(), I = j.x - B.x, Z = j.y - B.y - (B.height / 2 - j.height / 2), R = j.width / 0.75, J = Math.abs(R - B.width) > 1 ? {
            maxWidth: Qe(R)
          } : void 0, F = getComputedStyle(A), q = getComputedStyle(D), z = parseFloat(F.transitionDuration) * 1e3 || 150, E = parseFloat(q.getPropertyValue("--v-field-label-scale")), Q = q.getPropertyValue("color");
          A.style.visibility = "visible", D.style.visibility = "hidden", tr(A, {
            transform: `translate(${I}px, ${Z}px) scale(${E})`,
            color: Q,
            ...J
          }, {
            duration: z,
            easing: Ro,
            direction: L ? "normal" : "reverse"
          }).finished.then(() => {
            A.style.removeProperty("visibility"), D.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const P = k(() => ({
      isActive: m,
      isFocused: o,
      controlRef: x,
      blur: c,
      focus: u
    }));
    function M(L) {
      L.target !== document.activeElement && L.preventDefault();
    }
    function T(L) {
      var A;
      L.key !== "Enter" && L.key !== " " || (L.preventDefault(), L.stopPropagation(), (A = e["onClick:clear"]) == null || A.call(e, new MouseEvent("click")));
    }
    return ye(() => {
      var I, Z, R;
      const L = e.variant === "outlined", A = !!(i["prepend-inner"] || e.prependInnerIcon), D = !!(e.clearable || i.clear), B = !!(i["append-inner"] || e.appendInnerIcon || D), j = () => i.label ? i.label({
        ...P.value,
        label: e.label,
        props: {
          for: y.value
        }
      }) : e.label;
      return p("div", fe({
        class: ["v-field", {
          "v-field--active": m.value,
          "v-field--appended": B,
          "v-field--center-affix": e.centerAffix ?? !w.value,
          "v-field--disabled": e.disabled,
          "v-field--dirty": e.dirty,
          "v-field--error": e.error,
          "v-field--flat": e.flat,
          "v-field--has-background": !!e.bgColor,
          "v-field--persistent-clear": e.persistentClear,
          "v-field--prepended": A,
          "v-field--reverse": e.reverse,
          "v-field--single-line": e.singleLine,
          "v-field--no-label": !j(),
          [`v-field--variant-${e.variant}`]: !0
        }, l.value, V.value, s.value, r.value, f.value, h.value, e.class],
        style: [_.value, e.style],
        onClick: M
      }, n), [p("div", {
        class: "v-field__overlay"
      }, null), p(wu, {
        name: "v-field",
        active: !!e.loading,
        color: e.error ? "error" : typeof e.loading == "string" ? e.loading : e.color
      }, {
        default: i.loader
      }), A && p("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [e.prependInnerIcon && p(d, {
        key: "prepend-icon",
        name: "prependInner"
      }, null), (I = i["prepend-inner"]) == null ? void 0 : I.call(i, P.value)]), p("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && g.value && p(go, {
        key: "floating-label",
        ref: S,
        class: [O.value],
        floating: !0,
        for: y.value,
        style: $.value
      }, {
        default: () => [j()]
      }), p(go, {
        ref: C,
        for: y.value
      }, {
        default: () => [j()]
      }), (Z = i.default) == null ? void 0 : Z.call(i, {
        ...P.value,
        props: {
          id: y.value,
          class: "v-field__input",
          "aria-describedby": b.value
        },
        focus: u,
        blur: c
      })]), D && p(V2, {
        key: "clear"
      }, {
        default: () => [Ct(p("div", {
          class: "v-field__clearable",
          onMousedown: (J) => {
            J.preventDefault(), J.stopPropagation();
          }
        }, [p(lt, {
          defaults: {
            VIcon: {
              icon: e.clearIcon
            }
          }
        }, {
          default: () => [i.clear ? i.clear({
            ...P.value,
            props: {
              onKeydown: T,
              onFocus: u,
              onBlur: c,
              onClick: e["onClick:clear"]
            }
          }) : p(d, {
            name: "clear",
            onKeydown: T,
            onFocus: u,
            onBlur: c
          }, null)]
        })]), [[Dn, e.dirty]])]
      }), B && p("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [(R = i["append-inner"]) == null ? void 0 : R.call(i, P.value), e.appendInnerIcon && p(d, {
        key: "append-icon",
        name: "appendInner"
      }, null)]), p("div", {
        class: ["v-field__outline", O.value],
        style: $.value
      }, [L && p(ge, null, [p("div", {
        class: "v-field__outline__start"
      }, null), g.value && p("div", {
        class: "v-field__outline__notch"
      }, [p(go, {
        ref: S,
        floating: !0,
        for: y.value
      }, {
        default: () => [j()]
      })]), p("div", {
        class: "v-field__outline__end"
      }, null)]), w.value && g.value && p(go, {
        ref: S,
        floating: !0,
        for: y.value
      }, {
        default: () => [j()]
      })])]);
    }), {
      controlRef: x
    };
  }
});
function I2(e) {
  const t = Object.keys(Ks.props).filter((n) => !Bd(n) && n !== "class" && n !== "style");
  return u2(e, t);
}
const NP = ["color", "file", "time", "date", "datetime-local", "week", "month"], e1 = le({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...ll(),
  ...xu()
}, "VTextField"), pr = ve()({
  name: "VTextField",
  directives: {
    Intersect: pu
  },
  inheritAttrs: !1,
  props: e1(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: i
    } = t;
    const l = Fe(e, "modelValue"), {
      isFocused: r,
      focus: s,
      blur: o
    } = il(e), u = k(() => typeof e.counterValue == "function" ? e.counterValue(l.value) : typeof e.counterValue == "number" ? e.counterValue : (l.value ?? "").toString().length), c = k(() => {
      if (n.maxlength) return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    }), d = k(() => ["plain", "underlined"].includes(e.variant));
    function f(w, V) {
      var _, O;
      !e.autofocus || !w || (O = (_ = V[0].target) == null ? void 0 : _.focus) == null || O.call(_);
    }
    const h = Y(), m = Y(), g = Y(), v = k(() => NP.includes(e.type) || e.persistentPlaceholder || r.value || e.active);
    function y() {
      var w;
      g.value !== document.activeElement && ((w = g.value) == null || w.focus()), r.value || s();
    }
    function b(w) {
      a("mousedown:control", w), w.target !== g.value && (y(), w.preventDefault());
    }
    function C(w) {
      y(), a("click:control", w);
    }
    function S(w) {
      w.stopPropagation(), y(), et(() => {
        l.value = null, d2(e["onClick:clear"], w);
      });
    }
    function x(w) {
      var _;
      const V = w.target;
      if (l.value = V.value, (_ = e.modelModifiers) != null && _.trim && ["text", "search", "password", "tel", "url"].includes(e.type)) {
        const O = [V.selectionStart, V.selectionEnd];
        et(() => {
          V.selectionStart = O[0], V.selectionEnd = O[1];
        });
      }
    }
    return ye(() => {
      const w = !!(i.counter || e.counter !== !1 && e.counter != null), V = !!(w || i.details), [_, O] = Il(n), {
        modelValue: $,
        ...P
      } = Fn.filterProps(e), M = I2(e);
      return p(Fn, fe({
        ref: h,
        modelValue: l.value,
        "onUpdate:modelValue": (T) => l.value = T,
        class: ["v-text-field", {
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-input--plain-underlined": d.value
        }, e.class],
        style: e.style
      }, _, P, {
        centerAffix: !d.value,
        focused: r.value
      }), {
        ...i,
        default: (T) => {
          let {
            id: L,
            isDisabled: A,
            isDirty: D,
            isReadonly: B,
            isValid: j
          } = T;
          return p(Ks, fe({
            ref: m,
            onMousedown: b,
            onClick: C,
            "onClick:clear": S,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"],
            role: e.role
          }, M, {
            id: L.value,
            active: v.value || D.value,
            dirty: D.value || e.dirty,
            disabled: A.value,
            focused: r.value,
            error: j.value === !1
          }), {
            ...i,
            default: (I) => {
              let {
                props: {
                  class: Z,
                  ...R
                }
              } = I;
              const J = Ct(p("input", fe({
                ref: g,
                value: l.value,
                onInput: x,
                autofocus: e.autofocus,
                readonly: B.value,
                disabled: A.value,
                name: e.name,
                placeholder: e.placeholder,
                size: 1,
                type: e.type,
                onFocus: y,
                onBlur: o
              }, R, O), null), [[xa("intersect"), {
                handler: f
              }, null, {
                once: !0
              }]]);
              return p(ge, null, [e.prefix && p("span", {
                class: "v-text-field__prefix"
              }, [p("span", {
                class: "v-text-field__prefix__text"
              }, [e.prefix])]), i.default ? p("div", {
                class: Z,
                "data-no-activator": ""
              }, [i.default(), J]) : RC(J, {
                class: Z
              }), e.suffix && p("span", {
                class: "v-text-field__suffix"
              }, [p("span", {
                class: "v-text-field__suffix__text"
              }, [e.suffix])])]);
            }
          });
        },
        details: V ? (T) => {
          var L;
          return p(ge, null, [(L = i.details) == null ? void 0 : L.call(i, T), w && p(ge, null, [p("span", null, null), p(Jd, {
            active: e.persistentCounter || r.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, i.counter)])]);
        } : void 0
      });
    }), Ea({}, h, m, g);
  }
}), HP = le({
  renderless: Boolean,
  ...Ae()
}, "VVirtualScrollItem"), G3 = ve()({
  name: "VVirtualScrollItem",
  inheritAttrs: !1,
  props: HP(),
  emits: {
    "update:height": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: i
    } = t;
    const {
      resizeRef: l,
      contentRect: r
    } = Ga(void 0, "border");
    pe(() => {
      var s;
      return (s = r.value) == null ? void 0 : s.height;
    }, (s) => {
      s != null && a("update:height", s);
    }), ye(() => {
      var s, o;
      return e.renderless ? p(ge, null, [(s = i.default) == null ? void 0 : s.call(i, {
        itemRef: l
      })]) : p("div", fe({
        ref: l,
        class: ["v-virtual-scroll__item", e.class],
        style: e.style
      }, n), [(o = i.default) == null ? void 0 : o.call(i)]);
    });
  }
}), jP = -1, zP = 1, ef = 100, K3 = le({
  itemHeight: {
    type: [Number, String],
    default: null
  },
  height: [Number, String]
}, "virtual");
function J3(e, t) {
  const n = Za(), a = Ve(0);
  jt(() => {
    a.value = parseFloat(e.itemHeight || 0);
  });
  const i = Ve(0), l = Ve(Math.ceil(
    // Assume 16px items filling the entire screen height if
    // not provided. This is probably incorrect but it minimises
    // the chance of ending up with empty space at the bottom.
    // The default value is set here to avoid poisoning getSize()
    (parseInt(e.height) || n.height.value) / (a.value || 16)
  ) || 1), r = Ve(0), s = Ve(0), o = Y(), u = Y();
  let c = 0;
  const {
    resizeRef: d,
    contentRect: f
  } = Ga();
  jt(() => {
    d.value = o.value;
  });
  const h = k(() => {
    var I;
    return o.value === document.documentElement ? n.height.value : ((I = f.value) == null ? void 0 : I.height) || parseInt(e.height) || 0;
  }), m = k(() => !!(o.value && u.value && h.value && a.value));
  let g = Array.from({
    length: t.value.length
  }), v = Array.from({
    length: t.value.length
  });
  const y = Ve(0);
  let b = -1;
  function C(I) {
    return g[I] || a.value;
  }
  const S = xw(() => {
    const I = performance.now();
    v[0] = 0;
    const Z = t.value.length;
    for (let R = 1; R <= Z - 1; R++)
      v[R] = (v[R - 1] || 0) + C(R - 1);
    y.value = Math.max(y.value, performance.now() - I);
  }, y), x = pe(m, (I) => {
    I && (x(), c = u.value.offsetTop, S.immediate(), A(), ~b && et(() => {
      bt && window.requestAnimationFrame(() => {
        B(b), b = -1;
      });
    }));
  });
  Xn(() => {
    S.clear();
  });
  function w(I, Z) {
    const R = g[I], J = a.value;
    a.value = J ? Math.min(a.value, Z) : Z, (R !== Z || J !== a.value) && (g[I] = Z, S());
  }
  function V(I) {
    return I = ln(I, 0, t.value.length - 1), v[I] || 0;
  }
  function _(I) {
    return FP(v, I);
  }
  let O = 0, $ = 0, P = 0;
  pe(h, (I, Z) => {
    Z && (A(), I < Z && requestAnimationFrame(() => {
      $ = 0, A();
    }));
  });
  function M() {
    if (!o.value || !u.value) return;
    const I = o.value.scrollTop, Z = performance.now();
    Z - P > 500 ? ($ = Math.sign(I - O), c = u.value.offsetTop) : $ = I - O, O = I, P = Z, A();
  }
  function T() {
    !o.value || !u.value || ($ = 0, P = 0, A());
  }
  let L = -1;
  function A() {
    cancelAnimationFrame(L), L = requestAnimationFrame(D);
  }
  function D() {
    if (!o.value || !h.value) return;
    const I = O - c, Z = Math.sign($), R = Math.max(0, I - ef), J = ln(_(R), 0, t.value.length), F = I + h.value + ef, q = ln(_(F) + 1, J + 1, t.value.length);
    if (
      // Only update the side we're scrolling towards,
      // the other side will be updated incidentally
      (Z !== jP || J < i.value) && (Z !== zP || q > l.value)
    ) {
      const z = V(i.value) - V(J), E = V(q) - V(l.value);
      Math.max(z, E) > ef ? (i.value = J, l.value = q) : (J <= 0 && (i.value = J), q >= t.value.length && (l.value = q));
    }
    r.value = V(i.value), s.value = V(t.value.length) - V(l.value);
  }
  function B(I) {
    const Z = V(I);
    !o.value || I && !Z ? b = I : o.value.scrollTop = Z;
  }
  const j = k(() => t.value.slice(i.value, l.value).map((I, Z) => ({
    raw: I,
    index: Z + i.value
  })));
  return pe(t, () => {
    g = Array.from({
      length: t.value.length
    }), v = Array.from({
      length: t.value.length
    }), S.immediate(), A();
  }, {
    deep: !0
  }), {
    calculateVisibleItems: A,
    containerRef: o,
    markerRef: u,
    computedItems: j,
    paddingTop: r,
    paddingBottom: s,
    scrollToIndex: B,
    handleScroll: M,
    handleScrollend: T,
    handleItemResize: w
  };
}
function FP(e, t) {
  let n = e.length - 1, a = 0, i = 0, l = null, r = -1;
  if (e[n] < t)
    return n;
  for (; a <= n; )
    if (i = a + n >> 1, l = e[i], l > t)
      n = i - 1;
    else if (l < t)
      r = i, a = i + 1;
    else return l === t ? i : a;
  return r;
}
const XP = le({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...K3(),
  ...Ae(),
  ...vn()
}, "VVirtualScroll"), t1 = ve()({
  name: "VVirtualScroll",
  props: XP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Wt("VVirtualScroll"), {
      dimensionStyles: i
    } = gn(e), {
      calculateVisibleItems: l,
      containerRef: r,
      markerRef: s,
      handleScroll: o,
      handleScrollend: u,
      handleItemResize: c,
      scrollToIndex: d,
      paddingTop: f,
      paddingBottom: h,
      computedItems: m
    } = J3(e, ue(e, "items"));
    return la(() => e.renderless, () => {
      function g() {
        var b, C;
        const y = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? "addEventListener" : "removeEventListener";
        r.value === document.documentElement ? (document[y]("scroll", o, {
          passive: !0
        }), document[y]("scrollend", u)) : ((b = r.value) == null || b[y]("scroll", o, {
          passive: !0
        }), (C = r.value) == null || C[y]("scrollend", u));
      }
      rt(() => {
        r.value = g2(a.vnode.el, !0), g(!0);
      }), Xn(g);
    }), ye(() => {
      const g = m.value.map((v) => p(G3, {
        key: v.index,
        renderless: e.renderless,
        "onUpdate:height": (y) => c(v.index, y)
      }, {
        default: (y) => {
          var b;
          return (b = n.default) == null ? void 0 : b.call(n, {
            item: v.raw,
            index: v.index,
            ...y
          });
        }
      }));
      return e.renderless ? p(ge, null, [p("div", {
        ref: s,
        class: "v-virtual-scroll__spacer",
        style: {
          paddingTop: Qe(f.value)
        }
      }, null), g, p("div", {
        class: "v-virtual-scroll__spacer",
        style: {
          paddingBottom: Qe(h.value)
        }
      }, null)]) : p("div", {
        ref: r,
        class: ["v-virtual-scroll", e.class],
        onScrollPassive: o,
        onScrollend: u,
        style: [i.value, e.style]
      }, [p("div", {
        ref: s,
        class: "v-virtual-scroll__container",
        style: {
          paddingTop: Qe(f.value),
          paddingBottom: Qe(h.value)
        }
      }, [g])]);
    }), {
      calculateVisibleItems: l,
      scrollToIndex: d
    };
  }
});
function B2(e, t) {
  const n = Ve(!1);
  let a;
  function i(s) {
    cancelAnimationFrame(a), n.value = !0, a = requestAnimationFrame(() => {
      a = requestAnimationFrame(() => {
        n.value = !1;
      });
    });
  }
  async function l() {
    await new Promise((s) => requestAnimationFrame(s)), await new Promise((s) => requestAnimationFrame(s)), await new Promise((s) => requestAnimationFrame(s)), await new Promise((s) => {
      if (n.value) {
        const o = pe(n, () => {
          o(), s();
        });
      } else s();
    });
  }
  async function r(s) {
    var c, d;
    if (s.key === "Tab" && ((c = t.value) == null || c.focus()), !["PageDown", "PageUp", "Home", "End"].includes(s.key)) return;
    const o = (d = e.value) == null ? void 0 : d.$el;
    if (!o) return;
    (s.key === "Home" || s.key === "End") && o.scrollTo({
      top: s.key === "Home" ? 0 : o.scrollHeight,
      behavior: "smooth"
    }), await l();
    const u = o.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (s.key === "PageDown" || s.key === "Home") {
      const f = o.getBoundingClientRect().top;
      for (const h of u)
        if (h.getBoundingClientRect().top >= f) {
          h.focus();
          break;
        }
    } else {
      const f = o.getBoundingClientRect().bottom;
      for (const h of [...u].reverse())
        if (h.getBoundingClientRect().bottom <= f) {
          h.focus();
          break;
        }
    }
  }
  return {
    onScrollPassive: i,
    onKeydown: r
  };
}
const Z2 = le({
  chips: Boolean,
  closableChips: Boolean,
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  },
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  listProps: {
    type: Object
  },
  menu: Boolean,
  menuIcon: {
    type: Ue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  ...Y3({
    itemChildren: !1
  })
}, "Select"), YP = le({
  ...Z2(),
  ...hn(e1({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...ai({
    transition: {
      component: zd
    }
  })
}, "VSelect"), E2 = ve()({
  name: "VSelect",
  props: YP(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = tn(), i = Y(), l = Y(), r = Y(), s = Fe(e, "menu"), o = k({
      get: () => s.value,
      set: (I) => {
        var Z;
        s.value && !I && ((Z = l.value) != null && Z.ΨopenChildren.size) || (s.value = I);
      }
    }), {
      items: u,
      transformIn: c,
      transformOut: d
    } = R2(e), f = Fe(e, "modelValue", [], (I) => c(I === null ? [null] : Ht(I)), (I) => {
      const Z = d(I);
      return e.multiple ? Z : Z[0] ?? null;
    }), h = k(() => typeof e.counterValue == "function" ? e.counterValue(f.value) : typeof e.counterValue == "number" ? e.counterValue : f.value.length), m = Gd(), g = k(() => f.value.map((I) => I.value)), v = Ve(!1), y = k(() => o.value ? e.closeText : e.openText);
    let b = "", C;
    const S = k(() => e.hideSelected ? u.value.filter((I) => !f.value.some((Z) => e.valueComparator(Z, I))) : u.value), x = k(() => e.hideNoData && !S.value.length || e.readonly || (m == null ? void 0 : m.isReadonly.value)), w = k(() => {
      var I;
      return {
        ...e.menuProps,
        activatorProps: {
          ...((I = e.menuProps) == null ? void 0 : I.activatorProps) || {},
          "aria-haspopup": "listbox"
          // Set aria-haspopup to 'listbox'
        }
      };
    }), V = Y(), _ = B2(V, i);
    function O(I) {
      e.openOnClear && (o.value = !0);
    }
    function $() {
      x.value || (o.value = !o.value);
    }
    function P(I) {
      zc(I) && M(I);
    }
    function M(I) {
      var F, q;
      if (!I.key || e.readonly || m != null && m.isReadonly.value) return;
      ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(I.key) && I.preventDefault(), ["Enter", "ArrowDown", " "].includes(I.key) && (o.value = !0), ["Escape", "Tab"].includes(I.key) && (o.value = !1), I.key === "Home" ? (F = V.value) == null || F.focus("first") : I.key === "End" && ((q = V.value) == null || q.focus("last"));
      const Z = 1e3;
      if (e.multiple || !zc(I)) return;
      const R = performance.now();
      R - C > Z && (b = ""), b += I.key.toLowerCase(), C = R;
      const J = u.value.find((z) => z.title.toLowerCase().startsWith(b));
      if (J !== void 0) {
        f.value = [J];
        const z = S.value.indexOf(J);
        bt && window.requestAnimationFrame(() => {
          var E;
          z >= 0 && ((E = r.value) == null || E.scrollToIndex(z));
        });
      }
    }
    function T(I) {
      let Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!I.props.disabled)
        if (e.multiple) {
          const R = f.value.findIndex((F) => e.valueComparator(F.value, I.value)), J = Z ?? !~R;
          if (~R) {
            const F = J ? [...f.value, I] : [...f.value];
            F.splice(R, 1), f.value = F;
          } else J && (f.value = [...f.value, I]);
        } else {
          const R = Z !== !1;
          f.value = R ? [I] : [], et(() => {
            o.value = !1;
          });
        }
    }
    function L(I) {
      var Z;
      (Z = V.value) != null && Z.$el.contains(I.relatedTarget) || (o.value = !1);
    }
    function A() {
      var I;
      e.eager && ((I = r.value) == null || I.calculateVisibleItems());
    }
    function D() {
      var I;
      v.value && ((I = i.value) == null || I.focus());
    }
    function B(I) {
      v.value = !0;
    }
    function j(I) {
      if (I == null) f.value = [];
      else if (ys(i.value, ":autofill") || ys(i.value, ":-webkit-autofill")) {
        const Z = u.value.find((R) => R.title === I);
        Z && T(Z);
      } else i.value && (i.value.value = "");
    }
    return pe(o, () => {
      if (!e.hideSelected && o.value && f.value.length) {
        const I = S.value.findIndex((Z) => f.value.some((R) => e.valueComparator(R.value, Z.value)));
        bt && window.requestAnimationFrame(() => {
          var Z;
          I >= 0 && ((Z = r.value) == null || Z.scrollToIndex(I));
        });
      }
    }), pe(() => e.items, (I, Z) => {
      o.value || v.value && !Z.length && I.length && (o.value = !0);
    }), ye(() => {
      const I = !!(e.chips || n.chip), Z = !!(!e.hideNoData || S.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), R = f.value.length > 0, J = pr.filterProps(e), F = R || !v.value && e.label && !e.persistentPlaceholder ? void 0 : e.placeholder;
      return p(pr, fe({
        ref: i
      }, J, {
        modelValue: f.value.map((q) => q.props.value).join(", "),
        "onUpdate:modelValue": j,
        focused: v.value,
        "onUpdate:focused": (q) => v.value = q,
        validationValue: f.externalValue,
        counterValue: h.value,
        dirty: R,
        class: ["v-select", {
          "v-select--active-menu": o.value,
          "v-select--chips": !!e.chips,
          [`v-select--${e.multiple ? "multiple" : "single"}`]: !0,
          "v-select--selected": f.value.length,
          "v-select--selection-slot": !!n.selection
        }, e.class],
        style: e.style,
        inputmode: "none",
        placeholder: F,
        "onClick:clear": O,
        "onMousedown:control": $,
        onBlur: L,
        onKeydown: M,
        "aria-label": a(y.value),
        title: a(y.value)
      }), {
        ...n,
        default: () => p(ge, null, [p(ws, fe({
          ref: l,
          modelValue: o.value,
          "onUpdate:modelValue": (q) => o.value = q,
          activator: "parent",
          contentClass: "v-select__content",
          disabled: x.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: A,
          onAfterLeave: D
        }, w.value), {
          default: () => [Z && p(Kd, fe({
            ref: V,
            selected: g.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (q) => q.preventDefault(),
            onKeydown: P,
            onFocusin: B,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, _, e.listProps), {
            default: () => {
              var q, z, E;
              return [(q = n["prepend-item"]) == null ? void 0 : q.call(n), !S.value.length && !e.hideNoData && (((z = n["no-data"]) == null ? void 0 : z.call(n)) ?? p(Ui, {
                title: a(e.noDataText)
              }, null)), p(t1, {
                ref: r,
                renderless: !0,
                items: S.value
              }, {
                default: (Q) => {
                  var ne;
                  let {
                    item: W,
                    index: se,
                    itemRef: Se
                  } = Q;
                  const U = fe(W.props, {
                    ref: Se,
                    key: se,
                    onClick: () => T(W, null)
                  });
                  return ((ne = n.item) == null ? void 0 : ne.call(n, {
                    item: W,
                    index: se,
                    props: U
                  })) ?? p(Ui, fe(U, {
                    role: "option"
                  }), {
                    prepend: (K) => {
                      let {
                        isSelected: te
                      } = K;
                      return p(ge, null, [e.multiple && !e.hideSelected ? p(qi, {
                        key: W.value,
                        modelValue: te,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, W.props.prependAvatar && p(Da, {
                        image: W.props.prependAvatar
                      }, null), W.props.prependIcon && p(vt, {
                        icon: W.props.prependIcon
                      }, null)]);
                    }
                  });
                }
              }), (E = n["append-item"]) == null ? void 0 : E.call(n)];
            }
          })]
        }), f.value.map((q, z) => {
          function E(Se) {
            Se.stopPropagation(), Se.preventDefault(), T(q, !1);
          }
          const Q = {
            "onClick:close": E,
            onKeydown(Se) {
              Se.key !== "Enter" && Se.key !== " " || (Se.preventDefault(), Se.stopPropagation(), E(Se));
            },
            onMousedown(Se) {
              Se.preventDefault(), Se.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, W = I ? !!n.chip : !!n.selection, se = W ? Zd(I ? n.chip({
            item: q,
            index: z,
            props: Q
          }) : n.selection({
            item: q,
            index: z
          })) : void 0;
          if (!(W && !se))
            return p("div", {
              key: q.value,
              class: "v-select__selection"
            }, [I ? n.chip ? p(lt, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: q.title
                }
              }
            }, {
              default: () => [se]
            }) : p(Gs, fe({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: q.title,
              disabled: q.props.disabled
            }, Q), null) : se ?? p("span", {
              class: "v-select__selection-text"
            }, [q.title, e.multiple && z < f.value.length - 1 && p("span", {
              class: "v-select__selection-comma"
            }, [Ee(",")])])]);
        })]),
        "append-inner": function() {
          var Q;
          for (var q = arguments.length, z = new Array(q), E = 0; E < q; E++)
            z[E] = arguments[E];
          return p(ge, null, [(Q = n["append-inner"]) == null ? void 0 : Q.call(n, ...z), e.menuIcon ? p(vt, {
            class: "v-select__menu-icon",
            icon: e.menuIcon
          }, null) : void 0]);
        }
      });
    }), Ea({
      isFocused: v,
      menu: o,
      select: T
    }, i);
  }
}), WP = (e, t, n) => e == null || t == null ? -1 : e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase()), Pu = le({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function qP(e, t, n) {
  var s;
  const a = [], i = (n == null ? void 0 : n.default) ?? WP, l = n != null && n.filterKeys ? Ht(n.filterKeys) : !1, r = Object.keys((n == null ? void 0 : n.customKeyFilter) ?? {}).length;
  if (!(e != null && e.length)) return a;
  e: for (let o = 0; o < e.length; o++) {
    const [u, c = u] = Ht(e[o]), d = {}, f = {};
    let h = -1;
    if ((t || r > 0) && !(n != null && n.noFilter)) {
      if (typeof u == "object") {
        const v = l || Object.keys(c);
        for (const y of v) {
          const b = bn(c, y), C = (s = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : s[y];
          if (h = C ? C(b, t, u) : i(b, t, u), h !== -1 && h !== !1)
            C ? d[y] = h : f[y] = h;
          else if ((n == null ? void 0 : n.filterMode) === "every")
            continue e;
        }
      } else
        h = i(u, t, u), h !== -1 && h !== !1 && (f.title = h);
      const m = Object.keys(f).length, g = Object.keys(d).length;
      if (!m && !g || (n == null ? void 0 : n.filterMode) === "union" && g !== r && !m || (n == null ? void 0 : n.filterMode) === "intersection" && (g !== r || !m)) continue;
    }
    a.push({
      index: o,
      matches: {
        ...f,
        ...d
      }
    });
  }
  return a;
}
function $u(e, t, n, a) {
  const i = Y([]), l = Y(/* @__PURE__ */ new Map()), r = k(() => a != null && a.transform ? X(t).map((o) => [o, a.transform(o)]) : X(t));
  jt(() => {
    const o = typeof n == "function" ? n() : X(n), u = typeof o != "string" && typeof o != "number" ? "" : String(o), c = qP(r.value, u, {
      customKeyFilter: {
        ...e.customKeyFilter,
        ...X(a == null ? void 0 : a.customKeyFilter)
      },
      default: e.customFilter,
      filterKeys: e.filterKeys,
      filterMode: e.filterMode,
      noFilter: e.noFilter
    }), d = X(t), f = [], h = /* @__PURE__ */ new Map();
    c.forEach((m) => {
      let {
        index: g,
        matches: v
      } = m;
      const y = d[g];
      f.push(y), h.set(y.value, v);
    }), i.value = f, l.value = h;
  });
  function s(o) {
    return l.value.get(o.value);
  }
  return {
    filteredItems: i,
    filteredMatches: l,
    getMatches: s
  };
}
function UP(e, t, n) {
  if (t == null) return e;
  if (Array.isArray(t)) throw new Error("Multiple matches is not implemented");
  return typeof t == "number" && ~t ? p(ge, null, [p("span", {
    class: "v-autocomplete__unmask"
  }, [e.substr(0, t)]), p("span", {
    class: "v-autocomplete__mask"
  }, [e.substr(t, n)]), p("span", {
    class: "v-autocomplete__unmask"
  }, [e.substr(t + n)])]) : e;
}
const GP = le({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...Pu({
    filterKeys: ["title"]
  }),
  ...Z2(),
  ...hn(e1({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...ai({
    transition: !1
  })
}, "VAutocomplete"), KP = ve()({
  name: "VAutocomplete",
  props: GP(),
  emits: {
    "update:focused": (e) => !0,
    "update:search": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = tn(), i = Y(), l = Ve(!1), r = Ve(!0), s = Ve(!1), o = Y(), u = Y(), c = Fe(e, "menu"), d = k({
      get: () => c.value,
      set: (U) => {
        var ne;
        c.value && !U && ((ne = o.value) != null && ne.ΨopenChildren.size) || (c.value = U);
      }
    }), f = Ve(-1), h = k(() => {
      var U;
      return (U = i.value) == null ? void 0 : U.color;
    }), m = k(() => d.value ? e.closeText : e.openText), {
      items: g,
      transformIn: v,
      transformOut: y
    } = R2(e), {
      textColorClasses: b,
      textColorStyles: C
    } = zn(h), S = Fe(e, "search", ""), x = Fe(e, "modelValue", [], (U) => v(U === null ? [null] : Ht(U)), (U) => {
      const ne = y(U);
      return e.multiple ? ne : ne[0] ?? null;
    }), w = k(() => typeof e.counterValue == "function" ? e.counterValue(x.value) : typeof e.counterValue == "number" ? e.counterValue : x.value.length), V = Gd(), {
      filteredItems: _,
      getMatches: O
    } = $u(e, g, () => r.value ? "" : S.value), $ = k(() => e.hideSelected ? _.value.filter((U) => !x.value.some((ne) => ne.value === U.value)) : _.value), P = k(() => !!(e.chips || n.chip)), M = k(() => P.value || !!n.selection), T = k(() => x.value.map((U) => U.props.value)), L = k(() => {
      var ne;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && S.value === ((ne = $.value[0]) == null ? void 0 : ne.title)) && $.value.length > 0 && !r.value && !s.value;
    }), A = k(() => e.hideNoData && !$.value.length || e.readonly || (V == null ? void 0 : V.isReadonly.value)), D = Y(), B = B2(D, i);
    function j(U) {
      e.openOnClear && (d.value = !0), S.value = "";
    }
    function I() {
      A.value || (d.value = !0);
    }
    function Z(U) {
      A.value || (l.value && (U.preventDefault(), U.stopPropagation()), d.value = !d.value);
    }
    function R(U) {
      var ne;
      zc(U) && ((ne = i.value) == null || ne.focus());
    }
    function J(U) {
      var te, H, ce;
      if (e.readonly || V != null && V.isReadonly.value) return;
      const ne = i.value.selectionStart, K = x.value.length;
      if ((f.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(U.key)) && U.preventDefault(), ["Enter", "ArrowDown"].includes(U.key) && (d.value = !0), ["Escape"].includes(U.key) && (d.value = !1), L.value && ["Enter", "Tab"].includes(U.key) && !x.value.some((he) => {
        let {
          value: Oe
        } = he;
        return Oe === $.value[0].value;
      }) && Se($.value[0]), U.key === "ArrowDown" && L.value && ((te = D.value) == null || te.focus("next")), ["Backspace", "Delete"].includes(U.key)) {
        if (!e.multiple && M.value && x.value.length > 0 && !S.value) return Se(x.value[0], !1);
        if (~f.value) {
          const he = f.value;
          Se(x.value[f.value], !1), f.value = he >= K - 1 ? K - 2 : he;
        } else U.key === "Backspace" && !S.value && (f.value = K - 1);
      }
      if (e.multiple) {
        if (U.key === "ArrowLeft") {
          if (f.value < 0 && ne > 0) return;
          const he = f.value > -1 ? f.value - 1 : K - 1;
          x.value[he] ? f.value = he : (f.value = -1, i.value.setSelectionRange((H = S.value) == null ? void 0 : H.length, (ce = S.value) == null ? void 0 : ce.length));
        }
        if (U.key === "ArrowRight") {
          if (f.value < 0) return;
          const he = f.value + 1;
          x.value[he] ? f.value = he : (f.value = -1, i.value.setSelectionRange(0, 0));
        }
      }
    }
    function F(U) {
      if (ys(i.value, ":autofill") || ys(i.value, ":-webkit-autofill")) {
        const ne = g.value.find((K) => K.title === U.target.value);
        ne && Se(ne);
      }
    }
    function q() {
      var U;
      e.eager && ((U = u.value) == null || U.calculateVisibleItems());
    }
    function z() {
      var U;
      l.value && (r.value = !0, (U = i.value) == null || U.focus());
    }
    function E(U) {
      l.value = !0, setTimeout(() => {
        s.value = !0;
      });
    }
    function Q(U) {
      s.value = !1;
    }
    function W(U) {
      (U == null || U === "" && !e.multiple && !M.value) && (x.value = []);
    }
    const se = Ve(!1);
    function Se(U) {
      let ne = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!U || U.props.disabled))
        if (e.multiple) {
          const K = x.value.findIndex((H) => e.valueComparator(H.value, U.value)), te = ne ?? !~K;
          if (~K) {
            const H = te ? [...x.value, U] : [...x.value];
            H.splice(K, 1), x.value = H;
          } else te && (x.value = [...x.value, U]);
          e.clearOnSelect && (S.value = "");
        } else {
          const K = ne !== !1;
          x.value = K ? [U] : [], S.value = K && !M.value ? U.title : "", et(() => {
            d.value = !1, r.value = !0;
          });
        }
    }
    return pe(l, (U, ne) => {
      var K;
      U !== ne && (U ? (se.value = !0, S.value = e.multiple || M.value ? "" : String(((K = x.value.at(-1)) == null ? void 0 : K.props.title) ?? ""), r.value = !0, et(() => se.value = !1)) : (!e.multiple && S.value == null && (x.value = []), d.value = !1, x.value.some((te) => {
        let {
          title: H
        } = te;
        return H === S.value;
      }) || (S.value = ""), f.value = -1));
    }), pe(S, (U) => {
      !l.value || se.value || (U && (d.value = !0), r.value = !U);
    }), pe(d, () => {
      if (!e.hideSelected && d.value && x.value.length) {
        const U = $.value.findIndex((ne) => x.value.some((K) => ne.value === K.value));
        bt && window.requestAnimationFrame(() => {
          var ne;
          U >= 0 && ((ne = u.value) == null || ne.scrollToIndex(U));
        });
      }
    }), pe(() => e.items, (U, ne) => {
      d.value || l.value && !ne.length && U.length && (d.value = !0);
    }), ye(() => {
      const U = !!(!e.hideNoData || $.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), ne = x.value.length > 0, K = pr.filterProps(e);
      return p(pr, fe({
        ref: i
      }, K, {
        modelValue: S.value,
        "onUpdate:modelValue": [(te) => S.value = te, W],
        focused: l.value,
        "onUpdate:focused": (te) => l.value = te,
        validationValue: x.externalValue,
        counterValue: w.value,
        dirty: ne,
        onChange: F,
        class: ["v-autocomplete", `v-autocomplete--${e.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": d.value,
          "v-autocomplete--chips": !!e.chips,
          "v-autocomplete--selection-slot": !!M.value,
          "v-autocomplete--selecting-index": f.value > -1
        }, e.class],
        style: e.style,
        readonly: e.readonly,
        placeholder: ne ? void 0 : e.placeholder,
        "onClick:clear": j,
        "onMousedown:control": I,
        onKeydown: J
      }), {
        ...n,
        default: () => p(ge, null, [p(ws, fe({
          ref: o,
          modelValue: d.value,
          "onUpdate:modelValue": (te) => d.value = te,
          activator: "parent",
          contentClass: "v-autocomplete__content",
          disabled: A.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: q,
          onAfterLeave: z
        }, e.menuProps), {
          default: () => [U && p(Kd, fe({
            ref: D,
            selected: T.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (te) => te.preventDefault(),
            onKeydown: R,
            onFocusin: E,
            onFocusout: Q,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, B, e.listProps), {
            default: () => {
              var te, H, ce;
              return [(te = n["prepend-item"]) == null ? void 0 : te.call(n), !$.value.length && !e.hideNoData && (((H = n["no-data"]) == null ? void 0 : H.call(n)) ?? p(Ui, {
                title: a(e.noDataText)
              }, null)), p(t1, {
                ref: u,
                renderless: !0,
                items: $.value
              }, {
                default: (he) => {
                  var Be;
                  let {
                    item: Oe,
                    index: je,
                    itemRef: be
                  } = he;
                  const Te = fe(Oe.props, {
                    ref: be,
                    key: je,
                    active: L.value && je === 0 ? !0 : void 0,
                    onClick: () => Se(Oe, null)
                  });
                  return ((Be = n.item) == null ? void 0 : Be.call(n, {
                    item: Oe,
                    index: je,
                    props: Te
                  })) ?? p(Ui, fe(Te, {
                    role: "option"
                  }), {
                    prepend: (oe) => {
                      let {
                        isSelected: Me
                      } = oe;
                      return p(ge, null, [e.multiple && !e.hideSelected ? p(qi, {
                        key: Oe.value,
                        modelValue: Me,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, Oe.props.prependAvatar && p(Da, {
                        image: Oe.props.prependAvatar
                      }, null), Oe.props.prependIcon && p(vt, {
                        icon: Oe.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var oe, Me;
                      return r.value ? Oe.title : UP(Oe.title, (oe = O(Oe)) == null ? void 0 : oe.title, ((Me = S.value) == null ? void 0 : Me.length) ?? 0);
                    }
                  });
                }
              }), (ce = n["append-item"]) == null ? void 0 : ce.call(n)];
            }
          })]
        }), x.value.map((te, H) => {
          function ce(be) {
            be.stopPropagation(), be.preventDefault(), Se(te, !1);
          }
          const he = {
            "onClick:close": ce,
            onKeydown(be) {
              be.key !== "Enter" && be.key !== " " || (be.preventDefault(), be.stopPropagation(), ce(be));
            },
            onMousedown(be) {
              be.preventDefault(), be.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, Oe = P.value ? !!n.chip : !!n.selection, je = Oe ? Zd(P.value ? n.chip({
            item: te,
            index: H,
            props: he
          }) : n.selection({
            item: te,
            index: H
          })) : void 0;
          if (!(Oe && !je))
            return p("div", {
              key: te.value,
              class: ["v-autocomplete__selection", H === f.value && ["v-autocomplete__selection--selected", b.value]],
              style: H === f.value ? C.value : {}
            }, [P.value ? n.chip ? p(lt, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: te.title
                }
              }
            }, {
              default: () => [je]
            }) : p(Gs, fe({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: te.title,
              disabled: te.props.disabled
            }, he), null) : je ?? p("span", {
              class: "v-autocomplete__selection-text"
            }, [te.title, e.multiple && H < x.value.length - 1 && p("span", {
              class: "v-autocomplete__selection-comma"
            }, [Ee(",")])])]);
        })]),
        "append-inner": function() {
          var he;
          for (var te = arguments.length, H = new Array(te), ce = 0; ce < te; ce++)
            H[ce] = arguments[ce];
          return p(ge, null, [(he = n["append-inner"]) == null ? void 0 : he.call(n, ...H), e.menuIcon ? p(vt, {
            class: "v-autocomplete__menu-icon",
            icon: e.menuIcon,
            onMousedown: Z,
            onClick: m5,
            "aria-label": a(m.value),
            title: a(m.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Ea({
      isFocused: l,
      isPristine: r,
      menu: d,
      search: S,
      filteredItems: _,
      select: Se
    }, i);
  }
}), JP = le({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: Ue,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: !0
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...Ae(),
  ...al({
    location: "top end"
  }),
  ...Dt(),
  ...nt(),
  ...dt(),
  ...ai({
    transition: "scale-rotate-transition"
  })
}, "VBadge"), e$ = ve()({
  name: "VBadge",
  inheritAttrs: !1,
  props: JP(),
  setup(e, t) {
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: a
    } = kt(ue(e, "color")), {
      roundedClasses: i
    } = qt(e), {
      t: l
    } = tn(), {
      textColorClasses: r,
      textColorStyles: s
    } = zn(ue(e, "textColor")), {
      themeClasses: o
    } = H5(), {
      locationStyles: u
    } = Hr(e, !0, (c) => (e.floating ? e.dot ? 2 : 4 : e.dot ? 8 : 12) + (["top", "bottom"].includes(c) ? +(e.offsetY ?? 0) : ["left", "right"].includes(c) ? +(e.offsetX ?? 0) : 0));
    return ye(() => {
      const c = Number(e.content), d = !e.max || isNaN(c) ? e.content : c <= +e.max ? c : `${e.max}+`, [f, h] = Gf(t.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return p(e.tag, fe({
        class: ["v-badge", {
          "v-badge--bordered": e.bordered,
          "v-badge--dot": e.dot,
          "v-badge--floating": e.floating,
          "v-badge--inline": e.inline
        }, e.class]
      }, h, {
        style: e.style
      }), {
        default: () => {
          var m, g;
          return [p("div", {
            class: "v-badge__wrapper"
          }, [(g = (m = t.slots).default) == null ? void 0 : g.call(m), p(Kn, {
            transition: e.transition
          }, {
            default: () => {
              var v, y;
              return [Ct(p("span", fe({
                class: ["v-badge__badge", o.value, n.value, i.value, r.value],
                style: [a.value, s.value, e.inline ? {} : u.value],
                "aria-atomic": "true",
                "aria-label": l(e.label, c),
                "aria-live": "polite",
                role: "status"
              }, f), [e.dot ? void 0 : t.slots.badge ? (y = (v = t.slots).badge) == null ? void 0 : y.call(v) : e.icon ? p(vt, {
                icon: e.icon
              }, null) : d]), [[Dn, e.modelValue]])];
            }
          })])];
        }
      });
    }), {};
  }
}), t$ = le({
  color: String,
  density: String,
  ...Ae()
}, "VBannerActions"), e8 = ve()({
  name: "VBannerActions",
  props: t$(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Yt({
      VBtn: {
        color: e.color,
        density: e.density,
        slim: !0,
        variant: "text"
      }
    }), ye(() => {
      var a;
      return p("div", {
        class: ["v-banner-actions", e.class],
        style: e.style
      }, [(a = n.default) == null ? void 0 : a.call(n)]);
    }), {};
  }
}), t8 = Di("v-banner-text"), n$ = le({
  avatar: String,
  bgColor: String,
  color: String,
  icon: Ue,
  lines: String,
  stacked: Boolean,
  sticky: Boolean,
  text: String,
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...vn(),
  ...Qr({
    mobile: null
  }),
  ...Pn(),
  ...al(),
  ...Ws(),
  ...Dt(),
  ...nt(),
  ...dt()
}, "VBanner"), a$ = ve()({
  name: "VBanner",
  props: n$(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: i
    } = kt(e, "bgColor"), {
      borderClasses: l
    } = _a(e), {
      densityClasses: r
    } = ea(e), {
      displayClasses: s,
      mobile: o
    } = Za(e), {
      dimensionStyles: u
    } = gn(e), {
      elevationClasses: c
    } = Zn(e), {
      locationStyles: d
    } = Hr(e), {
      positionClasses: f
    } = qs(e), {
      roundedClasses: h
    } = qt(e), {
      themeClasses: m
    } = yt(e), g = ue(e, "color"), v = ue(e, "density");
    Yt({
      VBannerActions: {
        color: g,
        density: v
      }
    }), ye(() => {
      const y = !!(e.text || n.text), b = !!(e.avatar || e.icon), C = !!(b || n.prepend);
      return p(e.tag, {
        class: ["v-banner", {
          "v-banner--stacked": e.stacked || o.value,
          "v-banner--sticky": e.sticky,
          [`v-banner--${e.lines}-line`]: !!e.lines
        }, m.value, a.value, l.value, r.value, s.value, c.value, f.value, h.value, e.class],
        style: [i.value, u.value, d.value, e.style],
        role: "banner"
      }, {
        default: () => {
          var S;
          return [C && p("div", {
            key: "prepend",
            class: "v-banner__prepend"
          }, [n.prepend ? p(lt, {
            key: "prepend-defaults",
            disabled: !b,
            defaults: {
              VAvatar: {
                color: g.value,
                density: v.value,
                icon: e.icon,
                image: e.avatar
              }
            }
          }, n.prepend) : p(Da, {
            key: "prepend-avatar",
            color: g.value,
            density: v.value,
            icon: e.icon,
            image: e.avatar
          }, null)]), p("div", {
            class: "v-banner__content"
          }, [y && p(t8, {
            key: "text"
          }, {
            default: () => {
              var x;
              return [((x = n.text) == null ? void 0 : x.call(n)) ?? e.text];
            }
          }), (S = n.default) == null ? void 0 : S.call(n)]), n.actions && p(e8, {
            key: "actions"
          }, n.actions)];
        }
      });
    });
  }
}), i$ = le({
  baseColor: String,
  bgColor: String,
  color: String,
  grow: Boolean,
  mode: {
    type: String,
    validator: (e) => !e || ["horizontal", "shift"].includes(e)
  },
  height: {
    type: [Number, String],
    default: 56
  },
  active: {
    type: Boolean,
    default: !0
  },
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...Pn(),
  ...Dt(),
  ...Ar({
    name: "bottom-navigation"
  }),
  ...nt({
    tag: "header"
  }),
  ...Zr({
    selectedClass: "v-btn--selected"
  }),
  ...dt()
}, "VBottomNavigation"), l$ = ve()({
  name: "VBottomNavigation",
  props: i$(),
  emits: {
    "update:active": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = H5(), {
      borderClasses: i
    } = _a(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: r
    } = kt(ue(e, "bgColor")), {
      densityClasses: s
    } = ea(e), {
      elevationClasses: o
    } = Zn(e), {
      roundedClasses: u
    } = qt(e), {
      ssrBootStyles: c
    } = Ir(), d = k(() => Number(e.height) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0)), f = Fe(e, "active", e.active), {
      layoutItemStyles: h
    } = Dr({
      id: e.name,
      order: k(() => parseInt(e.order, 10)),
      position: k(() => "bottom"),
      layoutSize: k(() => f.value ? d.value : 0),
      elementSize: d,
      active: f,
      absolute: ue(e, "absolute")
    });
    return Zl(e, T2), Yt({
      VBtn: {
        baseColor: ue(e, "baseColor"),
        color: ue(e, "color"),
        density: ue(e, "density"),
        stacked: k(() => e.mode !== "horizontal"),
        variant: "text"
      }
    }, {
      scoped: !0
    }), ye(() => p(e.tag, {
      class: ["v-bottom-navigation", {
        "v-bottom-navigation--active": f.value,
        "v-bottom-navigation--grow": e.grow,
        "v-bottom-navigation--shift": e.mode === "shift"
      }, a.value, l.value, i.value, s.value, o.value, u.value, e.class],
      style: [r.value, h.value, {
        height: Qe(d.value)
      }, c.value, e.style]
    }, {
      default: () => [n.default && p("div", {
        class: "v-bottom-navigation__content"
      }, [n.default()])]
    })), {};
  }
}), n8 = le({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: !0
  },
  scrollable: Boolean,
  ...bu({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: zd
    },
    zIndex: 2400
  })
}, "VDialog"), gh = ve()({
  name: "VDialog",
  props: n8(),
  emits: {
    "update:modelValue": (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const i = Fe(e, "modelValue"), {
      scopeId: l
    } = Rr(), r = Y();
    function s(c) {
      var h, m;
      const d = c.relatedTarget, f = c.target;
      if (d !== f && ((h = r.value) != null && h.contentEl) && // We're the topmost dialog
      ((m = r.value) != null && m.globalTop) && // It isn't the document or the dialog body
      ![document, r.value.contentEl].includes(f) && // It isn't inside the dialog body
      !r.value.contentEl.contains(f)) {
        const g = Do(r.value.contentEl);
        if (!g.length) return;
        const v = g[0], y = g[g.length - 1];
        d === v ? y.focus() : v.focus();
      }
    }
    bt && pe(() => i.value && e.retainFocus, (c) => {
      c ? document.addEventListener("focusin", s) : document.removeEventListener("focusin", s);
    }, {
      immediate: !0
    });
    function o() {
      var c;
      n("afterEnter"), (c = r.value) != null && c.contentEl && !r.value.contentEl.contains(document.activeElement) && r.value.contentEl.focus({
        preventScroll: !0
      });
    }
    function u() {
      n("afterLeave");
    }
    return pe(i, async (c) => {
      var d;
      c || (await et(), (d = r.value.activatorEl) == null || d.focus({
        preventScroll: !0
      }));
    }), ye(() => {
      const c = Ka.filterProps(e), d = fe({
        "aria-haspopup": "dialog",
        "aria-expanded": String(i.value)
      }, e.activatorProps), f = fe({
        tabindex: -1
      }, e.contentProps);
      return p(Ka, fe({
        ref: r,
        class: ["v-dialog", {
          "v-dialog--fullscreen": e.fullscreen,
          "v-dialog--scrollable": e.scrollable
        }, e.class],
        style: e.style
      }, c, {
        modelValue: i.value,
        "onUpdate:modelValue": (h) => i.value = h,
        "aria-modal": "true",
        activatorProps: d,
        contentProps: f,
        role: "dialog",
        onAfterEnter: o,
        onAfterLeave: u
      }, l), {
        activator: a.activator,
        default: function() {
          for (var h = arguments.length, m = new Array(h), g = 0; g < h; g++)
            m[g] = arguments[g];
          return p(lt, {
            root: "VDialog"
          }, {
            default: () => {
              var v;
              return [(v = a.default) == null ? void 0 : v.call(a, ...m)];
            }
          });
        }
      });
    }), Ea({}, r);
  }
}), r$ = le({
  inset: Boolean,
  ...n8({
    transition: "bottom-sheet-transition"
  })
}, "VBottomSheet"), s$ = ve()({
  name: "VBottomSheet",
  props: r$(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue");
    return ye(() => {
      const i = gh.filterProps(e);
      return p(gh, fe(i, {
        contentClass: ["v-bottom-sheet__content", e.contentClass],
        modelValue: a.value,
        "onUpdate:modelValue": (l) => a.value = l,
        class: ["v-bottom-sheet", {
          "v-bottom-sheet--inset": e.inset
        }, e.class],
        style: e.style
      }), n);
    }), {};
  }
}), o$ = le({
  divider: [Number, String],
  ...Ae()
}, "VBreadcrumbsDivider"), a8 = ve()({
  name: "VBreadcrumbsDivider",
  props: o$(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => {
      var a;
      return p("li", {
        class: ["v-breadcrumbs-divider", e.class],
        style: e.style
      }, [((a = n == null ? void 0 : n.default) == null ? void 0 : a.call(n)) ?? e.divider]);
    }), {};
  }
}), u$ = le({
  active: Boolean,
  activeClass: String,
  activeColor: String,
  color: String,
  disabled: Boolean,
  title: String,
  ...Ae(),
  ...Ou(),
  ...nt({
    tag: "li"
  })
}, "VBreadcrumbsItem"), i8 = ve()({
  name: "VBreadcrumbsItem",
  props: u$(),
  setup(e, t) {
    let {
      slots: n,
      attrs: a
    } = t;
    const i = yu(e, a), l = k(() => {
      var u;
      return e.active || ((u = i.isActive) == null ? void 0 : u.value);
    }), r = k(() => l.value ? e.activeColor : e.color), {
      textColorClasses: s,
      textColorStyles: o
    } = zn(r);
    return ye(() => p(e.tag, {
      class: ["v-breadcrumbs-item", {
        "v-breadcrumbs-item--active": l.value,
        "v-breadcrumbs-item--disabled": e.disabled,
        [`${e.activeClass}`]: l.value && e.activeClass
      }, s.value, e.class],
      style: [o.value, e.style],
      "aria-current": l.value ? "page" : void 0
    }, {
      default: () => {
        var u, c;
        return [i.isLink.value ? p("a", {
          class: "v-breadcrumbs-item--link",
          href: i.href.value,
          "aria-current": l.value ? "page" : void 0,
          onClick: i.navigate
        }, [((c = n.default) == null ? void 0 : c.call(n)) ?? e.title]) : ((u = n.default) == null ? void 0 : u.call(n)) ?? e.title];
      }
    })), {};
  }
}), c$ = le({
  activeClass: String,
  activeColor: String,
  bgColor: String,
  color: String,
  disabled: Boolean,
  divider: {
    type: String,
    default: "/"
  },
  icon: Ue,
  items: {
    type: Array,
    default: () => []
  },
  ...Ae(),
  ...Ln(),
  ...Dt(),
  ...nt({
    tag: "ul"
  })
}, "VBreadcrumbs"), d$ = ve()({
  name: "VBreadcrumbs",
  props: c$(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: i
    } = kt(ue(e, "bgColor")), {
      densityClasses: l
    } = ea(e), {
      roundedClasses: r
    } = qt(e);
    Yt({
      VBreadcrumbsDivider: {
        divider: ue(e, "divider")
      },
      VBreadcrumbsItem: {
        activeClass: ue(e, "activeClass"),
        activeColor: ue(e, "activeColor"),
        color: ue(e, "color"),
        disabled: ue(e, "disabled")
      }
    });
    const s = k(() => e.items.map((o) => typeof o == "string" ? {
      item: {
        title: o
      },
      raw: o
    } : {
      item: o,
      raw: o
    }));
    return ye(() => {
      const o = !!(n.prepend || e.icon);
      return p(e.tag, {
        class: ["v-breadcrumbs", a.value, l.value, r.value, e.class],
        style: [i.value, e.style]
      }, {
        default: () => {
          var u;
          return [o && p("li", {
            key: "prepend",
            class: "v-breadcrumbs__prepend"
          }, [n.prepend ? p(lt, {
            key: "prepend-defaults",
            disabled: !e.icon,
            defaults: {
              VIcon: {
                icon: e.icon,
                start: !0
              }
            }
          }, n.prepend) : p(vt, {
            key: "prepend-icon",
            start: !0,
            icon: e.icon
          }, null)]), s.value.map((c, d, f) => {
            var g;
            let {
              item: h,
              raw: m
            } = c;
            return p(ge, null, [((g = n.item) == null ? void 0 : g.call(n, {
              item: h,
              index: d
            })) ?? p(i8, fe({
              key: d,
              disabled: d >= f.length - 1
            }, typeof h == "string" ? {
              title: h
            } : h), {
              default: n.title ? () => {
                var v;
                return (v = n.title) == null ? void 0 : v.call(n, {
                  item: h,
                  index: d
                });
              } : void 0
            }), d < f.length - 1 && p(a8, null, {
              default: n.divider ? () => {
                var v;
                return (v = n.divider) == null ? void 0 : v.call(n, {
                  item: m,
                  index: d
                });
              } : void 0
            })]);
          }), (u = n.default) == null ? void 0 : u.call(n)];
        }
      });
    }), {};
  }
}), l8 = ve()({
  name: "VCardActions",
  props: Ae(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Yt({
      VBtn: {
        slim: !0,
        variant: "text"
      }
    }), ye(() => {
      var a;
      return p("div", {
        class: ["v-card-actions", e.class],
        style: e.style
      }, [(a = n.default) == null ? void 0 : a.call(n)]);
    }), {};
  }
}), f$ = le({
  opacity: [Number, String],
  ...Ae(),
  ...nt()
}, "VCardSubtitle"), r8 = ve()({
  name: "VCardSubtitle",
  props: f$(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => p(e.tag, {
      class: ["v-card-subtitle", e.class],
      style: [{
        "--v-card-subtitle-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), s8 = Di("v-card-title"), h$ = le({
  appendAvatar: String,
  appendIcon: Ue,
  prependAvatar: String,
  prependIcon: Ue,
  subtitle: [String, Number],
  title: [String, Number],
  ...Ae(),
  ...Ln()
}, "VCardItem"), o8 = ve()({
  name: "VCardItem",
  props: h$(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => {
      var u;
      const a = !!(e.prependAvatar || e.prependIcon), i = !!(a || n.prepend), l = !!(e.appendAvatar || e.appendIcon), r = !!(l || n.append), s = !!(e.title != null || n.title), o = !!(e.subtitle != null || n.subtitle);
      return p("div", {
        class: ["v-card-item", e.class],
        style: e.style
      }, [i && p("div", {
        key: "prepend",
        class: "v-card-item__prepend"
      }, [n.prepend ? p(lt, {
        key: "prepend-defaults",
        disabled: !a,
        defaults: {
          VAvatar: {
            density: e.density,
            image: e.prependAvatar
          },
          VIcon: {
            density: e.density,
            icon: e.prependIcon
          }
        }
      }, n.prepend) : p(ge, null, [e.prependAvatar && p(Da, {
        key: "prepend-avatar",
        density: e.density,
        image: e.prependAvatar
      }, null), e.prependIcon && p(vt, {
        key: "prepend-icon",
        density: e.density,
        icon: e.prependIcon
      }, null)])]), p("div", {
        class: "v-card-item__content"
      }, [s && p(s8, {
        key: "title"
      }, {
        default: () => {
          var c;
          return [((c = n.title) == null ? void 0 : c.call(n)) ?? e.title];
        }
      }), o && p(r8, {
        key: "subtitle"
      }, {
        default: () => {
          var c;
          return [((c = n.subtitle) == null ? void 0 : c.call(n)) ?? e.subtitle];
        }
      }), (u = n.default) == null ? void 0 : u.call(n)]), r && p("div", {
        key: "append",
        class: "v-card-item__append"
      }, [n.append ? p(lt, {
        key: "append-defaults",
        disabled: !l,
        defaults: {
          VAvatar: {
            density: e.density,
            image: e.appendAvatar
          },
          VIcon: {
            density: e.density,
            icon: e.appendIcon
          }
        }
      }, n.append) : p(ge, null, [e.appendIcon && p(vt, {
        key: "append-icon",
        density: e.density,
        icon: e.appendIcon
      }, null), e.appendAvatar && p(Da, {
        key: "append-avatar",
        density: e.density,
        image: e.appendAvatar
      }, null)])])]);
    }), {};
  }
}), m$ = le({
  opacity: [Number, String],
  ...Ae(),
  ...nt()
}, "VCardText"), u8 = ve()({
  name: "VCardText",
  props: m$(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => p(e.tag, {
      class: ["v-card-text", e.class],
      style: [{
        "--v-card-text-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), v$ = le({
  appendAvatar: String,
  appendIcon: Ue,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: Ue,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  subtitle: [String, Number],
  text: [String, Number],
  title: [String, Number],
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...vn(),
  ...Pn(),
  ...Wd(),
  ...al(),
  ...Ws(),
  ...Dt(),
  ...Ou(),
  ...nt(),
  ...dt(),
  ...Na({
    variant: "elevated"
  })
}, "VCard"), g$ = ve()({
  name: "VCard",
  directives: {
    Ripple: nl
  },
  props: v$(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      themeClasses: i
    } = yt(e), {
      borderClasses: l
    } = _a(e), {
      colorClasses: r,
      colorStyles: s,
      variantClasses: o
    } = Br(e), {
      densityClasses: u
    } = ea(e), {
      dimensionStyles: c
    } = gn(e), {
      elevationClasses: d
    } = Zn(e), {
      loaderClasses: f
    } = Cu(e), {
      locationStyles: h
    } = Hr(e), {
      positionClasses: m
    } = qs(e), {
      roundedClasses: g
    } = qt(e), v = yu(e, n), y = k(() => e.link !== !1 && v.isLink.value), b = k(() => !e.disabled && e.link !== !1 && (e.link || v.isClickable.value));
    return ye(() => {
      const C = y.value ? "a" : e.tag, S = !!(a.title || e.title != null), x = !!(a.subtitle || e.subtitle != null), w = S || x, V = !!(a.append || e.appendAvatar || e.appendIcon), _ = !!(a.prepend || e.prependAvatar || e.prependIcon), O = !!(a.image || e.image), $ = w || _ || V, P = !!(a.text || e.text != null);
      return Ct(p(C, {
        class: ["v-card", {
          "v-card--disabled": e.disabled,
          "v-card--flat": e.flat,
          "v-card--hover": e.hover && !(e.disabled || e.flat),
          "v-card--link": b.value
        }, i.value, l.value, r.value, u.value, d.value, f.value, m.value, g.value, o.value, e.class],
        style: [s.value, c.value, h.value, e.style],
        href: v.href.value,
        onClick: b.value && v.navigate,
        tabindex: e.disabled ? -1 : void 0
      }, {
        default: () => {
          var M;
          return [O && p("div", {
            key: "image",
            class: "v-card__image"
          }, [a.image ? p(lt, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                cover: !0,
                src: e.image
              }
            }
          }, a.image) : p(Wi, {
            key: "image-img",
            cover: !0,
            src: e.image
          }, null)]), p(wu, {
            name: "v-card",
            active: !!e.loading,
            color: typeof e.loading == "boolean" ? void 0 : e.loading
          }, {
            default: a.loader
          }), $ && p(o8, {
            key: "item",
            prependAvatar: e.prependAvatar,
            prependIcon: e.prependIcon,
            title: e.title,
            subtitle: e.subtitle,
            appendAvatar: e.appendAvatar,
            appendIcon: e.appendIcon
          }, {
            default: a.item,
            prepend: a.prepend,
            title: a.title,
            subtitle: a.subtitle,
            append: a.append
          }), P && p(u8, {
            key: "text"
          }, {
            default: () => {
              var T;
              return [((T = a.text) == null ? void 0 : T.call(a)) ?? e.text];
            }
          }), (M = a.default) == null ? void 0 : M.call(a), a.actions && p(l8, null, {
            default: a.actions
          }), Bl(b.value, "v-card")];
        }
      }), [[xa("ripple"), b.value && e.ripple]]);
    }), {};
  }
}), c8 = Symbol.for("vuetify:v-window"), d8 = Symbol.for("vuetify:v-window-group"), n1 = le({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || e === "hover"
  },
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  ...Ae(),
  ...nt(),
  ...dt()
}, "VWindow"), yr = ve()({
  name: "VWindow",
  directives: {
    Touch: C2
  },
  props: n1(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e), {
      isRtl: i
    } = xn(), {
      t: l
    } = tn(), r = Zl(e, d8), s = Y(), o = k(() => i.value ? !e.reverse : e.reverse), u = Ve(!1), c = k(() => {
      const S = e.direction === "vertical" ? "y" : "x", w = (o.value ? !u.value : u.value) ? "-reverse" : "";
      return `v-window-${S}${w}-transition`;
    }), d = Ve(0), f = Y(void 0), h = k(() => r.items.value.findIndex((S) => r.selected.value.includes(S.id)));
    pe(h, (S, x) => {
      const w = r.items.value.length, V = w - 1;
      w <= 2 ? u.value = S < x : S === V && x === 0 ? u.value = !0 : S === 0 && x === V ? u.value = !1 : u.value = S < x;
    }), Tt(c8, {
      transition: c,
      isReversed: u,
      transitionCount: d,
      transitionHeight: f,
      rootRef: s
    });
    const m = k(() => e.continuous || h.value !== 0), g = k(() => e.continuous || h.value !== r.items.value.length - 1);
    function v() {
      m.value && r.prev();
    }
    function y() {
      g.value && r.next();
    }
    const b = k(() => {
      const S = [], x = {
        icon: i.value ? e.nextIcon : e.prevIcon,
        class: `v-window__${o.value ? "right" : "left"}`,
        onClick: r.prev,
        "aria-label": l("$vuetify.carousel.prev")
      };
      S.push(m.value ? n.prev ? n.prev({
        props: x
      }) : p(pt, x, null) : p("div", null, null));
      const w = {
        icon: i.value ? e.prevIcon : e.nextIcon,
        class: `v-window__${o.value ? "left" : "right"}`,
        onClick: r.next,
        "aria-label": l("$vuetify.carousel.next")
      };
      return S.push(g.value ? n.next ? n.next({
        props: w
      }) : p(pt, w, null) : p("div", null, null)), S;
    }), C = k(() => e.touch === !1 ? e.touch : {
      ...{
        left: () => {
          o.value ? v() : y();
        },
        right: () => {
          o.value ? y() : v();
        },
        start: (x) => {
          let {
            originalEvent: w
          } = x;
          w.stopPropagation();
        }
      },
      ...e.touch === !0 ? {} : e.touch
    });
    return ye(() => Ct(p(e.tag, {
      ref: s,
      class: ["v-window", {
        "v-window--show-arrows-on-hover": e.showArrows === "hover"
      }, a.value, e.class],
      style: e.style
    }, {
      default: () => {
        var S, x;
        return [p("div", {
          class: "v-window__container",
          style: {
            height: f.value
          }
        }, [(S = n.default) == null ? void 0 : S.call(n, {
          group: r
        }), e.showArrows !== !1 && p("div", {
          class: "v-window__controls"
        }, [b.value])]), (x = n.additional) == null ? void 0 : x.call(n, {
          group: r
        })];
      }
    }), [[xa("touch"), C.value]])), {
      group: r
    };
  }
}), p$ = le({
  color: String,
  cycle: Boolean,
  delimiterIcon: {
    type: Ue,
    default: "$delimiter"
  },
  height: {
    type: [Number, String],
    default: 500
  },
  hideDelimiters: Boolean,
  hideDelimiterBackground: Boolean,
  interval: {
    type: [Number, String],
    default: 6e3,
    validator: (e) => Number(e) > 0
  },
  progress: [Boolean, String],
  verticalDelimiters: [Boolean, String],
  ...n1({
    continuous: !0,
    mandatory: "force",
    showArrows: !0
  })
}, "VCarousel"), y$ = ve()({
  name: "VCarousel",
  props: p$(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), {
      t: i
    } = tn(), l = Y();
    let r = -1;
    pe(a, o), pe(() => e.interval, o), pe(() => e.cycle, (u) => {
      u ? o() : window.clearTimeout(r);
    }), rt(s);
    function s() {
      !e.cycle || !l.value || (r = window.setTimeout(l.value.group.next, +e.interval > 0 ? +e.interval : 6e3));
    }
    function o() {
      window.clearTimeout(r), window.requestAnimationFrame(s);
    }
    return ye(() => {
      const u = yr.filterProps(e);
      return p(yr, fe({
        ref: l
      }, u, {
        modelValue: a.value,
        "onUpdate:modelValue": (c) => a.value = c,
        class: ["v-carousel", {
          "v-carousel--hide-delimiter-background": e.hideDelimiterBackground,
          "v-carousel--vertical-delimiters": e.verticalDelimiters
        }, e.class],
        style: [{
          height: Qe(e.height)
        }, e.style]
      }), {
        default: n.default,
        additional: (c) => {
          let {
            group: d
          } = c;
          return p(ge, null, [!e.hideDelimiters && p("div", {
            class: "v-carousel__controls",
            style: {
              left: e.verticalDelimiters === "left" && e.verticalDelimiters ? 0 : "auto",
              right: e.verticalDelimiters === "right" ? 0 : "auto"
            }
          }, [d.items.value.length > 0 && p(lt, {
            defaults: {
              VBtn: {
                color: e.color,
                icon: e.delimiterIcon,
                size: "x-small",
                variant: "text"
              }
            },
            scoped: !0
          }, {
            default: () => [d.items.value.map((f, h) => {
              const m = {
                id: `carousel-item-${f.id}`,
                "aria-label": i("$vuetify.carousel.ariaLabel.delimiter", h + 1, d.items.value.length),
                class: ["v-carousel__controls__item", d.isSelected(f.id) && "v-btn--active"],
                onClick: () => d.select(f.id, !0)
              };
              return n.item ? n.item({
                props: m,
                item: f
              }) : p(pt, fe(f, m), null);
            })]
          })]), e.progress && p(Yd, {
            class: "v-carousel__progress",
            color: typeof e.progress == "string" ? e.progress : void 0,
            modelValue: (d.getItemIndex(a.value) + 1) / d.items.value.length * 100
          }, null)]);
        },
        prev: n.prev,
        next: n.next
      });
    }), {};
  }
}), a1 = le({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...Ae(),
  ...Er(),
  ...x2()
}, "VWindowItem"), Or = ve()({
  name: "VWindowItem",
  directives: {
    Touch: C2
  },
  props: a1(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = ct(c8), i = Nr(e, d8), {
      isBooted: l
    } = Ir();
    if (!a || !i) throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const r = Ve(!1), s = k(() => l.value && (a.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1));
    function o() {
      !r.value || !a || (r.value = !1, a.transitionCount.value > 0 && (a.transitionCount.value -= 1, a.transitionCount.value === 0 && (a.transitionHeight.value = void 0)));
    }
    function u() {
      var m;
      r.value || !a || (r.value = !0, a.transitionCount.value === 0 && (a.transitionHeight.value = Qe((m = a.rootRef.value) == null ? void 0 : m.clientHeight)), a.transitionCount.value += 1);
    }
    function c() {
      o();
    }
    function d(m) {
      r.value && et(() => {
        !s.value || !r.value || !a || (a.transitionHeight.value = Qe(m.clientHeight));
      });
    }
    const f = k(() => {
      const m = a.isReversed.value ? e.reverseTransition : e.transition;
      return s.value ? {
        name: typeof m != "string" ? a.transition.value : m,
        onBeforeEnter: u,
        onAfterEnter: o,
        onEnterCancelled: c,
        onBeforeLeave: u,
        onAfterLeave: o,
        onLeaveCancelled: c,
        onEnter: d
      } : !1;
    }), {
      hasContent: h
    } = P2(e, i.isSelected);
    return ye(() => p(Kn, {
      transition: f.value,
      disabled: !l.value
    }, {
      default: () => {
        var m;
        return [Ct(p("div", {
          class: ["v-window-item", i.selectedClass.value, e.class],
          style: e.style
        }, [h.value && ((m = n.default) == null ? void 0 : m.call(n))]), [[Dn, i.isSelected.value]])];
      }
    })), {
      groupItem: i
    };
  }
}), O$ = le({
  ...O3(),
  ...a1()
}, "VCarouselItem"), b$ = ve()({
  name: "VCarouselItem",
  inheritAttrs: !1,
  props: O$(),
  setup(e, t) {
    let {
      slots: n,
      attrs: a
    } = t;
    ye(() => {
      const i = Wi.filterProps(e), l = Or.filterProps(e);
      return p(Or, fe({
        class: ["v-carousel-item", e.class]
      }, l), {
        default: () => [p(Wi, fe(a, i), n)]
      });
    });
  }
}), C$ = Di("v-code"), w$ = le({
  color: {
    type: Object
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  height: {
    type: [Number, String],
    default: 150
  },
  width: {
    type: [Number, String],
    default: 300
  },
  ...Ae()
}, "VColorPickerCanvas"), k$ = Pa({
  name: "VColorPickerCanvas",
  props: w$(),
  emits: {
    "update:color": (e) => !0,
    "update:position": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const a = Ve(!1), i = Y(), l = Ve(parseFloat(e.width)), r = Ve(parseFloat(e.height)), s = Y({
      x: 0,
      y: 0
    }), o = k({
      get: () => s.value,
      set(v) {
        var C, S;
        if (!i.value) return;
        const {
          x: y,
          y: b
        } = v;
        s.value = v, n("update:color", {
          h: ((C = e.color) == null ? void 0 : C.h) ?? 0,
          s: ln(y, 0, l.value) / l.value,
          v: 1 - ln(b, 0, r.value) / r.value,
          a: ((S = e.color) == null ? void 0 : S.a) ?? 1
        });
      }
    }), u = k(() => {
      const {
        x: v,
        y
      } = o.value, b = parseInt(e.dotSize, 10) / 2;
      return {
        width: Qe(e.dotSize),
        height: Qe(e.dotSize),
        transform: `translate(${Qe(v - b)}, ${Qe(y - b)})`
      };
    }), {
      resizeRef: c
    } = Ga((v) => {
      var C;
      if (!((C = c.el) != null && C.offsetParent)) return;
      const {
        width: y,
        height: b
      } = v[0].contentRect;
      l.value = y, r.value = b;
    });
    function d(v, y, b) {
      const {
        left: C,
        top: S,
        width: x,
        height: w
      } = b;
      o.value = {
        x: ln(v - C, 0, x),
        y: ln(y - S, 0, w)
      };
    }
    function f(v) {
      v.type === "mousedown" && v.preventDefault(), !e.disabled && (h(v), window.addEventListener("mousemove", h), window.addEventListener("mouseup", m), window.addEventListener("touchmove", h), window.addEventListener("touchend", m));
    }
    function h(v) {
      if (e.disabled || !i.value) return;
      a.value = !0;
      const y = _w(v);
      d(y.clientX, y.clientY, i.value.getBoundingClientRect());
    }
    function m() {
      window.removeEventListener("mousemove", h), window.removeEventListener("mouseup", m), window.removeEventListener("touchmove", h), window.removeEventListener("touchend", m);
    }
    function g() {
      var S;
      if (!i.value) return;
      const v = i.value, y = v.getContext("2d");
      if (!y) return;
      const b = y.createLinearGradient(0, 0, v.width, 0);
      b.addColorStop(0, "hsla(0, 0%, 100%, 1)"), b.addColorStop(1, `hsla(${((S = e.color) == null ? void 0 : S.h) ?? 0}, 100%, 50%, 1)`), y.fillStyle = b, y.fillRect(0, 0, v.width, v.height);
      const C = y.createLinearGradient(0, 0, 0, v.height);
      C.addColorStop(0, "hsla(0, 0%, 0%, 0)"), C.addColorStop(1, "hsla(0, 0%, 0%, 1)"), y.fillStyle = C, y.fillRect(0, 0, v.width, v.height);
    }
    return pe(() => {
      var v;
      return (v = e.color) == null ? void 0 : v.h;
    }, g, {
      immediate: !0
    }), pe(() => [l.value, r.value], (v, y) => {
      g(), s.value = {
        x: o.value.x * v[0] / y[0],
        y: o.value.y * v[1] / y[1]
      };
    }, {
      flush: "post"
    }), pe(() => e.color, () => {
      if (a.value) {
        a.value = !1;
        return;
      }
      s.value = e.color ? {
        x: e.color.s * l.value,
        y: (1 - e.color.v) * r.value
      } : {
        x: 0,
        y: 0
      };
    }, {
      deep: !0,
      immediate: !0
    }), rt(() => g()), ye(() => p("div", {
      ref: c,
      class: ["v-color-picker-canvas", e.class],
      style: e.style,
      onMousedown: f,
      onTouchstartPassive: f
    }, [p("canvas", {
      ref: i,
      width: l.value,
      height: r.value
    }, null), e.color && p("div", {
      class: ["v-color-picker-canvas__dot", {
        "v-color-picker-canvas__dot--disabled": e.disabled
      }],
      style: u.value
    }, null)])), {};
  }
});
function S$(e, t) {
  if (t) {
    const {
      a: n,
      ...a
    } = e;
    return a;
  }
  return e;
}
function x$(e, t) {
  if (t == null || typeof t == "string") {
    const n = P5(e);
    return e.a === 1 ? n.slice(0, 7) : n;
  }
  if (typeof t == "object") {
    let n;
    return er(t, ["r", "g", "b"]) ? n = Yi(e) : er(t, ["h", "s", "l"]) ? n = b5(e) : er(t, ["h", "s", "v"]) && (n = e), S$(n, !er(t, ["a"]) && e.a === 1);
  }
  return e;
}
const ls = {
  h: 0,
  s: 0,
  v: 0,
  a: 1
}, ph = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "R",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.r),
    getColor: (e, t) => ({
      ...e,
      r: Number(t)
    })
  }, {
    label: "G",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.g),
    getColor: (e, t) => ({
      ...e,
      g: Number(t)
    })
  }, {
    label: "B",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.b),
    getColor: (e, t) => ({
      ...e,
      b: Number(t)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    })
  }],
  to: Yi,
  from: Ed
};
var Y4;
const P$ = {
  ...ph,
  inputs: (Y4 = ph.inputs) == null ? void 0 : Y4.slice(0, 3)
}, yh = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "H",
    max: 360,
    step: 1,
    getValue: (e) => Math.round(e.h),
    getColor: (e, t) => ({
      ...e,
      h: Number(t)
    })
  }, {
    label: "S",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.s * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      s: Number(t)
    })
  }, {
    label: "L",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.l * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      l: Number(t)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    })
  }],
  to: b5,
  from: m2
}, $$ = {
  ...yh,
  inputs: yh.inputs.slice(0, 3)
}, f8 = {
  inputProps: {
    type: "text"
  },
  inputs: [{
    label: "HEXA",
    getValue: (e) => e,
    getColor: (e, t) => t
  }],
  to: P5,
  from: x5
}, _$ = {
  ...f8,
  inputs: [{
    label: "HEX",
    getValue: (e) => e.slice(0, 7),
    getColor: (e, t) => t
  }]
}, cr = {
  rgb: P$,
  rgba: ph,
  hsl: $$,
  hsla: yh,
  hex: _$,
  hexa: f8
}, M$ = (e) => {
  let {
    label: t,
    ...n
  } = e;
  return p("div", {
    class: "v-color-picker-edit__input"
  }, [p("input", n, null), p("span", null, [t])]);
}, V$ = le({
  color: Object,
  disabled: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(cr).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(cr),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(cr).includes(t))
  },
  ...Ae()
}, "VColorPickerEdit"), T$ = Pa({
  name: "VColorPickerEdit",
  props: V$(),
  emits: {
    "update:color": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const a = k(() => e.modes.map((l) => ({
      ...cr[l],
      name: l
    }))), i = k(() => {
      var s;
      const l = a.value.find((o) => o.name === e.mode);
      if (!l) return [];
      const r = e.color ? l.to(e.color) : null;
      return (s = l.inputs) == null ? void 0 : s.map((o) => {
        let {
          getValue: u,
          getColor: c,
          ...d
        } = o;
        return {
          ...l.inputProps,
          ...d,
          disabled: e.disabled,
          value: r && u(r),
          onChange: (f) => {
            const h = f.target;
            h && n("update:color", l.from(c(r ?? l.to(ls), h.value)));
          }
        };
      });
    });
    return ye(() => {
      var l;
      return p("div", {
        class: ["v-color-picker-edit", e.class],
        style: e.style
      }, [(l = i.value) == null ? void 0 : l.map((r) => p(M$, r, null)), a.value.length > 1 && p(pt, {
        icon: "$unfold",
        size: "x-small",
        variant: "plain",
        onClick: () => {
          const r = a.value.findIndex((s) => s.name === e.mode);
          n("update:mode", a.value[(r + 1) % a.value.length].name);
        }
      }, null)]);
    }), {};
  }
}), N2 = Symbol.for("vuetify:v-slider");
function Oh(e, t, n) {
  const a = n === "vertical", i = t.getBoundingClientRect(), l = "touches" in e ? e.touches[0] : e;
  return a ? l.clientY - (i.top + i.height / 2) : l.clientX - (i.left + i.width / 2);
}
function L$(e, t) {
  return "touches" in e && e.touches.length ? e.touches[0][t] : "changedTouches" in e && e.changedTouches.length ? e.changedTouches[0][t] : e[t];
}
const h8 = le({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  readonly: {
    type: Boolean,
    default: null
  },
  max: {
    type: [Number, String],
    default: 100
  },
  min: {
    type: [Number, String],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 0
  },
  thumbColor: String,
  thumbLabel: {
    type: [Boolean, String],
    default: void 0,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  thumbSize: {
    type: [Number, String],
    default: 20
  },
  showTicks: {
    type: [Boolean, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  ticks: {
    type: [Array, Object]
  },
  tickSize: {
    type: [Number, String],
    default: 2
  },
  color: String,
  trackColor: String,
  trackFillColor: String,
  trackSize: {
    type: [Number, String],
    default: 4
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  reverse: Boolean,
  ...Dt(),
  ...Pn({
    elevation: 2
  }),
  ripple: {
    type: Boolean,
    default: !0
  }
}, "Slider"), m8 = (e) => {
  const t = k(() => parseFloat(e.min)), n = k(() => parseFloat(e.max)), a = k(() => +e.step > 0 ? parseFloat(e.step) : 0), i = k(() => Math.max(Av(a.value), Av(t.value)));
  function l(r) {
    if (r = parseFloat(r), a.value <= 0) return r;
    const s = ln(r, t.value, n.value), o = t.value % a.value, u = Math.round((s - o) / a.value) * a.value + o;
    return parseFloat(Math.min(u, n.value).toFixed(i.value));
  }
  return {
    min: t,
    max: n,
    step: a,
    decimals: i,
    roundValue: l
  };
}, v8 = (e) => {
  let {
    props: t,
    steps: n,
    onSliderStart: a,
    onSliderMove: i,
    onSliderEnd: l,
    getActiveThumb: r
  } = e;
  const {
    isRtl: s
  } = xn(), o = ue(t, "reverse"), u = k(() => t.direction === "vertical"), c = k(() => u.value !== o.value), {
    min: d,
    max: f,
    step: h,
    decimals: m,
    roundValue: g
  } = n, v = k(() => parseInt(t.thumbSize, 10)), y = k(() => parseInt(t.tickSize, 10)), b = k(() => parseInt(t.trackSize, 10)), C = k(() => (f.value - d.value) / h.value), S = ue(t, "disabled"), x = k(() => t.error || t.disabled ? void 0 : t.thumbColor ?? t.color), w = k(() => t.error || t.disabled ? void 0 : t.trackColor ?? t.color), V = k(() => t.error || t.disabled ? void 0 : t.trackFillColor ?? t.color), _ = Ve(!1), O = Ve(0), $ = Y(), P = Y();
  function M(E) {
    var H;
    const Q = t.direction === "vertical", W = Q ? "top" : "left", se = Q ? "height" : "width", Se = Q ? "clientY" : "clientX", {
      [W]: U,
      [se]: ne
    } = (H = $.value) == null ? void 0 : H.$el.getBoundingClientRect(), K = L$(E, Se);
    let te = Math.min(Math.max((K - U - O.value) / ne, 0), 1) || 0;
    return (Q ? c.value : c.value !== s.value) && (te = 1 - te), g(d.value + te * (f.value - d.value));
  }
  const T = (E) => {
    l({
      value: M(E)
    }), _.value = !1, O.value = 0;
  }, L = (E) => {
    P.value = r(E), P.value && (P.value.focus(), _.value = !0, P.value.contains(E.target) ? O.value = Oh(E, P.value, t.direction) : (O.value = 0, i({
      value: M(E)
    })), a({
      value: M(E)
    }));
  }, A = {
    passive: !0,
    capture: !0
  };
  function D(E) {
    i({
      value: M(E)
    });
  }
  function B(E) {
    E.stopPropagation(), E.preventDefault(), T(E), window.removeEventListener("mousemove", D, A), window.removeEventListener("mouseup", B);
  }
  function j(E) {
    var Q;
    T(E), window.removeEventListener("touchmove", D, A), (Q = E.target) == null || Q.removeEventListener("touchend", j);
  }
  function I(E) {
    var Q;
    L(E), window.addEventListener("touchmove", D, A), (Q = E.target) == null || Q.addEventListener("touchend", j, {
      passive: !1
    });
  }
  function Z(E) {
    E.preventDefault(), L(E), window.addEventListener("mousemove", D, A), window.addEventListener("mouseup", B, {
      passive: !1
    });
  }
  const R = (E) => {
    const Q = (E - d.value) / (f.value - d.value) * 100;
    return ln(isNaN(Q) ? 0 : Q, 0, 100);
  }, J = ue(t, "showTicks"), F = k(() => J.value ? t.ticks ? Array.isArray(t.ticks) ? t.ticks.map((E) => ({
    value: E,
    position: R(E),
    label: E.toString()
  })) : Object.keys(t.ticks).map((E) => ({
    value: parseFloat(E),
    position: R(parseFloat(E)),
    label: t.ticks[E]
  })) : C.value !== 1 / 0 ? bi(C.value + 1).map((E) => {
    const Q = d.value + E * h.value;
    return {
      value: Q,
      position: R(Q)
    };
  }) : [] : []), q = k(() => F.value.some((E) => {
    let {
      label: Q
    } = E;
    return !!Q;
  })), z = {
    activeThumbRef: P,
    color: ue(t, "color"),
    decimals: m,
    disabled: S,
    direction: ue(t, "direction"),
    elevation: ue(t, "elevation"),
    hasLabels: q,
    isReversed: o,
    indexFromEnd: c,
    min: d,
    max: f,
    mousePressed: _,
    numTicks: C,
    onSliderMousedown: Z,
    onSliderTouchstart: I,
    parsedTicks: F,
    parseMouseMove: M,
    position: R,
    readonly: ue(t, "readonly"),
    rounded: ue(t, "rounded"),
    roundValue: g,
    showTicks: J,
    startOffset: O,
    step: h,
    thumbSize: v,
    thumbColor: x,
    thumbLabel: ue(t, "thumbLabel"),
    ticks: ue(t, "ticks"),
    tickSize: y,
    trackColor: w,
    trackContainerRef: $,
    trackFillColor: V,
    trackSize: b,
    vertical: u
  };
  return Tt(N2, z), z;
}, Q$ = le({
  focused: Boolean,
  max: {
    type: Number,
    required: !0
  },
  min: {
    type: Number,
    required: !0
  },
  modelValue: {
    type: Number,
    required: !0
  },
  position: {
    type: Number,
    required: !0
  },
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  name: String,
  ...Ae()
}, "VSliderThumb"), bh = ve()({
  name: "VSliderThumb",
  directives: {
    Ripple: nl
  },
  props: Q$(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const i = ct(N2), {
      isRtl: l,
      rtlClasses: r
    } = xn();
    if (!i) throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
    const {
      thumbColor: s,
      step: o,
      disabled: u,
      thumbSize: c,
      thumbLabel: d,
      direction: f,
      isReversed: h,
      vertical: m,
      readonly: g,
      elevation: v,
      mousePressed: y,
      decimals: b,
      indexFromEnd: C
    } = i, S = k(() => u.value ? void 0 : v.value), {
      elevationClasses: x
    } = Zn(S), {
      textColorClasses: w,
      textColorStyles: V
    } = zn(s), {
      pageup: _,
      pagedown: O,
      end: $,
      home: P,
      left: M,
      right: T,
      down: L,
      up: A
    } = Uf, D = [_, O, $, P, M, T, L, A], B = k(() => o.value ? [1, 2, 3] : [1, 5, 10]);
    function j(Z, R) {
      if (!D.includes(Z.key)) return;
      Z.preventDefault();
      const J = o.value || 0.1, F = (e.max - e.min) / J;
      if ([M, T, L, A].includes(Z.key)) {
        const z = (m.value ? [l.value ? M : T, h.value ? L : A] : C.value !== l.value ? [M, A] : [T, A]).includes(Z.key) ? 1 : -1, E = Z.shiftKey ? 2 : Z.ctrlKey ? 1 : 0;
        R = R + z * J * B.value[E];
      } else if (Z.key === P)
        R = e.min;
      else if (Z.key === $)
        R = e.max;
      else {
        const q = Z.key === O ? 1 : -1;
        R = R - q * J * (F > 100 ? F / 10 : 10);
      }
      return Math.max(e.min, Math.min(e.max, R));
    }
    function I(Z) {
      const R = j(Z, e.modelValue);
      R != null && a("update:modelValue", R);
    }
    return ye(() => {
      const Z = Qe(C.value ? 100 - e.position : e.position, "%");
      return p("div", {
        class: ["v-slider-thumb", {
          "v-slider-thumb--focused": e.focused,
          "v-slider-thumb--pressed": e.focused && y.value
        }, e.class, r.value],
        style: [{
          "--v-slider-thumb-position": Z,
          "--v-slider-thumb-size": Qe(c.value)
        }, e.style],
        role: "slider",
        tabindex: u.value ? -1 : 0,
        "aria-label": e.name,
        "aria-valuemin": e.min,
        "aria-valuemax": e.max,
        "aria-valuenow": e.modelValue,
        "aria-readonly": !!g.value,
        "aria-orientation": f.value,
        onKeydown: g.value ? void 0 : I
      }, [p("div", {
        class: ["v-slider-thumb__surface", w.value, x.value],
        style: {
          ...V.value
        }
      }, null), Ct(p("div", {
        class: ["v-slider-thumb__ripple", w.value],
        style: V.value
      }, null), [[xa("ripple"), e.ripple, null, {
        circle: !0,
        center: !0
      }]]), p(_2, {
        origin: "bottom center"
      }, {
        default: () => {
          var R;
          return [Ct(p("div", {
            class: "v-slider-thumb__label-container"
          }, [p("div", {
            class: ["v-slider-thumb__label"]
          }, [p("div", null, [((R = n["thumb-label"]) == null ? void 0 : R.call(n, {
            modelValue: e.modelValue
          })) ?? e.modelValue.toFixed(o.value ? b.value : 1)])])]), [[Dn, d.value && e.focused || d.value === "always"]])];
        }
      })]);
    }), {};
  }
}), A$ = le({
  start: {
    type: Number,
    required: !0
  },
  stop: {
    type: Number,
    required: !0
  },
  ...Ae()
}, "VSliderTrack"), g8 = ve()({
  name: "VSliderTrack",
  props: A$(),
  emits: {},
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = ct(N2);
    if (!a) throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
    const {
      color: i,
      parsedTicks: l,
      rounded: r,
      showTicks: s,
      tickSize: o,
      trackColor: u,
      trackFillColor: c,
      trackSize: d,
      vertical: f,
      min: h,
      max: m,
      indexFromEnd: g
    } = a, {
      roundedClasses: v
    } = qt(r), {
      backgroundColorClasses: y,
      backgroundColorStyles: b
    } = kt(c), {
      backgroundColorClasses: C,
      backgroundColorStyles: S
    } = kt(u), x = k(() => `inset-${f.value ? "block" : "inline"}-${g.value ? "end" : "start"}`), w = k(() => f.value ? "height" : "width"), V = k(() => ({
      [x.value]: "0%",
      [w.value]: "100%"
    })), _ = k(() => e.stop - e.start), O = k(() => ({
      [x.value]: Qe(e.start, "%"),
      [w.value]: Qe(_.value, "%")
    })), $ = k(() => s.value ? (f.value ? l.value.slice().reverse() : l.value).map((M, T) => {
      var A;
      const L = M.value !== h.value && M.value !== m.value ? Qe(M.position, "%") : void 0;
      return p("div", {
        key: M.value,
        class: ["v-slider-track__tick", {
          "v-slider-track__tick--filled": M.position >= e.start && M.position <= e.stop,
          "v-slider-track__tick--first": M.value === h.value,
          "v-slider-track__tick--last": M.value === m.value
        }],
        style: {
          [x.value]: L
        }
      }, [(M.label || n["tick-label"]) && p("div", {
        class: "v-slider-track__tick-label"
      }, [((A = n["tick-label"]) == null ? void 0 : A.call(n, {
        tick: M,
        index: T
      })) ?? M.label])]);
    }) : []);
    return ye(() => p("div", {
      class: ["v-slider-track", v.value, e.class],
      style: [{
        "--v-slider-track-size": Qe(d.value),
        "--v-slider-tick-size": Qe(o.value)
      }, e.style]
    }, [p("div", {
      class: ["v-slider-track__background", C.value, {
        "v-slider-track__background--opacity": !!i.value || !c.value
      }],
      style: {
        ...V.value,
        ...S.value
      }
    }, null), p("div", {
      class: ["v-slider-track__fill", y.value],
      style: {
        ...O.value,
        ...b.value
      }
    }, null), s.value && p("div", {
      class: ["v-slider-track__ticks", {
        "v-slider-track__ticks--always-show": s.value === "always"
      }]
    }, [$.value])])), {};
  }
}), D$ = le({
  ...ku(),
  ...h8(),
  ...ll(),
  modelValue: {
    type: [Number, String],
    default: 0
  }
}, "VSlider"), Ch = ve()({
  name: "VSlider",
  props: D$(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    start: (e) => !0,
    end: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const i = Y(), {
      rtlClasses: l
    } = xn(), r = m8(e), s = Fe(e, "modelValue", void 0, (w) => r.roundValue(w ?? r.min.value)), {
      min: o,
      max: u,
      mousePressed: c,
      roundValue: d,
      onSliderMousedown: f,
      onSliderTouchstart: h,
      trackContainerRef: m,
      position: g,
      hasLabels: v,
      readonly: y
    } = v8({
      props: e,
      steps: r,
      onSliderStart: () => {
        a("start", s.value);
      },
      onSliderEnd: (w) => {
        let {
          value: V
        } = w;
        const _ = d(V);
        s.value = _, a("end", _);
      },
      onSliderMove: (w) => {
        let {
          value: V
        } = w;
        return s.value = d(V);
      },
      getActiveThumb: () => {
        var w;
        return (w = i.value) == null ? void 0 : w.$el;
      }
    }), {
      isFocused: b,
      focus: C,
      blur: S
    } = il(e), x = k(() => g(s.value));
    return ye(() => {
      const w = Fn.filterProps(e), V = !!(e.label || n.label || n.prepend);
      return p(Fn, fe({
        class: ["v-slider", {
          "v-slider--has-labels": !!n["tick-label"] || v.value,
          "v-slider--focused": b.value,
          "v-slider--pressed": c.value,
          "v-slider--disabled": e.disabled
        }, l.value, e.class],
        style: e.style
      }, w, {
        focused: b.value
      }), {
        ...n,
        prepend: V ? (_) => {
          var O, $;
          return p(ge, null, [((O = n.label) == null ? void 0 : O.call(n, _)) ?? (e.label ? p(Us, {
            id: _.id.value,
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), ($ = n.prepend) == null ? void 0 : $.call(n, _)]);
        } : void 0,
        default: (_) => {
          let {
            id: O,
            messagesId: $
          } = _;
          return p("div", {
            class: "v-slider__container",
            onMousedown: y.value ? void 0 : f,
            onTouchstartPassive: y.value ? void 0 : h
          }, [p("input", {
            id: O.value,
            name: e.name || O.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: s.value
          }, null), p(g8, {
            ref: m,
            start: 0,
            stop: x.value
          }, {
            "tick-label": n["tick-label"]
          }), p(bh, {
            ref: i,
            "aria-describedby": $.value,
            focused: b.value,
            min: o.value,
            max: u.value,
            modelValue: s.value,
            "onUpdate:modelValue": (P) => s.value = P,
            position: x.value,
            elevation: e.elevation,
            onFocus: C,
            onBlur: S,
            ripple: e.ripple,
            name: e.name
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), {};
  }
}), R$ = le({
  color: {
    type: Object
  },
  disabled: Boolean,
  hideAlpha: Boolean,
  ...Ae()
}, "VColorPickerPreview"), I$ = Pa({
  name: "VColorPickerPreview",
  props: R$(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const a = new AbortController();
    ni(() => a.abort());
    async function i() {
      if (!Vv) return;
      const l = new window.EyeDropper();
      try {
        const r = await l.open({
          signal: a.signal
        }), s = x5(r.sRGBHex);
        n("update:color", {
          ...e.color ?? ls,
          ...s
        });
      } catch {
      }
    }
    return ye(() => {
      var l, r;
      return p("div", {
        class: ["v-color-picker-preview", {
          "v-color-picker-preview--hide-alpha": e.hideAlpha
        }, e.class],
        style: e.style
      }, [Vv && p("div", {
        class: "v-color-picker-preview__eye-dropper",
        key: "eyeDropper"
      }, [p(pt, {
        onClick: i,
        icon: "$eyeDropper",
        variant: "plain",
        density: "comfortable"
      }, null)]), p("div", {
        class: "v-color-picker-preview__dot"
      }, [p("div", {
        style: {
          background: w5(e.color ?? ls)
        }
      }, null)]), p("div", {
        class: "v-color-picker-preview__sliders"
      }, [p(Ch, {
        class: "v-color-picker-preview__track v-color-picker-preview__hue",
        modelValue: (l = e.color) == null ? void 0 : l.h,
        "onUpdate:modelValue": (s) => n("update:color", {
          ...e.color ?? ls,
          h: s
        }),
        step: 0,
        min: 0,
        max: 360,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null), !e.hideAlpha && p(Ch, {
        class: "v-color-picker-preview__track v-color-picker-preview__alpha",
        modelValue: ((r = e.color) == null ? void 0 : r.a) ?? 1,
        "onUpdate:modelValue": (s) => n("update:color", {
          ...e.color ?? ls,
          a: s
        }),
        step: 1 / 256,
        min: 0,
        max: 1,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null)])]);
    }), {};
  }
}), B$ = {
  base: "#f44336",
  lighten5: "#ffebee",
  lighten4: "#ffcdd2",
  lighten3: "#ef9a9a",
  lighten2: "#e57373",
  lighten1: "#ef5350",
  darken1: "#e53935",
  darken2: "#d32f2f",
  darken3: "#c62828",
  darken4: "#b71c1c",
  accent1: "#ff8a80",
  accent2: "#ff5252",
  accent3: "#ff1744",
  accent4: "#d50000"
}, Z$ = {
  base: "#e91e63",
  lighten5: "#fce4ec",
  lighten4: "#f8bbd0",
  lighten3: "#f48fb1",
  lighten2: "#f06292",
  lighten1: "#ec407a",
  darken1: "#d81b60",
  darken2: "#c2185b",
  darken3: "#ad1457",
  darken4: "#880e4f",
  accent1: "#ff80ab",
  accent2: "#ff4081",
  accent3: "#f50057",
  accent4: "#c51162"
}, E$ = {
  base: "#9c27b0",
  lighten5: "#f3e5f5",
  lighten4: "#e1bee7",
  lighten3: "#ce93d8",
  lighten2: "#ba68c8",
  lighten1: "#ab47bc",
  darken1: "#8e24aa",
  darken2: "#7b1fa2",
  darken3: "#6a1b9a",
  darken4: "#4a148c",
  accent1: "#ea80fc",
  accent2: "#e040fb",
  accent3: "#d500f9",
  accent4: "#aa00ff"
}, N$ = {
  base: "#673ab7",
  lighten5: "#ede7f6",
  lighten4: "#d1c4e9",
  lighten3: "#b39ddb",
  lighten2: "#9575cd",
  lighten1: "#7e57c2",
  darken1: "#5e35b1",
  darken2: "#512da8",
  darken3: "#4527a0",
  darken4: "#311b92",
  accent1: "#b388ff",
  accent2: "#7c4dff",
  accent3: "#651fff",
  accent4: "#6200ea"
}, H$ = {
  base: "#3f51b5",
  lighten5: "#e8eaf6",
  lighten4: "#c5cae9",
  lighten3: "#9fa8da",
  lighten2: "#7986cb",
  lighten1: "#5c6bc0",
  darken1: "#3949ab",
  darken2: "#303f9f",
  darken3: "#283593",
  darken4: "#1a237e",
  accent1: "#8c9eff",
  accent2: "#536dfe",
  accent3: "#3d5afe",
  accent4: "#304ffe"
}, j$ = {
  base: "#2196f3",
  lighten5: "#e3f2fd",
  lighten4: "#bbdefb",
  lighten3: "#90caf9",
  lighten2: "#64b5f6",
  lighten1: "#42a5f5",
  darken1: "#1e88e5",
  darken2: "#1976d2",
  darken3: "#1565c0",
  darken4: "#0d47a1",
  accent1: "#82b1ff",
  accent2: "#448aff",
  accent3: "#2979ff",
  accent4: "#2962ff"
}, z$ = {
  base: "#03a9f4",
  lighten5: "#e1f5fe",
  lighten4: "#b3e5fc",
  lighten3: "#81d4fa",
  lighten2: "#4fc3f7",
  lighten1: "#29b6f6",
  darken1: "#039be5",
  darken2: "#0288d1",
  darken3: "#0277bd",
  darken4: "#01579b",
  accent1: "#80d8ff",
  accent2: "#40c4ff",
  accent3: "#00b0ff",
  accent4: "#0091ea"
}, F$ = {
  base: "#00bcd4",
  lighten5: "#e0f7fa",
  lighten4: "#b2ebf2",
  lighten3: "#80deea",
  lighten2: "#4dd0e1",
  lighten1: "#26c6da",
  darken1: "#00acc1",
  darken2: "#0097a7",
  darken3: "#00838f",
  darken4: "#006064",
  accent1: "#84ffff",
  accent2: "#18ffff",
  accent3: "#00e5ff",
  accent4: "#00b8d4"
}, X$ = {
  base: "#009688",
  lighten5: "#e0f2f1",
  lighten4: "#b2dfdb",
  lighten3: "#80cbc4",
  lighten2: "#4db6ac",
  lighten1: "#26a69a",
  darken1: "#00897b",
  darken2: "#00796b",
  darken3: "#00695c",
  darken4: "#004d40",
  accent1: "#a7ffeb",
  accent2: "#64ffda",
  accent3: "#1de9b6",
  accent4: "#00bfa5"
}, Y$ = {
  base: "#4caf50",
  lighten5: "#e8f5e9",
  lighten4: "#c8e6c9",
  lighten3: "#a5d6a7",
  lighten2: "#81c784",
  lighten1: "#66bb6a",
  darken1: "#43a047",
  darken2: "#388e3c",
  darken3: "#2e7d32",
  darken4: "#1b5e20",
  accent1: "#b9f6ca",
  accent2: "#69f0ae",
  accent3: "#00e676",
  accent4: "#00c853"
}, W$ = {
  base: "#8bc34a",
  lighten5: "#f1f8e9",
  lighten4: "#dcedc8",
  lighten3: "#c5e1a5",
  lighten2: "#aed581",
  lighten1: "#9ccc65",
  darken1: "#7cb342",
  darken2: "#689f38",
  darken3: "#558b2f",
  darken4: "#33691e",
  accent1: "#ccff90",
  accent2: "#b2ff59",
  accent3: "#76ff03",
  accent4: "#64dd17"
}, q$ = {
  base: "#cddc39",
  lighten5: "#f9fbe7",
  lighten4: "#f0f4c3",
  lighten3: "#e6ee9c",
  lighten2: "#dce775",
  lighten1: "#d4e157",
  darken1: "#c0ca33",
  darken2: "#afb42b",
  darken3: "#9e9d24",
  darken4: "#827717",
  accent1: "#f4ff81",
  accent2: "#eeff41",
  accent3: "#c6ff00",
  accent4: "#aeea00"
}, U$ = {
  base: "#ffeb3b",
  lighten5: "#fffde7",
  lighten4: "#fff9c4",
  lighten3: "#fff59d",
  lighten2: "#fff176",
  lighten1: "#ffee58",
  darken1: "#fdd835",
  darken2: "#fbc02d",
  darken3: "#f9a825",
  darken4: "#f57f17",
  accent1: "#ffff8d",
  accent2: "#ffff00",
  accent3: "#ffea00",
  accent4: "#ffd600"
}, G$ = {
  base: "#ffc107",
  lighten5: "#fff8e1",
  lighten4: "#ffecb3",
  lighten3: "#ffe082",
  lighten2: "#ffd54f",
  lighten1: "#ffca28",
  darken1: "#ffb300",
  darken2: "#ffa000",
  darken3: "#ff8f00",
  darken4: "#ff6f00",
  accent1: "#ffe57f",
  accent2: "#ffd740",
  accent3: "#ffc400",
  accent4: "#ffab00"
}, K$ = {
  base: "#ff9800",
  lighten5: "#fff3e0",
  lighten4: "#ffe0b2",
  lighten3: "#ffcc80",
  lighten2: "#ffb74d",
  lighten1: "#ffa726",
  darken1: "#fb8c00",
  darken2: "#f57c00",
  darken3: "#ef6c00",
  darken4: "#e65100",
  accent1: "#ffd180",
  accent2: "#ffab40",
  accent3: "#ff9100",
  accent4: "#ff6d00"
}, J$ = {
  base: "#ff5722",
  lighten5: "#fbe9e7",
  lighten4: "#ffccbc",
  lighten3: "#ffab91",
  lighten2: "#ff8a65",
  lighten1: "#ff7043",
  darken1: "#f4511e",
  darken2: "#e64a19",
  darken3: "#d84315",
  darken4: "#bf360c",
  accent1: "#ff9e80",
  accent2: "#ff6e40",
  accent3: "#ff3d00",
  accent4: "#dd2c00"
}, e_ = {
  base: "#795548",
  lighten5: "#efebe9",
  lighten4: "#d7ccc8",
  lighten3: "#bcaaa4",
  lighten2: "#a1887f",
  lighten1: "#8d6e63",
  darken1: "#6d4c41",
  darken2: "#5d4037",
  darken3: "#4e342e",
  darken4: "#3e2723"
}, t_ = {
  base: "#607d8b",
  lighten5: "#eceff1",
  lighten4: "#cfd8dc",
  lighten3: "#b0bec5",
  lighten2: "#90a4ae",
  lighten1: "#78909c",
  darken1: "#546e7a",
  darken2: "#455a64",
  darken3: "#37474f",
  darken4: "#263238"
}, n_ = {
  base: "#9e9e9e",
  lighten5: "#fafafa",
  lighten4: "#f5f5f5",
  lighten3: "#eeeeee",
  lighten2: "#e0e0e0",
  lighten1: "#bdbdbd",
  darken1: "#757575",
  darken2: "#616161",
  darken3: "#424242",
  darken4: "#212121"
}, a_ = {
  black: "#000000",
  white: "#ffffff",
  transparent: "#ffffff00"
}, i_ = {
  red: B$,
  pink: Z$,
  purple: E$,
  deepPurple: N$,
  indigo: H$,
  blue: j$,
  lightBlue: z$,
  cyan: F$,
  teal: X$,
  green: Y$,
  lightGreen: W$,
  lime: q$,
  yellow: U$,
  amber: G$,
  orange: K$,
  deepOrange: J$,
  brown: e_,
  blueGrey: t_,
  grey: n_,
  shades: a_
}, l_ = le({
  swatches: {
    type: Array,
    default: () => r_(i_)
  },
  disabled: Boolean,
  color: Object,
  maxHeight: [Number, String],
  ...Ae()
}, "VColorPickerSwatches");
function r_(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return n.base ? [n.base, n.darken4, n.darken3, n.darken2, n.darken1, n.lighten1, n.lighten2, n.lighten3, n.lighten4, n.lighten5] : [n.black, n.white, n.transparent];
  });
}
const s_ = Pa({
  name: "VColorPickerSwatches",
  props: l_(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    return ye(() => p("div", {
      class: ["v-color-picker-swatches", e.class],
      style: [{
        maxHeight: Qe(e.maxHeight)
      }, e.style]
    }, [p("div", null, [e.swatches.map((a) => p("div", {
      class: "v-color-picker-swatches__swatch"
    }, [a.map((i) => {
      const l = Ta(i), r = Ed(l), s = C5(l);
      return p("div", {
        class: "v-color-picker-swatches__color",
        onClick: () => r && n("update:color", r)
      }, [p("div", {
        style: {
          background: s
        }
      }, [e.color && Qi(e.color, r) ? p(vt, {
        size: "x-small",
        icon: "$success",
        color: tk(i, "#FFFFFF") > 2 ? "white" : "black"
      }, null) : void 0])]);
    })]))])])), {};
  }
}), i1 = le({
  color: String,
  ...ya(),
  ...Ae(),
  ...vn(),
  ...Pn(),
  ...al(),
  ...Ws(),
  ...Dt(),
  ...nt(),
  ...dt()
}, "VSheet"), br = ve()({
  name: "VSheet",
  props: i1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e), {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = kt(ue(e, "color")), {
      borderClasses: r
    } = _a(e), {
      dimensionStyles: s
    } = gn(e), {
      elevationClasses: o
    } = Zn(e), {
      locationStyles: u
    } = Hr(e), {
      positionClasses: c
    } = qs(e), {
      roundedClasses: d
    } = qt(e);
    return ye(() => p(e.tag, {
      class: ["v-sheet", a.value, i.value, r.value, o.value, c.value, d.value, e.class],
      style: [l.value, s.value, u.value, e.style]
    }, n)), {};
  }
}), o_ = le({
  canvasHeight: {
    type: [String, Number],
    default: 150
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  hideCanvas: Boolean,
  hideSliders: Boolean,
  hideInputs: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(cr).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(cr),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(cr).includes(t))
  },
  showSwatches: Boolean,
  swatches: Array,
  swatchesMaxHeight: {
    type: [Number, String],
    default: 150
  },
  modelValue: {
    type: [Object, String]
  },
  ...hn(i1({
    width: 300
  }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
}, "VColorPicker"), u_ = Pa({
  name: "VColorPicker",
  props: o_(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e) {
    const t = Fe(e, "mode"), n = Y(null), a = Fe(e, "modelValue", void 0, (o) => {
      if (o == null || o === "") return null;
      let u;
      try {
        u = Ed(Ta(o));
      } catch (c) {
        return Wa(c), null;
      }
      return u;
    }, (o) => o ? x$(o, e.modelValue) : null), i = k(() => a.value ? {
      ...a.value,
      h: n.value ?? a.value.h
    } : null), {
      rtlClasses: l
    } = xn();
    let r = !0;
    pe(a, (o) => {
      if (!r) {
        r = !0;
        return;
      }
      o && (n.value = o.h);
    }, {
      immediate: !0
    });
    const s = (o) => {
      r = !1, n.value = o.h, a.value = o;
    };
    return rt(() => {
      e.modes.includes(t.value) || (t.value = e.modes[0]);
    }), Yt({
      VSlider: {
        color: void 0,
        trackColor: void 0,
        trackFillColor: void 0
      }
    }), ye(() => {
      const o = br.filterProps(e);
      return p(br, fe({
        rounded: e.rounded,
        elevation: e.elevation,
        theme: e.theme,
        class: ["v-color-picker", l.value, e.class],
        style: [{
          "--v-color-picker-color-hsv": w5({
            ...i.value ?? ls,
            a: 1
          })
        }, e.style]
      }, o, {
        maxWidth: e.width
      }), {
        default: () => [!e.hideCanvas && p(k$, {
          key: "canvas",
          color: i.value,
          "onUpdate:color": s,
          disabled: e.disabled,
          dotSize: e.dotSize,
          width: e.width,
          height: e.canvasHeight
        }, null), (!e.hideSliders || !e.hideInputs) && p("div", {
          key: "controls",
          class: "v-color-picker__controls"
        }, [!e.hideSliders && p(I$, {
          key: "preview",
          color: i.value,
          "onUpdate:color": s,
          hideAlpha: !t.value.endsWith("a"),
          disabled: e.disabled
        }, null), !e.hideInputs && p(T$, {
          key: "edit",
          modes: e.modes,
          mode: t.value,
          "onUpdate:mode": (u) => t.value = u,
          color: i.value,
          "onUpdate:color": s,
          disabled: e.disabled
        }, null)]), e.showSwatches && p(s_, {
          key: "swatches",
          color: i.value,
          "onUpdate:color": s,
          maxHeight: e.swatchesMaxHeight,
          swatches: e.swatches,
          disabled: e.disabled
        }, null)]
      });
    }), {};
  }
});
function c_(e, t, n) {
  if (t == null) return e;
  if (Array.isArray(t)) throw new Error("Multiple matches is not implemented");
  return typeof t == "number" && ~t ? p(ge, null, [p("span", {
    class: "v-combobox__unmask"
  }, [e.substr(0, t)]), p("span", {
    class: "v-combobox__mask"
  }, [e.substr(t, n)]), p("span", {
    class: "v-combobox__unmask"
  }, [e.substr(t + n)])]) : e;
}
const d_ = le({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: {
    type: Boolean,
    default: !0
  },
  delimiters: Array,
  ...Pu({
    filterKeys: ["title"]
  }),
  ...Z2({
    hideNoData: !0,
    returnObject: !0
  }),
  ...hn(e1({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...ai({
    transition: !1
  })
}, "VCombobox"), f_ = ve()({
  name: "VCombobox",
  props: d_(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:search": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    var ne;
    let {
      emit: n,
      slots: a
    } = t;
    const {
      t: i
    } = tn(), l = Y(), r = Ve(!1), s = Ve(!0), o = Ve(!1), u = Y(), c = Y(), d = Fe(e, "menu"), f = k({
      get: () => d.value,
      set: (K) => {
        var te;
        d.value && !K && ((te = u.value) != null && te.ΨopenChildren.size) || (d.value = K);
      }
    }), h = Ve(-1);
    let m = !1;
    const g = k(() => {
      var K;
      return (K = l.value) == null ? void 0 : K.color;
    }), v = k(() => f.value ? e.closeText : e.openText), {
      items: y,
      transformIn: b,
      transformOut: C
    } = R2(e), {
      textColorClasses: S,
      textColorStyles: x
    } = zn(g), w = Fe(e, "modelValue", [], (K) => b(Ht(K)), (K) => {
      const te = C(K);
      return e.multiple ? te : te[0] ?? null;
    }), V = Gd(), _ = k(() => !!(e.chips || a.chip)), O = k(() => _.value || !!a.selection), $ = Ve(!e.multiple && !O.value ? ((ne = w.value[0]) == null ? void 0 : ne.title) ?? "" : ""), P = k({
      get: () => $.value,
      set: (K) => {
        var te;
        if ($.value = K ?? "", !e.multiple && !O.value && (w.value = [pl(e, K)]), K && e.multiple && ((te = e.delimiters) != null && te.length)) {
          const H = K.split(new RegExp(`(?:${e.delimiters.join("|")})+`));
          H.length > 1 && (H.forEach((ce) => {
            ce = ce.trim(), ce && W(pl(e, ce));
          }), $.value = "");
        }
        K || (h.value = -1), s.value = !K;
      }
    }), M = k(() => typeof e.counterValue == "function" ? e.counterValue(w.value) : typeof e.counterValue == "number" ? e.counterValue : e.multiple ? w.value.length : P.value.length);
    pe($, (K) => {
      m ? et(() => m = !1) : r.value && !f.value && (f.value = !0), n("update:search", K);
    }), pe(w, (K) => {
      var te;
      !e.multiple && !O.value && ($.value = ((te = K[0]) == null ? void 0 : te.title) ?? "");
    });
    const {
      filteredItems: T,
      getMatches: L
    } = $u(e, y, () => s.value ? "" : P.value), A = k(() => e.hideSelected ? T.value.filter((K) => !w.value.some((te) => te.value === K.value)) : T.value), D = k(() => w.value.map((K) => K.value)), B = k(() => {
      var te;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && P.value === ((te = A.value[0]) == null ? void 0 : te.title)) && A.value.length > 0 && !s.value && !o.value;
    }), j = k(() => e.hideNoData && !A.value.length || e.readonly || (V == null ? void 0 : V.isReadonly.value)), I = Y(), Z = B2(I, l);
    function R(K) {
      m = !0, e.openOnClear && (f.value = !0);
    }
    function J() {
      j.value || (f.value = !0);
    }
    function F(K) {
      j.value || (r.value && (K.preventDefault(), K.stopPropagation()), f.value = !f.value);
    }
    function q(K) {
      var te;
      zc(K) && ((te = l.value) == null || te.focus());
    }
    function z(K) {
      var ce;
      if (Sw(K) || e.readonly || V != null && V.isReadonly.value) return;
      const te = l.value.selectionStart, H = w.value.length;
      if ((h.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(K.key)) && K.preventDefault(), ["Enter", "ArrowDown"].includes(K.key) && (f.value = !0), ["Escape"].includes(K.key) && (f.value = !1), ["Enter", "Escape", "Tab"].includes(K.key) && (B.value && ["Enter", "Tab"].includes(K.key) && !w.value.some((he) => {
        let {
          value: Oe
        } = he;
        return Oe === A.value[0].value;
      }) && W(T.value[0]), s.value = !0), K.key === "ArrowDown" && B.value && ((ce = I.value) == null || ce.focus("next")), K.key === "Enter" && P.value && (W(pl(e, P.value)), O.value && ($.value = "")), ["Backspace", "Delete"].includes(K.key)) {
        if (!e.multiple && O.value && w.value.length > 0 && !P.value) return W(w.value[0], !1);
        if (~h.value) {
          const he = h.value;
          W(w.value[h.value], !1), h.value = he >= H - 1 ? H - 2 : he;
        } else K.key === "Backspace" && !P.value && (h.value = H - 1);
      }
      if (e.multiple) {
        if (K.key === "ArrowLeft") {
          if (h.value < 0 && te > 0) return;
          const he = h.value > -1 ? h.value - 1 : H - 1;
          w.value[he] ? h.value = he : (h.value = -1, l.value.setSelectionRange(P.value.length, P.value.length));
        }
        if (K.key === "ArrowRight") {
          if (h.value < 0) return;
          const he = h.value + 1;
          w.value[he] ? h.value = he : (h.value = -1, l.value.setSelectionRange(0, 0));
        }
      }
    }
    function E() {
      var K;
      e.eager && ((K = c.value) == null || K.calculateVisibleItems());
    }
    function Q() {
      var K;
      r.value && (s.value = !0, (K = l.value) == null || K.focus());
    }
    function W(K) {
      let te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!K || K.props.disabled))
        if (e.multiple) {
          const H = w.value.findIndex((he) => e.valueComparator(he.value, K.value)), ce = te ?? !~H;
          if (~H) {
            const he = ce ? [...w.value, K] : [...w.value];
            he.splice(H, 1), w.value = he;
          } else ce && (w.value = [...w.value, K]);
          e.clearOnSelect && (P.value = "");
        } else {
          const H = te !== !1;
          w.value = H ? [K] : [], $.value = H && !O.value ? K.title : "", et(() => {
            f.value = !1, s.value = !0;
          });
        }
    }
    function se(K) {
      r.value = !0, setTimeout(() => {
        o.value = !0;
      });
    }
    function Se(K) {
      o.value = !1;
    }
    function U(K) {
      (K == null || K === "" && !e.multiple && !O.value) && (w.value = []);
    }
    return pe(r, (K, te) => {
      if (!(K || K === te) && (h.value = -1, f.value = !1, P.value)) {
        if (e.multiple) {
          W(pl(e, P.value));
          return;
        }
        if (!O.value) return;
        w.value.some((H) => {
          let {
            title: ce
          } = H;
          return ce === P.value;
        }) ? $.value = "" : W(pl(e, P.value));
      }
    }), pe(f, () => {
      if (!e.hideSelected && f.value && w.value.length) {
        const K = A.value.findIndex((te) => w.value.some((H) => e.valueComparator(H.value, te.value)));
        bt && window.requestAnimationFrame(() => {
          var te;
          K >= 0 && ((te = c.value) == null || te.scrollToIndex(K));
        });
      }
    }), pe(() => e.items, (K, te) => {
      f.value || r.value && !te.length && K.length && (f.value = !0);
    }), ye(() => {
      const K = !!(!e.hideNoData || A.value.length || a["prepend-item"] || a["append-item"] || a["no-data"]), te = w.value.length > 0, H = pr.filterProps(e);
      return p(pr, fe({
        ref: l
      }, H, {
        modelValue: P.value,
        "onUpdate:modelValue": [(ce) => P.value = ce, U],
        focused: r.value,
        "onUpdate:focused": (ce) => r.value = ce,
        validationValue: w.externalValue,
        counterValue: M.value,
        dirty: te,
        class: ["v-combobox", {
          "v-combobox--active-menu": f.value,
          "v-combobox--chips": !!e.chips,
          "v-combobox--selection-slot": !!O.value,
          "v-combobox--selecting-index": h.value > -1,
          [`v-combobox--${e.multiple ? "multiple" : "single"}`]: !0
        }, e.class],
        style: e.style,
        readonly: e.readonly,
        placeholder: te ? void 0 : e.placeholder,
        "onClick:clear": R,
        "onMousedown:control": J,
        onKeydown: z
      }), {
        ...a,
        default: () => p(ge, null, [p(ws, fe({
          ref: u,
          modelValue: f.value,
          "onUpdate:modelValue": (ce) => f.value = ce,
          activator: "parent",
          contentClass: "v-combobox__content",
          disabled: j.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: E,
          onAfterLeave: Q
        }, e.menuProps), {
          default: () => [K && p(Kd, fe({
            ref: I,
            selected: D.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (ce) => ce.preventDefault(),
            onKeydown: q,
            onFocusin: se,
            onFocusout: Se,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, Z, e.listProps), {
            default: () => {
              var ce, he, Oe;
              return [(ce = a["prepend-item"]) == null ? void 0 : ce.call(a), !A.value.length && !e.hideNoData && (((he = a["no-data"]) == null ? void 0 : he.call(a)) ?? p(Ui, {
                title: i(e.noDataText)
              }, null)), p(t1, {
                ref: c,
                renderless: !0,
                items: A.value
              }, {
                default: (je) => {
                  var Me;
                  let {
                    item: be,
                    index: Te,
                    itemRef: Be
                  } = je;
                  const oe = fe(be.props, {
                    ref: Be,
                    key: Te,
                    active: B.value && Te === 0 ? !0 : void 0,
                    onClick: () => W(be, null)
                  });
                  return ((Me = a.item) == null ? void 0 : Me.call(a, {
                    item: be,
                    index: Te,
                    props: oe
                  })) ?? p(Ui, fe(oe, {
                    role: "option"
                  }), {
                    prepend: (Xe) => {
                      let {
                        isSelected: Ke
                      } = Xe;
                      return p(ge, null, [e.multiple && !e.hideSelected ? p(qi, {
                        key: be.value,
                        modelValue: Ke,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, be.props.prependAvatar && p(Da, {
                        image: be.props.prependAvatar
                      }, null), be.props.prependIcon && p(vt, {
                        icon: be.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var Xe, Ke;
                      return s.value ? be.title : c_(be.title, (Xe = L(be)) == null ? void 0 : Xe.title, ((Ke = P.value) == null ? void 0 : Ke.length) ?? 0);
                    }
                  });
                }
              }), (Oe = a["append-item"]) == null ? void 0 : Oe.call(a)];
            }
          })]
        }), w.value.map((ce, he) => {
          function Oe(Be) {
            Be.stopPropagation(), Be.preventDefault(), W(ce, !1);
          }
          const je = {
            "onClick:close": Oe,
            onKeydown(Be) {
              Be.key !== "Enter" && Be.key !== " " || (Be.preventDefault(), Be.stopPropagation(), Oe(Be));
            },
            onMousedown(Be) {
              Be.preventDefault(), Be.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, be = _.value ? !!a.chip : !!a.selection, Te = be ? Zd(_.value ? a.chip({
            item: ce,
            index: he,
            props: je
          }) : a.selection({
            item: ce,
            index: he
          })) : void 0;
          if (!(be && !Te))
            return p("div", {
              key: ce.value,
              class: ["v-combobox__selection", he === h.value && ["v-combobox__selection--selected", S.value]],
              style: he === h.value ? x.value : {}
            }, [_.value ? a.chip ? p(lt, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: ce.title
                }
              }
            }, {
              default: () => [Te]
            }) : p(Gs, fe({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: ce.title,
              disabled: ce.props.disabled
            }, je), null) : Te ?? p("span", {
              class: "v-combobox__selection-text"
            }, [ce.title, e.multiple && he < w.value.length - 1 && p("span", {
              class: "v-combobox__selection-comma"
            }, [Ee(",")])])]);
        })]),
        "append-inner": function() {
          var je;
          for (var ce = arguments.length, he = new Array(ce), Oe = 0; Oe < ce; Oe++)
            he[Oe] = arguments[Oe];
          return p(ge, null, [(je = a["append-inner"]) == null ? void 0 : je.call(a, ...he), (!e.hideNoData || e.items.length) && e.menuIcon ? p(vt, {
            class: "v-combobox__menu-icon",
            icon: e.menuIcon,
            onMousedown: F,
            onClick: m5,
            "aria-label": i(v.value),
            title: i(v.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Ea({
      isFocused: r,
      isPristine: s,
      menu: f,
      search: P,
      selectionIndex: h,
      filteredItems: T,
      select: W
    }, l);
  }
}), h_ = le({
  modelValue: null,
  color: String,
  cancelText: {
    type: String,
    default: "$vuetify.confirmEdit.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.confirmEdit.ok"
  }
}, "VConfirmEdit"), m_ = ve()({
  name: "VConfirmEdit",
  props: h_(),
  emits: {
    cancel: () => !0,
    save: (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const i = Fe(e, "modelValue"), l = Y();
    jt(() => {
      l.value = structuredClone(At(i.value));
    });
    const {
      t: r
    } = tn(), s = k(() => Qi(i.value, l.value));
    function o() {
      i.value = l.value, n("save", l.value);
    }
    function u() {
      l.value = structuredClone(At(i.value)), n("cancel");
    }
    let c = !1;
    return ye(() => {
      var f;
      const d = p(ge, null, [p(pt, {
        disabled: s.value,
        variant: "text",
        color: e.color,
        onClick: u,
        text: r(e.cancelText)
      }, null), p(pt, {
        disabled: s.value,
        variant: "text",
        color: e.color,
        onClick: o,
        text: r(e.okText)
      }, null)]);
      return p(ge, null, [(f = a.default) == null ? void 0 : f.call(a, {
        model: l,
        save: o,
        cancel: u,
        isPristine: s.value,
        get actions() {
          return c = !0, d;
        }
      }), !c && d]);
    }), {
      save: o,
      cancel: u,
      isPristine: s
    };
  }
}), p8 = le({
  expandOnClick: Boolean,
  showExpand: Boolean,
  expanded: {
    type: Array,
    default: () => []
  }
}, "DataTable-expand"), y8 = Symbol.for("vuetify:datatable:expanded");
function l1(e) {
  const t = ue(e, "expandOnClick"), n = Fe(e, "expanded", e.expanded, (s) => new Set(s), (s) => [...s.values()]);
  function a(s, o) {
    const u = new Set(n.value);
    o ? u.add(s.value) : u.delete(s.value), n.value = u;
  }
  function i(s) {
    return n.value.has(s.value);
  }
  function l(s) {
    a(s, !i(s));
  }
  const r = {
    expand: a,
    expanded: n,
    expandOnClick: t,
    isExpanded: i,
    toggleExpand: l
  };
  return Tt(y8, r), r;
}
function O8() {
  const e = ct(y8);
  if (!e) throw new Error("foo");
  return e;
}
const H2 = le({
  groupBy: {
    type: Array,
    default: () => []
  }
}, "DataTable-group"), b8 = Symbol.for("vuetify:data-table-group");
function j2(e) {
  return {
    groupBy: Fe(e, "groupBy")
  };
}
function r1(e) {
  const {
    disableSort: t,
    groupBy: n,
    sortBy: a
  } = e, i = Y(/* @__PURE__ */ new Set()), l = k(() => n.value.map((c) => ({
    ...c,
    order: c.order ?? !1
  })).concat(t != null && t.value ? [] : a.value));
  function r(c) {
    return i.value.has(c.id);
  }
  function s(c) {
    const d = new Set(i.value);
    r(c) ? d.delete(c.id) : d.add(c.id), i.value = d;
  }
  function o(c) {
    function d(f) {
      const h = [];
      for (const m of f.items)
        "type" in m && m.type === "group" ? h.push(...d(m)) : h.push(m);
      return h;
    }
    return d({
      items: c
    });
  }
  const u = {
    sortByWithGroups: l,
    toggleGroup: s,
    opened: i,
    groupBy: n,
    extractRows: o,
    isGroupOpen: r
  };
  return Tt(b8, u), u;
}
function C8() {
  const e = ct(b8);
  if (!e) throw new Error("Missing group!");
  return e;
}
function v_(e, t) {
  if (!e.length) return [];
  const n = /* @__PURE__ */ new Map();
  for (const a of e) {
    const i = gr(a.raw, t);
    n.has(i) || n.set(i, []), n.get(i).push(a);
  }
  return n;
}
function w8(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
  if (!t.length) return [];
  const i = v_(e, t[0]), l = [], r = t.slice(1);
  return i.forEach((s, o) => {
    const u = t[0], c = `${a}_${u}_${o}`;
    l.push({
      depth: n,
      id: c,
      key: u,
      value: o,
      items: r.length ? w8(s, r, n + 1, c) : s,
      type: "group"
    });
  }), l;
}
function k8(e, t) {
  const n = [];
  for (const a of e)
    "type" in a && a.type === "group" ? (a.value != null && n.push(a), (t.has(a.id) || a.value == null) && n.push(...k8(a.items, t))) : n.push(a);
  return n;
}
function s1(e, t, n) {
  return {
    flatItems: k(() => {
      if (!t.value.length) return e.value;
      const i = w8(e.value, t.value.map((l) => l.key));
      return k8(i, n.value);
    })
  };
}
function o1(e) {
  let {
    page: t,
    itemsPerPage: n,
    sortBy: a,
    groupBy: i,
    search: l
  } = e;
  const r = Wt("VDataTable"), s = k(() => ({
    page: t.value,
    itemsPerPage: n.value,
    sortBy: a.value,
    groupBy: i.value,
    search: l.value
  }));
  let o = null;
  pe(s, () => {
    Qi(o, s.value) || (o && o.search !== s.value.search && (t.value = 1), r.emit("update:options", s.value), o = s.value);
  }, {
    deep: !0,
    immediate: !0
  });
}
const z2 = le({
  page: {
    type: [Number, String],
    default: 1
  },
  itemsPerPage: {
    type: [Number, String],
    default: 10
  }
}, "DataTable-paginate"), S8 = Symbol.for("vuetify:data-table-pagination");
function F2(e) {
  const t = Fe(e, "page", void 0, (a) => +(a ?? 1)), n = Fe(e, "itemsPerPage", void 0, (a) => +(a ?? 10));
  return {
    page: t,
    itemsPerPage: n
  };
}
function X2(e) {
  const {
    page: t,
    itemsPerPage: n,
    itemsLength: a
  } = e, i = k(() => n.value === -1 ? 0 : n.value * (t.value - 1)), l = k(() => n.value === -1 ? a.value : Math.min(a.value, i.value + n.value)), r = k(() => n.value === -1 || a.value === 0 ? 1 : Math.ceil(a.value / n.value));
  jt(() => {
    t.value > r.value && (t.value = r.value);
  });
  function s(f) {
    n.value = f, t.value = 1;
  }
  function o() {
    t.value = ln(t.value + 1, 1, r.value);
  }
  function u() {
    t.value = ln(t.value - 1, 1, r.value);
  }
  function c(f) {
    t.value = ln(f, 1, r.value);
  }
  const d = {
    page: t,
    itemsPerPage: n,
    startIndex: i,
    stopIndex: l,
    pageCount: r,
    itemsLength: a,
    nextPage: o,
    prevPage: u,
    setPage: c,
    setItemsPerPage: s
  };
  return Tt(S8, d), d;
}
function g_() {
  const e = ct(S8);
  if (!e) throw new Error("Missing pagination!");
  return e;
}
function x8(e) {
  const t = Wt("usePaginatedItems"), {
    items: n,
    startIndex: a,
    stopIndex: i,
    itemsPerPage: l
  } = e, r = k(() => l.value <= 0 ? n.value : n.value.slice(a.value, i.value));
  return pe(r, (s) => {
    t.emit("update:currentItems", s);
  }), {
    paginatedItems: r
  };
}
const p_ = {
  showSelectAll: !1,
  allSelected: () => [],
  select: (e) => {
    var a;
    let {
      items: t,
      value: n
    } = e;
    return new Set(n ? [(a = t[0]) == null ? void 0 : a.value] : []);
  },
  selectAll: (e) => {
    let {
      selected: t
    } = e;
    return t;
  }
}, P8 = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      currentPage: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: a
    } = e;
    for (const i of t)
      n ? a.add(i.value) : a.delete(i.value);
    return a;
  },
  selectAll: (e) => {
    let {
      value: t,
      currentPage: n,
      selected: a
    } = e;
    return P8.select({
      items: n,
      value: t,
      selected: a
    });
  }
}, $8 = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      allItems: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: a
    } = e;
    for (const i of t)
      n ? a.add(i.value) : a.delete(i.value);
    return a;
  },
  selectAll: (e) => {
    let {
      value: t,
      allItems: n,
      selected: a
    } = e;
    return $8.select({
      items: n,
      value: t,
      selected: a
    });
  }
}, _8 = le({
  showSelect: Boolean,
  selectStrategy: {
    type: [String, Object],
    default: "page"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  valueComparator: {
    type: Function,
    default: Qi
  }
}, "DataTable-select"), M8 = Symbol.for("vuetify:data-table-selection");
function u1(e, t) {
  let {
    allItems: n,
    currentPage: a
  } = t;
  const i = Fe(e, "modelValue", e.modelValue, (y) => new Set(Ht(y).map((b) => {
    var C;
    return ((C = n.value.find((S) => e.valueComparator(b, S.value))) == null ? void 0 : C.value) ?? b;
  })), (y) => [...y.values()]), l = k(() => n.value.filter((y) => y.selectable)), r = k(() => a.value.filter((y) => y.selectable)), s = k(() => {
    if (typeof e.selectStrategy == "object") return e.selectStrategy;
    switch (e.selectStrategy) {
      case "single":
        return p_;
      case "all":
        return $8;
      case "page":
      default:
        return P8;
    }
  });
  function o(y) {
    return Ht(y).every((b) => i.value.has(b.value));
  }
  function u(y) {
    return Ht(y).some((b) => i.value.has(b.value));
  }
  function c(y, b) {
    const C = s.value.select({
      items: y,
      value: b,
      selected: new Set(i.value)
    });
    i.value = C;
  }
  function d(y) {
    c([y], !o([y]));
  }
  function f(y) {
    const b = s.value.selectAll({
      value: y,
      allItems: l.value,
      currentPage: r.value,
      selected: new Set(i.value)
    });
    i.value = b;
  }
  const h = k(() => i.value.size > 0), m = k(() => {
    const y = s.value.allSelected({
      allItems: l.value,
      currentPage: r.value
    });
    return !!y.length && o(y);
  }), g = k(() => s.value.showSelectAll), v = {
    toggleSelect: d,
    select: c,
    selectAll: f,
    isSelected: o,
    isSomeSelected: u,
    someSelected: h,
    allSelected: m,
    showSelectAll: g
  };
  return Tt(M8, v), v;
}
function c1() {
  const e = ct(M8);
  if (!e) throw new Error("Missing selection!");
  return e;
}
const V8 = le({
  sortBy: {
    type: Array,
    default: () => []
  },
  customKeySort: Object,
  multiSort: Boolean,
  mustSort: Boolean
}, "DataTable-sort"), T8 = Symbol.for("vuetify:data-table-sort");
function d1(e) {
  const t = Fe(e, "sortBy"), n = ue(e, "mustSort"), a = ue(e, "multiSort");
  return {
    sortBy: t,
    mustSort: n,
    multiSort: a
  };
}
function f1(e) {
  const {
    sortBy: t,
    mustSort: n,
    multiSort: a,
    page: i
  } = e, l = (o) => {
    if (o.key == null) return;
    let u = t.value.map((d) => ({
      ...d
    })) ?? [];
    const c = u.find((d) => d.key === o.key);
    c ? c.order === "desc" ? n.value ? c.order = "asc" : u = u.filter((d) => d.key !== o.key) : c.order = "desc" : a.value ? u = [...u, {
      key: o.key,
      order: "asc"
    }] : u = [{
      key: o.key,
      order: "asc"
    }], t.value = u, i && (i.value = 1);
  };
  function r(o) {
    return !!t.value.find((u) => u.key === o.key);
  }
  const s = {
    sortBy: t,
    toggleSort: l,
    isSorted: r
  };
  return Tt(T8, s), s;
}
function L8() {
  const e = ct(T8);
  if (!e) throw new Error("Missing sort!");
  return e;
}
function Y2(e, t, n, a) {
  const i = tn();
  return {
    sortedItems: k(() => {
      var r, s;
      return n.value.length ? y_(t.value, n.value, i.current.value, {
        transform: a == null ? void 0 : a.transform,
        sortFunctions: {
          ...e.customKeySort,
          ...(r = a == null ? void 0 : a.sortFunctions) == null ? void 0 : r.value
        },
        sortRawFunctions: (s = a == null ? void 0 : a.sortRawFunctions) == null ? void 0 : s.value
      }) : t.value;
    })
  };
}
function y_(e, t, n, a) {
  const i = new Intl.Collator(n, {
    sensitivity: "accent",
    usage: "sort"
  });
  return e.map((r) => [r, a != null && a.transform ? a.transform(r) : r]).sort((r, s) => {
    var o, u;
    for (let c = 0; c < t.length; c++) {
      let d = !1;
      const f = t[c].key, h = t[c].order ?? "asc";
      if (h === !1) continue;
      let m = gr(r[1], f), g = gr(s[1], f), v = r[0].raw, y = s[0].raw;
      if (h === "desc" && ([m, g] = [g, m], [v, y] = [y, v]), (o = a == null ? void 0 : a.sortRawFunctions) != null && o[f]) {
        const b = a.sortRawFunctions[f](v, y);
        if (b == null) continue;
        if (d = !0, b) return b;
      }
      if ((u = a == null ? void 0 : a.sortFunctions) != null && u[f]) {
        const b = a.sortFunctions[f](m, g);
        if (b == null) continue;
        if (d = !0, b) return b;
      }
      if (!d) {
        if (m instanceof Date && g instanceof Date)
          return m.getTime() - g.getTime();
        if ([m, g] = [m, g].map((b) => b != null ? b.toString().toLocaleLowerCase() : b), m !== g)
          return zu(m) && zu(g) ? 0 : zu(m) ? -1 : zu(g) ? 1 : !isNaN(m) && !isNaN(g) ? Number(m) - Number(g) : i.compare(m, g);
      }
    }
    return 0;
  }).map((r) => {
    let [s] = r;
    return s;
  });
}
const O_ = le({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  returnObject: Boolean
}, "DataIterator-items");
function b_(e, t) {
  const n = e.returnObject ? t : bn(t, e.itemValue), a = bn(t, e.itemSelectable, !0);
  return {
    type: "item",
    value: n,
    selectable: a,
    raw: t
  };
}
function C_(e, t) {
  const n = [];
  for (const a of t)
    n.push(b_(e, a));
  return n;
}
function w_(e) {
  return {
    items: k(() => C_(e, e.items))
  };
}
const k_ = le({
  search: String,
  loading: Boolean,
  ...Ae(),
  ...O_(),
  ..._8(),
  ...V8(),
  ...z2({
    itemsPerPage: 5
  }),
  ...p8(),
  ...H2(),
  ...Pu(),
  ...nt(),
  ...ai({
    transition: {
      component: No,
      hideOnLeave: !0
    }
  })
}, "VDataIterator"), S_ = ve()({
  name: "VDataIterator",
  props: k_(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "groupBy"), i = ue(e, "search"), {
      items: l
    } = w_(e), {
      filteredItems: r
    } = $u(e, l, i, {
      transform: (R) => R.raw
    }), {
      sortBy: s,
      multiSort: o,
      mustSort: u
    } = d1(e), {
      page: c,
      itemsPerPage: d
    } = F2(e), {
      toggleSort: f
    } = f1({
      sortBy: s,
      multiSort: o,
      mustSort: u,
      page: c
    }), {
      sortByWithGroups: h,
      opened: m,
      extractRows: g,
      isGroupOpen: v,
      toggleGroup: y
    } = r1({
      groupBy: a,
      sortBy: s
    }), {
      sortedItems: b
    } = Y2(e, r, h, {
      transform: (R) => R.raw
    }), {
      flatItems: C
    } = s1(b, a, m), S = k(() => C.value.length), {
      startIndex: x,
      stopIndex: w,
      pageCount: V,
      prevPage: _,
      nextPage: O,
      setItemsPerPage: $,
      setPage: P
    } = X2({
      page: c,
      itemsPerPage: d,
      itemsLength: S
    }), {
      paginatedItems: M
    } = x8({
      items: C,
      startIndex: x,
      stopIndex: w,
      itemsPerPage: d
    }), T = k(() => g(M.value)), {
      isSelected: L,
      select: A,
      selectAll: D,
      toggleSelect: B
    } = u1(e, {
      allItems: l,
      currentPage: T
    }), {
      isExpanded: j,
      toggleExpand: I
    } = l1(e);
    o1({
      page: c,
      itemsPerPage: d,
      sortBy: s,
      groupBy: a,
      search: i
    });
    const Z = k(() => ({
      page: c.value,
      itemsPerPage: d.value,
      sortBy: s.value,
      pageCount: V.value,
      toggleSort: f,
      prevPage: _,
      nextPage: O,
      setPage: P,
      setItemsPerPage: $,
      isSelected: L,
      select: A,
      selectAll: D,
      toggleSelect: B,
      isExpanded: j,
      toggleExpand: I,
      isGroupOpen: v,
      toggleGroup: y,
      items: T.value,
      groupedItems: M.value
    }));
    return ye(() => p(e.tag, {
      class: ["v-data-iterator", {
        "v-data-iterator--loading": e.loading
      }, e.class],
      style: e.style
    }, {
      default: () => {
        var R, J;
        return [(R = n.header) == null ? void 0 : R.call(n, Z.value), p(Kn, {
          transition: e.transition
        }, {
          default: () => {
            var F, q;
            return [e.loading ? p(wu, {
              key: "loader",
              name: "v-data-iterator",
              active: !0
            }, {
              default: (z) => {
                var E;
                return (E = n.loader) == null ? void 0 : E.call(n, z);
              }
            }) : p("div", {
              key: "items"
            }, [M.value.length ? (q = n.default) == null ? void 0 : q.call(n, Z.value) : (F = n["no-data"]) == null ? void 0 : F.call(n)])];
          }
        }), (J = n.footer) == null ? void 0 : J.call(n, Z.value)];
      }
    })), {};
  }
});
function x_() {
  const e = Y([]);
  G4(() => e.value = []);
  function t(n, a) {
    e.value[a] = n;
  }
  return {
    refs: e,
    updateRef: t
  };
}
const P_ = le({
  activeColor: String,
  start: {
    type: [Number, String],
    default: 1
  },
  modelValue: {
    type: Number,
    default: (e) => e.start
  },
  disabled: Boolean,
  length: {
    type: [Number, String],
    default: 1,
    validator: (e) => e % 1 === 0
  },
  totalVisible: [Number, String],
  firstIcon: {
    type: Ue,
    default: "$first"
  },
  prevIcon: {
    type: Ue,
    default: "$prev"
  },
  nextIcon: {
    type: Ue,
    default: "$next"
  },
  lastIcon: {
    type: Ue,
    default: "$last"
  },
  ariaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.root"
  },
  pageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.page"
  },
  currentPageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.currentPage"
  },
  firstAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.first"
  },
  previousAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.previous"
  },
  nextAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.next"
  },
  lastAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.last"
  },
  ellipsis: {
    type: String,
    default: "..."
  },
  showFirstLastPage: Boolean,
  ...ya(),
  ...Ae(),
  ...Ln(),
  ...Pn(),
  ...Dt(),
  ...Ri(),
  ...nt({
    tag: "nav"
  }),
  ...dt(),
  ...Na({
    variant: "text"
  })
}, "VPagination"), wh = ve()({
  name: "VPagination",
  props: P_(),
  emits: {
    "update:modelValue": (e) => !0,
    first: (e) => !0,
    prev: (e) => !0,
    next: (e) => !0,
    last: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const i = Fe(e, "modelValue"), {
      t: l,
      n: r
    } = tn(), {
      isRtl: s
    } = xn(), {
      themeClasses: o
    } = yt(e), {
      width: u
    } = Za(), c = Ve(-1);
    Yt(void 0, {
      scoped: !0
    });
    const {
      resizeRef: d
    } = Ga((_) => {
      if (!_.length) return;
      const {
        target: O,
        contentRect: $
      } = _[0], P = O.querySelector(".v-pagination__list > *");
      if (!P) return;
      const M = $.width, T = P.offsetWidth + parseFloat(getComputedStyle(P).marginRight) * 2;
      c.value = g(M, T);
    }), f = k(() => parseInt(e.length, 10)), h = k(() => parseInt(e.start, 10)), m = k(() => e.totalVisible != null ? parseInt(e.totalVisible, 10) : c.value >= 0 ? c.value : g(u.value, 58));
    function g(_, O) {
      const $ = e.showFirstLastPage ? 5 : 3;
      return Math.max(0, Math.floor(
        // Round to two decimal places to avoid floating point errors
        +((_ - O * $) / O).toFixed(2)
      ));
    }
    const v = k(() => {
      if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER) return [];
      if (m.value <= 0) return [];
      if (m.value === 1) return [i.value];
      if (f.value <= m.value)
        return bi(f.value, h.value);
      const _ = m.value % 2 === 0, O = _ ? m.value / 2 : Math.floor(m.value / 2), $ = _ ? O : O + 1, P = f.value - O;
      if ($ - i.value >= 0)
        return [...bi(Math.max(1, m.value - 1), h.value), e.ellipsis, f.value];
      if (i.value - P >= (_ ? 1 : 0)) {
        const M = m.value - 1, T = f.value - M + h.value;
        return [h.value, e.ellipsis, ...bi(M, T)];
      } else {
        const M = Math.max(1, m.value - 3), T = M === 1 ? i.value : i.value - Math.ceil(M / 2) + h.value;
        return [h.value, e.ellipsis, ...bi(M, T), e.ellipsis, f.value];
      }
    });
    function y(_, O, $) {
      _.preventDefault(), i.value = O, $ && a($, O);
    }
    const {
      refs: b,
      updateRef: C
    } = x_();
    Yt({
      VPaginationBtn: {
        color: ue(e, "color"),
        border: ue(e, "border"),
        density: ue(e, "density"),
        size: ue(e, "size"),
        variant: ue(e, "variant"),
        rounded: ue(e, "rounded"),
        elevation: ue(e, "elevation")
      }
    });
    const S = k(() => v.value.map((_, O) => {
      const $ = (P) => C(P, O);
      if (typeof _ == "string")
        return {
          isActive: !1,
          key: `ellipsis-${O}`,
          page: _,
          props: {
            ref: $,
            ellipsis: !0,
            icon: !0,
            disabled: !0
          }
        };
      {
        const P = _ === i.value;
        return {
          isActive: P,
          key: _,
          page: r(_),
          props: {
            ref: $,
            ellipsis: !1,
            icon: !0,
            disabled: !!e.disabled || +e.length < 2,
            color: P ? e.activeColor : e.color,
            "aria-current": P,
            "aria-label": l(P ? e.currentPageAriaLabel : e.pageAriaLabel, _),
            onClick: (M) => y(M, _)
          }
        };
      }
    })), x = k(() => {
      const _ = !!e.disabled || i.value <= h.value, O = !!e.disabled || i.value >= h.value + f.value - 1;
      return {
        first: e.showFirstLastPage ? {
          icon: s.value ? e.lastIcon : e.firstIcon,
          onClick: ($) => y($, h.value, "first"),
          disabled: _,
          "aria-label": l(e.firstAriaLabel),
          "aria-disabled": _
        } : void 0,
        prev: {
          icon: s.value ? e.nextIcon : e.prevIcon,
          onClick: ($) => y($, i.value - 1, "prev"),
          disabled: _,
          "aria-label": l(e.previousAriaLabel),
          "aria-disabled": _
        },
        next: {
          icon: s.value ? e.prevIcon : e.nextIcon,
          onClick: ($) => y($, i.value + 1, "next"),
          disabled: O,
          "aria-label": l(e.nextAriaLabel),
          "aria-disabled": O
        },
        last: e.showFirstLastPage ? {
          icon: s.value ? e.firstIcon : e.lastIcon,
          onClick: ($) => y($, h.value + f.value - 1, "last"),
          disabled: O,
          "aria-label": l(e.lastAriaLabel),
          "aria-disabled": O
        } : void 0
      };
    });
    function w() {
      var O;
      const _ = i.value - h.value;
      (O = b.value[_]) == null || O.$el.focus();
    }
    function V(_) {
      _.key === Uf.left && !e.disabled && i.value > +e.start ? (i.value = i.value - 1, et(w)) : _.key === Uf.right && !e.disabled && i.value < h.value + f.value - 1 && (i.value = i.value + 1, et(w));
    }
    return ye(() => p(e.tag, {
      ref: d,
      class: ["v-pagination", o.value, e.class],
      style: e.style,
      role: "navigation",
      "aria-label": l(e.ariaLabel),
      onKeydown: V,
      "data-test": "v-pagination-root"
    }, {
      default: () => [p("ul", {
        class: "v-pagination__list"
      }, [e.showFirstLastPage && p("li", {
        key: "first",
        class: "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [n.first ? n.first(x.value.first) : p(pt, fe({
        _as: "VPaginationBtn"
      }, x.value.first), null)]), p("li", {
        key: "prev",
        class: "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [n.prev ? n.prev(x.value.prev) : p(pt, fe({
        _as: "VPaginationBtn"
      }, x.value.prev), null)]), S.value.map((_, O) => p("li", {
        key: _.key,
        class: ["v-pagination__item", {
          "v-pagination__item--is-active": _.isActive
        }],
        "data-test": "v-pagination-item"
      }, [n.item ? n.item(_) : p(pt, fe({
        _as: "VPaginationBtn"
      }, _.props), {
        default: () => [_.page]
      })])), p("li", {
        key: "next",
        class: "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [n.next ? n.next(x.value.next) : p(pt, fe({
        _as: "VPaginationBtn"
      }, x.value.next), null)]), e.showFirstLastPage && p("li", {
        key: "last",
        class: "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [n.last ? n.last(x.value.last) : p(pt, fe({
        _as: "VPaginationBtn"
      }, x.value.last), null)])])]
    })), {};
  }
}), W2 = le({
  prevIcon: {
    type: Ue,
    default: "$prev"
  },
  nextIcon: {
    type: Ue,
    default: "$next"
  },
  firstIcon: {
    type: Ue,
    default: "$first"
  },
  lastIcon: {
    type: Ue,
    default: "$last"
  },
  itemsPerPageText: {
    type: String,
    default: "$vuetify.dataFooter.itemsPerPageText"
  },
  pageText: {
    type: String,
    default: "$vuetify.dataFooter.pageText"
  },
  firstPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.firstPage"
  },
  prevPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.prevPage"
  },
  nextPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.nextPage"
  },
  lastPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.lastPage"
  },
  itemsPerPageOptions: {
    type: Array,
    default: () => [{
      value: 10,
      title: "10"
    }, {
      value: 25,
      title: "25"
    }, {
      value: 50,
      title: "50"
    }, {
      value: 100,
      title: "100"
    }, {
      value: -1,
      title: "$vuetify.dataFooter.itemsPerPageAll"
    }]
  },
  showCurrentPage: Boolean
}, "VDataTableFooter"), Fo = ve()({
  name: "VDataTableFooter",
  props: W2(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = tn(), {
      page: i,
      pageCount: l,
      startIndex: r,
      stopIndex: s,
      itemsLength: o,
      itemsPerPage: u,
      setItemsPerPage: c
    } = g_(), d = k(() => e.itemsPerPageOptions.map((f) => typeof f == "number" ? {
      value: f,
      title: f === -1 ? a("$vuetify.dataFooter.itemsPerPageAll") : String(f)
    } : {
      ...f,
      title: isNaN(Number(f.title)) ? a(f.title) : f.title
    }));
    return ye(() => {
      var h;
      const f = wh.filterProps(e);
      return p("div", {
        class: "v-data-table-footer"
      }, [(h = n.prepend) == null ? void 0 : h.call(n), p("div", {
        class: "v-data-table-footer__items-per-page"
      }, [p("span", null, [a(e.itemsPerPageText)]), p(E2, {
        items: d.value,
        modelValue: u.value,
        "onUpdate:modelValue": (m) => c(Number(m)),
        density: "compact",
        variant: "outlined",
        "hide-details": !0
      }, null)]), p("div", {
        class: "v-data-table-footer__info"
      }, [p("div", null, [a(e.pageText, o.value ? r.value + 1 : 0, s.value, o.value)])]), p("div", {
        class: "v-data-table-footer__pagination"
      }, [p(wh, fe({
        modelValue: i.value,
        "onUpdate:modelValue": (m) => i.value = m,
        density: "comfortable",
        "first-aria-label": e.firstPageLabel,
        "last-aria-label": e.lastPageLabel,
        length: l.value,
        "next-aria-label": e.nextPageLabel,
        "previous-aria-label": e.prevPageLabel,
        rounded: !0,
        "show-first-last-page": !0,
        "total-visible": e.showCurrentPage ? 1 : 0,
        variant: "plain"
      }, f), null)])]);
    }), {};
  }
}), Gc = rk({
  align: {
    type: String,
    default: "start"
  },
  fixed: Boolean,
  fixedOffset: [Number, String],
  height: [Number, String],
  lastFixed: Boolean,
  noPadding: Boolean,
  tag: String,
  width: [Number, String],
  maxWidth: [Number, String],
  nowrap: Boolean
}, (e, t) => {
  let {
    slots: n
  } = t;
  const a = e.tag ?? "td";
  return p(a, {
    class: ["v-data-table__td", {
      "v-data-table-column--fixed": e.fixed,
      "v-data-table-column--last-fixed": e.lastFixed,
      "v-data-table-column--no-padding": e.noPadding,
      "v-data-table-column--nowrap": e.nowrap
    }, `v-data-table-column--align-${e.align}`],
    style: {
      height: Qe(e.height),
      width: Qe(e.width),
      maxWidth: Qe(e.maxWidth),
      left: Qe(e.fixedOffset || null)
    }
  }, {
    default: () => {
      var i;
      return [(i = n.default) == null ? void 0 : i.call(n)];
    }
  });
}), $_ = le({
  headers: Array
}, "DataTable-header"), Q8 = Symbol.for("vuetify:data-table-headers"), A8 = {
  title: "",
  sortable: !1
}, __ = {
  ...A8,
  width: 48
};
function M_() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map((n) => ({
    element: n,
    priority: 0
  }));
  return {
    enqueue: (n, a) => {
      let i = !1;
      for (let l = 0; l < t.length; l++)
        if (t[l].priority > a) {
          t.splice(l, 0, {
            element: n,
            priority: a
          }), i = !0;
          break;
        }
      i || t.push({
        element: n,
        priority: a
      });
    },
    size: () => t.length,
    count: () => {
      let n = 0;
      if (!t.length) return 0;
      const a = Math.floor(t[0].priority);
      for (let i = 0; i < t.length; i++)
        Math.floor(t[i].priority) === a && (n += 1);
      return n;
    },
    dequeue: () => t.shift()
  };
}
function kh(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (!e.children)
    t.push(e);
  else
    for (const n of e.children)
      kh(n, t);
  return t;
}
function D8(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
  for (const n of e)
    n.key && t.add(n.key), n.children && D8(n.children, t);
  return t;
}
function V_(e) {
  if (e.key) {
    if (e.key === "data-table-group") return A8;
    if (["data-table-expand", "data-table-select"].includes(e.key)) return __;
  }
}
function q2(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return e.children ? Math.max(t, ...e.children.map((n) => q2(n, t + 1))) : t;
}
function T_(e) {
  let t = !1;
  function n(l) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (l)
      if (r && (l.fixed = !0), l.fixed)
        if (l.children)
          for (let s = l.children.length - 1; s >= 0; s--)
            n(l.children[s], !0);
        else
          t ? isNaN(+l.width) && Fc(`Multiple fixed columns should have a static width (key: ${l.key})`) : l.lastFixed = !0, t = !0;
      else if (l.children)
        for (let s = l.children.length - 1; s >= 0; s--)
          n(l.children[s]);
      else
        t = !1;
  }
  for (let l = e.length - 1; l >= 0; l--)
    n(e[l]);
  function a(l) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!l) return r;
    if (l.children) {
      l.fixedOffset = r;
      for (const s of l.children)
        r = a(s, r);
    } else l.fixed && (l.fixedOffset = r, r += parseFloat(l.width || "0") || 0);
    return r;
  }
  let i = 0;
  for (const l of e)
    i = a(l, i);
}
function L_(e, t) {
  const n = [];
  let a = 0;
  const i = M_(e);
  for (; i.size() > 0; ) {
    let r = i.count();
    const s = [];
    let o = 1;
    for (; r > 0; ) {
      const {
        element: u,
        priority: c
      } = i.dequeue(), d = t - a - q2(u);
      if (s.push({
        ...u,
        rowspan: d ?? 1,
        colspan: u.children ? kh(u).length : 1
      }), u.children)
        for (const f of u.children) {
          const h = c % 1 + o / Math.pow(10, a + 2);
          i.enqueue(f, a + d + h);
        }
      o += 1, r -= 1;
    }
    a += 1, n.push(s);
  }
  return {
    columns: e.map((r) => kh(r)).flat(),
    headers: n
  };
}
function R8(e) {
  const t = [];
  for (const n of e) {
    const a = {
      ...V_(n),
      ...n
    }, i = a.key ?? (typeof a.value == "string" ? a.value : null), l = a.value ?? i ?? null, r = {
      ...a,
      key: i,
      value: l,
      sortable: a.sortable ?? (a.key != null || !!a.sort),
      children: a.children ? R8(a.children) : void 0
    };
    t.push(r);
  }
  return t;
}
function U2(e, t) {
  const n = Y([]), a = Y([]), i = Y({}), l = Y({}), r = Y({});
  jt(() => {
    var g, v, y;
    const u = (e.headers || Object.keys(e.items[0] ?? {}).map((b) => ({
      key: b,
      title: js(b)
    }))).slice(), c = D8(u);
    (g = t == null ? void 0 : t.groupBy) != null && g.value.length && !c.has("data-table-group") && u.unshift({
      key: "data-table-group",
      title: "Group"
    }), (v = t == null ? void 0 : t.showSelect) != null && v.value && !c.has("data-table-select") && u.unshift({
      key: "data-table-select"
    }), (y = t == null ? void 0 : t.showExpand) != null && y.value && !c.has("data-table-expand") && u.push({
      key: "data-table-expand"
    });
    const d = R8(u);
    T_(d);
    const f = Math.max(...d.map((b) => q2(b))) + 1, h = L_(d, f);
    n.value = h.headers, a.value = h.columns;
    const m = h.headers.flat(1);
    for (const b of m)
      b.key && (b.sortable && (b.sort && (i.value[b.key] = b.sort), b.sortRaw && (l.value[b.key] = b.sortRaw)), b.filter && (r.value[b.key] = b.filter));
  });
  const s = {
    headers: n,
    columns: a,
    sortFunctions: i,
    sortRawFunctions: l,
    filterFunctions: r
  };
  return Tt(Q8, s), s;
}
function h1() {
  const e = ct(Q8);
  if (!e) throw new Error("Missing headers!");
  return e;
}
const I8 = le({
  color: String,
  sticky: Boolean,
  disableSort: Boolean,
  multiSort: Boolean,
  sortAscIcon: {
    type: Ue,
    default: "$sortAsc"
  },
  sortDescIcon: {
    type: Ue,
    default: "$sortDesc"
  },
  headerProps: {
    type: Object
  },
  ...Qr(),
  ...Wd()
}, "VDataTableHeaders"), Cr = ve()({
  name: "VDataTableHeaders",
  props: I8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = tn(), {
      toggleSort: i,
      sortBy: l,
      isSorted: r
    } = L8(), {
      someSelected: s,
      allSelected: o,
      selectAll: u,
      showSelectAll: c
    } = c1(), {
      columns: d,
      headers: f
    } = h1(), {
      loaderClasses: h
    } = Cu(e);
    function m(_, O) {
      if (!(!e.sticky && !_.fixed))
        return {
          position: "sticky",
          left: _.fixed ? Qe(_.fixedOffset) : void 0,
          top: e.sticky ? `calc(var(--v-table-header-height) * ${O})` : void 0
        };
    }
    function g(_) {
      const O = l.value.find(($) => $.key === _.key);
      return O ? O.order === "asc" ? e.sortAscIcon : e.sortDescIcon : e.sortAscIcon;
    }
    const {
      backgroundColorClasses: v,
      backgroundColorStyles: y
    } = kt(e, "color"), {
      displayClasses: b,
      mobile: C
    } = Za(e), S = k(() => ({
      headers: f.value,
      columns: d.value,
      toggleSort: i,
      isSorted: r,
      sortBy: l.value,
      someSelected: s.value,
      allSelected: o.value,
      selectAll: u,
      getSortIcon: g
    })), x = k(() => ["v-data-table__th", {
      "v-data-table__th--sticky": e.sticky
    }, b.value, h.value]), w = (_) => {
      let {
        column: O,
        x: $,
        y: P
      } = _;
      const M = O.key === "data-table-select" || O.key === "data-table-expand", T = fe(e.headerProps ?? {}, O.headerProps ?? {});
      return p(Gc, fe({
        tag: "th",
        align: O.align,
        class: [{
          "v-data-table__th--sortable": O.sortable && !e.disableSort,
          "v-data-table__th--sorted": r(O),
          "v-data-table__th--fixed": O.fixed
        }, ...x.value],
        style: {
          width: Qe(O.width),
          minWidth: Qe(O.minWidth),
          maxWidth: Qe(O.maxWidth),
          ...m(O, P)
        },
        colspan: O.colspan,
        rowspan: O.rowspan,
        onClick: O.sortable ? () => i(O) : void 0,
        fixed: O.fixed,
        nowrap: O.nowrap,
        lastFixed: O.lastFixed,
        noPadding: M
      }, T), {
        default: () => {
          var D;
          const L = `header.${O.key}`, A = {
            column: O,
            selectAll: u,
            isSorted: r,
            toggleSort: i,
            sortBy: l.value,
            someSelected: s.value,
            allSelected: o.value,
            getSortIcon: g
          };
          return n[L] ? n[L](A) : O.key === "data-table-select" ? ((D = n["header.data-table-select"]) == null ? void 0 : D.call(n, A)) ?? (c.value && p(qi, {
            modelValue: o.value,
            indeterminate: s.value && !o.value,
            "onUpdate:modelValue": u
          }, null)) : p("div", {
            class: "v-data-table-header__content"
          }, [p("span", null, [O.title]), O.sortable && !e.disableSort && p(vt, {
            key: "icon",
            class: "v-data-table-header__sort-icon",
            icon: g(O)
          }, null), e.multiSort && r(O) && p("div", {
            key: "badge",
            class: ["v-data-table-header__sort-badge", ...v.value],
            style: y.value
          }, [l.value.findIndex((B) => B.key === O.key) + 1])]);
        }
      });
    }, V = () => {
      const _ = fe(e.headerProps ?? {} ?? {}), O = k(() => d.value.filter((P) => (P == null ? void 0 : P.sortable) && !e.disableSort)), $ = k(() => {
        if (d.value.find((M) => M.key === "data-table-select") != null)
          return o.value ? "$checkboxOn" : s.value ? "$checkboxIndeterminate" : "$checkboxOff";
      });
      return p(Gc, fe({
        tag: "th",
        class: [...x.value],
        colspan: f.value.length + 1
      }, _), {
        default: () => [p("div", {
          class: "v-data-table-header__content"
        }, [p(E2, {
          chips: !0,
          class: "v-data-table__td-sort-select",
          clearable: !0,
          density: "default",
          items: O.value,
          label: a("$vuetify.dataTable.sortBy"),
          multiple: e.multiSort,
          variant: "underlined",
          "onClick:clear": () => l.value = [],
          appendIcon: $.value,
          "onClick:append": () => u(!o.value)
        }, {
          ...n,
          chip: (P) => {
            var M;
            return p(Gs, {
              onClick: (M = P.item.raw) != null && M.sortable ? () => i(P.item.raw) : void 0,
              onMousedown: (T) => {
                T.preventDefault(), T.stopPropagation();
              }
            }, {
              default: () => [P.item.title, p(vt, {
                class: ["v-data-table__td-sort-icon", r(P.item.raw) && "v-data-table__td-sort-icon-active"],
                icon: g(P.item.raw),
                size: "small"
              }, null)]
            });
          }
        })])]
      });
    };
    ye(() => C.value ? p("tr", null, [p(V, null, null)]) : p(ge, null, [n.headers ? n.headers(S.value) : f.value.map((_, O) => p("tr", null, [_.map(($, P) => p(w, {
      column: $,
      x: P,
      y: O
    }, null))])), e.loading && p("tr", {
      class: "v-data-table-progress"
    }, [p("th", {
      colspan: d.value.length
    }, [p(wu, {
      name: "v-data-table-progress",
      absolute: !0,
      active: !0,
      color: typeof e.loading == "boolean" ? void 0 : e.loading,
      indeterminate: !0
    }, {
      default: n.loader
    })])])]));
  }
}), Q_ = le({
  item: {
    type: Object,
    required: !0
  }
}, "VDataTableGroupHeaderRow"), A_ = ve()({
  name: "VDataTableGroupHeaderRow",
  props: Q_(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isGroupOpen: a,
      toggleGroup: i,
      extractRows: l
    } = C8(), {
      isSelected: r,
      isSomeSelected: s,
      select: o
    } = c1(), {
      columns: u
    } = h1(), c = k(() => l([e.item]));
    return () => p("tr", {
      class: "v-data-table-group-header-row",
      style: {
        "--v-data-table-group-header-row-depth": e.item.depth
      }
    }, [u.value.map((d) => {
      var f, h;
      if (d.key === "data-table-group") {
        const m = a(e.item) ? "$expand" : "$next", g = () => i(e.item);
        return ((f = n["data-table-group"]) == null ? void 0 : f.call(n, {
          item: e.item,
          count: c.value.length,
          props: {
            icon: m,
            onClick: g
          }
        })) ?? p(Gc, {
          class: "v-data-table-group-header-row__column"
        }, {
          default: () => [p(pt, {
            size: "small",
            variant: "text",
            icon: m,
            onClick: g
          }, null), p("span", null, [e.item.value]), p("span", null, [Ee("("), c.value.length, Ee(")")])]
        });
      }
      if (d.key === "data-table-select") {
        const m = r(c.value), g = s(c.value) && !m, v = (y) => o(c.value, y);
        return ((h = n["data-table-select"]) == null ? void 0 : h.call(n, {
          props: {
            modelValue: m,
            indeterminate: g,
            "onUpdate:modelValue": v
          }
        })) ?? p("td", null, [p(qi, {
          modelValue: m,
          indeterminate: g,
          "onUpdate:modelValue": v
        }, null)]);
      }
      return p("td", null, null);
    })]);
  }
}), D_ = le({
  index: Number,
  item: Object,
  cellProps: [Object, Function],
  onClick: Rn(),
  onContextmenu: Rn(),
  onDblclick: Rn(),
  ...Qr()
}, "VDataTableRow"), G2 = ve()({
  name: "VDataTableRow",
  props: D_(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      displayClasses: a,
      mobile: i
    } = Za(e, "v-data-table__tr"), {
      isSelected: l,
      toggleSelect: r,
      someSelected: s,
      allSelected: o,
      selectAll: u
    } = c1(), {
      isExpanded: c,
      toggleExpand: d
    } = O8(), {
      toggleSort: f,
      sortBy: h,
      isSorted: m
    } = L8(), {
      columns: g
    } = h1();
    ye(() => p("tr", {
      class: ["v-data-table__tr", {
        "v-data-table__tr--clickable": !!(e.onClick || e.onContextmenu || e.onDblclick)
      }, a.value],
      onClick: e.onClick,
      onContextmenu: e.onContextmenu,
      onDblclick: e.onDblclick
    }, [e.item && g.value.map((v, y) => {
      const b = e.item, C = `item.${v.key}`, S = `header.${v.key}`, x = {
        index: e.index,
        item: b.raw,
        internalItem: b,
        value: gr(b.columns, v.key),
        column: v,
        isSelected: l,
        toggleSelect: r,
        isExpanded: c,
        toggleExpand: d
      }, w = {
        column: v,
        selectAll: u,
        isSorted: m,
        toggleSort: f,
        sortBy: h.value,
        someSelected: s.value,
        allSelected: o.value,
        getSortIcon: () => ""
      }, V = typeof e.cellProps == "function" ? e.cellProps({
        index: x.index,
        item: x.item,
        internalItem: x.internalItem,
        value: x.value,
        column: v
      }) : e.cellProps, _ = typeof v.cellProps == "function" ? v.cellProps({
        index: x.index,
        item: x.item,
        internalItem: x.internalItem,
        value: x.value
      }) : v.cellProps;
      return p(Gc, fe({
        align: v.align,
        class: {
          "v-data-table__td--expanded-row": v.key === "data-table-expand",
          "v-data-table__td--select-row": v.key === "data-table-select"
        },
        fixed: v.fixed,
        fixedOffset: v.fixedOffset,
        lastFixed: v.lastFixed,
        maxWidth: i.value ? void 0 : v.maxWidth,
        noPadding: v.key === "data-table-select" || v.key === "data-table-expand",
        nowrap: v.nowrap,
        width: i.value ? void 0 : v.width
      }, V, _), {
        default: () => {
          var $, P, M, T, L;
          if (n[C] && !i.value) return ($ = n[C]) == null ? void 0 : $.call(n, x);
          if (v.key === "data-table-select")
            return ((P = n["item.data-table-select"]) == null ? void 0 : P.call(n, x)) ?? p(qi, {
              disabled: !b.selectable,
              modelValue: l([b]),
              onClick: $t(() => r(b), ["stop"])
            }, null);
          if (v.key === "data-table-expand")
            return ((M = n["item.data-table-expand"]) == null ? void 0 : M.call(n, x)) ?? p(pt, {
              icon: c(b) ? "$collapse" : "$expand",
              size: "small",
              variant: "text",
              onClick: $t(() => d(b), ["stop"])
            }, null);
          const O = xe(x.value);
          return i.value ? p(ge, null, [p("div", {
            class: "v-data-table__td-title"
          }, [((T = n[S]) == null ? void 0 : T.call(n, w)) ?? v.title]), p("div", {
            class: "v-data-table__td-value"
          }, [((L = n[C]) == null ? void 0 : L.call(n, x)) ?? O])]) : O;
        }
      });
    })]));
  }
}), B8 = le({
  loading: [Boolean, String],
  loadingText: {
    type: String,
    default: "$vuetify.dataIterator.loadingText"
  },
  hideNoData: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  ...Qr()
}, "VDataTableRows"), wr = ve()({
  name: "VDataTableRows",
  inheritAttrs: !1,
  props: B8(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      columns: i
    } = h1(), {
      expandOnClick: l,
      toggleExpand: r,
      isExpanded: s
    } = O8(), {
      isSelected: o,
      toggleSelect: u
    } = c1(), {
      toggleGroup: c,
      isGroupOpen: d
    } = C8(), {
      t: f
    } = tn(), {
      mobile: h
    } = Za(e);
    return ye(() => {
      var m, g;
      return e.loading && (!e.items.length || a.loading) ? p("tr", {
        class: "v-data-table-rows-loading",
        key: "loading"
      }, [p("td", {
        colspan: i.value.length
      }, [((m = a.loading) == null ? void 0 : m.call(a)) ?? f(e.loadingText)])]) : !e.loading && !e.items.length && !e.hideNoData ? p("tr", {
        class: "v-data-table-rows-no-data",
        key: "no-data"
      }, [p("td", {
        colspan: i.value.length
      }, [((g = a["no-data"]) == null ? void 0 : g.call(a)) ?? f(e.noDataText)])]) : p(ge, null, [e.items.map((v, y) => {
        var S;
        if (v.type === "group") {
          const x = {
            index: y,
            item: v,
            columns: i.value,
            isExpanded: s,
            toggleExpand: r,
            isSelected: o,
            toggleSelect: u,
            toggleGroup: c,
            isGroupOpen: d
          };
          return a["group-header"] ? a["group-header"](x) : p(A_, fe({
            key: `group-header_${v.id}`,
            item: v
          }, Uv(n, ":group-header", () => x)), a);
        }
        const b = {
          index: y,
          item: v.raw,
          internalItem: v,
          columns: i.value,
          isExpanded: s,
          toggleExpand: r,
          isSelected: o,
          toggleSelect: u
        }, C = {
          ...b,
          props: fe({
            key: `item_${v.key ?? v.index}`,
            onClick: l.value ? () => {
              r(v);
            } : void 0,
            index: y,
            item: v,
            cellProps: e.cellProps,
            mobile: h.value
          }, Uv(n, ":row", () => b), typeof e.rowProps == "function" ? e.rowProps({
            item: b.item,
            index: b.index,
            internalItem: b.internalItem
          }) : e.rowProps)
        };
        return p(ge, {
          key: C.props.key
        }, [a.item ? a.item(C) : p(G2, C.props, a), s(v) && ((S = a["expanded-row"]) == null ? void 0 : S.call(a, b))]);
      })]);
    }), {};
  }
}), Z8 = le({
  fixedHeader: Boolean,
  fixedFooter: Boolean,
  height: [Number, String],
  hover: Boolean,
  ...Ae(),
  ...Ln(),
  ...nt(),
  ...dt()
}, "VTable"), kr = ve()({
  name: "VTable",
  props: Z8(),
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const {
      themeClasses: i
    } = yt(e), {
      densityClasses: l
    } = ea(e);
    return ye(() => p(e.tag, {
      class: ["v-table", {
        "v-table--fixed-height": !!e.height,
        "v-table--fixed-header": e.fixedHeader,
        "v-table--fixed-footer": e.fixedFooter,
        "v-table--has-top": !!n.top,
        "v-table--has-bottom": !!n.bottom,
        "v-table--hover": e.hover
      }, i.value, l.value, e.class],
      style: e.style
    }, {
      default: () => {
        var r, s, o;
        return [(r = n.top) == null ? void 0 : r.call(n), n.default ? p("div", {
          class: "v-table__wrapper",
          style: {
            height: Qe(e.height)
          }
        }, [p("table", null, [n.default()])]) : (s = n.wrapper) == null ? void 0 : s.call(n), (o = n.bottom) == null ? void 0 : o.call(n)];
      }
    })), {};
  }
}), R_ = le({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  returnObject: Boolean
}, "DataTable-items");
function I_(e, t, n, a) {
  const i = e.returnObject ? t : bn(t, e.itemValue), l = bn(t, e.itemSelectable, !0), r = a.reduce((s, o) => (o.key != null && (s[o.key] = bn(t, o.value)), s), {});
  return {
    type: "item",
    key: e.returnObject ? bn(t, e.itemValue) : i,
    index: n,
    value: i,
    selectable: l,
    columns: r,
    raw: t
  };
}
function B_(e, t, n) {
  return t.map((a, i) => I_(e, a, i, n));
}
function K2(e, t) {
  return {
    items: k(() => B_(e, e.items, t.value))
  };
}
const J2 = le({
  ...B8(),
  hideDefaultBody: Boolean,
  hideDefaultFooter: Boolean,
  hideDefaultHeader: Boolean,
  width: [String, Number],
  search: String,
  ...p8(),
  ...H2(),
  ...$_(),
  ...R_(),
  ..._8(),
  ...V8(),
  ...I8(),
  ...Z8()
}, "DataTable"), Z_ = le({
  ...z2(),
  ...J2(),
  ...Pu(),
  ...W2()
}, "VDataTable"), E_ = ve()({
  name: "VDataTable",
  props: Z_(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      groupBy: i
    } = j2(e), {
      sortBy: l,
      multiSort: r,
      mustSort: s
    } = d1(e), {
      page: o,
      itemsPerPage: u
    } = F2(e), {
      disableSort: c
    } = Tr(e), {
      columns: d,
      headers: f,
      sortFunctions: h,
      sortRawFunctions: m,
      filterFunctions: g
    } = U2(e, {
      groupBy: i,
      showSelect: ue(e, "showSelect"),
      showExpand: ue(e, "showExpand")
    }), {
      items: v
    } = K2(e, d), y = ue(e, "search"), {
      filteredItems: b
    } = $u(e, v, y, {
      transform: (Q) => Q.columns,
      customKeyFilter: g
    }), {
      toggleSort: C
    } = f1({
      sortBy: l,
      multiSort: r,
      mustSort: s,
      page: o
    }), {
      sortByWithGroups: S,
      opened: x,
      extractRows: w,
      isGroupOpen: V,
      toggleGroup: _
    } = r1({
      groupBy: i,
      sortBy: l,
      disableSort: c
    }), {
      sortedItems: O
    } = Y2(e, b, S, {
      transform: (Q) => ({
        ...Q.raw,
        ...Q.columns
      }),
      sortFunctions: h,
      sortRawFunctions: m
    }), {
      flatItems: $
    } = s1(O, i, x), P = k(() => $.value.length), {
      startIndex: M,
      stopIndex: T,
      pageCount: L,
      setItemsPerPage: A
    } = X2({
      page: o,
      itemsPerPage: u,
      itemsLength: P
    }), {
      paginatedItems: D
    } = x8({
      items: $,
      startIndex: M,
      stopIndex: T,
      itemsPerPage: u
    }), B = k(() => w(D.value)), {
      isSelected: j,
      select: I,
      selectAll: Z,
      toggleSelect: R,
      someSelected: J,
      allSelected: F
    } = u1(e, {
      allItems: v,
      currentPage: B
    }), {
      isExpanded: q,
      toggleExpand: z
    } = l1(e);
    o1({
      page: o,
      itemsPerPage: u,
      sortBy: l,
      groupBy: i,
      search: y
    }), Yt({
      VDataTableRows: {
        hideNoData: ue(e, "hideNoData"),
        noDataText: ue(e, "noDataText"),
        loading: ue(e, "loading"),
        loadingText: ue(e, "loadingText")
      }
    });
    const E = k(() => ({
      page: o.value,
      itemsPerPage: u.value,
      sortBy: l.value,
      pageCount: L.value,
      toggleSort: C,
      setItemsPerPage: A,
      someSelected: J.value,
      allSelected: F.value,
      isSelected: j,
      select: I,
      selectAll: Z,
      toggleSelect: R,
      isExpanded: q,
      toggleExpand: z,
      isGroupOpen: V,
      toggleGroup: _,
      items: B.value.map((Q) => Q.raw),
      internalItems: B.value,
      groupedItems: D.value,
      columns: d.value,
      headers: f.value
    }));
    return ye(() => {
      const Q = Fo.filterProps(e), W = Cr.filterProps(e), se = wr.filterProps(e), Se = kr.filterProps(e);
      return p(kr, fe({
        class: ["v-data-table", {
          "v-data-table--show-select": e.showSelect,
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Se), {
        top: () => {
          var U;
          return (U = a.top) == null ? void 0 : U.call(a, E.value);
        },
        default: () => {
          var U, ne, K, te, H, ce;
          return a.default ? a.default(E.value) : p(ge, null, [(U = a.colgroup) == null ? void 0 : U.call(a, E.value), !e.hideDefaultHeader && p("thead", {
            key: "thead"
          }, [p(Cr, W, a)]), (ne = a.thead) == null ? void 0 : ne.call(a, E.value), !e.hideDefaultBody && p("tbody", null, [(K = a["body.prepend"]) == null ? void 0 : K.call(a, E.value), a.body ? a.body(E.value) : p(wr, fe(n, se, {
            items: D.value
          }), a), (te = a["body.append"]) == null ? void 0 : te.call(a, E.value)]), (H = a.tbody) == null ? void 0 : H.call(a, E.value), (ce = a.tfoot) == null ? void 0 : ce.call(a, E.value)]);
        },
        bottom: () => a.bottom ? a.bottom(E.value) : !e.hideDefaultFooter && p(ge, null, [p(Su, null, null), p(Fo, Q, {
          prepend: a["footer.prepend"]
        })])
      });
    }), {};
  }
}), N_ = le({
  ...J2(),
  ...H2(),
  ...K3(),
  ...Pu()
}, "VDataTableVirtual"), H_ = ve()({
  name: "VDataTableVirtual",
  props: N_(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      groupBy: i
    } = j2(e), {
      sortBy: l,
      multiSort: r,
      mustSort: s
    } = d1(e), {
      disableSort: o
    } = Tr(e), {
      columns: u,
      headers: c,
      filterFunctions: d,
      sortFunctions: f,
      sortRawFunctions: h
    } = U2(e, {
      groupBy: i,
      showSelect: ue(e, "showSelect"),
      showExpand: ue(e, "showExpand")
    }), {
      items: m
    } = K2(e, u), g = ue(e, "search"), {
      filteredItems: v
    } = $u(e, m, g, {
      transform: (W) => W.columns,
      customKeyFilter: d
    }), {
      toggleSort: y
    } = f1({
      sortBy: l,
      multiSort: r,
      mustSort: s
    }), {
      sortByWithGroups: b,
      opened: C,
      extractRows: S,
      isGroupOpen: x,
      toggleGroup: w
    } = r1({
      groupBy: i,
      sortBy: l,
      disableSort: o
    }), {
      sortedItems: V
    } = Y2(e, v, b, {
      transform: (W) => ({
        ...W.raw,
        ...W.columns
      }),
      sortFunctions: f,
      sortRawFunctions: h
    }), {
      flatItems: _
    } = s1(V, i, C), O = k(() => S(_.value)), {
      isSelected: $,
      select: P,
      selectAll: M,
      toggleSelect: T,
      someSelected: L,
      allSelected: A
    } = u1(e, {
      allItems: O,
      currentPage: O
    }), {
      isExpanded: D,
      toggleExpand: B
    } = l1(e), {
      containerRef: j,
      markerRef: I,
      paddingTop: Z,
      paddingBottom: R,
      computedItems: J,
      handleItemResize: F,
      handleScroll: q,
      handleScrollend: z
    } = J3(e, _), E = k(() => J.value.map((W) => W.raw));
    o1({
      sortBy: l,
      page: Ve(1),
      itemsPerPage: Ve(-1),
      groupBy: i,
      search: g
    }), Yt({
      VDataTableRows: {
        hideNoData: ue(e, "hideNoData"),
        noDataText: ue(e, "noDataText"),
        loading: ue(e, "loading"),
        loadingText: ue(e, "loadingText")
      }
    });
    const Q = k(() => ({
      sortBy: l.value,
      toggleSort: y,
      someSelected: L.value,
      allSelected: A.value,
      isSelected: $,
      select: P,
      selectAll: M,
      toggleSelect: T,
      isExpanded: D,
      toggleExpand: B,
      isGroupOpen: x,
      toggleGroup: w,
      items: O.value.map((W) => W.raw),
      internalItems: O.value,
      groupedItems: _.value,
      columns: u.value,
      headers: c.value
    }));
    ye(() => {
      const W = Cr.filterProps(e), se = wr.filterProps(e), Se = kr.filterProps(e);
      return p(kr, fe({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Se), {
        top: () => {
          var U;
          return (U = a.top) == null ? void 0 : U.call(a, Q.value);
        },
        wrapper: () => {
          var U, ne, K;
          return p("div", {
            ref: j,
            onScrollPassive: q,
            onScrollend: z,
            class: "v-table__wrapper",
            style: {
              height: Qe(e.height)
            }
          }, [p("table", null, [(U = a.colgroup) == null ? void 0 : U.call(a, Q.value), !e.hideDefaultHeader && p("thead", {
            key: "thead"
          }, [p(Cr, fe(W, {
            sticky: e.fixedHeader
          }), a)]), !e.hideDefaultBody && p("tbody", null, [p("tr", {
            ref: I,
            style: {
              height: Qe(Z.value),
              border: 0
            }
          }, [p("td", {
            colspan: u.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)]), (ne = a["body.prepend"]) == null ? void 0 : ne.call(a, Q.value), p(wr, fe(n, se, {
            items: E.value
          }), {
            ...a,
            item: (te) => p(G3, {
              key: te.internalItem.index,
              renderless: !0,
              "onUpdate:height": (H) => F(te.internalItem.index, H)
            }, {
              default: (H) => {
                var he;
                let {
                  itemRef: ce
                } = H;
                return ((he = a.item) == null ? void 0 : he.call(a, {
                  ...te,
                  itemRef: ce
                })) ?? p(G2, fe(te.props, {
                  ref: ce,
                  key: te.internalItem.index,
                  index: te.internalItem.index
                }), a);
              }
            })
          }), (K = a["body.append"]) == null ? void 0 : K.call(a, Q.value), p("tr", {
            style: {
              height: Qe(R.value),
              border: 0
            }
          }, [p("td", {
            colspan: u.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)])])])]);
        },
        bottom: () => {
          var U;
          return (U = a.bottom) == null ? void 0 : U.call(a, Q.value);
        }
      });
    });
  }
}), j_ = le({
  itemsLength: {
    type: [Number, String],
    required: !0
  },
  ...z2(),
  ...J2(),
  ...W2()
}, "VDataTableServer"), z_ = ve()({
  name: "VDataTableServer",
  props: j_(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:groupBy": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      groupBy: i
    } = j2(e), {
      sortBy: l,
      multiSort: r,
      mustSort: s
    } = d1(e), {
      page: o,
      itemsPerPage: u
    } = F2(e), {
      disableSort: c
    } = Tr(e), d = k(() => parseInt(e.itemsLength, 10)), {
      columns: f,
      headers: h
    } = U2(e, {
      groupBy: i,
      showSelect: ue(e, "showSelect"),
      showExpand: ue(e, "showExpand")
    }), {
      items: m
    } = K2(e, f), {
      toggleSort: g
    } = f1({
      sortBy: l,
      multiSort: r,
      mustSort: s,
      page: o
    }), {
      opened: v,
      isGroupOpen: y,
      toggleGroup: b,
      extractRows: C
    } = r1({
      groupBy: i,
      sortBy: l,
      disableSort: c
    }), {
      pageCount: S,
      setItemsPerPage: x
    } = X2({
      page: o,
      itemsPerPage: u,
      itemsLength: d
    }), {
      flatItems: w
    } = s1(m, i, v), {
      isSelected: V,
      select: _,
      selectAll: O,
      toggleSelect: $,
      someSelected: P,
      allSelected: M
    } = u1(e, {
      allItems: m,
      currentPage: m
    }), {
      isExpanded: T,
      toggleExpand: L
    } = l1(e), A = k(() => C(m.value));
    o1({
      page: o,
      itemsPerPage: u,
      sortBy: l,
      groupBy: i,
      search: ue(e, "search")
    }), Tt("v-data-table", {
      toggleSort: g,
      sortBy: l
    }), Yt({
      VDataTableRows: {
        hideNoData: ue(e, "hideNoData"),
        noDataText: ue(e, "noDataText"),
        loading: ue(e, "loading"),
        loadingText: ue(e, "loadingText")
      }
    });
    const D = k(() => ({
      page: o.value,
      itemsPerPage: u.value,
      sortBy: l.value,
      pageCount: S.value,
      toggleSort: g,
      setItemsPerPage: x,
      someSelected: P.value,
      allSelected: M.value,
      isSelected: V,
      select: _,
      selectAll: O,
      toggleSelect: $,
      isExpanded: T,
      toggleExpand: L,
      isGroupOpen: y,
      toggleGroup: b,
      items: A.value.map((B) => B.raw),
      internalItems: A.value,
      groupedItems: w.value,
      columns: f.value,
      headers: h.value
    }));
    ye(() => {
      const B = Fo.filterProps(e), j = Cr.filterProps(e), I = wr.filterProps(e), Z = kr.filterProps(e);
      return p(kr, fe({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Z), {
        top: () => {
          var R;
          return (R = a.top) == null ? void 0 : R.call(a, D.value);
        },
        default: () => {
          var R, J, F, q, z, E;
          return a.default ? a.default(D.value) : p(ge, null, [(R = a.colgroup) == null ? void 0 : R.call(a, D.value), !e.hideDefaultHeader && p("thead", {
            key: "thead",
            class: "v-data-table__thead",
            role: "rowgroup"
          }, [p(Cr, fe(j, {
            sticky: e.fixedHeader
          }), a)]), (J = a.thead) == null ? void 0 : J.call(a, D.value), !e.hideDefaultBody && p("tbody", {
            class: "v-data-table__tbody",
            role: "rowgroup"
          }, [(F = a["body.prepend"]) == null ? void 0 : F.call(a, D.value), a.body ? a.body(D.value) : p(wr, fe(n, I, {
            items: w.value
          }), a), (q = a["body.append"]) == null ? void 0 : q.call(a, D.value)]), (z = a.tbody) == null ? void 0 : z.call(a, D.value), (E = a.tfoot) == null ? void 0 : E.call(a, D.value)]);
        },
        bottom: () => a.bottom ? a.bottom(D.value) : !e.hideDefaultFooter && p(ge, null, [p(Su, null, null), p(Fo, B, {
          prepend: a["footer.prepend"]
        })])
      });
    });
  }
}), F_ = le({
  fluid: {
    type: Boolean,
    default: !1
  },
  ...Ae(),
  ...vn(),
  ...nt()
}, "VContainer"), X_ = ve()({
  name: "VContainer",
  props: F_(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: a
    } = xn(), {
      dimensionStyles: i
    } = gn(e);
    return ye(() => p(e.tag, {
      class: ["v-container", {
        "v-container--fluid": e.fluid
      }, a.value, e.class],
      style: [i.value, e.style]
    }, n)), {};
  }
}), E8 = Hd.reduce((e, t) => (e[t] = {
  type: [Boolean, String, Number],
  default: !1
}, e), {}), N8 = Hd.reduce((e, t) => {
  const n = "offset" + js(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}), H8 = Hd.reduce((e, t) => {
  const n = "order" + js(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}), Cg = {
  col: Object.keys(E8),
  offset: Object.keys(N8),
  order: Object.keys(H8)
};
function Y_(e, t, n) {
  let a = e;
  if (!(n == null || n === !1)) {
    if (t) {
      const i = t.replace(e, "");
      a += `-${i}`;
    }
    return e === "col" && (a = "v-" + a), e === "col" && (n === "" || n === !0) || (a += `-${n}`), a.toLowerCase();
  }
}
const W_ = ["auto", "start", "end", "center", "baseline", "stretch"], q_ = le({
  cols: {
    type: [Boolean, String, Number],
    default: !1
  },
  ...E8,
  offset: {
    type: [String, Number],
    default: null
  },
  ...N8,
  order: {
    type: [String, Number],
    default: null
  },
  ...H8,
  alignSelf: {
    type: String,
    default: null,
    validator: (e) => W_.includes(e)
  },
  ...Ae(),
  ...nt()
}, "VCol"), U_ = ve()({
  name: "VCol",
  props: q_(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = k(() => {
      const i = [];
      let l;
      for (l in Cg)
        Cg[l].forEach((s) => {
          const o = e[s], u = Y_(l, s, o);
          u && i.push(u);
        });
      const r = i.some((s) => s.startsWith("v-col-"));
      return i.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !r || !e.cols,
        [`v-col-${e.cols}`]: e.cols,
        [`offset-${e.offset}`]: e.offset,
        [`order-${e.order}`]: e.order,
        [`align-self-${e.alignSelf}`]: e.alignSelf
      }), i;
    });
    return () => {
      var i;
      return G(e.tag, {
        class: [a.value, e.class],
        style: e.style
      }, (i = n.default) == null ? void 0 : i.call(n));
    };
  }
}), em = ["start", "end", "center"], j8 = ["space-between", "space-around", "space-evenly"];
function tm(e, t) {
  return Hd.reduce((n, a) => {
    const i = e + js(a);
    return n[i] = t(), n;
  }, {});
}
const G_ = [...em, "baseline", "stretch"], z8 = (e) => G_.includes(e), F8 = tm("align", () => ({
  type: String,
  default: null,
  validator: z8
})), K_ = [...em, ...j8], X8 = (e) => K_.includes(e), Y8 = tm("justify", () => ({
  type: String,
  default: null,
  validator: X8
})), J_ = [...em, ...j8, "stretch"], W8 = (e) => J_.includes(e), q8 = tm("alignContent", () => ({
  type: String,
  default: null,
  validator: W8
})), wg = {
  align: Object.keys(F8),
  justify: Object.keys(Y8),
  alignContent: Object.keys(q8)
}, eM = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function tM(e, t, n) {
  let a = eM[e];
  if (n != null) {
    if (t) {
      const i = t.replace(e, "");
      a += `-${i}`;
    }
    return a += `-${n}`, a.toLowerCase();
  }
}
const nM = le({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: z8
  },
  ...F8,
  justify: {
    type: String,
    default: null,
    validator: X8
  },
  ...Y8,
  alignContent: {
    type: String,
    default: null,
    validator: W8
  },
  ...q8,
  ...Ae(),
  ...nt()
}, "VRow"), aM = ve()({
  name: "VRow",
  props: nM(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = k(() => {
      const i = [];
      let l;
      for (l in wg)
        wg[l].forEach((r) => {
          const s = e[r], o = tM(l, r, s);
          o && i.push(o);
        });
      return i.push({
        "v-row--no-gutters": e.noGutters,
        "v-row--dense": e.dense,
        [`align-${e.align}`]: e.align,
        [`justify-${e.justify}`]: e.justify,
        [`align-content-${e.alignContent}`]: e.alignContent
      }), i;
    });
    return () => {
      var i;
      return G(e.tag, {
        class: ["v-row", a.value, e.class],
        style: e.style
      }, (i = n.default) == null ? void 0 : i.call(n));
    };
  }
}), U8 = Di("v-spacer", "div", "VSpacer"), G8 = le({
  active: {
    type: [String, Array],
    default: void 0
  },
  disabled: {
    type: [Boolean, String, Array],
    default: !1
  },
  nextIcon: {
    type: Ue,
    default: "$next"
  },
  prevIcon: {
    type: Ue,
    default: "$prev"
  },
  modeIcon: {
    type: Ue,
    default: "$subgroup"
  },
  text: String,
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls"), Sh = ve()({
  name: "VDatePickerControls",
  props: G8(),
  emits: {
    "click:year": () => !0,
    "click:month": () => !0,
    "click:prev": () => !0,
    "click:next": () => !0,
    "click:text": () => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const a = k(() => Array.isArray(e.disabled) ? e.disabled.includes("text") : !!e.disabled), i = k(() => Array.isArray(e.disabled) ? e.disabled.includes("mode") : !!e.disabled), l = k(() => Array.isArray(e.disabled) ? e.disabled.includes("prev") : !!e.disabled), r = k(() => Array.isArray(e.disabled) ? e.disabled.includes("next") : !!e.disabled);
    function s() {
      n("click:prev");
    }
    function o() {
      n("click:next");
    }
    function u() {
      n("click:year");
    }
    function c() {
      n("click:month");
    }
    return ye(() => p("div", {
      class: ["v-date-picker-controls"]
    }, [p(pt, {
      class: "v-date-picker-controls__month-btn",
      disabled: a.value,
      text: e.text,
      variant: "text",
      rounded: !0,
      onClick: c
    }, null), p(pt, {
      key: "mode-btn",
      class: "v-date-picker-controls__mode-btn",
      disabled: i.value,
      density: "comfortable",
      icon: e.modeIcon,
      variant: "text",
      onClick: u
    }, null), p(U8, {
      key: "mode-spacer"
    }, null), p("div", {
      key: "month-buttons",
      class: "v-date-picker-controls__month"
    }, [p(pt, {
      disabled: l.value,
      icon: e.prevIcon,
      variant: "text",
      onClick: s
    }, null), p(pt, {
      disabled: r.value,
      icon: e.nextIcon,
      variant: "text",
      onClick: o
    }, null)])])), {};
  }
}), iM = le({
  appendIcon: String,
  color: String,
  header: String,
  transition: String,
  onClick: Rn()
}, "VDatePickerHeader"), xh = ve()({
  name: "VDatePickerHeader",
  props: iM(),
  emits: {
    click: () => !0,
    "click:append": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = kt(e, "color");
    function r() {
      n("click");
    }
    function s() {
      n("click:append");
    }
    return ye(() => {
      const o = !!(a.default || e.header), u = !!(a.append || e.appendIcon);
      return p("div", {
        class: ["v-date-picker-header", {
          "v-date-picker-header--clickable": !!e.onClick
        }, i.value],
        style: l.value,
        onClick: r
      }, [a.prepend && p("div", {
        key: "prepend",
        class: "v-date-picker-header__prepend"
      }, [a.prepend()]), o && p(Kn, {
        key: "content",
        name: e.transition
      }, {
        default: () => {
          var c;
          return [p("div", {
            key: e.header,
            class: "v-date-picker-header__content"
          }, [((c = a.default) == null ? void 0 : c.call(a)) ?? e.header])];
        }
      }), u && p("div", {
        class: "v-date-picker-header__append"
      }, [a.append ? p(lt, {
        key: "append-defaults",
        disabled: !e.appendIcon,
        defaults: {
          VBtn: {
            icon: e.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => {
          var c;
          return [(c = a.append) == null ? void 0 : c.call(a)];
        }
      }) : p(pt, {
        key: "append-btn",
        icon: e.appendIcon,
        variant: "text",
        onClick: s
      }, null)])]);
    }), {};
  }
}), lM = le({
  allowedDates: [Array, Function],
  disabled: Boolean,
  displayValue: null,
  modelValue: Array,
  month: [Number, String],
  max: null,
  min: null,
  showAdjacentMonths: Boolean,
  year: [Number, String],
  weekdays: {
    type: Array,
    default: () => [0, 1, 2, 3, 4, 5, 6]
  },
  weeksInMonth: {
    type: String,
    default: "dynamic"
  },
  firstDayOfWeek: [Number, String]
}, "calendar");
function rM(e) {
  const t = gu(), n = Fe(e, "modelValue", [], (h) => Ht(h)), a = k(() => e.displayValue ? t.date(e.displayValue) : n.value.length > 0 ? t.date(n.value[0]) : e.min ? t.date(e.min) : Array.isArray(e.allowedDates) ? t.date(e.allowedDates[0]) : t.date()), i = Fe(e, "year", void 0, (h) => {
    const m = h != null ? Number(h) : t.getYear(a.value);
    return t.startOfYear(t.setYear(t.date(), m));
  }, (h) => t.getYear(h)), l = Fe(e, "month", void 0, (h) => {
    const m = h != null ? Number(h) : t.getMonth(a.value), g = t.setYear(t.startOfMonth(t.date()), t.getYear(i.value));
    return t.setMonth(g, m);
  }, (h) => t.getMonth(h)), r = k(() => {
    const h = Number(e.firstDayOfWeek ?? 0);
    return e.weekdays.map((m) => (m + h) % 7);
  }), s = k(() => {
    const h = t.getWeekArray(l.value, e.firstDayOfWeek), m = h.flat(), g = 6 * 7;
    if (e.weeksInMonth === "static" && m.length < g) {
      const v = m[m.length - 1];
      let y = [];
      for (let b = 1; b <= g - m.length; b++)
        y.push(t.addDays(v, b)), b % 7 === 0 && (h.push(y), y = []);
    }
    return h;
  });
  function o(h, m) {
    return h.filter((g) => r.value.includes(t.toJsDate(g).getDay())).map((g, v) => {
      const y = t.toISO(g), b = !t.isSameMonth(g, l.value), C = t.isSameDay(g, t.startOfMonth(l.value)), S = t.isSameDay(g, t.endOfMonth(l.value)), x = t.isSameDay(g, l.value);
      return {
        date: g,
        isoDate: y,
        formatted: t.format(g, "keyboardDate"),
        year: t.getYear(g),
        month: t.getMonth(g),
        isDisabled: f(g),
        isWeekStart: v % 7 === 0,
        isWeekEnd: v % 7 === 6,
        isToday: t.isSameDay(g, m),
        isAdjacent: b,
        isHidden: b && !e.showAdjacentMonths,
        isStart: C,
        isSelected: n.value.some((w) => t.isSameDay(g, w)),
        isEnd: S,
        isSame: x,
        localized: t.format(g, "dayOfMonth")
      };
    });
  }
  const u = k(() => {
    const h = t.startOfWeek(a.value, e.firstDayOfWeek), m = [];
    for (let v = 0; v <= 6; v++)
      m.push(t.addDays(h, v));
    const g = t.date();
    return o(m, g);
  }), c = k(() => {
    const h = s.value.flat(), m = t.date();
    return o(h, m);
  }), d = k(() => s.value.map((h) => h.length ? aS(t, h[0]) : null));
  function f(h) {
    if (e.disabled) return !0;
    const m = t.date(h);
    return e.min && t.isAfter(t.date(e.min), m) || e.max && t.isAfter(m, t.date(e.max)) ? !0 : Array.isArray(e.allowedDates) && e.allowedDates.length > 0 ? !e.allowedDates.some((g) => t.isSameDay(t.date(g), m)) : typeof e.allowedDates == "function" ? !e.allowedDates(m) : !1;
  }
  return {
    displayValue: a,
    daysInMonth: c,
    daysInWeek: u,
    genDays: o,
    model: n,
    weeksInMonth: s,
    weekDays: r,
    weekNumbers: d
  };
}
const K8 = le({
  color: String,
  hideWeekdays: Boolean,
  multiple: [Boolean, Number, String],
  showWeek: Boolean,
  transition: {
    type: String,
    default: "picker-transition"
  },
  reverseTransition: {
    type: String,
    default: "picker-reverse-transition"
  },
  ...lM()
}, "VDatePickerMonth"), Ph = ve()({
  name: "VDatePickerMonth",
  props: K8(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const i = Y(), {
      daysInMonth: l,
      model: r,
      weekNumbers: s
    } = rM(e), o = gu(), u = Ve(), c = Ve(), d = Ve(!1), f = k(() => d.value ? e.reverseTransition : e.transition);
    e.multiple === "range" && r.value.length > 0 && (u.value = r.value[0], r.value.length > 1 && (c.value = r.value[r.value.length - 1]));
    const h = k(() => {
      const y = ["number", "string"].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0;
      return r.value.length >= y;
    });
    pe(l, (y, b) => {
      b && (d.value = o.isBefore(y[0].date, b[0].date));
    });
    function m(y) {
      const b = o.startOfDay(y);
      if (r.value.length === 0 ? u.value = void 0 : r.value.length === 1 && (u.value = r.value[0], c.value = void 0), !u.value)
        u.value = b, r.value = [u.value];
      else if (c.value)
        u.value = y, c.value = void 0, r.value = [u.value];
      else {
        if (o.isSameDay(b, u.value)) {
          u.value = void 0, r.value = [];
          return;
        } else o.isBefore(b, u.value) ? (c.value = o.endOfDay(u.value), u.value = b) : c.value = o.endOfDay(b);
        const C = o.getDiff(c.value, u.value, "days"), S = [u.value];
        for (let x = 1; x < C; x++) {
          const w = o.addDays(u.value, x);
          S.push(w);
        }
        S.push(c.value), r.value = S;
      }
    }
    function g(y) {
      const b = r.value.findIndex((C) => o.isSameDay(C, y));
      if (b === -1)
        r.value = [...r.value, y];
      else {
        const C = [...r.value];
        C.splice(b, 1), r.value = C;
      }
    }
    function v(y) {
      e.multiple === "range" ? m(y) : e.multiple ? g(y) : r.value = [y];
    }
    return () => p("div", {
      class: "v-date-picker-month"
    }, [e.showWeek && p("div", {
      key: "weeks",
      class: "v-date-picker-month__weeks"
    }, [!e.hideWeekdays && p("div", {
      key: "hide-week-days",
      class: "v-date-picker-month__day"
    }, [Ee(" ")]), s.value.map((y) => p("div", {
      class: ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
    }, [y]))]), p(Kn, {
      name: f.value
    }, {
      default: () => {
        var y;
        return [p("div", {
          ref: i,
          key: (y = l.value[0].date) == null ? void 0 : y.toString(),
          class: "v-date-picker-month__days"
        }, [!e.hideWeekdays && o.getWeekdays(e.firstDayOfWeek).map((b) => p("div", {
          class: ["v-date-picker-month__day", "v-date-picker-month__weekday"]
        }, [b])), l.value.map((b, C) => {
          const S = {
            props: {
              onClick: () => v(b.date)
            },
            item: b,
            i: C
          };
          return h.value && !b.isSelected && (b.isDisabled = !0), p("div", {
            class: ["v-date-picker-month__day", {
              "v-date-picker-month__day--adjacent": b.isAdjacent,
              "v-date-picker-month__day--hide-adjacent": b.isHidden,
              "v-date-picker-month__day--selected": b.isSelected,
              "v-date-picker-month__day--week-end": b.isWeekEnd,
              "v-date-picker-month__day--week-start": b.isWeekStart
            }],
            "data-v-date": b.isDisabled ? void 0 : b.isoDate
          }, [(e.showAdjacentMonths || !b.isAdjacent) && p(lt, {
            defaults: {
              VBtn: {
                class: "v-date-picker-month__day-btn",
                color: (b.isSelected || b.isToday) && !b.isDisabled ? e.color : void 0,
                disabled: b.isDisabled,
                icon: !0,
                ripple: !1,
                text: b.localized,
                variant: b.isDisabled ? b.isToday ? "outlined" : "text" : b.isToday && !b.isSelected ? "outlined" : "flat",
                onClick: () => v(b.date)
              }
            }
          }, {
            default: () => {
              var x;
              return [((x = a.day) == null ? void 0 : x.call(a, S)) ?? p(pt, S.props, null)];
            }
          })]);
        })])];
      }
    })]);
  }
}), J8 = le({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  year: Number
}, "VDatePickerMonths"), $h = ve()({
  name: "VDatePickerMonths",
  props: J8(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const i = gu(), l = Fe(e, "modelValue"), r = k(() => {
      let s = i.startOfYear(i.date());
      return e.year && (s = i.setYear(s, e.year)), bi(12).map((o) => {
        const u = i.format(s, "monthShort"), c = !!(e.min && i.isAfter(i.startOfMonth(i.date(e.min)), s) || e.max && i.isAfter(s, i.startOfMonth(i.date(e.max))));
        return s = i.getNextMonth(s), {
          isDisabled: c,
          text: u,
          value: o
        };
      });
    });
    return jt(() => {
      l.value = l.value ?? i.getMonth(i.date());
    }), ye(() => p("div", {
      class: "v-date-picker-months",
      style: {
        height: Qe(e.height)
      }
    }, [p("div", {
      class: "v-date-picker-months__content"
    }, [r.value.map((s, o) => {
      var d;
      const u = {
        active: l.value === o,
        color: l.value === o ? e.color : void 0,
        disabled: s.isDisabled,
        rounded: !0,
        text: s.text,
        variant: l.value === s.value ? "flat" : "text",
        onClick: () => c(o)
      };
      function c(f) {
        if (l.value === f) {
          n("update:modelValue", l.value);
          return;
        }
        l.value = f;
      }
      return ((d = a.month) == null ? void 0 : d.call(a, {
        month: s,
        i: o,
        props: u
      })) ?? p(pt, fe({
        key: "month"
      }, u), null);
    })])])), {};
  }
}), e7 = le({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number
}, "VDatePickerYears"), _h = ve()({
  name: "VDatePickerYears",
  props: e7(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const i = gu(), l = Fe(e, "modelValue"), r = k(() => {
      const o = i.getYear(i.date());
      let u = o - 100, c = o + 52;
      e.min && (u = i.getYear(i.date(e.min))), e.max && (c = i.getYear(i.date(e.max)));
      let d = i.startOfYear(i.date());
      return d = i.setYear(d, u), bi(c - u + 1, u).map((f) => {
        const h = i.format(d, "year");
        return d = i.setYear(d, i.getYear(d) + 1), {
          text: h,
          value: f
        };
      });
    });
    jt(() => {
      l.value = l.value ?? i.getYear(i.date());
    });
    const s = jc();
    return rt(async () => {
      var o;
      await et(), (o = s.el) == null || o.scrollIntoView({
        block: "center"
      });
    }), ye(() => p("div", {
      class: "v-date-picker-years",
      style: {
        height: Qe(e.height)
      }
    }, [p("div", {
      class: "v-date-picker-years__content"
    }, [r.value.map((o, u) => {
      var d;
      const c = {
        ref: l.value === o.value ? s : void 0,
        active: l.value === o.value,
        color: l.value === o.value ? e.color : void 0,
        rounded: !0,
        text: o.text,
        variant: l.value === o.value ? "flat" : "text",
        onClick: () => {
          if (l.value === o.value) {
            n("update:modelValue", l.value);
            return;
          }
          l.value = o.value;
        }
      };
      return ((d = a.year) == null ? void 0 : d.call(a, {
        year: o,
        i: u,
        props: c
      })) ?? p(pt, fe({
        key: "month"
      }, c), null);
    })])])), {};
  }
}), sM = Di("v-picker-title"), t7 = le({
  bgColor: String,
  landscape: Boolean,
  title: String,
  hideHeader: Boolean,
  ...i1()
}, "VPicker"), kg = ve()({
  name: "VPicker",
  props: t7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: i
    } = kt(ue(e, "color"));
    return ye(() => {
      const l = br.filterProps(e), r = !!(e.title || n.title);
      return p(br, fe(l, {
        color: e.bgColor,
        class: ["v-picker", {
          "v-picker--landscape": e.landscape,
          "v-picker--with-actions": !!n.actions
        }, e.class],
        style: e.style
      }), {
        default: () => {
          var s;
          return [!e.hideHeader && p("div", {
            key: "header",
            class: [a.value],
            style: [i.value]
          }, [r && p(sM, {
            key: "picker-title"
          }, {
            default: () => {
              var o;
              return [((o = n.title) == null ? void 0 : o.call(n)) ?? e.title];
            }
          }), n.header && p("div", {
            class: "v-picker__header"
          }, [n.header()])]), p("div", {
            class: "v-picker__body"
          }, [(s = n.default) == null ? void 0 : s.call(n)]), n.actions && p(lt, {
            defaults: {
              VBtn: {
                slim: !0,
                variant: "text"
              }
            }
          }, {
            default: () => [p("div", {
              class: "v-picker__actions"
            }, [n.actions()])]
          })];
        }
      });
    }), {};
  }
}), oM = le({
  // TODO: implement in v3.5
  // calendarIcon: {
  //   type: String,
  //   default: '$calendar',
  // },
  // keyboardIcon: {
  //   type: String,
  //   default: '$edit',
  // },
  // inputMode: {
  //   type: String as PropType<'calendar' | 'keyboard'>,
  //   default: 'calendar',
  // },
  // inputText: {
  //   type: String,
  //   default: '$vuetify.datePicker.input.placeholder',
  // },
  // inputPlaceholder: {
  //   type: String,
  //   default: 'dd/mm/yyyy',
  // },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  ...G8(),
  ...K8({
    weeksInMonth: "static"
  }),
  ...hn(J8(), ["modelValue"]),
  ...hn(e7(), ["modelValue"]),
  ...t7({
    title: "$vuetify.datePicker.title"
  }),
  modelValue: null
}, "VDatePicker"), uM = ve()({
  name: "VDatePicker",
  props: oM(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0,
    // 'update:inputMode': (date: any) => true,
    "update:viewMode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const i = gu(), {
      t: l
    } = tn(), r = Fe(e, "modelValue", void 0, (O) => Ht(O), (O) => e.multiple ? O : O[0]), s = Fe(e, "viewMode"), o = k(() => {
      var $;
      const O = i.date(($ = r.value) == null ? void 0 : $[0]);
      return O && i.isValid(O) ? O : i.date();
    }), u = Y(Number(e.month ?? i.getMonth(i.startOfMonth(o.value)))), c = Y(Number(e.year ?? i.getYear(i.startOfYear(i.setMonth(o.value, u.value))))), d = Ve(!1), f = k(() => e.multiple && r.value.length > 1 ? l("$vuetify.datePicker.itemsSelected", r.value.length) : r.value[0] && i.isValid(r.value[0]) ? i.format(i.date(r.value[0]), "normalDateWithWeekday") : l(e.header)), h = k(() => {
      let O = i.date();
      return O = i.setDate(O, 1), O = i.setMonth(O, u.value), O = i.setYear(O, c.value), i.format(O, "monthAndYear");
    }), m = k(() => `date-picker-header${d.value ? "-reverse" : ""}-transition`), g = k(() => {
      const O = i.date(e.min);
      return e.min && i.isValid(O) ? O : null;
    }), v = k(() => {
      const O = i.date(e.max);
      return e.max && i.isValid(O) ? O : null;
    }), y = k(() => {
      if (e.disabled) return !0;
      const O = [];
      if (s.value !== "month")
        O.push("prev", "next");
      else {
        let $ = i.date();
        if ($ = i.setYear($, c.value), $ = i.setMonth($, u.value), g.value) {
          const P = i.addDays(i.startOfMonth($), -1);
          i.isAfter(g.value, P) && O.push("prev");
        }
        if (v.value) {
          const P = i.addDays(i.endOfMonth($), 1);
          i.isAfter(P, v.value) && O.push("next");
        }
      }
      return O;
    });
    function b() {
      u.value < 11 ? u.value++ : (c.value++, u.value = 0, _(c.value)), V(u.value);
    }
    function C() {
      u.value > 0 ? u.value-- : (c.value--, u.value = 11, _(c.value)), V(u.value);
    }
    function S() {
      s.value = "month";
    }
    function x() {
      s.value = s.value === "months" ? "month" : "months";
    }
    function w() {
      s.value = s.value === "year" ? "month" : "year";
    }
    function V(O) {
      s.value === "months" && x(), n("update:month", O);
    }
    function _(O) {
      s.value === "year" && w(), n("update:year", O);
    }
    return pe(r, (O, $) => {
      const P = Ht($), M = Ht(O);
      if (!M.length) return;
      const T = i.date(P[P.length - 1]), L = i.date(M[M.length - 1]), A = i.getMonth(L), D = i.getYear(L);
      A !== u.value && (u.value = A, V(u.value)), D !== c.value && (c.value = D, _(c.value)), d.value = i.isBefore(T, L);
    }), ye(() => {
      const O = kg.filterProps(e), $ = Sh.filterProps(e), P = xh.filterProps(e), M = Ph.filterProps(e), T = hn($h.filterProps(e), ["modelValue"]), L = hn(_h.filterProps(e), ["modelValue"]), A = {
        header: f.value,
        transition: m.value
      };
      return p(kg, fe(O, {
        class: ["v-date-picker", `v-date-picker--${s.value}`, {
          "v-date-picker--show-week": e.showWeek
        }, e.class],
        style: e.style
      }), {
        title: () => {
          var D;
          return ((D = a.title) == null ? void 0 : D.call(a)) ?? p("div", {
            class: "v-date-picker__title"
          }, [l(e.title)]);
        },
        header: () => a.header ? p(lt, {
          defaults: {
            VDatePickerHeader: {
              ...A
            }
          }
        }, {
          default: () => {
            var D;
            return [(D = a.header) == null ? void 0 : D.call(a, A)];
          }
        }) : p(xh, fe({
          key: "header"
        }, P, A, {
          onClick: s.value !== "month" ? S : void 0
        }), {
          ...a,
          default: void 0
        }),
        default: () => p(ge, null, [p(Sh, fe($, {
          disabled: y.value,
          text: h.value,
          "onClick:next": b,
          "onClick:prev": C,
          "onClick:month": x,
          "onClick:year": w
        }), null), p(No, {
          hideOnLeave: !0
        }, {
          default: () => [s.value === "months" ? p($h, fe({
            key: "date-picker-months"
          }, T, {
            modelValue: u.value,
            "onUpdate:modelValue": [(D) => u.value = D, V],
            min: g.value,
            max: v.value,
            year: c.value
          }), null) : s.value === "year" ? p(_h, fe({
            key: "date-picker-years"
          }, L, {
            modelValue: c.value,
            "onUpdate:modelValue": [(D) => c.value = D, _],
            min: g.value,
            max: v.value
          }), null) : p(Ph, fe({
            key: "date-picker-month"
          }, M, {
            modelValue: r.value,
            "onUpdate:modelValue": (D) => r.value = D,
            month: u.value,
            "onUpdate:month": [(D) => u.value = D, V],
            year: c.value,
            "onUpdate:year": [(D) => c.value = D, _],
            min: g.value,
            max: v.value
          }), null)]
        })]),
        actions: a.actions
      });
    }), {};
  }
}), cM = le({
  actionText: String,
  bgColor: String,
  color: String,
  icon: Ue,
  image: String,
  justify: {
    type: String,
    default: "center"
  },
  headline: String,
  title: String,
  text: String,
  textWidth: {
    type: [Number, String],
    default: 500
  },
  href: String,
  to: String,
  ...Ae(),
  ...vn(),
  ...Ri({
    size: void 0
  }),
  ...dt()
}, "VEmptyState"), dM = ve()({
  name: "VEmptyState",
  props: cM(),
  emits: {
    "click:action": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      themeClasses: i
    } = yt(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: r
    } = kt(ue(e, "bgColor")), {
      dimensionStyles: s
    } = gn(e), {
      displayClasses: o
    } = Za();
    function u(c) {
      n("click:action", c);
    }
    return ye(() => {
      var v, y, b;
      const c = !!(a.actions || e.actionText), d = !!(a.headline || e.headline), f = !!(a.title || e.title), h = !!(a.text || e.text), m = !!(a.media || e.image || e.icon), g = e.size || (e.image ? 200 : 96);
      return p("div", {
        class: ["v-empty-state", {
          [`v-empty-state--${e.justify}`]: !0
        }, i.value, l.value, o.value, e.class],
        style: [r.value, s.value, e.style]
      }, [m && p("div", {
        key: "media",
        class: "v-empty-state__media"
      }, [a.media ? p(lt, {
        key: "media-defaults",
        defaults: {
          VImg: {
            src: e.image,
            height: g
          },
          VIcon: {
            size: g,
            icon: e.icon
          }
        }
      }, {
        default: () => [a.media()]
      }) : p(ge, null, [e.image ? p(Wi, {
        key: "image",
        src: e.image,
        height: g
      }, null) : e.icon ? p(vt, {
        key: "icon",
        color: e.color,
        size: g,
        icon: e.icon
      }, null) : void 0])]), d && p("div", {
        key: "headline",
        class: "v-empty-state__headline"
      }, [((v = a.headline) == null ? void 0 : v.call(a)) ?? e.headline]), f && p("div", {
        key: "title",
        class: "v-empty-state__title"
      }, [((y = a.title) == null ? void 0 : y.call(a)) ?? e.title]), h && p("div", {
        key: "text",
        class: "v-empty-state__text",
        style: {
          maxWidth: Qe(e.textWidth)
        }
      }, [((b = a.text) == null ? void 0 : b.call(a)) ?? e.text]), a.default && p("div", {
        key: "content",
        class: "v-empty-state__content"
      }, [a.default()]), c && p("div", {
        key: "actions",
        class: "v-empty-state__actions"
      }, [p(lt, {
        defaults: {
          VBtn: {
            class: "v-empty-state__action-btn",
            color: e.color ?? "surface-variant",
            text: e.actionText
          }
        }
      }, {
        default: () => {
          var C;
          return [((C = a.actions) == null ? void 0 : C.call(a, {
            props: {
              onClick: u
            }
          })) ?? p(pt, {
            onClick: u
          }, null)];
        }
      })])]);
    }), {};
  }
}), Xo = Symbol.for("vuetify:v-expansion-panel"), n7 = le({
  ...Ae(),
  ...x2()
}, "VExpansionPanelText"), Mh = ve()({
  name: "VExpansionPanelText",
  props: n7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = ct(Xo);
    if (!a) throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent: i,
      onAfterLeave: l
    } = P2(e, a.isSelected);
    return ye(() => p(Fd, {
      onAfterLeave: l
    }, {
      default: () => {
        var r;
        return [Ct(p("div", {
          class: ["v-expansion-panel-text", e.class],
          style: e.style
        }, [n.default && i.value && p("div", {
          class: "v-expansion-panel-text__wrapper"
        }, [(r = n.default) == null ? void 0 : r.call(n)])]), [[Dn, a.isSelected.value]])];
      }
    })), {};
  }
}), a7 = le({
  color: String,
  expandIcon: {
    type: Ue,
    default: "$expand"
  },
  collapseIcon: {
    type: Ue,
    default: "$collapse"
  },
  hideActions: Boolean,
  focusable: Boolean,
  static: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !1
  },
  readonly: Boolean,
  ...Ae(),
  ...vn()
}, "VExpansionPanelTitle"), Vh = ve()({
  name: "VExpansionPanelTitle",
  directives: {
    Ripple: nl
  },
  props: a7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = ct(Xo);
    if (!a) throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = kt(e, "color"), {
      dimensionStyles: r
    } = gn(e), s = k(() => ({
      collapseIcon: e.collapseIcon,
      disabled: a.disabled.value,
      expanded: a.isSelected.value,
      expandIcon: e.expandIcon,
      readonly: e.readonly
    })), o = k(() => a.isSelected.value ? e.collapseIcon : e.expandIcon);
    return ye(() => {
      var u;
      return Ct(p("button", {
        class: ["v-expansion-panel-title", {
          "v-expansion-panel-title--active": a.isSelected.value,
          "v-expansion-panel-title--focusable": e.focusable,
          "v-expansion-panel-title--static": e.static
        }, i.value, e.class],
        style: [l.value, r.value, e.style],
        type: "button",
        tabindex: a.disabled.value ? -1 : void 0,
        disabled: a.disabled.value,
        "aria-expanded": a.isSelected.value,
        onClick: e.readonly ? void 0 : a.toggle
      }, [p("span", {
        class: "v-expansion-panel-title__overlay"
      }, null), (u = n.default) == null ? void 0 : u.call(n, s.value), !e.hideActions && p(lt, {
        defaults: {
          VIcon: {
            icon: o.value
          }
        }
      }, {
        default: () => {
          var c;
          return [p("span", {
            class: "v-expansion-panel-title__icon"
          }, [((c = n.actions) == null ? void 0 : c.call(n, s.value)) ?? p(vt, null, null)])];
        }
      })]), [[xa("ripple"), e.ripple]]);
    }), {};
  }
}), i7 = le({
  title: String,
  text: String,
  bgColor: String,
  ...Pn(),
  ...Er(),
  ...Dt(),
  ...nt(),
  ...a7(),
  ...n7()
}, "VExpansionPanel"), fM = ve()({
  name: "VExpansionPanel",
  props: i7(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Nr(e, Xo), {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = kt(e, "bgColor"), {
      elevationClasses: r
    } = Zn(e), {
      roundedClasses: s
    } = qt(e), o = k(() => (a == null ? void 0 : a.disabled.value) || e.disabled), u = k(() => a.group.items.value.reduce((f, h, m) => (a.group.selected.value.includes(h.id) && f.push(m), f), [])), c = k(() => {
      const f = a.group.items.value.findIndex((h) => h.id === a.id);
      return !a.isSelected.value && u.value.some((h) => h - f === 1);
    }), d = k(() => {
      const f = a.group.items.value.findIndex((h) => h.id === a.id);
      return !a.isSelected.value && u.value.some((h) => h - f === -1);
    });
    return Tt(Xo, a), ye(() => {
      const f = !!(n.text || e.text), h = !!(n.title || e.title), m = Vh.filterProps(e), g = Mh.filterProps(e);
      return p(e.tag, {
        class: ["v-expansion-panel", {
          "v-expansion-panel--active": a.isSelected.value,
          "v-expansion-panel--before-active": c.value,
          "v-expansion-panel--after-active": d.value,
          "v-expansion-panel--disabled": o.value
        }, s.value, i.value, e.class],
        style: [l.value, e.style]
      }, {
        default: () => [p("div", {
          class: ["v-expansion-panel__shadow", ...r.value]
        }, null), p(lt, {
          defaults: {
            VExpansionPanelTitle: {
              ...m
            },
            VExpansionPanelText: {
              ...g
            }
          }
        }, {
          default: () => {
            var v;
            return [h && p(Vh, {
              key: "title"
            }, {
              default: () => [n.title ? n.title() : e.title]
            }), f && p(Mh, {
              key: "text"
            }, {
              default: () => [n.text ? n.text() : e.text]
            }), (v = n.default) == null ? void 0 : v.call(n)];
          }
        })]
      });
    }), {
      groupItem: a
    };
  }
}), hM = ["default", "accordion", "inset", "popout"], mM = le({
  flat: Boolean,
  ...Zr(),
  ...u2(i7(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"]),
  ...dt(),
  ...Ae(),
  ...nt(),
  variant: {
    type: String,
    default: "default",
    validator: (e) => hM.includes(e)
  }
}, "VExpansionPanels"), vM = ve()({
  name: "VExpansionPanels",
  props: mM(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      next: a,
      prev: i
    } = Zl(e, Xo), {
      themeClasses: l
    } = yt(e), r = k(() => e.variant && `v-expansion-panels--variant-${e.variant}`);
    return Yt({
      VExpansionPanel: {
        bgColor: ue(e, "bgColor"),
        collapseIcon: ue(e, "collapseIcon"),
        color: ue(e, "color"),
        eager: ue(e, "eager"),
        elevation: ue(e, "elevation"),
        expandIcon: ue(e, "expandIcon"),
        focusable: ue(e, "focusable"),
        hideActions: ue(e, "hideActions"),
        readonly: ue(e, "readonly"),
        ripple: ue(e, "ripple"),
        rounded: ue(e, "rounded"),
        static: ue(e, "static")
      }
    }), ye(() => p(e.tag, {
      class: ["v-expansion-panels", {
        "v-expansion-panels--flat": e.flat,
        "v-expansion-panels--tile": e.tile
      }, l.value, r.value, e.class],
      style: e.style
    }, {
      default: () => {
        var s;
        return [(s = n.default) == null ? void 0 : s.call(n, {
          prev: i,
          next: a
        })];
      }
    })), {
      next: a,
      prev: i
    };
  }
}), gM = le({
  app: Boolean,
  appear: Boolean,
  extended: Boolean,
  layout: Boolean,
  offset: Boolean,
  modelValue: {
    type: Boolean,
    default: !0
  },
  ...hn(qd({
    active: !0
  }), ["location"]),
  ...Ar(),
  ...al(),
  ...ai({
    transition: "fab-transition"
  })
}, "VFab"), pM = ve()({
  name: "VFab",
  props: gM(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), i = Ve(56), l = Y(), {
      resizeRef: r
    } = Ga((d) => {
      d.length && (i.value = d[0].target.clientHeight);
    }), s = k(() => e.app || e.absolute), o = k(() => {
      var d;
      return s.value ? ((d = e.location) == null ? void 0 : d.split(" ").shift()) ?? "bottom" : !1;
    }), u = k(() => {
      var d;
      return s.value ? ((d = e.location) == null ? void 0 : d.split(" ")[1]) ?? "end" : !1;
    });
    la(() => e.app, () => {
      const d = Dr({
        id: e.name,
        order: k(() => parseInt(e.order, 10)),
        position: o,
        layoutSize: k(() => e.layout ? i.value + 24 : 0),
        elementSize: k(() => i.value + 24),
        active: k(() => e.app && a.value),
        absolute: ue(e, "absolute")
      });
      jt(() => {
        l.value = d.layoutItemStyles.value;
      });
    });
    const c = Y();
    return ye(() => {
      const d = pt.filterProps(e);
      return p("div", {
        ref: c,
        class: ["v-fab", {
          "v-fab--absolute": e.absolute,
          "v-fab--app": !!e.app,
          "v-fab--extended": e.extended,
          "v-fab--offset": e.offset,
          [`v-fab--${o.value}`]: s.value,
          [`v-fab--${u.value}`]: s.value
        }, e.class],
        style: [e.app ? {
          ...l.value
        } : {
          height: "inherit",
          width: void 0
        }, e.style]
      }, [p("div", {
        class: "v-fab__container"
      }, [p(Kn, {
        appear: e.appear,
        transition: e.transition
      }, {
        default: () => [Ct(p(pt, fe({
          ref: r
        }, d, {
          active: void 0,
          location: void 0
        }), n), [[Dn, e.active]])]
      })])]);
    }), {};
  }
}), yM = le({
  chips: Boolean,
  counter: Boolean,
  counterSizeString: {
    type: String,
    default: "$vuetify.fileInput.counterSize"
  },
  counterString: {
    type: String,
    default: "$vuetify.fileInput.counter"
  },
  hideInput: Boolean,
  multiple: Boolean,
  showSize: {
    type: [Boolean, Number, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || [1e3, 1024].includes(Number(e))
  },
  ...ll({
    prependIcon: "$file"
  }),
  modelValue: {
    type: [Array, Object],
    default: (e) => e.multiple ? [] : null,
    validator: (e) => Ht(e).every((t) => t != null && typeof t == "object")
  },
  ...xu({
    clearable: !0
  })
}, "VFileInput"), OM = ve()({
  name: "VFileInput",
  inheritAttrs: !1,
  props: yM(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: i
    } = t;
    const {
      t: l
    } = tn(), r = Fe(e, "modelValue", e.modelValue, (O) => Ht(O), (O) => !e.multiple && Array.isArray(O) ? O[0] : O), {
      isFocused: s,
      focus: o,
      blur: u
    } = il(e), c = k(() => typeof e.showSize != "boolean" ? e.showSize : void 0), d = k(() => (r.value ?? []).reduce((O, $) => {
      let {
        size: P = 0
      } = $;
      return O + P;
    }, 0)), f = k(() => Iv(d.value, c.value)), h = k(() => (r.value ?? []).map((O) => {
      const {
        name: $ = "",
        size: P = 0
      } = O;
      return e.showSize ? `${$} (${Iv(P, c.value)})` : $;
    })), m = k(() => {
      var $;
      const O = (($ = r.value) == null ? void 0 : $.length) ?? 0;
      return e.showSize ? l(e.counterSizeString, O, f.value) : l(e.counterString, O);
    }), g = Y(), v = Y(), y = Y(), b = k(() => s.value || e.active), C = k(() => ["plain", "underlined"].includes(e.variant));
    function S() {
      var O;
      y.value !== document.activeElement && ((O = y.value) == null || O.focus()), s.value || o();
    }
    function x(O) {
      var $;
      ($ = y.value) == null || $.click();
    }
    function w(O) {
      a("mousedown:control", O);
    }
    function V(O) {
      var $;
      ($ = y.value) == null || $.click(), a("click:control", O);
    }
    function _(O) {
      O.stopPropagation(), S(), et(() => {
        r.value = [], d2(e["onClick:clear"], O);
      });
    }
    return pe(r, (O) => {
      (!Array.isArray(O) || !O.length) && y.value && (y.value.value = "");
    }), ye(() => {
      const O = !!(i.counter || e.counter), $ = !!(O || i.details), [P, M] = Il(n), {
        modelValue: T,
        ...L
      } = Fn.filterProps(e), A = I2(e);
      return p(Fn, fe({
        ref: g,
        modelValue: r.value,
        "onUpdate:modelValue": (D) => r.value = D,
        class: ["v-file-input", {
          "v-file-input--chips": !!e.chips,
          "v-file-input--hide": e.hideInput,
          "v-input--plain-underlined": C.value
        }, e.class],
        style: e.style,
        "onClick:prepend": x
      }, P, L, {
        centerAffix: !C.value,
        focused: s.value
      }), {
        ...i,
        default: (D) => {
          let {
            id: B,
            isDisabled: j,
            isDirty: I,
            isReadonly: Z,
            isValid: R
          } = D;
          return p(Ks, fe({
            ref: v,
            "prepend-icon": e.prependIcon,
            onMousedown: w,
            onClick: V,
            "onClick:clear": _,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, A, {
            id: B.value,
            active: b.value || I.value,
            dirty: I.value || e.dirty,
            disabled: j.value,
            focused: s.value,
            error: R.value === !1
          }), {
            ...i,
            default: (J) => {
              var z;
              let {
                props: {
                  class: F,
                  ...q
                }
              } = J;
              return p(ge, null, [p("input", fe({
                ref: y,
                type: "file",
                readonly: Z.value,
                disabled: j.value,
                multiple: e.multiple,
                name: e.name,
                onClick: (E) => {
                  E.stopPropagation(), Z.value && E.preventDefault(), S();
                },
                onChange: (E) => {
                  if (!E.target) return;
                  const Q = E.target;
                  r.value = [...Q.files ?? []];
                },
                onFocus: S,
                onBlur: u
              }, q, M), null), p("div", {
                class: F
              }, [!!((z = r.value) != null && z.length) && !e.hideInput && (i.selection ? i.selection({
                fileNames: h.value,
                totalBytes: d.value,
                totalBytesReadable: f.value
              }) : e.chips ? h.value.map((E) => p(Gs, {
                key: E,
                size: "small",
                text: E
              }, null)) : h.value.join(", "))])]);
            }
          });
        },
        details: $ ? (D) => {
          var B, j;
          return p(ge, null, [(B = i.details) == null ? void 0 : B.call(i, D), O && p(ge, null, [p("span", null, null), p(Jd, {
            active: !!((j = r.value) != null && j.length),
            value: m.value,
            disabled: e.disabled
          }, i.counter)])]);
        } : void 0
      });
    }), Ea({}, g, v, y);
  }
}), bM = le({
  app: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...ya(),
  ...Ae(),
  ...Pn(),
  ...Ar(),
  ...Dt(),
  ...nt({
    tag: "footer"
  }),
  ...dt()
}, "VFooter"), CM = ve()({
  name: "VFooter",
  props: bM(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Y(), {
      themeClasses: i
    } = yt(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: r
    } = kt(ue(e, "color")), {
      borderClasses: s
    } = _a(e), {
      elevationClasses: o
    } = Zn(e), {
      roundedClasses: u
    } = qt(e), c = Ve(32), {
      resizeRef: d
    } = Ga((h) => {
      h.length && (c.value = h[0].target.clientHeight);
    }), f = k(() => e.height === "auto" ? c.value : parseInt(e.height, 10));
    return la(() => e.app, () => {
      const h = Dr({
        id: e.name,
        order: k(() => parseInt(e.order, 10)),
        position: k(() => "bottom"),
        layoutSize: f,
        elementSize: k(() => e.height === "auto" ? void 0 : f.value),
        active: k(() => e.app),
        absolute: ue(e, "absolute")
      });
      jt(() => {
        a.value = h.layoutItemStyles.value;
      });
    }), ye(() => p(e.tag, {
      ref: d,
      class: ["v-footer", i.value, l.value, s.value, o.value, u.value, e.class],
      style: [r.value, e.app ? a.value : {
        height: Qe(e.height)
      }, e.style]
    }, n)), {};
  }
}), wM = le({
  ...Ae(),
  ...nP()
}, "VForm"), kM = ve()({
  name: "VForm",
  props: wM(),
  emits: {
    "update:modelValue": (e) => !0,
    submit: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const i = aP(e), l = Y();
    function r(o) {
      o.preventDefault(), i.reset();
    }
    function s(o) {
      const u = o, c = i.validate();
      u.then = c.then.bind(c), u.catch = c.catch.bind(c), u.finally = c.finally.bind(c), a("submit", u), u.defaultPrevented || c.then((d) => {
        var h;
        let {
          valid: f
        } = d;
        f && ((h = l.value) == null || h.submit());
      }), u.preventDefault();
    }
    return ye(() => {
      var o;
      return p("form", {
        ref: l,
        class: ["v-form", e.class],
        style: e.style,
        novalidate: !0,
        onReset: r,
        onSubmit: s
      }, [(o = n.default) == null ? void 0 : o.call(n, i)]);
    }), Ea(i, l);
  }
}), SM = le({
  disabled: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  ...w2()
}, "VHover"), xM = ve()({
  name: "VHover",
  props: SM(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), {
      runOpenDelay: i,
      runCloseDelay: l
    } = k2(e, (r) => !e.disabled && (a.value = r));
    return () => {
      var r;
      return (r = n.default) == null ? void 0 : r.call(n, {
        isHovering: a.value,
        props: {
          onMouseenter: i,
          onMouseleave: l
        }
      });
    };
  }
}), PM = le({
  color: String,
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  side: {
    type: String,
    default: "end",
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  mode: {
    type: String,
    default: "intersect",
    validator: (e) => ["intersect", "manual"].includes(e)
  },
  margin: [Number, String],
  loadMoreText: {
    type: String,
    default: "$vuetify.infiniteScroll.loadMore"
  },
  emptyText: {
    type: String,
    default: "$vuetify.infiniteScroll.empty"
  },
  ...vn(),
  ...nt()
}, "VInfiniteScroll"), Sg = Pa({
  name: "VInfiniteScrollIntersect",
  props: {
    side: {
      type: String,
      required: !0
    },
    rootMargin: String
  },
  emits: {
    intersect: (e, t) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const {
      intersectionRef: a,
      isIntersecting: i
    } = Xd();
    return pe(i, async (l) => {
      n("intersect", e.side, l);
    }), ye(() => p("div", {
      class: "v-infinite-scroll-intersect",
      style: {
        "--v-infinite-margin-size": e.rootMargin
      },
      ref: a
    }, [Ee(" ")])), {};
  }
}), $M = ve()({
  name: "VInfiniteScroll",
  props: PM(),
  emits: {
    load: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const i = Y(), l = Ve("ok"), r = Ve("ok"), s = k(() => Qe(e.margin)), o = Ve(!1);
    function u(x) {
      if (!i.value) return;
      const w = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      i.value[w] = x;
    }
    function c() {
      if (!i.value) return 0;
      const x = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      return i.value[x];
    }
    function d() {
      if (!i.value) return 0;
      const x = e.direction === "vertical" ? "scrollHeight" : "scrollWidth";
      return i.value[x];
    }
    function f() {
      if (!i.value) return 0;
      const x = e.direction === "vertical" ? "clientHeight" : "clientWidth";
      return i.value[x];
    }
    rt(() => {
      i.value && (e.side === "start" ? u(d()) : e.side === "both" && u(d() / 2 - f() / 2));
    });
    function h(x, w) {
      x === "start" ? l.value = w : x === "end" && (r.value = w);
    }
    function m(x) {
      return x === "start" ? l.value : r.value;
    }
    let g = 0;
    function v(x, w) {
      o.value = w, o.value && y(x);
    }
    function y(x) {
      if (e.mode !== "manual" && !o.value) return;
      const w = m(x);
      if (!i.value || ["empty", "loading"].includes(w)) return;
      g = d(), h(x, "loading");
      function V(_) {
        h(x, _), et(() => {
          _ === "empty" || _ === "error" || (_ === "ok" && x === "start" && u(d() - g + c()), e.mode !== "manual" && et(() => {
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(() => {
                window.requestAnimationFrame(() => {
                  y(x);
                });
              });
            });
          }));
        });
      }
      a("load", {
        side: x,
        done: V
      });
    }
    const {
      t: b
    } = tn();
    function C(x, w) {
      var O, $, P, M, T;
      if (e.side !== x && e.side !== "both") return;
      const V = () => y(x), _ = {
        side: x,
        props: {
          onClick: V,
          color: e.color
        }
      };
      return w === "error" ? (O = n.error) == null ? void 0 : O.call(n, _) : w === "empty" ? (($ = n.empty) == null ? void 0 : $.call(n, _)) ?? p("div", null, [b(e.emptyText)]) : e.mode === "manual" ? w === "loading" ? ((P = n.loading) == null ? void 0 : P.call(n, _)) ?? p(Cs, {
        indeterminate: !0,
        color: e.color
      }, null) : ((M = n["load-more"]) == null ? void 0 : M.call(n, _)) ?? p(pt, {
        variant: "outlined",
        color: e.color,
        onClick: V
      }, {
        default: () => [b(e.loadMoreText)]
      }) : ((T = n.loading) == null ? void 0 : T.call(n, _)) ?? p(Cs, {
        indeterminate: !0,
        color: e.color
      }, null);
    }
    const {
      dimensionStyles: S
    } = gn(e);
    ye(() => {
      const x = e.tag, w = e.side === "start" || e.side === "both", V = e.side === "end" || e.side === "both", _ = e.mode === "intersect";
      return p(x, {
        ref: i,
        class: ["v-infinite-scroll", `v-infinite-scroll--${e.direction}`, {
          "v-infinite-scroll--start": w,
          "v-infinite-scroll--end": V
        }],
        style: S.value
      }, {
        default: () => {
          var O;
          return [p("div", {
            class: "v-infinite-scroll__side"
          }, [C("start", l.value)]), w && _ && p(Sg, {
            key: "start",
            side: "start",
            onIntersect: v,
            rootMargin: s.value
          }, null), (O = n.default) == null ? void 0 : O.call(n), V && _ && p(Sg, {
            key: "end",
            side: "end",
            onIntersect: v,
            rootMargin: s.value
          }, null), p("div", {
            class: "v-infinite-scroll__side"
          }, [C("end", r.value)])];
        }
      });
    });
  }
}), l7 = Symbol.for("vuetify:v-item-group"), _M = le({
  ...Ae(),
  ...Zr({
    selectedClass: "v-item--selected"
  }),
  ...nt(),
  ...dt()
}, "VItemGroup"), MM = ve()({
  name: "VItemGroup",
  props: _M(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e), {
      isSelected: i,
      select: l,
      next: r,
      prev: s,
      selected: o
    } = Zl(e, l7);
    return () => p(e.tag, {
      class: ["v-item-group", a.value, e.class],
      style: e.style
    }, {
      default: () => {
        var u;
        return [(u = n.default) == null ? void 0 : u.call(n, {
          isSelected: i,
          select: l,
          next: r,
          prev: s,
          selected: o.value
        })];
      }
    });
  }
}), VM = ve()({
  name: "VItem",
  props: Er(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: a,
      select: i,
      toggle: l,
      selectedClass: r,
      value: s,
      disabled: o
    } = Nr(e, l7);
    return () => {
      var u;
      return (u = n.default) == null ? void 0 : u.call(n, {
        isSelected: a.value,
        selectedClass: r.value,
        select: i,
        toggle: l,
        value: s.value,
        disabled: o.value
      });
    };
  }
}), TM = Di("v-kbd"), LM = le({
  ...Ae(),
  ...vn(),
  ...z5()
}, "VLayout"), QM = ve()({
  name: "VLayout",
  props: LM(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutClasses: a,
      layoutStyles: i,
      getLayoutItem: l,
      items: r,
      layoutRef: s
    } = X5(e), {
      dimensionStyles: o
    } = gn(e);
    return ye(() => {
      var u;
      return p("div", {
        ref: s,
        class: [a.value, e.class],
        style: [o.value, i.value, e.style]
      }, [(u = n.default) == null ? void 0 : u.call(n)]);
    }), {
      getLayoutItem: l,
      items: r
    };
  }
}), AM = le({
  position: {
    type: String,
    required: !0
  },
  size: {
    type: [Number, String],
    default: 300
  },
  modelValue: Boolean,
  ...Ae(),
  ...Ar()
}, "VLayoutItem"), DM = ve()({
  name: "VLayoutItem",
  props: AM(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutItemStyles: a
    } = Dr({
      id: e.name,
      order: k(() => parseInt(e.order, 10)),
      position: ue(e, "position"),
      elementSize: ue(e, "size"),
      layoutSize: ue(e, "size"),
      active: ue(e, "modelValue"),
      absolute: ue(e, "absolute")
    });
    return () => {
      var i;
      return p("div", {
        class: ["v-layout-item", e.class],
        style: [a.value, e.style]
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    };
  }
}), RM = le({
  modelValue: Boolean,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  ...Ae(),
  ...vn(),
  ...nt(),
  ...ai({
    transition: "fade-transition"
  })
}, "VLazy"), IM = ve()({
  name: "VLazy",
  directives: {
    intersect: pu
  },
  props: RM(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: a
    } = gn(e), i = Fe(e, "modelValue");
    function l(r) {
      i.value || (i.value = r);
    }
    return ye(() => Ct(p(e.tag, {
      class: ["v-lazy", e.class],
      style: [a.value, e.style]
    }, {
      default: () => [i.value && p(Kn, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => {
          var r;
          return [(r = n.default) == null ? void 0 : r.call(n)];
        }
      })]
    }), [[xa("intersect"), {
      handler: l,
      options: e.options
    }, null]])), {};
  }
}), BM = le({
  locale: String,
  fallbackLocale: String,
  messages: Object,
  rtl: {
    type: Boolean,
    default: void 0
  },
  ...Ae()
}, "VLocaleProvider"), ZM = ve()({
  name: "VLocaleProvider",
  props: BM(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: a
    } = mk(e);
    return ye(() => {
      var i;
      return p("div", {
        class: ["v-locale-provider", a.value, e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), EM = le({
  scrollable: Boolean,
  ...Ae(),
  ...vn(),
  ...nt({
    tag: "main"
  })
}, "VMain"), NM = ve()({
  name: "VMain",
  props: EM(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: a
    } = gn(e), {
      mainStyles: i
    } = F5(), {
      ssrBootStyles: l
    } = Ir();
    return ye(() => p(e.tag, {
      class: ["v-main", {
        "v-main--scrollable": e.scrollable
      }, e.class],
      style: [i.value, l.value, a.value, e.style]
    }, {
      default: () => {
        var r, s;
        return [e.scrollable ? p("div", {
          class: "v-main__scroller"
        }, [(r = n.default) == null ? void 0 : r.call(n)]) : (s = n.default) == null ? void 0 : s.call(n)];
      }
    })), {};
  }
});
function HM(e) {
  let {
    rootEl: t,
    isSticky: n,
    layoutItemStyles: a
  } = e;
  const i = Ve(!1), l = Ve(0), r = k(() => {
    const u = typeof i.value == "boolean" ? "top" : i.value;
    return [n.value ? {
      top: "auto",
      bottom: "auto",
      height: void 0
    } : void 0, i.value ? {
      [u]: Qe(l.value)
    } : {
      top: a.value.top
    }];
  });
  rt(() => {
    pe(n, (u) => {
      u ? window.addEventListener("scroll", o, {
        passive: !0
      }) : window.removeEventListener("scroll", o);
    }, {
      immediate: !0
    });
  }), mn(() => {
    window.removeEventListener("scroll", o);
  });
  let s = 0;
  function o() {
    const u = s > window.scrollY ? "up" : "down", c = t.value.getBoundingClientRect(), d = parseFloat(a.value.top ?? 0), f = window.scrollY - Math.max(0, l.value - d), h = c.height + Math.max(l.value, d) - window.scrollY - window.innerHeight, m = parseFloat(getComputedStyle(t.value).getPropertyValue("--v-body-scroll-y")) || 0;
    c.height < window.innerHeight - d ? (i.value = "top", l.value = d) : u === "up" && i.value === "bottom" || u === "down" && i.value === "top" ? (l.value = window.scrollY + c.top - m, i.value = !0) : u === "down" && h <= 0 ? (l.value = 0, i.value = "bottom") : u === "up" && f <= 0 && (m ? i.value !== "top" && (l.value = -f + m + d, i.value = "top") : (l.value = c.top + f, i.value = "top")), s = window.scrollY;
  }
  return {
    isStuck: i,
    stickyStyles: r
  };
}
const jM = 100, zM = 20;
function xg(e) {
  return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * 1.41421356237;
}
function Pg(e) {
  if (e.length < 2)
    return 0;
  if (e.length === 2)
    return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t);
  let t = 0;
  for (let n = e.length - 1; n > 0; n--) {
    if (e[n].t === e[n - 1].t)
      continue;
    const a = xg(t), i = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t);
    t += (i - a) * Math.abs(i), n === e.length - 1 && (t *= 0.5);
  }
  return xg(t) * 1e3;
}
function FM() {
  const e = {};
  function t(i) {
    Array.from(i.changedTouches).forEach((l) => {
      (e[l.identifier] ?? (e[l.identifier] = new $w(zM))).push([i.timeStamp, l]);
    });
  }
  function n(i) {
    Array.from(i.changedTouches).forEach((l) => {
      delete e[l.identifier];
    });
  }
  function a(i) {
    var u;
    const l = (u = e[i]) == null ? void 0 : u.values().reverse();
    if (!l)
      throw new Error(`No samples for touch id ${i}`);
    const r = l[0], s = [], o = [];
    for (const c of l) {
      if (r[0] - c[0] > jM) break;
      s.push({
        t: c[0],
        d: c[1].clientX
      }), o.push({
        t: c[0],
        d: c[1].clientY
      });
    }
    return {
      x: Pg(s),
      y: Pg(o),
      get direction() {
        const {
          x: c,
          y: d
        } = this, [f, h] = [Math.abs(c), Math.abs(d)];
        return f > h && c >= 0 ? "right" : f > h && c <= 0 ? "left" : h > f && d >= 0 ? "down" : h > f && d <= 0 ? "up" : XM();
      }
    };
  }
  return {
    addMovement: t,
    endTouch: n,
    getVelocity: a
  };
}
function XM() {
  throw new Error();
}
function YM(e) {
  let {
    el: t,
    isActive: n,
    isTemporary: a,
    width: i,
    touchless: l,
    position: r
  } = e;
  rt(() => {
    window.addEventListener("touchstart", b, {
      passive: !0
    }), window.addEventListener("touchmove", C, {
      passive: !1
    }), window.addEventListener("touchend", S, {
      passive: !0
    });
  }), mn(() => {
    window.removeEventListener("touchstart", b), window.removeEventListener("touchmove", C), window.removeEventListener("touchend", S);
  });
  const s = k(() => ["left", "right"].includes(r.value)), {
    addMovement: o,
    endTouch: u,
    getVelocity: c
  } = FM();
  let d = !1;
  const f = Ve(!1), h = Ve(0), m = Ve(0);
  let g;
  function v(w, V) {
    return (r.value === "left" ? w : r.value === "right" ? document.documentElement.clientWidth - w : r.value === "top" ? w : r.value === "bottom" ? document.documentElement.clientHeight - w : qr()) - (V ? i.value : 0);
  }
  function y(w) {
    let V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const _ = r.value === "left" ? (w - m.value) / i.value : r.value === "right" ? (document.documentElement.clientWidth - w - m.value) / i.value : r.value === "top" ? (w - m.value) / i.value : r.value === "bottom" ? (document.documentElement.clientHeight - w - m.value) / i.value : qr();
    return V ? Math.max(0, Math.min(1, _)) : _;
  }
  function b(w) {
    if (l.value) return;
    const V = w.changedTouches[0].clientX, _ = w.changedTouches[0].clientY, O = 25, $ = r.value === "left" ? V < O : r.value === "right" ? V > document.documentElement.clientWidth - O : r.value === "top" ? _ < O : r.value === "bottom" ? _ > document.documentElement.clientHeight - O : qr(), P = n.value && (r.value === "left" ? V < i.value : r.value === "right" ? V > document.documentElement.clientWidth - i.value : r.value === "top" ? _ < i.value : r.value === "bottom" ? _ > document.documentElement.clientHeight - i.value : qr());
    ($ || P || n.value && a.value) && (g = [V, _], m.value = v(s.value ? V : _, n.value), h.value = y(s.value ? V : _), d = m.value > -20 && m.value < 80, u(w), o(w));
  }
  function C(w) {
    const V = w.changedTouches[0].clientX, _ = w.changedTouches[0].clientY;
    if (d) {
      if (!w.cancelable) {
        d = !1;
        return;
      }
      const $ = Math.abs(V - g[0]), P = Math.abs(_ - g[1]);
      (s.value ? $ > P && $ > 3 : P > $ && P > 3) ? (f.value = !0, d = !1) : (s.value ? P : $) > 3 && (d = !1);
    }
    if (!f.value) return;
    w.preventDefault(), o(w);
    const O = y(s.value ? V : _, !1);
    h.value = Math.max(0, Math.min(1, O)), O > 1 ? m.value = v(s.value ? V : _, !0) : O < 0 && (m.value = v(s.value ? V : _, !1));
  }
  function S(w) {
    if (d = !1, !f.value) return;
    o(w), f.value = !1;
    const V = c(w.changedTouches[0].identifier), _ = Math.abs(V.x), O = Math.abs(V.y);
    (s.value ? _ > O && _ > 400 : O > _ && O > 3) ? n.value = V.direction === ({
      left: "right",
      right: "left",
      top: "down",
      bottom: "up"
    }[r.value] || qr()) : n.value = h.value > 0.5;
  }
  const x = k(() => f.value ? {
    transform: r.value === "left" ? `translateX(calc(-100% + ${h.value * i.value}px))` : r.value === "right" ? `translateX(calc(100% - ${h.value * i.value}px))` : r.value === "top" ? `translateY(calc(-100% + ${h.value * i.value}px))` : r.value === "bottom" ? `translateY(calc(100% - ${h.value * i.value}px))` : qr(),
    transition: "none"
  } : void 0);
  return la(f, () => {
    var _, O;
    const w = ((_ = t.value) == null ? void 0 : _.style.transform) ?? null, V = ((O = t.value) == null ? void 0 : O.style.transition) ?? null;
    jt(() => {
      var $, P, M, T;
      (P = t.value) == null || P.style.setProperty("transform", (($ = x.value) == null ? void 0 : $.transform) || "none"), (T = t.value) == null || T.style.setProperty("transition", ((M = x.value) == null ? void 0 : M.transition) || null);
    }), Xn(() => {
      var $, P;
      ($ = t.value) == null || $.style.setProperty("transform", w), (P = t.value) == null || P.style.setProperty("transition", V);
    });
  }), {
    isDragging: f,
    dragProgress: h,
    dragStyles: x
  };
}
function qr() {
  throw new Error();
}
const WM = ["start", "end", "left", "right", "top", "bottom"], qM = le({
  color: String,
  disableResizeWatcher: Boolean,
  disableRouteWatcher: Boolean,
  expandOnHover: Boolean,
  floating: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  permanent: Boolean,
  rail: {
    type: Boolean,
    default: null
  },
  railWidth: {
    type: [Number, String],
    default: 56
  },
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  image: String,
  temporary: Boolean,
  persistent: Boolean,
  touchless: Boolean,
  width: {
    type: [Number, String],
    default: 256
  },
  location: {
    type: String,
    default: "start",
    validator: (e) => WM.includes(e)
  },
  sticky: Boolean,
  ...ya(),
  ...Ae(),
  ...w2(),
  ...Qr({
    mobile: null
  }),
  ...Pn(),
  ...Ar(),
  ...Dt(),
  ...nt({
    tag: "nav"
  }),
  ...dt()
}, "VNavigationDrawer"), UM = ve()({
  name: "VNavigationDrawer",
  props: qM(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:rail": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: i
    } = t;
    const {
      isRtl: l
    } = xn(), {
      themeClasses: r
    } = yt(e), {
      borderClasses: s
    } = _a(e), {
      backgroundColorClasses: o,
      backgroundColorStyles: u
    } = kt(ue(e, "color")), {
      elevationClasses: c
    } = Zn(e), {
      displayClasses: d,
      mobile: f
    } = Za(e), {
      roundedClasses: h
    } = qt(e), m = h3(), g = Fe(e, "modelValue", null, (R) => !!R), {
      ssrBootStyles: v
    } = Ir(), {
      scopeId: y
    } = Rr(), b = Y(), C = Ve(!1), {
      runOpenDelay: S,
      runCloseDelay: x
    } = k2(e, (R) => {
      C.value = R;
    }), w = k(() => e.rail && e.expandOnHover && C.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width)), V = k(() => Jf(e.location, l.value)), _ = k(() => e.persistent), O = k(() => !e.permanent && (f.value || e.temporary)), $ = k(() => e.sticky && !O.value && V.value !== "bottom");
    la(() => e.expandOnHover && e.rail != null, () => {
      pe(C, (R) => a("update:rail", !R));
    }), la(() => !e.disableResizeWatcher, () => {
      pe(O, (R) => !e.permanent && et(() => g.value = !R));
    }), la(() => !e.disableRouteWatcher && !!m, () => {
      pe(m.currentRoute, () => O.value && (g.value = !1));
    }), pe(() => e.permanent, (R) => {
      R && (g.value = !0);
    }), e.modelValue == null && !O.value && (g.value = e.permanent || !f.value);
    const {
      isDragging: P,
      dragProgress: M
    } = YM({
      el: b,
      isActive: g,
      isTemporary: O,
      width: w,
      touchless: ue(e, "touchless"),
      position: V
    }), T = k(() => {
      const R = O.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : w.value;
      return P.value ? R * M.value : R;
    }), L = k(() => ["top", "bottom"].includes(e.location) ? 0 : w.value), {
      layoutItemStyles: A,
      layoutItemScrimStyles: D
    } = Dr({
      id: e.name,
      order: k(() => parseInt(e.order, 10)),
      position: V,
      layoutSize: T,
      elementSize: L,
      active: k(() => g.value || P.value),
      disableTransitions: k(() => P.value),
      absolute: k(() => (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        e.absolute || $.value && typeof B.value != "string"
      ))
    }), {
      isStuck: B,
      stickyStyles: j
    } = HM({
      rootEl: b,
      isSticky: $,
      layoutItemStyles: A
    }), I = kt(k(() => typeof e.scrim == "string" ? e.scrim : null)), Z = k(() => ({
      ...P.value ? {
        opacity: M.value * 0.2,
        transition: "none"
      } : void 0,
      ...D.value
    }));
    return Yt({
      VList: {
        bgColor: "transparent"
      }
    }), ye(() => {
      const R = i.image || e.image;
      return p(ge, null, [p(e.tag, fe({
        ref: b,
        onMouseenter: S,
        onMouseleave: x,
        class: ["v-navigation-drawer", `v-navigation-drawer--${V.value}`, {
          "v-navigation-drawer--expand-on-hover": e.expandOnHover,
          "v-navigation-drawer--floating": e.floating,
          "v-navigation-drawer--is-hovering": C.value,
          "v-navigation-drawer--rail": e.rail,
          "v-navigation-drawer--temporary": O.value,
          "v-navigation-drawer--persistent": _.value,
          "v-navigation-drawer--active": g.value,
          "v-navigation-drawer--sticky": $.value
        }, r.value, o.value, s.value, d.value, c.value, h.value, e.class],
        style: [u.value, A.value, v.value, j.value, e.style, ["top", "bottom"].includes(V.value) ? {
          height: "auto"
        } : {}]
      }, y, n), {
        default: () => {
          var J, F, q;
          return [R && p("div", {
            key: "image",
            class: "v-navigation-drawer__img"
          }, [i.image ? p(lt, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                alt: "",
                cover: !0,
                height: "inherit",
                src: e.image
              }
            }
          }, i.image) : p(Wi, {
            key: "image-img",
            alt: "",
            cover: !0,
            height: "inherit",
            src: e.image
          }, null)]), i.prepend && p("div", {
            class: "v-navigation-drawer__prepend"
          }, [(J = i.prepend) == null ? void 0 : J.call(i)]), p("div", {
            class: "v-navigation-drawer__content"
          }, [(F = i.default) == null ? void 0 : F.call(i)]), i.append && p("div", {
            class: "v-navigation-drawer__append"
          }, [(q = i.append) == null ? void 0 : q.call(i)])];
        }
      }), p(Jn, {
        name: "fade-transition"
      }, {
        default: () => [O.value && (P.value || g.value) && !!e.scrim && p("div", fe({
          class: ["v-navigation-drawer__scrim", I.backgroundColorClasses.value],
          style: [Z.value, I.backgroundColorStyles.value],
          onClick: () => {
            _.value || (g.value = !1);
          }
        }, y), null)]
      })]);
    }), {
      isStuck: B
    };
  }
}), GM = Pa({
  name: "VNoSsr",
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = f3();
    return () => {
      var i;
      return a.value && ((i = n.default) == null ? void 0 : i.call(n));
    };
  }
}), KM = le({
  autofocus: Boolean,
  divider: String,
  focusAll: Boolean,
  label: {
    type: String,
    default: "$vuetify.input.otp"
  },
  length: {
    type: [Number, String],
    default: 6
  },
  modelValue: {
    type: [Number, String],
    default: void 0
  },
  placeholder: String,
  type: {
    type: String,
    default: "number"
  },
  ...vn(),
  ...ku(),
  ...Id(xu({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])
}, "VOtpInput"), JM = ve()({
  name: "VOtpInput",
  props: KM(),
  emits: {
    finish: (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: i
    } = t;
    const {
      dimensionStyles: l
    } = gn(e), {
      isFocused: r,
      focus: s,
      blur: o
    } = il(e), u = Fe(e, "modelValue", "", (_) => _ == null ? [] : String(_).split(""), (_) => _.join("")), {
      t: c
    } = tn(), d = k(() => Number(e.length)), f = k(() => Array(d.value).fill(0)), h = Y(-1), m = Y(), g = Y([]), v = k(() => g.value[h.value]);
    function y() {
      if (V(v.value.value)) {
        v.value.value = "";
        return;
      }
      const _ = u.value.slice(), O = v.value.value;
      _[h.value] = O;
      let $ = null;
      h.value > u.value.length ? $ = u.value.length + 1 : h.value + 1 !== d.value && ($ = "next"), u.value = _, $ && or(m.value, $);
    }
    function b(_) {
      const O = u.value.slice(), $ = h.value;
      let P = null;
      ["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(_.key) && (_.preventDefault(), _.key === "ArrowLeft" ? P = "prev" : _.key === "ArrowRight" ? P = "next" : ["Backspace", "Delete"].includes(_.key) && (O[h.value] = "", u.value = O, h.value > 0 && _.key === "Backspace" ? P = "prev" : requestAnimationFrame(() => {
        var M;
        (M = g.value[$]) == null || M.select();
      })), requestAnimationFrame(() => {
        P != null && or(m.value, P);
      }));
    }
    function C(_, O) {
      var P, M;
      O.preventDefault(), O.stopPropagation();
      const $ = ((P = O == null ? void 0 : O.clipboardData) == null ? void 0 : P.getData("Text").slice(0, d.value)) ?? "";
      V($) || (u.value = $.split(""), (M = g.value) == null || M[_].blur());
    }
    function S() {
      u.value = [];
    }
    function x(_, O) {
      s(), h.value = O;
    }
    function w() {
      o(), h.value = -1;
    }
    function V(_) {
      return e.type === "number" && /[^0-9]/g.test(_);
    }
    return Yt({
      VField: {
        color: k(() => e.color),
        bgColor: k(() => e.color),
        baseColor: k(() => e.baseColor),
        disabled: k(() => e.disabled),
        error: k(() => e.error),
        variant: k(() => e.variant)
      }
    }, {
      scoped: !0
    }), pe(u, (_) => {
      _.length === d.value && a("finish", _.join(""));
    }, {
      deep: !0
    }), pe(h, (_) => {
      _ < 0 || et(() => {
        var O;
        (O = g.value[_]) == null || O.select();
      });
    }), ye(() => {
      var $;
      const [_, O] = Il(n);
      return p("div", fe({
        class: ["v-otp-input", {
          "v-otp-input--divided": !!e.divider
        }, e.class],
        style: [e.style]
      }, _), [p("div", {
        ref: m,
        class: "v-otp-input__content",
        style: [l.value]
      }, [f.value.map((P, M) => p(ge, null, [e.divider && M !== 0 && p("span", {
        class: "v-otp-input__divider"
      }, [e.divider]), p(Ks, {
        focused: r.value && e.focusAll || h.value === M,
        key: M
      }, {
        ...i,
        loader: void 0,
        default: () => p("input", {
          ref: (T) => g.value[M] = T,
          "aria-label": c(e.label, M + 1),
          autofocus: M === 0 && e.autofocus,
          autocomplete: "one-time-code",
          class: ["v-otp-input__field"],
          disabled: e.disabled,
          inputmode: e.type === "number" ? "numeric" : "text",
          min: e.type === "number" ? 0 : void 0,
          maxlength: "1",
          placeholder: e.placeholder,
          type: e.type === "number" ? "text" : e.type,
          value: u.value[M],
          onInput: y,
          onFocus: (T) => x(T, M),
          onBlur: w,
          onKeydown: b,
          onPaste: (T) => C(M, T)
        }, null)
      })])), p("input", fe({
        class: "v-otp-input-input",
        type: "hidden"
      }, O, {
        value: u.value.join("")
      }), null), p(Ka, {
        contained: !0,
        "content-class": "v-otp-input__loader",
        "model-value": !!e.loading,
        persistent: !0
      }, {
        default: () => {
          var P;
          return [((P = i.loader) == null ? void 0 : P.call(i)) ?? p(Cs, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            size: "24",
            width: "2"
          }, null)];
        }
      }), ($ = i.default) == null ? void 0 : $.call(i)])]);
    }), {
      blur: () => {
        var _;
        (_ = g.value) == null || _.some((O) => O.blur());
      },
      focus: () => {
        var _;
        (_ = g.value) == null || _[0].focus();
      },
      reset: S,
      isFocused: r
    };
  }
});
function eV(e) {
  return Math.floor(Math.abs(e)) * Math.sign(e);
}
const tV = le({
  scale: {
    type: [Number, String],
    default: 0.5
  },
  ...Ae()
}, "VParallax"), nV = ve()({
  name: "VParallax",
  props: tV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      intersectionRef: a,
      isIntersecting: i
    } = Xd(), {
      resizeRef: l,
      contentRect: r
    } = Ga(), {
      height: s
    } = Za(), o = Y();
    jt(() => {
      var h;
      a.value = l.value = (h = o.value) == null ? void 0 : h.$el;
    });
    let u;
    pe(i, (h) => {
      h ? (u = g2(a.value), u = u === document.scrollingElement ? document : u, u.addEventListener("scroll", f, {
        passive: !0
      }), f()) : u.removeEventListener("scroll", f);
    }), mn(() => {
      u == null || u.removeEventListener("scroll", f);
    }), pe(s, f), pe(() => {
      var h;
      return (h = r.value) == null ? void 0 : h.height;
    }, f);
    const c = k(() => 1 - ln(+e.scale));
    let d = -1;
    function f() {
      i.value && (cancelAnimationFrame(d), d = requestAnimationFrame(() => {
        var x;
        const h = ((x = o.value) == null ? void 0 : x.$el).querySelector(".v-img__img");
        if (!h) return;
        const m = u instanceof Document ? document.documentElement.clientHeight : u.clientHeight, g = u instanceof Document ? window.scrollY : u.scrollTop, v = a.value.getBoundingClientRect().top + g, y = r.value.height, b = v + (y - m) / 2, C = eV((g - b) * c.value), S = Math.max(1, (c.value * (m - y) + y) / y);
        h.style.setProperty("transform", `translateY(${C}px) scale(${S})`);
      }));
    }
    return ye(() => p(Wi, {
      class: ["v-parallax", {
        "v-parallax--active": i.value
      }, e.class],
      style: e.style,
      ref: o,
      cover: !0,
      onLoadstart: f,
      onLoad: f
    }, n)), {};
  }
}), aV = le({
  ...Ud({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })
}, "VRadio"), iV = ve()({
  name: "VRadio",
  props: aV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => {
      const a = $l.filterProps(e);
      return p($l, fe(a, {
        class: ["v-radio", e.class],
        style: e.style,
        type: "radio"
      }), n);
    }), {};
  }
}), lV = le({
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...ll(),
  ...hn(L2(), ["multiple"]),
  trueIcon: {
    type: Ue,
    default: "$radioOn"
  },
  falseIcon: {
    type: Ue,
    default: "$radioOff"
  },
  type: {
    type: String,
    default: "radio"
  }
}, "VRadioGroup"), rV = ve()({
  name: "VRadioGroup",
  inheritAttrs: !1,
  props: lV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const i = Bn(), l = k(() => e.id || `radio-group-${i}`), r = Fe(e, "modelValue");
    return ye(() => {
      const [s, o] = Il(n), u = Fn.filterProps(e), c = $l.filterProps(e), d = a.label ? a.label({
        label: e.label,
        props: {
          for: l.value
        }
      }) : e.label;
      return p(Fn, fe({
        class: ["v-radio-group", e.class],
        style: e.style
      }, s, u, {
        modelValue: r.value,
        "onUpdate:modelValue": (f) => r.value = f,
        id: l.value
      }), {
        ...a,
        default: (f) => {
          let {
            id: h,
            messagesId: m,
            isDisabled: g,
            isReadonly: v
          } = f;
          return p(ge, null, [d && p(Us, {
            id: h.value
          }, {
            default: () => [d]
          }), p(x3, fe(c, {
            id: h.value,
            "aria-describedby": m.value,
            defaultsTarget: "VRadio",
            trueIcon: e.trueIcon,
            falseIcon: e.falseIcon,
            type: e.type,
            disabled: g.value,
            readonly: v.value,
            "aria-labelledby": d ? h.value : void 0,
            multiple: !1
          }, o, {
            modelValue: r.value,
            "onUpdate:modelValue": (y) => r.value = y
          }), a)]);
        }
      });
    }), {};
  }
}), sV = le({
  ...ku(),
  ...ll(),
  ...h8(),
  strict: Boolean,
  modelValue: {
    type: Array,
    default: () => [0, 0]
  }
}, "VRangeSlider"), oV = ve()({
  name: "VRangeSlider",
  props: sV(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    end: (e) => !0,
    start: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const i = Y(), l = Y(), r = Y(), {
      rtlClasses: s
    } = xn();
    function o($) {
      if (!i.value || !l.value) return;
      const P = Oh($, i.value.$el, e.direction), M = Oh($, l.value.$el, e.direction), T = Math.abs(P), L = Math.abs(M);
      return T < L || T === L && P < 0 ? i.value.$el : l.value.$el;
    }
    const u = m8(e), c = Fe(e, "modelValue", void 0, ($) => $ != null && $.length ? $.map((P) => u.roundValue(P)) : [0, 0]), {
      activeThumbRef: d,
      hasLabels: f,
      max: h,
      min: m,
      mousePressed: g,
      onSliderMousedown: v,
      onSliderTouchstart: y,
      position: b,
      trackContainerRef: C,
      readonly: S
    } = v8({
      props: e,
      steps: u,
      onSliderStart: () => {
        a("start", c.value);
      },
      onSliderEnd: ($) => {
        var T;
        let {
          value: P
        } = $;
        const M = d.value === ((T = i.value) == null ? void 0 : T.$el) ? [P, c.value[1]] : [c.value[0], P];
        !e.strict && M[0] < M[1] && (c.value = M), a("end", c.value);
      },
      onSliderMove: ($) => {
        var L, A, D, B;
        let {
          value: P
        } = $;
        const [M, T] = c.value;
        !e.strict && M === T && M !== m.value && (d.value = P > M ? (L = l.value) == null ? void 0 : L.$el : (A = i.value) == null ? void 0 : A.$el, (D = d.value) == null || D.focus()), d.value === ((B = i.value) == null ? void 0 : B.$el) ? c.value = [Math.min(P, T), T] : c.value = [M, Math.max(M, P)];
      },
      getActiveThumb: o
    }), {
      isFocused: x,
      focus: w,
      blur: V
    } = il(e), _ = k(() => b(c.value[0])), O = k(() => b(c.value[1]));
    return ye(() => {
      const $ = Fn.filterProps(e), P = !!(e.label || n.label || n.prepend);
      return p(Fn, fe({
        class: ["v-slider", "v-range-slider", {
          "v-slider--has-labels": !!n["tick-label"] || f.value,
          "v-slider--focused": x.value,
          "v-slider--pressed": g.value,
          "v-slider--disabled": e.disabled
        }, s.value, e.class],
        style: e.style,
        ref: r
      }, $, {
        focused: x.value
      }), {
        ...n,
        prepend: P ? (M) => {
          var T, L;
          return p(ge, null, [((T = n.label) == null ? void 0 : T.call(n, M)) ?? (e.label ? p(Us, {
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (L = n.prepend) == null ? void 0 : L.call(n, M)]);
        } : void 0,
        default: (M) => {
          var A, D;
          let {
            id: T,
            messagesId: L
          } = M;
          return p("div", {
            class: "v-slider__container",
            onMousedown: S.value ? void 0 : v,
            onTouchstartPassive: S.value ? void 0 : y
          }, [p("input", {
            id: `${T.value}_start`,
            name: e.name || T.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: c.value[0]
          }, null), p("input", {
            id: `${T.value}_stop`,
            name: e.name || T.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: c.value[1]
          }, null), p(g8, {
            ref: C,
            start: _.value,
            stop: O.value
          }, {
            "tick-label": n["tick-label"]
          }), p(bh, {
            ref: i,
            "aria-describedby": L.value,
            focused: x && d.value === ((A = i.value) == null ? void 0 : A.$el),
            modelValue: c.value[0],
            "onUpdate:modelValue": (B) => c.value = [B, c.value[1]],
            onFocus: (B) => {
              var j, I, Z, R;
              w(), d.value = (j = i.value) == null ? void 0 : j.$el, c.value[0] === c.value[1] && c.value[1] === m.value && B.relatedTarget !== ((I = l.value) == null ? void 0 : I.$el) && ((Z = i.value) == null || Z.$el.blur(), (R = l.value) == null || R.$el.focus());
            },
            onBlur: () => {
              V(), d.value = void 0;
            },
            min: m.value,
            max: c.value[1],
            position: _.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          }), p(bh, {
            ref: l,
            "aria-describedby": L.value,
            focused: x && d.value === ((D = l.value) == null ? void 0 : D.$el),
            modelValue: c.value[1],
            "onUpdate:modelValue": (B) => c.value = [c.value[0], B],
            onFocus: (B) => {
              var j, I, Z, R;
              w(), d.value = (j = l.value) == null ? void 0 : j.$el, c.value[0] === c.value[1] && c.value[0] === h.value && B.relatedTarget !== ((I = i.value) == null ? void 0 : I.$el) && ((Z = l.value) == null || Z.$el.blur(), (R = i.value) == null || R.$el.focus());
            },
            onBlur: () => {
              V(), d.value = void 0;
            },
            min: c.value[0],
            max: h.value,
            position: O.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), {};
  }
}), uV = le({
  name: String,
  itemAriaLabel: {
    type: String,
    default: "$vuetify.rating.ariaLabel.item"
  },
  activeColor: String,
  color: String,
  clearable: Boolean,
  disabled: Boolean,
  emptyIcon: {
    type: Ue,
    default: "$ratingEmpty"
  },
  fullIcon: {
    type: Ue,
    default: "$ratingFull"
  },
  halfIncrements: Boolean,
  hover: Boolean,
  length: {
    type: [Number, String],
    default: 5
  },
  readonly: Boolean,
  modelValue: {
    type: [Number, String],
    default: 0
  },
  itemLabels: Array,
  itemLabelPosition: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ripple: Boolean,
  ...Ae(),
  ...Ln(),
  ...Ri(),
  ...nt(),
  ...dt()
}, "VRating"), cV = ve()({
  name: "VRating",
  props: uV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = tn(), {
      themeClasses: i
    } = yt(e), l = Fe(e, "modelValue"), r = k(() => ln(parseFloat(l.value), 0, +e.length)), s = k(() => bi(Number(e.length), 1)), o = k(() => s.value.flatMap((g) => e.halfIncrements ? [g - 0.5, g] : [g])), u = Ve(-1), c = k(() => o.value.map((g) => {
      const v = e.hover && u.value > -1, y = r.value >= g, b = u.value >= g, S = (v ? b : y) ? e.fullIcon : e.emptyIcon, x = e.activeColor ?? e.color, w = y || b ? x : e.color;
      return {
        isFilled: y,
        isHovered: b,
        icon: S,
        color: w
      };
    })), d = k(() => [0, ...o.value].map((g) => {
      function v() {
        u.value = g;
      }
      function y() {
        u.value = -1;
      }
      function b() {
        e.disabled || e.readonly || (l.value = r.value === g && e.clearable ? 0 : g);
      }
      return {
        onMouseenter: e.hover ? v : void 0,
        onMouseleave: e.hover ? y : void 0,
        onClick: b
      };
    })), f = k(() => e.name ?? `v-rating-${Bn()}`);
    function h(g) {
      var _, O;
      let {
        value: v,
        index: y,
        showStar: b = !0
      } = g;
      const {
        onMouseenter: C,
        onMouseleave: S,
        onClick: x
      } = d.value[y + 1], w = `${f.value}-${String(v).replace(".", "-")}`, V = {
        color: (_ = c.value[y]) == null ? void 0 : _.color,
        density: e.density,
        disabled: e.disabled,
        icon: (O = c.value[y]) == null ? void 0 : O.icon,
        ripple: e.ripple,
        size: e.size,
        variant: "plain"
      };
      return p(ge, null, [p("label", {
        for: w,
        class: {
          "v-rating__item--half": e.halfIncrements && v % 1 > 0,
          "v-rating__item--full": e.halfIncrements && v % 1 === 0
        },
        onMouseenter: C,
        onMouseleave: S,
        onClick: x
      }, [p("span", {
        class: "v-rating__hidden"
      }, [a(e.itemAriaLabel, v, e.length)]), b ? n.item ? n.item({
        ...c.value[y],
        props: V,
        value: v,
        index: y,
        rating: r.value
      }) : p(pt, fe({
        "aria-label": a(e.itemAriaLabel, v, e.length)
      }, V), null) : void 0]), p("input", {
        class: "v-rating__hidden",
        name: f.value,
        id: w,
        type: "radio",
        value: v,
        checked: r.value === v,
        tabindex: -1,
        readonly: e.readonly,
        disabled: e.disabled
      }, null)]);
    }
    function m(g) {
      return n["item-label"] ? n["item-label"](g) : g.label ? p("span", null, [g.label]) : p("span", null, [Ee(" ")]);
    }
    return ye(() => {
      var v;
      const g = !!((v = e.itemLabels) != null && v.length) || n["item-label"];
      return p(e.tag, {
        class: ["v-rating", {
          "v-rating--hover": e.hover,
          "v-rating--readonly": e.readonly
        }, i.value, e.class],
        style: e.style
      }, {
        default: () => [p(h, {
          value: 0,
          index: -1,
          showStar: !1
        }, null), s.value.map((y, b) => {
          var C, S;
          return p("div", {
            class: "v-rating__wrapper"
          }, [g && e.itemLabelPosition === "top" ? m({
            value: y,
            index: b,
            label: (C = e.itemLabels) == null ? void 0 : C[b]
          }) : void 0, p("div", {
            class: "v-rating__item"
          }, [e.halfIncrements ? p(ge, null, [p(h, {
            value: y - 0.5,
            index: b * 2
          }, null), p(h, {
            value: y,
            index: b * 2 + 1
          }, null)]) : p(h, {
            value: y,
            index: b
          }, null)]), g && e.itemLabelPosition === "bottom" ? m({
            value: y,
            index: b,
            label: (S = e.itemLabels) == null ? void 0 : S[b]
          }) : void 0]);
        })]
      });
    }), {};
  }
}), dV = {
  actions: "button@2",
  article: "heading, paragraph",
  avatar: "avatar",
  button: "button",
  card: "image, heading",
  "card-avatar": "image, list-item-avatar",
  chip: "chip",
  "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
  "date-picker-options": "text, avatar@2",
  "date-picker-days": "avatar@28",
  divider: "divider",
  heading: "heading",
  image: "image",
  "list-item": "text",
  "list-item-avatar": "avatar, text",
  "list-item-two-line": "sentences",
  "list-item-avatar-two-line": "avatar, sentences",
  "list-item-three-line": "paragraph",
  "list-item-avatar-three-line": "avatar, paragraph",
  ossein: "ossein",
  paragraph: "text@3",
  sentences: "text@2",
  subtitle: "text",
  table: "table-heading, table-thead, table-tbody, table-tfoot",
  "table-heading": "chip, text",
  "table-thead": "heading@6",
  "table-tbody": "table-row-divider@6",
  "table-row-divider": "table-row, divider",
  "table-row": "text@6",
  "table-tfoot": "text@2, avatar@2",
  text: "text"
};
function fV(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return p("div", {
    class: ["v-skeleton-loader__bone", `v-skeleton-loader__${e}`]
  }, [t]);
}
function $g(e) {
  const [t, n] = e.split("@");
  return Array.from({
    length: n
  }).map(() => m1(t));
}
function m1(e) {
  let t = [];
  if (!e) return t;
  const n = dV[e];
  if (e !== n) {
    if (e.includes(",")) return _g(e);
    if (e.includes("@")) return $g(e);
    n.includes(",") ? t = _g(n) : n.includes("@") ? t = $g(n) : n && t.push(m1(n));
  }
  return [fV(e, t)];
}
function _g(e) {
  return e.replace(/\s/g, "").split(",").map(m1);
}
const hV = le({
  boilerplate: Boolean,
  color: String,
  loading: Boolean,
  loadingText: {
    type: String,
    default: "$vuetify.loading"
  },
  type: {
    type: [String, Array],
    default: "ossein"
  },
  ...vn(),
  ...Pn(),
  ...dt()
}, "VSkeletonLoader"), mV = ve()({
  name: "VSkeletonLoader",
  props: hV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: i
    } = kt(ue(e, "color")), {
      dimensionStyles: l
    } = gn(e), {
      elevationClasses: r
    } = Zn(e), {
      themeClasses: s
    } = yt(e), {
      t: o
    } = tn(), u = k(() => m1(Ht(e.type).join(",")));
    return ye(() => {
      var f;
      const c = !n.default || e.loading, d = e.boilerplate || !c ? {} : {
        ariaLive: "polite",
        ariaLabel: o(e.loadingText),
        role: "alert"
      };
      return p("div", fe({
        class: ["v-skeleton-loader", {
          "v-skeleton-loader--boilerplate": e.boilerplate
        }, s.value, a.value, r.value],
        style: [i.value, c ? l.value : {}]
      }, d), [c ? u.value : (f = n.default) == null ? void 0 : f.call(n)]);
    }), {};
  }
}), vV = ve()({
  name: "VSlideGroupItem",
  props: Er(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Nr(e, A3);
    return () => {
      var i;
      return (i = n.default) == null ? void 0 : i.call(n, {
        isSelected: a.isSelected.value,
        select: a.select,
        toggle: a.toggle,
        selectedClass: a.selectedClass.value
      });
    };
  }
});
function gV(e) {
  const t = Ve(e());
  let n = -1;
  function a() {
    clearInterval(n);
  }
  function i() {
    a(), et(() => t.value = e());
  }
  function l(r) {
    const s = r ? getComputedStyle(r) : {
      transitionDuration: 0.2
    }, o = parseFloat(s.transitionDuration) * 1e3 || 200;
    if (a(), t.value <= 0) return;
    const u = performance.now();
    n = window.setInterval(() => {
      const c = performance.now() - u + o;
      t.value = Math.max(e() - c, 0), t.value <= 0 && a();
    }, o);
  }
  return Xn(a), {
    clear: a,
    time: t,
    start: l,
    reset: i
  };
}
const pV = le({
  multiLine: Boolean,
  text: String,
  timer: [Boolean, String],
  timeout: {
    type: [Number, String],
    default: 5e3
  },
  vertical: Boolean,
  ...al({
    location: "bottom"
  }),
  ...Ws(),
  ...Dt(),
  ...Na(),
  ...dt(),
  ...hn(bu({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])
}, "VSnackbar"), yV = ve()({
  name: "VSnackbar",
  props: pV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), {
      positionClasses: i
    } = qs(e), {
      scopeId: l
    } = Rr(), {
      themeClasses: r
    } = yt(e), {
      colorClasses: s,
      colorStyles: o,
      variantClasses: u
    } = Br(e), {
      roundedClasses: c
    } = qt(e), d = gV(() => Number(e.timeout)), f = Y(), h = Y(), m = Ve(!1), g = Ve(0), v = Y(), y = ct(Bo, void 0);
    la(() => !!y, () => {
      const P = F5();
      jt(() => {
        v.value = P.mainStyles.value;
      });
    }), pe(a, C), pe(() => e.timeout, C), rt(() => {
      a.value && C();
    });
    let b = -1;
    function C() {
      d.reset(), window.clearTimeout(b);
      const P = Number(e.timeout);
      if (!a.value || P === -1) return;
      const M = o2(h.value);
      d.start(M), b = window.setTimeout(() => {
        a.value = !1;
      }, P);
    }
    function S() {
      d.reset(), window.clearTimeout(b);
    }
    function x() {
      m.value = !0, S();
    }
    function w() {
      m.value = !1, C();
    }
    function V(P) {
      g.value = P.touches[0].clientY;
    }
    function _(P) {
      Math.abs(g.value - P.changedTouches[0].clientY) > 50 && (a.value = !1);
    }
    function O() {
      m.value && w();
    }
    const $ = k(() => e.location.split(" ").reduce((P, M) => (P[`v-snackbar--${M}`] = !0, P), {}));
    return ye(() => {
      const P = Ka.filterProps(e), M = !!(n.default || n.text || e.text);
      return p(Ka, fe({
        ref: f,
        class: ["v-snackbar", {
          "v-snackbar--active": a.value,
          "v-snackbar--multi-line": e.multiLine && !e.vertical,
          "v-snackbar--timer": !!e.timer,
          "v-snackbar--vertical": e.vertical
        }, $.value, i.value, e.class],
        style: [v.value, e.style]
      }, P, {
        modelValue: a.value,
        "onUpdate:modelValue": (T) => a.value = T,
        contentProps: fe({
          class: ["v-snackbar__wrapper", r.value, s.value, c.value, u.value],
          style: [o.value],
          onPointerenter: x,
          onPointerleave: w
        }, P.contentProps),
        persistent: !0,
        noClickAnimation: !0,
        scrim: !1,
        scrollStrategy: "none",
        _disableGlobalStack: !0,
        onTouchstartPassive: V,
        onTouchend: _,
        onAfterLeave: O
      }, l), {
        default: () => {
          var T, L;
          return [Bl(!1, "v-snackbar"), e.timer && !m.value && p("div", {
            key: "timer",
            class: "v-snackbar__timer"
          }, [p(Yd, {
            ref: h,
            color: typeof e.timer == "string" ? e.timer : "info",
            max: e.timeout,
            "model-value": d.time.value
          }, null)]), M && p("div", {
            key: "content",
            class: "v-snackbar__content",
            role: "status",
            "aria-live": "polite"
          }, [((T = n.text) == null ? void 0 : T.call(n)) ?? e.text, (L = n.default) == null ? void 0 : L.call(n)]), n.actions && p(lt, {
            defaults: {
              VBtn: {
                variant: "text",
                ripple: !1,
                slim: !0
              }
            }
          }, {
            default: () => [p("div", {
              class: "v-snackbar__actions"
            }, [n.actions({
              isActive: a
            })])]
          })];
        },
        activator: n.activator
      });
    }), Ea({}, f);
  }
}), r7 = le({
  autoDraw: Boolean,
  autoDrawDuration: [Number, String],
  autoDrawEasing: {
    type: String,
    default: "ease"
  },
  color: String,
  gradient: {
    type: Array,
    default: () => []
  },
  gradientDirection: {
    type: String,
    validator: (e) => ["top", "bottom", "left", "right"].includes(e),
    default: "top"
  },
  height: {
    type: [String, Number],
    default: 75
  },
  labels: {
    type: Array,
    default: () => []
  },
  labelSize: {
    type: [Number, String],
    default: 7
  },
  lineWidth: {
    type: [String, Number],
    default: 4
  },
  id: String,
  itemValue: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  min: [String, Number],
  max: [String, Number],
  padding: {
    type: [String, Number],
    default: 8
  },
  showLabels: Boolean,
  smooth: Boolean,
  width: {
    type: [Number, String],
    default: 300
  }
}, "Line"), s7 = le({
  autoLineWidth: Boolean,
  ...r7()
}, "VBarline"), Mg = ve()({
  name: "VBarline",
  props: s7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Bn(), i = k(() => e.id || `barline-${a}`), l = k(() => Number(e.autoDrawDuration) || 500), r = k(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), s = k(() => parseFloat(e.lineWidth) || 4), o = k(() => Math.max(e.modelValue.length * s.value, Number(e.width))), u = k(() => ({
      minX: 0,
      maxX: o.value,
      minY: 0,
      maxY: parseInt(e.height, 10)
    })), c = k(() => e.modelValue.map((g) => bn(g, e.itemValue, g)));
    function d(g, v) {
      const {
        minX: y,
        maxX: b,
        minY: C,
        maxY: S
      } = v, x = g.length;
      let w = e.max != null ? Number(e.max) : Math.max(...g), V = e.min != null ? Number(e.min) : Math.min(...g);
      V > 0 && e.min == null && (V = 0), w < 0 && e.max == null && (w = 0);
      const _ = b / x, O = (S - C) / (w - V || 1), $ = S - Math.abs(V * O);
      return g.map((P, M) => {
        const T = Math.abs(O * P);
        return {
          x: y + M * _,
          y: $ - T + +(P < 0) * T,
          height: T,
          value: P
        };
      });
    }
    const f = k(() => {
      const g = [], v = d(c.value, u.value), y = v.length;
      for (let b = 0; g.length < y; b++) {
        const C = v[b];
        let S = e.labels[b];
        S || (S = typeof C == "object" ? C.value : C), g.push({
          x: C.x,
          value: String(S)
        });
      }
      return g;
    }), h = k(() => d(c.value, u.value)), m = k(() => (Math.abs(h.value[0].x - h.value[1].x) - s.value) / 2);
    ye(() => {
      const g = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return p("svg", {
        display: "block"
      }, [p("defs", null, [p("linearGradient", {
        id: i.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [g.map((v, y) => p("stop", {
        offset: y / Math.max(g.length - 1, 1),
        "stop-color": v || "currentColor"
      }, null))])]), p("clipPath", {
        id: `${i.value}-clip`
      }, [h.value.map((v) => p("rect", {
        x: v.x + m.value,
        y: v.y,
        width: s.value,
        height: v.height,
        rx: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0,
        ry: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0
      }, [e.autoDraw && p(ge, null, [p("animate", {
        attributeName: "y",
        from: v.y + v.height,
        to: v.y,
        dur: `${l.value}ms`,
        fill: "freeze"
      }, null), p("animate", {
        attributeName: "height",
        from: "0",
        to: v.height,
        dur: `${l.value}ms`,
        fill: "freeze"
      }, null)])]))]), r.value && p("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [f.value.map((v, y) => {
        var b;
        return p("text", {
          x: v.x + m.value + s.value / 2,
          y: parseInt(e.height, 10) - 2 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((b = n.label) == null ? void 0 : b.call(n, {
          index: y,
          value: v.value
        })) ?? v.value]);
      })]), p("g", {
        "clip-path": `url(#${i.value}-clip)`,
        fill: `url(#${i.value})`
      }, [p("rect", {
        x: 0,
        y: 0,
        width: Math.max(e.modelValue.length * s.value, Number(e.width)),
        height: e.height
      }, null)])]);
    });
  }
});
function OV(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
  if (e.length === 0) return "";
  const i = e.shift(), l = e[e.length - 1];
  return (n ? `M${i.x} ${a - i.x + 2} L${i.x} ${i.y}` : `M${i.x} ${i.y}`) + e.map((r, s) => {
    const o = e[s + 1], u = e[s - 1] || i, c = o && bV(o, r, u);
    if (!o || c)
      return `L${r.x} ${r.y}`;
    const d = Math.min(Vg(u, r), Vg(o, r)), h = d / 2 < t ? d / 2 : t, m = Tg(u, r, h), g = Tg(o, r, h);
    return `L${m.x} ${m.y}S${r.x} ${r.y} ${g.x} ${g.y}`;
  }).join("") + (n ? `L${l.x} ${a - i.x + 2} Z` : "");
}
function Wu(e) {
  return parseInt(e, 10);
}
function bV(e, t, n) {
  return Wu(e.x + n.x) === Wu(2 * t.x) && Wu(e.y + n.y) === Wu(2 * t.y);
}
function Vg(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function Tg(e, t, n) {
  const a = {
    x: e.x - t.x,
    y: e.y - t.y
  }, i = Math.sqrt(a.x * a.x + a.y * a.y), l = {
    x: a.x / i,
    y: a.y / i
  };
  return {
    x: t.x + l.x * n,
    y: t.y + l.y * n
  };
}
const o7 = le({
  fill: Boolean,
  ...r7()
}, "VTrendline"), Lg = ve()({
  name: "VTrendline",
  props: o7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Bn(), i = k(() => e.id || `trendline-${a}`), l = k(() => Number(e.autoDrawDuration) || (e.fill ? 500 : 2e3)), r = Y(0), s = Y(null);
    function o(v, y) {
      const {
        minX: b,
        maxX: C,
        minY: S,
        maxY: x
      } = y, w = v.length, V = e.max != null ? Number(e.max) : Math.max(...v), _ = e.min != null ? Number(e.min) : Math.min(...v), O = (C - b) / (w - 1), $ = (x - S) / (V - _ || 1);
      return v.map((P, M) => ({
        x: b + M * O,
        y: x - (P - _) * $,
        value: P
      }));
    }
    const u = k(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), c = k(() => parseFloat(e.lineWidth) || 4), d = k(() => Number(e.width)), f = k(() => {
      const v = Number(e.padding);
      return {
        minX: v,
        maxX: d.value - v,
        minY: v,
        maxY: parseInt(e.height, 10) - v
      };
    }), h = k(() => e.modelValue.map((v) => bn(v, e.itemValue, v))), m = k(() => {
      const v = [], y = o(h.value, f.value), b = y.length;
      for (let C = 0; v.length < b; C++) {
        const S = y[C];
        let x = e.labels[C];
        x || (x = typeof S == "object" ? S.value : S), v.push({
          x: S.x,
          value: String(x)
        });
      }
      return v;
    });
    pe(() => e.modelValue, async () => {
      if (await et(), !e.autoDraw || !s.value) return;
      const v = s.value, y = v.getTotalLength();
      e.fill ? (v.style.transformOrigin = "bottom center", v.style.transition = "none", v.style.transform = "scaleY(0)", v.getBoundingClientRect(), v.style.transition = `transform ${l.value}ms ${e.autoDrawEasing}`, v.style.transform = "scaleY(1)") : (v.style.strokeDasharray = `${y}`, v.style.strokeDashoffset = `${y}`, v.getBoundingClientRect(), v.style.transition = `stroke-dashoffset ${l.value}ms ${e.autoDrawEasing}`, v.style.strokeDashoffset = "0"), r.value = y;
    }, {
      immediate: !0
    });
    function g(v) {
      return OV(o(h.value, f.value), e.smooth ? 8 : Number(e.smooth), v, parseInt(e.height, 10));
    }
    ye(() => {
      var y;
      const v = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return p("svg", {
        display: "block",
        "stroke-width": parseFloat(e.lineWidth) ?? 4
      }, [p("defs", null, [p("linearGradient", {
        id: i.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [v.map((b, C) => p("stop", {
        offset: C / Math.max(v.length - 1, 1),
        "stop-color": b || "currentColor"
      }, null))])]), u.value && p("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [m.value.map((b, C) => {
        var S;
        return p("text", {
          x: b.x + c.value / 2 + c.value / 2,
          y: parseInt(e.height, 10) - 4 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((S = n.label) == null ? void 0 : S.call(n, {
          index: C,
          value: b.value
        })) ?? b.value]);
      })]), p("path", {
        ref: s,
        d: g(e.fill),
        fill: e.fill ? `url(#${i.value})` : "none",
        stroke: e.fill ? "none" : `url(#${i.value})`
      }, null), e.fill && p("path", {
        d: g(!1),
        fill: "none",
        stroke: e.color ?? ((y = e.gradient) == null ? void 0 : y[0])
      }, null)]);
    });
  }
}), CV = le({
  type: {
    type: String,
    default: "trend"
  },
  ...s7(),
  ...o7()
}, "VSparkline"), wV = ve()({
  name: "VSparkline",
  props: CV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: a,
      textColorStyles: i
    } = zn(ue(e, "color")), l = k(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), r = k(() => {
      let s = parseInt(e.height, 10);
      return l.value && (s += parseInt(e.labelSize, 10) * 1.5), s;
    });
    ye(() => {
      const s = e.type === "trend" ? Lg : Mg, o = e.type === "trend" ? Lg.filterProps(e) : Mg.filterProps(e);
      return p(s, fe({
        key: e.type,
        class: a.value,
        style: i.value,
        viewBox: `0 0 ${e.width} ${parseInt(r.value, 10)}`
      }, o), n);
    });
  }
}), kV = le({
  ...Ae(),
  ...U3({
    offset: 8,
    minWidth: 0,
    openDelay: 0,
    closeDelay: 100,
    location: "top center",
    transition: "scale-transition"
  })
}, "VSpeedDial"), SV = ve()({
  name: "VSpeedDial",
  props: kV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Fe(e, "modelValue"), i = Y(), l = k(() => {
      var u;
      const [s, o = "center"] = ((u = e.location) == null ? void 0 : u.split(" ")) ?? [];
      return `${s} ${o}`;
    }), r = k(() => ({
      [`v-speed-dial__content--${l.value.replace(" ", "-")}`]: !0
    }));
    return ye(() => {
      const s = ws.filterProps(e);
      return p(ws, fe(s, {
        modelValue: a.value,
        "onUpdate:modelValue": (o) => a.value = o,
        class: e.class,
        style: e.style,
        contentClass: ["v-speed-dial__content", r.value, e.contentClass],
        location: l.value,
        ref: i,
        transition: "fade-transition"
      }), {
        ...n,
        default: (o) => p(lt, {
          defaults: {
            VBtn: {
              size: "small"
            }
          }
        }, {
          default: () => [p(Kn, {
            appear: !0,
            group: !0,
            transition: e.transition
          }, {
            default: () => {
              var u;
              return [(u = n.default) == null ? void 0 : u.call(n, o)];
            }
          })]
        })
      });
    }), {};
  }
}), nm = Symbol.for("vuetify:v-stepper"), u7 = le({
  color: String,
  disabled: {
    type: [Boolean, String],
    default: !1
  },
  prevText: {
    type: String,
    default: "$vuetify.stepper.prev"
  },
  nextText: {
    type: String,
    default: "$vuetify.stepper.next"
  }
}, "VStepperActions"), c7 = ve()({
  name: "VStepperActions",
  props: u7(),
  emits: {
    "click:prev": () => !0,
    "click:next": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      t: i
    } = tn();
    function l() {
      n("click:prev");
    }
    function r() {
      n("click:next");
    }
    return ye(() => {
      const s = {
        onClick: l
      }, o = {
        onClick: r
      };
      return p("div", {
        class: "v-stepper-actions"
      }, [p(lt, {
        defaults: {
          VBtn: {
            disabled: ["prev", !0].includes(e.disabled),
            text: i(e.prevText),
            variant: "text"
          }
        }
      }, {
        default: () => {
          var u;
          return [((u = a.prev) == null ? void 0 : u.call(a, {
            props: s
          })) ?? p(pt, s, null)];
        }
      }), p(lt, {
        defaults: {
          VBtn: {
            color: e.color,
            disabled: ["next", !0].includes(e.disabled),
            text: i(e.nextText),
            variant: "tonal"
          }
        }
      }, {
        default: () => {
          var u;
          return [((u = a.next) == null ? void 0 : u.call(a, {
            props: o
          })) ?? p(pt, o, null)];
        }
      })]);
    }), {};
  }
}), d7 = Di("v-stepper-header"), xV = le({
  color: String,
  title: String,
  subtitle: String,
  complete: Boolean,
  completeIcon: {
    type: String,
    default: "$complete"
  },
  editable: Boolean,
  editIcon: {
    type: String,
    default: "$edit"
  },
  error: Boolean,
  errorIcon: {
    type: String,
    default: "$error"
  },
  icon: String,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  rules: {
    type: Array,
    default: () => []
  }
}, "StepperItem"), PV = le({
  ...xV(),
  ...Er()
}, "VStepperItem"), f7 = ve()({
  name: "VStepperItem",
  directives: {
    Ripple: nl
  },
  props: PV(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Nr(e, nm, !0), i = k(() => (a == null ? void 0 : a.value.value) ?? e.value), l = k(() => e.rules.every((f) => f() === !0)), r = k(() => !e.disabled && e.editable), s = k(() => !e.disabled && e.editable), o = k(() => e.error || !l.value), u = k(() => e.complete || e.rules.length > 0 && l.value), c = k(() => o.value ? e.errorIcon : u.value ? e.completeIcon : a.isSelected.value && e.editable ? e.editIcon : e.icon), d = k(() => ({
      canEdit: s.value,
      hasError: o.value,
      hasCompleted: u.value,
      title: e.title,
      subtitle: e.subtitle,
      step: i.value,
      value: e.value
    }));
    return ye(() => {
      var v, y, b;
      const f = (!a || a.isSelected.value || u.value || s.value) && !o.value && !e.disabled, h = !!(e.title != null || n.title), m = !!(e.subtitle != null || n.subtitle);
      function g() {
        a == null || a.toggle();
      }
      return Ct(p("button", {
        class: ["v-stepper-item", {
          "v-stepper-item--complete": u.value,
          "v-stepper-item--disabled": e.disabled,
          "v-stepper-item--error": o.value
        }, a == null ? void 0 : a.selectedClass.value],
        disabled: !e.editable,
        onClick: g
      }, [r.value && Bl(!0, "v-stepper-item"), p(Da, {
        key: "stepper-avatar",
        class: "v-stepper-item__avatar",
        color: f ? e.color : void 0,
        size: 24
      }, {
        default: () => {
          var C;
          return [((C = n.icon) == null ? void 0 : C.call(n, d.value)) ?? (c.value ? p(vt, {
            icon: c.value
          }, null) : i.value)];
        }
      }), p("div", {
        class: "v-stepper-item__content"
      }, [h && p("div", {
        key: "title",
        class: "v-stepper-item__title"
      }, [((v = n.title) == null ? void 0 : v.call(n, d.value)) ?? e.title]), m && p("div", {
        key: "subtitle",
        class: "v-stepper-item__subtitle"
      }, [((y = n.subtitle) == null ? void 0 : y.call(n, d.value)) ?? e.subtitle]), (b = n.default) == null ? void 0 : b.call(n, d.value)])]), [[xa("ripple"), e.ripple && e.editable, null]]);
    }), {};
  }
}), $V = le({
  ...hn(n1(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VStepperWindow"), h7 = ve()({
  name: "VStepperWindow",
  props: $V(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = ct(nm, null), i = Fe(e, "modelValue"), l = k({
      get() {
        var r;
        return i.value != null || !a ? i.value : (r = a.items.value.find((s) => a.selected.value.includes(s.id))) == null ? void 0 : r.value;
      },
      set(r) {
        i.value = r;
      }
    });
    return ye(() => {
      const r = yr.filterProps(e);
      return p(yr, fe({
        _as: "VStepperWindow"
      }, r, {
        modelValue: l.value,
        "onUpdate:modelValue": (s) => l.value = s,
        class: ["v-stepper-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), _V = le({
  ...a1()
}, "VStepperWindowItem"), m7 = ve()({
  name: "VStepperWindowItem",
  props: _V(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => {
      const a = Or.filterProps(e);
      return p(Or, fe({
        _as: "VStepperWindowItem"
      }, a, {
        class: ["v-stepper-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
}), MV = le({
  altLabels: Boolean,
  bgColor: String,
  completeIcon: String,
  editIcon: String,
  editable: Boolean,
  errorIcon: String,
  hideActions: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: String,
    default: "title"
  },
  itemValue: {
    type: String,
    default: "value"
  },
  nonLinear: Boolean,
  flat: Boolean,
  ...Qr()
}, "Stepper"), VV = le({
  ...MV(),
  ...Zr({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  }),
  ...i1(),
  ...Id(u7(), ["prevText", "nextText"])
}, "VStepper"), TV = ve()({
  name: "VStepper",
  props: VV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: a,
      next: i,
      prev: l,
      selected: r
    } = Zl(e, nm), {
      displayClasses: s,
      mobile: o
    } = Za(e), {
      completeIcon: u,
      editIcon: c,
      errorIcon: d,
      color: f,
      editable: h,
      prevText: m,
      nextText: g
    } = Tr(e), v = k(() => e.items.map((C, S) => {
      const x = bn(C, e.itemTitle, C), w = bn(C, e.itemValue, S + 1);
      return {
        title: x,
        value: w,
        raw: C
      };
    })), y = k(() => a.value.findIndex((C) => r.value.includes(C.id))), b = k(() => e.disabled ? e.disabled : y.value === 0 ? "prev" : y.value === a.value.length - 1 ? "next" : !1);
    return Yt({
      VStepperItem: {
        editable: h,
        errorIcon: d,
        completeIcon: u,
        editIcon: c,
        prevText: m,
        nextText: g
      },
      VStepperActions: {
        color: f,
        disabled: b,
        prevText: m,
        nextText: g
      }
    }), ye(() => {
      const C = br.filterProps(e), S = !!(n.header || e.items.length), x = e.items.length > 0, w = !e.hideActions && !!(x || n.actions);
      return p(br, fe(C, {
        color: e.bgColor,
        class: ["v-stepper", {
          "v-stepper--alt-labels": e.altLabels,
          "v-stepper--flat": e.flat,
          "v-stepper--non-linear": e.nonLinear,
          "v-stepper--mobile": o.value
        }, s.value, e.class],
        style: e.style
      }), {
        default: () => {
          var V, _;
          return [S && p(d7, {
            key: "stepper-header"
          }, {
            default: () => [v.value.map((O, $) => {
              let {
                raw: P,
                ...M
              } = O;
              return p(ge, null, [!!$ && p(Su, null, null), p(f7, M, {
                default: n[`header-item.${M.value}`] ?? n.header,
                icon: n.icon,
                title: n.title,
                subtitle: n.subtitle
              })]);
            })]
          }), x && p(h7, {
            key: "stepper-window"
          }, {
            default: () => [v.value.map((O) => p(m7, {
              value: O.value
            }, {
              default: () => {
                var $, P;
                return (($ = n[`item.${O.value}`]) == null ? void 0 : $.call(n, O)) ?? ((P = n.item) == null ? void 0 : P.call(n, O));
              }
            }))]
          }), (V = n.default) == null ? void 0 : V.call(n, {
            prev: l,
            next: i
          }), w && (((_ = n.actions) == null ? void 0 : _.call(n, {
            next: i,
            prev: l
          })) ?? p(c7, {
            key: "stepper-actions",
            "onClick:prev": l,
            "onClick:next": i
          }, n))];
        }
      });
    }), {
      prev: l,
      next: i
    };
  }
}), LV = le({
  indeterminate: Boolean,
  inset: Boolean,
  flat: Boolean,
  loading: {
    type: [Boolean, String],
    default: !1
  },
  ...ll(),
  ...Ud()
}, "VSwitch"), QV = ve()({
  name: "VSwitch",
  inheritAttrs: !1,
  props: LV(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const i = Fe(e, "indeterminate"), l = Fe(e, "modelValue"), {
      loaderClasses: r
    } = Cu(e), {
      isFocused: s,
      focus: o,
      blur: u
    } = il(e), c = Y(), d = bt && window.matchMedia("(forced-colors: active)").matches, f = k(() => typeof e.loading == "string" && e.loading !== "" ? e.loading : e.color), h = Bn(), m = k(() => e.id || `switch-${h}`);
    function g() {
      i.value && (i.value = !1);
    }
    function v(y) {
      var b, C;
      y.stopPropagation(), y.preventDefault(), (C = (b = c.value) == null ? void 0 : b.input) == null || C.click();
    }
    return ye(() => {
      const [y, b] = Il(n), C = Fn.filterProps(e), S = $l.filterProps(e);
      return p(Fn, fe({
        class: ["v-switch", {
          "v-switch--flat": e.flat
        }, {
          "v-switch--inset": e.inset
        }, {
          "v-switch--indeterminate": i.value
        }, r.value, e.class]
      }, y, C, {
        modelValue: l.value,
        "onUpdate:modelValue": (x) => l.value = x,
        id: m.value,
        focused: s.value,
        style: e.style
      }), {
        ...a,
        default: (x) => {
          let {
            id: w,
            messagesId: V,
            isDisabled: _,
            isReadonly: O,
            isValid: $
          } = x;
          const P = {
            model: l,
            isValid: $
          };
          return p($l, fe({
            ref: c
          }, S, {
            modelValue: l.value,
            "onUpdate:modelValue": [(M) => l.value = M, g],
            id: w.value,
            "aria-describedby": V.value,
            type: "checkbox",
            "aria-checked": i.value ? "mixed" : void 0,
            disabled: _.value,
            readonly: O.value,
            onFocus: o,
            onBlur: u
          }, b), {
            ...a,
            default: (M) => {
              let {
                backgroundColorClasses: T,
                backgroundColorStyles: L
              } = M;
              return p("div", {
                class: ["v-switch__track", d ? void 0 : T.value],
                style: L.value,
                onClick: v
              }, [a["track-true"] && p("div", {
                key: "prepend",
                class: "v-switch__track-true"
              }, [a["track-true"](P)]), a["track-false"] && p("div", {
                key: "append",
                class: "v-switch__track-false"
              }, [a["track-false"](P)])]);
            },
            input: (M) => {
              let {
                inputNode: T,
                icon: L,
                backgroundColorClasses: A,
                backgroundColorStyles: D
              } = M;
              return p(ge, null, [T, p("div", {
                class: ["v-switch__thumb", {
                  "v-switch__thumb--filled": L || e.loading
                }, e.inset || d ? void 0 : A.value],
                style: e.inset ? void 0 : D.value
              }, [a.thumb ? p(lt, {
                defaults: {
                  VIcon: {
                    icon: L,
                    size: "x-small"
                  }
                }
              }, {
                default: () => [a.thumb({
                  ...P,
                  icon: L
                })]
              }) : p(_2, null, {
                default: () => [e.loading ? p(wu, {
                  name: "v-switch",
                  active: !0,
                  color: $.value === !1 ? void 0 : f.value
                }, {
                  default: (B) => a.loader ? a.loader(B) : p(Cs, {
                    active: B.isActive,
                    color: B.color,
                    indeterminate: !0,
                    size: "16",
                    width: "2"
                  }, null)
                }) : L && p(vt, {
                  key: String(L),
                  icon: L,
                  size: "x-small"
                }, null)]
              })])]);
            }
          });
        }
      });
    }), {};
  }
}), AV = le({
  color: String,
  height: [Number, String],
  window: Boolean,
  ...Ae(),
  ...Pn(),
  ...Ar(),
  ...Dt(),
  ...nt(),
  ...dt()
}, "VSystemBar"), DV = ve()({
  name: "VSystemBar",
  props: AV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e), {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = kt(ue(e, "color")), {
      elevationClasses: r
    } = Zn(e), {
      roundedClasses: s
    } = qt(e), {
      ssrBootStyles: o
    } = Ir(), u = k(() => e.height ?? (e.window ? 32 : 24)), {
      layoutItemStyles: c
    } = Dr({
      id: e.name,
      order: k(() => parseInt(e.order, 10)),
      position: Ve("top"),
      layoutSize: u,
      elementSize: u,
      active: k(() => !0),
      absolute: ue(e, "absolute")
    });
    return ye(() => p(e.tag, {
      class: ["v-system-bar", {
        "v-system-bar--window": e.window
      }, a.value, i.value, r.value, s.value, e.class],
      style: [l.value, c.value, o.value, e.style]
    }, n)), {};
  }
}), am = Symbol.for("vuetify:v-tabs"), RV = le({
  fixed: Boolean,
  sliderColor: String,
  hideSlider: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...hn(qd({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab"), v7 = ve()({
  name: "VTab",
  props: RV(),
  setup(e, t) {
    let {
      slots: n,
      attrs: a
    } = t;
    const {
      textColorClasses: i,
      textColorStyles: l
    } = zn(e, "sliderColor"), r = Y(), s = Y(), o = k(() => e.direction === "horizontal"), u = k(() => {
      var d, f;
      return ((f = (d = r.value) == null ? void 0 : d.group) == null ? void 0 : f.isSelected.value) ?? !1;
    });
    function c(d) {
      var h, m;
      let {
        value: f
      } = d;
      if (f) {
        const g = (m = (h = r.value) == null ? void 0 : h.$el.parentElement) == null ? void 0 : m.querySelector(".v-tab--selected .v-tab__slider"), v = s.value;
        if (!g || !v) return;
        const y = getComputedStyle(g).color, b = g.getBoundingClientRect(), C = v.getBoundingClientRect(), S = o.value ? "x" : "y", x = o.value ? "X" : "Y", w = o.value ? "right" : "bottom", V = o.value ? "width" : "height", _ = b[S], O = C[S], $ = _ > O ? b[w] - C[w] : b[S] - C[S], P = Math.sign($) > 0 ? o.value ? "right" : "bottom" : Math.sign($) < 0 ? o.value ? "left" : "top" : "center", T = (Math.abs($) + (Math.sign($) < 0 ? b[V] : C[V])) / Math.max(b[V], C[V]) || 0, L = b[V] / C[V] || 0, A = 1.5;
        tr(v, {
          backgroundColor: [y, "currentcolor"],
          transform: [`translate${x}(${$}px) scale${x}(${L})`, `translate${x}(${$ / A}px) scale${x}(${(T - 1) / A + 1})`, "none"],
          transformOrigin: Array(3).fill(P)
        }, {
          duration: 225,
          easing: Ro
        });
      }
    }
    return ye(() => {
      const d = pt.filterProps(e);
      return p(pt, fe({
        symbol: am,
        ref: r,
        class: ["v-tab", e.class],
        style: e.style,
        tabindex: u.value ? 0 : -1,
        role: "tab",
        "aria-selected": String(u.value),
        active: !1
      }, d, a, {
        block: e.fixed,
        maxWidth: e.fixed ? 300 : void 0,
        "onGroup:selected": c
      }), {
        ...n,
        default: () => {
          var f;
          return p(ge, null, [((f = n.default) == null ? void 0 : f.call(n)) ?? e.text, !e.hideSlider && p("div", {
            ref: s,
            class: ["v-tab__slider", i.value],
            style: l.value
          }, null)]);
        }
      });
    }), Ea({}, r);
  }
}), IV = le({
  ...hn(n1(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VTabsWindow"), g7 = ve()({
  name: "VTabsWindow",
  props: IV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = ct(am, null), i = Fe(e, "modelValue"), l = k({
      get() {
        var r;
        return i.value != null || !a ? i.value : (r = a.items.value.find((s) => a.selected.value.includes(s.id))) == null ? void 0 : r.value;
      },
      set(r) {
        i.value = r;
      }
    });
    return ye(() => {
      const r = yr.filterProps(e);
      return p(yr, fe({
        _as: "VTabsWindow"
      }, r, {
        modelValue: l.value,
        "onUpdate:modelValue": (s) => l.value = s,
        class: ["v-tabs-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), BV = le({
  ...a1()
}, "VTabsWindowItem"), p7 = ve()({
  name: "VTabsWindowItem",
  props: BV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ye(() => {
      const a = Or.filterProps(e);
      return p(Or, fe({
        _as: "VTabsWindowItem"
      }, a, {
        class: ["v-tabs-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
});
function ZV(e) {
  return e ? e.map((t) => s2(t) ? t : {
    text: t,
    value: t
  }) : [];
}
const EV = le({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  sliderColor: String,
  ...Q2({
    mandatory: "force",
    selectedClass: "v-tab-item--selected"
  }),
  ...Ln(),
  ...nt()
}, "VTabs"), NV = ve()({
  name: "VTabs",
  props: EV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const i = Fe(e, "modelValue"), l = k(() => ZV(e.items)), {
      densityClasses: r
    } = ea(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: o
    } = kt(ue(e, "bgColor")), {
      scopeId: u
    } = Rr();
    return Yt({
      VTab: {
        color: ue(e, "color"),
        direction: ue(e, "direction"),
        stacked: ue(e, "stacked"),
        fixed: ue(e, "fixedTabs"),
        sliderColor: ue(e, "sliderColor"),
        hideSlider: ue(e, "hideSlider")
      }
    }), ye(() => {
      const c = jo.filterProps(e), d = !!(a.window || e.items.length > 0);
      return p(ge, null, [p(jo, fe(c, {
        modelValue: i.value,
        "onUpdate:modelValue": (f) => i.value = f,
        class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
          "v-tabs--fixed-tabs": e.fixedTabs,
          "v-tabs--grow": e.grow,
          "v-tabs--stacked": e.stacked
        }, r.value, s.value, e.class],
        style: [{
          "--v-tabs-height": Qe(e.height)
        }, o.value, e.style],
        role: "tablist",
        symbol: am
      }, u, n), {
        default: () => {
          var f;
          return [((f = a.default) == null ? void 0 : f.call(a)) ?? l.value.map((h) => {
            var m;
            return ((m = a.tab) == null ? void 0 : m.call(a, {
              item: h
            })) ?? p(v7, fe(h, {
              key: h.text,
              value: h.value
            }), {
              default: a[`tab.${h.value}`] ? () => {
                var g;
                return (g = a[`tab.${h.value}`]) == null ? void 0 : g.call(a, {
                  item: h
                });
              } : void 0
            });
          })];
        }
      }), d && p(g7, fe({
        modelValue: i.value,
        "onUpdate:modelValue": (f) => i.value = f,
        key: "tabs-window"
      }, u), {
        default: () => {
          var f;
          return [l.value.map((h) => {
            var m;
            return ((m = a.item) == null ? void 0 : m.call(a, {
              item: h
            })) ?? p(p7, {
              value: h.value
            }, {
              default: () => {
                var g;
                return (g = a[`item.${h.value}`]) == null ? void 0 : g.call(a, {
                  item: h
                });
              }
            });
          }), (f = a.window) == null ? void 0 : f.call(a)];
        }
      })]);
    }), {};
  }
}), HV = le({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (e) => !isNaN(parseFloat(e))
  },
  maxRows: {
    type: [Number, String],
    validator: (e) => !isNaN(parseFloat(e))
  },
  suffix: String,
  modelModifiers: Object,
  ...ll(),
  ...xu()
}, "VTextarea"), jV = ve()({
  name: "VTextarea",
  directives: {
    Intersect: pu
  },
  inheritAttrs: !1,
  props: HV(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: i
    } = t;
    const l = Fe(e, "modelValue"), {
      isFocused: r,
      focus: s,
      blur: o
    } = il(e), u = k(() => typeof e.counterValue == "function" ? e.counterValue(l.value) : (l.value || "").toString().length), c = k(() => {
      if (n.maxlength) return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    });
    function d(P, M) {
      var T, L;
      !e.autofocus || !P || (L = (T = M[0].target) == null ? void 0 : T.focus) == null || L.call(T);
    }
    const f = Y(), h = Y(), m = Ve(""), g = Y(), v = k(() => e.persistentPlaceholder || r.value || e.active);
    function y() {
      var P;
      g.value !== document.activeElement && ((P = g.value) == null || P.focus()), r.value || s();
    }
    function b(P) {
      y(), a("click:control", P);
    }
    function C(P) {
      a("mousedown:control", P);
    }
    function S(P) {
      P.stopPropagation(), y(), et(() => {
        l.value = "", d2(e["onClick:clear"], P);
      });
    }
    function x(P) {
      var T;
      const M = P.target;
      if (l.value = M.value, (T = e.modelModifiers) != null && T.trim) {
        const L = [M.selectionStart, M.selectionEnd];
        et(() => {
          M.selectionStart = L[0], M.selectionEnd = L[1];
        });
      }
    }
    const w = Y(), V = Y(+e.rows), _ = k(() => ["plain", "underlined"].includes(e.variant));
    jt(() => {
      e.autoGrow || (V.value = +e.rows);
    });
    function O() {
      e.autoGrow && et(() => {
        if (!w.value || !h.value) return;
        const P = getComputedStyle(w.value), M = getComputedStyle(h.value.$el), T = parseFloat(P.getPropertyValue("--v-field-padding-top")) + parseFloat(P.getPropertyValue("--v-input-padding-top")) + parseFloat(P.getPropertyValue("--v-field-padding-bottom")), L = w.value.scrollHeight, A = parseFloat(P.lineHeight), D = Math.max(parseFloat(e.rows) * A + T, parseFloat(M.getPropertyValue("--v-input-control-height"))), B = parseFloat(e.maxRows) * A + T || 1 / 0, j = ln(L ?? 0, D, B);
        V.value = Math.floor((j - T) / A), m.value = Qe(j);
      });
    }
    rt(O), pe(l, O), pe(() => e.rows, O), pe(() => e.maxRows, O), pe(() => e.density, O);
    let $;
    return pe(w, (P) => {
      P ? ($ = new ResizeObserver(O), $.observe(w.value)) : $ == null || $.disconnect();
    }), mn(() => {
      $ == null || $.disconnect();
    }), ye(() => {
      const P = !!(i.counter || e.counter || e.counterValue), M = !!(P || i.details), [T, L] = Il(n), {
        modelValue: A,
        ...D
      } = Fn.filterProps(e), B = I2(e);
      return p(Fn, fe({
        ref: f,
        modelValue: l.value,
        "onUpdate:modelValue": (j) => l.value = j,
        class: ["v-textarea v-text-field", {
          "v-textarea--prefixed": e.prefix,
          "v-textarea--suffixed": e.suffix,
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-textarea--auto-grow": e.autoGrow,
          "v-textarea--no-resize": e.noResize || e.autoGrow,
          "v-input--plain-underlined": _.value
        }, e.class],
        style: e.style
      }, T, D, {
        centerAffix: V.value === 1 && !_.value,
        focused: r.value
      }), {
        ...i,
        default: (j) => {
          let {
            id: I,
            isDisabled: Z,
            isDirty: R,
            isReadonly: J,
            isValid: F
          } = j;
          return p(Ks, fe({
            ref: h,
            style: {
              "--v-textarea-control-height": m.value
            },
            onClick: b,
            onMousedown: C,
            "onClick:clear": S,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, B, {
            id: I.value,
            active: v.value || R.value,
            centerAffix: V.value === 1 && !_.value,
            dirty: R.value || e.dirty,
            disabled: Z.value,
            focused: r.value,
            error: F.value === !1
          }), {
            ...i,
            default: (q) => {
              let {
                props: {
                  class: z,
                  ...E
                }
              } = q;
              return p(ge, null, [e.prefix && p("span", {
                class: "v-text-field__prefix"
              }, [e.prefix]), Ct(p("textarea", fe({
                ref: g,
                class: z,
                value: l.value,
                onInput: x,
                autofocus: e.autofocus,
                readonly: J.value,
                disabled: Z.value,
                placeholder: e.placeholder,
                rows: e.rows,
                name: e.name,
                onFocus: y,
                onBlur: o
              }, E, L), null), [[xa("intersect"), {
                handler: d
              }, null, {
                once: !0
              }]]), e.autoGrow && Ct(p("textarea", {
                class: [z, "v-textarea__sizer"],
                id: `${E.id}-sizer`,
                "onUpdate:modelValue": (Q) => l.value = Q,
                ref: w,
                readonly: !0,
                "aria-hidden": "true"
              }, null), [[IC, l.value]]), e.suffix && p("span", {
                class: "v-text-field__suffix"
              }, [e.suffix])]);
            }
          });
        },
        details: M ? (j) => {
          var I;
          return p(ge, null, [(I = i.details) == null ? void 0 : I.call(i, j), P && p(ge, null, [p("span", null, null), p(Jd, {
            active: e.persistentCounter || r.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, i.counter)])]);
        } : void 0
      });
    }), Ea({}, f, h, g);
  }
}), zV = le({
  withBackground: Boolean,
  ...Ae(),
  ...dt(),
  ...nt()
}, "VThemeProvider"), FV = ve()({
  name: "VThemeProvider",
  props: zV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e);
    return () => {
      var i;
      return e.withBackground ? p(e.tag, {
        class: ["v-theme-provider", a.value, e.class],
        style: e.style
      }, {
        default: () => {
          var l;
          return [(l = n.default) == null ? void 0 : l.call(n)];
        }
      }) : (i = n.default) == null ? void 0 : i.call(n);
    };
  }
}), XV = le({
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  icon: Ue,
  iconColor: String,
  lineColor: String,
  ...Ae(),
  ...Dt(),
  ...Ri(),
  ...Pn()
}, "VTimelineDivider"), YV = ve()({
  name: "VTimelineDivider",
  props: XV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      sizeClasses: a,
      sizeStyles: i
    } = Ys(e, "v-timeline-divider__dot"), {
      backgroundColorStyles: l,
      backgroundColorClasses: r
    } = kt(ue(e, "dotColor")), {
      roundedClasses: s
    } = qt(e, "v-timeline-divider__dot"), {
      elevationClasses: o
    } = Zn(e), {
      backgroundColorClasses: u,
      backgroundColorStyles: c
    } = kt(ue(e, "lineColor"));
    return ye(() => p("div", {
      class: ["v-timeline-divider", {
        "v-timeline-divider--fill-dot": e.fillDot
      }, e.class],
      style: e.style
    }, [p("div", {
      class: ["v-timeline-divider__before", u.value],
      style: c.value
    }, null), !e.hideDot && p("div", {
      key: "dot",
      class: ["v-timeline-divider__dot", o.value, s.value, a.value],
      style: i.value
    }, [p("div", {
      class: ["v-timeline-divider__inner-dot", r.value, s.value],
      style: l.value
    }, [n.default ? p(lt, {
      key: "icon-defaults",
      disabled: !e.icon,
      defaults: {
        VIcon: {
          color: e.iconColor,
          icon: e.icon,
          size: e.size
        }
      }
    }, n.default) : p(vt, {
      key: "icon",
      color: e.iconColor,
      icon: e.icon,
      size: e.size
    }, null)])]), p("div", {
      class: ["v-timeline-divider__after", u.value],
      style: c.value
    }, null)])), {};
  }
}), y7 = le({
  density: String,
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  hideOpposite: {
    type: Boolean,
    default: void 0
  },
  icon: Ue,
  iconColor: String,
  lineInset: [Number, String],
  ...Ae(),
  ...vn(),
  ...Pn(),
  ...Dt(),
  ...Ri(),
  ...nt()
}, "VTimelineItem"), WV = ve()({
  name: "VTimelineItem",
  props: y7(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: a
    } = gn(e), i = Ve(0), l = Y();
    return pe(l, (r) => {
      var s;
      r && (i.value = ((s = r.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : s.getBoundingClientRect().width) ?? 0);
    }, {
      flush: "post"
    }), ye(() => {
      var r, s;
      return p("div", {
        class: ["v-timeline-item", {
          "v-timeline-item--fill-dot": e.fillDot
        }, e.class],
        style: [{
          "--v-timeline-dot-size": Qe(i.value),
          "--v-timeline-line-inset": e.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${Qe(e.lineInset)})` : Qe(0)
        }, e.style]
      }, [p("div", {
        class: "v-timeline-item__body",
        style: a.value
      }, [(r = n.default) == null ? void 0 : r.call(n)]), p(YV, {
        ref: l,
        hideDot: e.hideDot,
        icon: e.icon,
        iconColor: e.iconColor,
        size: e.size,
        elevation: e.elevation,
        dotColor: e.dotColor,
        fillDot: e.fillDot,
        rounded: e.rounded
      }, {
        default: n.icon
      }), e.density !== "compact" && p("div", {
        class: "v-timeline-item__opposite"
      }, [!e.hideOpposite && ((s = n.opposite) == null ? void 0 : s.call(n))])]);
    }), {};
  }
}), qV = le({
  align: {
    type: String,
    default: "center",
    validator: (e) => ["center", "start"].includes(e)
  },
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  justify: {
    type: String,
    default: "auto",
    validator: (e) => ["auto", "center"].includes(e)
  },
  side: {
    type: String,
    validator: (e) => e == null || ["start", "end"].includes(e)
  },
  lineThickness: {
    type: [String, Number],
    default: 2
  },
  lineColor: String,
  truncateLine: {
    type: String,
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  ...Id(y7({
    lineInset: 0
  }), ["dotColor", "fillDot", "hideOpposite", "iconColor", "lineInset", "size"]),
  ...Ae(),
  ...Ln(),
  ...nt(),
  ...dt()
}, "VTimeline"), UV = ve()({
  name: "VTimeline",
  props: qV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = yt(e), {
      densityClasses: i
    } = ea(e), {
      rtlClasses: l
    } = xn();
    Yt({
      VTimelineDivider: {
        lineColor: ue(e, "lineColor")
      },
      VTimelineItem: {
        density: ue(e, "density"),
        dotColor: ue(e, "dotColor"),
        fillDot: ue(e, "fillDot"),
        hideOpposite: ue(e, "hideOpposite"),
        iconColor: ue(e, "iconColor"),
        lineColor: ue(e, "lineColor"),
        lineInset: ue(e, "lineInset"),
        size: ue(e, "size")
      }
    });
    const r = k(() => {
      const o = e.side ? e.side : e.density !== "default" ? "end" : null;
      return o && `v-timeline--side-${o}`;
    }), s = k(() => {
      const o = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
      switch (e.truncateLine) {
        case "both":
          return o;
        case "start":
          return o[0];
        case "end":
          return o[1];
        default:
          return null;
      }
    });
    return ye(() => p(e.tag, {
      class: ["v-timeline", `v-timeline--${e.direction}`, `v-timeline--align-${e.align}`, `v-timeline--justify-${e.justify}`, s.value, {
        "v-timeline--inset-line": !!e.lineInset
      }, a.value, i.value, r.value, l.value, e.class],
      style: [{
        "--v-timeline-line-thickness": Qe(e.lineThickness)
      }, e.style]
    }, n)), {};
  }
}), GV = le({
  ...Ae(),
  ...Na({
    variant: "text"
  })
}, "VToolbarItems"), KV = ve()({
  name: "VToolbarItems",
  props: GV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Yt({
      VBtn: {
        color: ue(e, "color"),
        height: "inherit",
        variant: ue(e, "variant")
      }
    }), ye(() => {
      var a;
      return p("div", {
        class: ["v-toolbar-items", e.class],
        style: e.style
      }, [(a = n.default) == null ? void 0 : a.call(n)]);
    }), {};
  }
}), JV = ve()({
  name: "VValidation",
  props: V3(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = T3(e, "validation");
    return () => {
      var i;
      return (i = n.default) == null ? void 0 : i.call(n, a);
    };
  }
}), eT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VAlert: Ux,
  VAlertTitle: k3,
  VApp: hx,
  VAppBar: Lx,
  VAppBarNavIcon: Xx,
  VAppBarTitle: Yx,
  VAutocomplete: KP,
  VAvatar: Da,
  VBadge: e$,
  VBanner: a$,
  VBannerActions: e8,
  VBannerText: t8,
  VBottomNavigation: l$,
  VBottomSheet: s$,
  VBreadcrumbs: d$,
  VBreadcrumbsDivider: a8,
  VBreadcrumbsItem: i8,
  VBtn: pt,
  VBtnGroup: hh,
  VBtnToggle: Bx,
  VCard: g$,
  VCardActions: l8,
  VCardItem: o8,
  VCardSubtitle: r8,
  VCardText: u8,
  VCardTitle: s8,
  VCarousel: y$,
  VCarouselItem: b$,
  VCheckbox: lP,
  VCheckboxBtn: qi,
  VChip: Gs,
  VChipGroup: cP,
  VClassIcon: b2,
  VCode: C$,
  VCol: U_,
  VColorPicker: u_,
  VCombobox: f_,
  VComponentIcon: lh,
  VConfirmEdit: m_,
  VContainer: X_,
  VCounter: Jd,
  VDataIterator: S_,
  VDataTable: E_,
  VDataTableFooter: Fo,
  VDataTableHeaders: Cr,
  VDataTableRow: G2,
  VDataTableRows: wr,
  VDataTableServer: z_,
  VDataTableVirtual: H_,
  VDatePicker: uM,
  VDatePickerControls: Sh,
  VDatePickerHeader: xh,
  VDatePickerMonth: Ph,
  VDatePickerMonths: $h,
  VDatePickerYears: _h,
  VDefaultsProvider: lt,
  VDialog: gh,
  VDialogBottomTransition: px,
  VDialogTopTransition: yx,
  VDialogTransition: zd,
  VDivider: Su,
  VEmptyState: dM,
  VExpandTransition: Fd,
  VExpandXTransition: V2,
  VExpansionPanel: fM,
  VExpansionPanelText: Mh,
  VExpansionPanelTitle: Vh,
  VExpansionPanels: vM,
  VFab: pM,
  VFabTransition: gx,
  VFadeTransition: No,
  VField: Ks,
  VFieldLabel: go,
  VFileInput: OM,
  VFooter: CM,
  VForm: kM,
  VHover: xM,
  VIcon: vt,
  VImg: Wi,
  VInfiniteScroll: $M,
  VInput: Fn,
  VItem: VM,
  VItemGroup: MM,
  VKbd: TM,
  VLabel: Us,
  VLayout: QM,
  VLayoutItem: DM,
  VLazy: IM,
  VLigatureIcon: cS,
  VList: Kd,
  VListGroup: vh,
  VListImg: QP,
  VListItem: Ui,
  VListItemAction: DP,
  VListItemMedia: IP,
  VListItemSubtitle: j3,
  VListItemTitle: z3,
  VListSubheader: F3,
  VLocaleProvider: ZM,
  VMain: NM,
  VMenu: ws,
  VMessages: _3,
  VNavigationDrawer: UM,
  VNoSsr: GM,
  VOtpInput: JM,
  VOverlay: Ka,
  VPagination: wh,
  VParallax: nV,
  VProgressCircular: Cs,
  VProgressLinear: Yd,
  VRadio: iV,
  VRadioGroup: rV,
  VRangeSlider: oV,
  VRating: cV,
  VResponsive: dh,
  VRow: aM,
  VScaleTransition: _2,
  VScrollXReverseTransition: bx,
  VScrollXTransition: Ox,
  VScrollYReverseTransition: wx,
  VScrollYTransition: Cx,
  VSelect: E2,
  VSelectionControl: $l,
  VSelectionControlGroup: x3,
  VSheet: br,
  VSkeletonLoader: mV,
  VSlideGroup: jo,
  VSlideGroupItem: vV,
  VSlideXReverseTransition: Sx,
  VSlideXTransition: kx,
  VSlideYReverseTransition: xx,
  VSlideYTransition: M2,
  VSlider: Ch,
  VSnackbar: yV,
  VSpacer: U8,
  VSparkline: wV,
  VSpeedDial: SV,
  VStepper: TV,
  VStepperActions: c7,
  VStepperHeader: d7,
  VStepperItem: f7,
  VStepperWindow: h7,
  VStepperWindowItem: m7,
  VSvgIcon: O2,
  VSwitch: QV,
  VSystemBar: DV,
  VTab: v7,
  VTable: kr,
  VTabs: NV,
  VTabsWindow: g7,
  VTabsWindowItem: p7,
  VTextField: pr,
  VTextarea: jV,
  VThemeProvider: FV,
  VTimeline: UV,
  VTimelineItem: WV,
  VToolbar: fh,
  VToolbarItems: KV,
  VToolbarTitle: $2,
  VTooltip: m3,
  VValidation: JV,
  VVirtualScroll: t1,
  VWindow: yr,
  VWindowItem: Or
}, Symbol.toStringTag, { value: "Module" })), tT = {
  dark: !1,
  colors: {},
  variables: { "font-family": "Paperlogy, Noto Sans KR, sans-serif" }
}, O7 = {
  defaultTheme: "defaultTheme",
  themes: { defaultTheme: tT }
}, Ut = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, i] of t)
    n[a] = i;
  return n;
}, nT = {
  __name: "SBtn",
  props: {
    title: {
      type: String,
      required: !1,
      default: ""
    },
    to: {
      type: String,
      required: !1,
      default: null
    },
    height: {
      type: [String, Number],
      required: !1,
      default: null
    },
    size: {
      type: String,
      default: "default",
      //기본 medium
      validator: (e) => ["default", "x-small", "small", "large", "x-large"].includes(e)
    },
    color: {
      type: String,
      default: "blue"
    },
    icon: {
      type: String,
      default: void 0
    }
  },
  setup(e) {
    const t = e, n = Rl(), a = k(() => !!(n.icon || t.icon));
    return (i, l) => {
      const r = Pe("v-btn");
      return N(), Ce(r, {
        class: "s-btn",
        elevation: "0",
        "s-color": e.color,
        size: e.size,
        to: e.to,
        height: e.height,
        icon: e.icon
      }, Xt({ _: 2 }, [
        a.value && !i.$slots.default ? {
          name: "icon",
          fn: re(() => [
            p(X(vt), null, {
              default: re(() => [
                Ee(xe(e.icon), 1)
              ]),
              _: 1
            })
          ]),
          key: "0"
        } : {
          name: "default",
          fn: re(() => [
            Ee(xe(e.title) + " ", 1),
            ke(i.$slots, "default", {}, void 0, !0)
          ]),
          key: "1"
        }
      ]), 1032, ["s-color", "size", "to", "height", "icon"]);
    };
  }
}, _n = /* @__PURE__ */ Ut(nT, [["__scopeId", "data-v-5e15c61d"]]), aT = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_206_5961)'%3e%3cpath%20d='M8%200C3.584%200%200%203.584%200%208C0%2012.416%203.584%2016%208%2016C12.416%2016%2016%2012.416%2016%208C16%203.584%2012.416%200%208%200ZM8.728%2012.92C8.48%2013.168%208.048%2012.992%208.048%2012.64V12C8.032%2012%208.016%2012%208%2012C6.976%2012%205.952%2011.608%205.168%2010.832C4.024%209.688%203.72%208.016%204.256%206.592C4.408%206.184%204.944%206.08%205.248%206.392C5.424%206.568%205.464%206.824%205.384%207.048C5.016%208.04%205.224%209.192%206.024%209.992C6.584%2010.552%207.32%2010.816%208.056%2010.8V10.048C8.056%209.688%208.488%209.512%208.736%209.768L10.032%2011.064C10.192%2011.224%2010.192%2011.472%2010.032%2011.632L8.728%2012.92ZM10.752%209.616C10.576%209.44%2010.536%209.184%2010.616%208.96C10.984%207.968%2010.776%206.816%209.976%206.016C9.416%205.456%208.68%205.184%207.952%205.2V5.952C7.952%206.312%207.52%206.488%207.272%206.232L5.968%204.944C5.808%204.784%205.808%204.536%205.968%204.376L7.264%203.08C7.512%202.832%207.944%203.008%207.944%203.36V4.008C8.984%203.992%2010.032%204.368%2010.824%205.168C11.968%206.312%2012.272%207.984%2011.736%209.408C11.584%209.824%2011.056%209.928%2010.752%209.616Z'%20fill='%231B75BB'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_206_5961'%3e%3crect%20width='16'%20height='16'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e", iT = { class: "position-relative refresh-time-wrapper" }, lT = { class: "refresh-time" }, rT = ["src"], sT = {
  __name: "SRefreshBtn",
  props: {
    onClickRefresh: {
      type: Function,
      required: !0
    },
    refreshDate: {
      type: Date,
      default: /* @__PURE__ */ new Date()
    },
    refreshDateTitle: {
      type: String,
      default: "기준일자"
    }
  },
  setup(e) {
    const t = e, n = k(() => {
      const a = t.refreshDate.getFullYear(), i = (t.refreshDate.getMonth() + 1).toString().padStart(2, "0"), l = t.refreshDate.getDate().toString().padStart(2, "0"), r = t.refreshDate.getHours().toString().padStart(2, "0"), s = t.refreshDate.getMinutes().toString().padStart(2, "0"), o = t.refreshDate.getSeconds().toString().padStart(2, "0");
      return `${a}-${i}-${l} ${r}:${s}:${o}`;
    });
    return (a, i) => (N(), ee("span", iT, [
      ie("span", lT, xe(e.refreshDateTitle) + " : " + xe(n.value), 1),
      ie("img", {
        class: "cursor-pointer ml-1 refresh-icon",
        height: "16",
        width: "16",
        src: X(aT),
        onClick: i[0] || (i[0] = (...l) => e.onClickRefresh && e.onClickRefresh(...l))
      }, null, 8, rT)
    ]));
  }
}, b7 = /* @__PURE__ */ Ut(sT, [["__scopeId", "data-v-6f5f944d"]]), oT = {};
function uT(e, t) {
  const n = Pe("v-text-field"), a = Pe("v-col"), i = Pe("v-checkbox"), l = Pe("v-row");
  return N(), Ce(l, null, {
    default: re(() => [
      p(a, null, {
        default: re(() => [
          p(n, {
            density: "compact",
            variant: "outlined"
          })
        ]),
        _: 1
      }),
      p(a, null, {
        default: re(() => [
          p(i, {
            density: "compact",
            variant: "outlined"
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  });
}
const cT = /* @__PURE__ */ Ut(oT, [["render", uT]]), dT = { class: "shell-script-wrapper" }, fT = { class: "line-numbers" }, hT = {
  __name: "SShellScriptInput",
  props: /* @__PURE__ */ Nc({
    labelTitle: {
      type: String,
      default: null,
      required: !1
    }
  }, {
    modelValue: {
      type: String,
      default: "",
      required: !0
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = l2(e, "modelValue"), n = Y(1), a = () => {
      n.value = t.value.split(`
`).length;
    };
    return a(), (i, l) => {
      const r = Pe("v-label"), s = Pe("v-textarea");
      return N(), ee(ge, null, [
        e.labelTitle ? (N(), Ce(r, { key: 0 }, {
          default: re(() => [
            Ee(xe(e.labelTitle), 1)
          ]),
          _: 1
        })) : de("", !0),
        ie("div", dT, [
          ie("div", fT, [
            (N(!0), ee(ge, null, Ge(n.value, (o) => (N(), ee("span", { key: o }, xe(o), 1))), 128))
          ]),
          p(s, {
            modelValue: t.value,
            "onUpdate:modelValue": l[0] || (l[0] = (o) => t.value = o),
            placeholder: "",
            "auto-grow": "",
            rows: "10",
            outlined: "",
            class: "shell-script-textarea",
            onInput: a
          }, null, 8, ["modelValue"])
        ])
      ], 64);
    };
  }
}, mT = { class: "s-file-input" }, vT = {
  __name: "SFileInputBtn",
  props: {
    placeholder: {
      type: String,
      default: "파일을 선택하세요"
    },
    modelValue: {
      type: [Object, String],
      default: null
    },
    errorMessages: {
      type: Array,
      default: () => []
    },
    btnDisabled: {
      type: Boolean,
      default: !1
    },
    hideDetails: {
      type: [String, Boolean],
      default: "auto"
    },
    buttonText: {
      type: String,
      default: "파일 찾기"
    },
    accept: {
      type: String,
      default: "*"
    }
  },
  emits: ["update:model-value"],
  setup(e, { emit: t }) {
    const n = e, a = t, i = Y(null), l = Y(null), r = (s) => {
      i.value = s, l.value = s == null ? void 0 : s.name, a("update:model-value", s);
    };
    return rt(() => {
      i.value = n.modelValue;
    }), (s, o) => {
      const u = Pe("v-file-input"), c = Pe("v-text-field");
      return N(), ee("div", mT, [
        p(u, {
          ref: "importFile",
          "model-value": i.value,
          class: "d-none",
          "onUpdate:modelValue": r,
          accept: e.accept
        }, null, 8, ["model-value", "accept"]),
        p(c, {
          "model-value": l.value,
          variant: "outlined",
          density: "compact",
          "hide-details": e.hideDetails,
          readonly: "",
          "error-messages": e.errorMessages,
          placeholder: e.placeholder
        }, null, 8, ["model-value", "hide-details", "error-messages", "placeholder"]),
        p(X(_n), {
          height: "30",
          variant: "outlined",
          disabled: e.btnDisabled,
          onClick: o[0] || (o[0] = (d) => s.$refs.importFile.click())
        }, {
          default: re(() => [
            p(X(Pd), {
              name: "file",
              size: 16,
              class: "mr-1"
            }),
            Ee(" " + xe(e.buttonText), 1)
          ]),
          _: 1
        }, 8, ["disabled"])
      ]);
    };
  }
}, gT = { class: "s-key-value-selector__filter" }, pT = { class: "s-key-value-selector__table" }, yT = { key: 0 }, OT = {
  colspan: "3",
  class: "s-key-value-selector__empty"
}, bT = { class: "s-key-value-selector__add-item" }, CT = { class: "s-key-value-selector__actions" }, wT = { class: "s-key-value-selector__buttons" }, kT = {
  __name: "SKeyValueSelect",
  props: {
    items: {
      type: Array,
      default: () => []
    },
    keyList: {
      type: Array,
      default: () => []
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    displayText: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "labels",
      validator: (e) => ["labels", "tags"].includes(e)
    },
    applyButtonText: {
      type: String,
      default: "적용"
    },
    cancelButtonText: {
      type: String,
      default: "취소"
    },
    resetButtonText: {
      type: String,
      default: "초기화"
    },
    typeText: {
      type: Object,
      default: () => ({
        title: null,
        key: null,
        value: null,
        add: null,
        select: null
      }),
      description: "타입에 따른 텍스트 설정"
    },
    allSelectButtonText: {
      type: String,
      default: "전체 선택"
    },
    getValueList: {
      type: Function,
      default: () => []
    },
    density: {
      type: String,
      default: "comfortable"
    },
    width: {
      type: [String, Number],
      default: 316
    }
  },
  emits: [
    "update:model-value",
    "cancel",
    "apply",
    "add-label"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, i = Y([]), l = Y([]), r = Y(!1), s = Y({}), o = async (M) => {
      const T = M.filter((A) => A && !s.value[A]);
      if (!T.length) return;
      const L = T.map(async (A) => {
        try {
          const D = { keys: [A] };
          let B = [];
          B = await n.getValueList(n.type, D);
          let j = [];
          return B.length > 0 && typeof B[0] == "object" && "value" in B[0] ? j = B.map((I) => {
            const { value: Z } = I, R = Z.split(":");
            return R.length > 1 ? R[1] : Z;
          }) : j = B.map((I) => {
            const Z = I.split(":");
            return Z.length > 1 ? Z[1] : I;
          }), { key: A, values: j };
        } catch (D) {
          return console.error("Failed to fetch values for key:", A, D), { key: A, values: [] };
        }
      });
      try {
        (await Promise.all(L)).forEach(({ key: D, values: B }) => {
          s.value[D] = B;
        });
      } catch (A) {
        console.error("Error fetching value lists in parallel:", A);
      }
    };
    rt(() => {
      i.value = [...n.modelValue || []], l.value = [];
      const M = i.value.map((T) => T.key).filter(Boolean);
      M.length > 0 && o(M);
    }), pe(
      () => n.modelValue,
      (M) => {
        i.value = [...M || []], r.value || (l.value = []);
        const T = M.map((L) => L.key).filter(Boolean);
        T.length > 0 && o(T);
      },
      { deep: !0 }
    ), pe(
      () => r.value,
      (M) => {
        M && (l.value = i.value.map((T) => ({
          key: T.key,
          values: [...T.values],
          isKeyMenuOpen: !1,
          isValueMenuOpen: !1
        })));
      }
    );
    const u = k(() => l.value.some((M) => {
      var T;
      return M.key && ((T = M.values) == null ? void 0 : T.length) > 0;
    }) || l.value.length > 0), c = k(() => {
      var T;
      if (n.displayText) return n.displayText;
      const M = ((T = n.modelValue) == null ? void 0 : T.filter((L) => L.key && L.values.length > 0).length) || 0;
      return M === 0 ? n.typeText.empty : `${n.typeText.title} ${M}개`;
    }), d = () => n.keyList.at(0) === typeof {} ? n.keyList.map((T) => T.key) : n.keyList, f = (M) => {
      var T;
      return (T = l.value[M]) != null && T.key ? s.value[l.value[M].key] ? s.value[l.value[M].key] : [] : [];
    }, h = () => {
      l.value.push({
        key: "",
        values: [],
        isKeyMenuOpen: !1,
        isValueMenuOpen: !1
      });
    }, m = async (M, T) => {
      l.value[T].key = M, l.value[T].values = [], l.value[T].isKeyMenuOpen = !1, s.value[M] || o([M]);
    }, g = (M, T) => {
      const L = l.value[T], A = L.values.indexOf(M);
      A === -1 ? L.values.push(M) : L.values.splice(A, 1);
    }, v = (M) => l.value[M].values.length === f(M).length, y = (M) => l.value[M].values.length > 0 && !v(M), b = (M) => {
      const T = l.value[M];
      v(M) ? T.values = [] : T.values = [...f(M)];
    }, C = (M) => {
      l.value.splice(M, 1);
    }, S = () => {
      i.value = [...n.modelValue || []], l.value = [], r.value = !1, a("cancel");
    }, x = () => {
      const M = l.value.filter(
        (T) => T.key && T.values.length
      );
      i.value = [...M], a(
        "update:model-value",
        M.map((T) => ({
          key: T.key,
          values: T.values
        }))
      ), a(
        "apply",
        M.map((T) => ({
          key: T.key,
          values: T.values
        }))
      ), r.value = !1, l.value = [];
    }, w = (M, T) => {
      T == null || T.stopPropagation();
    }, V = (M, T) => {
      T == null || T.stopPropagation(), M.isKeyMenuOpen || (M.isValueMenuOpen = !1);
    }, _ = (M) => {
      if (l.value.some(
        (A) => A.isKeyMenuOpen || A.isValueMenuOpen
      )) {
        M == null || M.preventDefault(), M == null || M.stopPropagation();
        return;
      }
      const L = l.value.filter(
        (A) => A.key && A.values.length
      );
      i.value = [...L], a(
        "update:model-value",
        L.map((A) => ({
          key: A.key,
          values: A.values
        }))
      ), a(
        "apply",
        L.map((A) => ({
          key: A.key,
          values: A.values
        }))
      ), r.value = !1, l.value = [];
    }, O = k(() => l.value.filter((M) => M)), $ = (M) => {
      const T = l.value[M];
      T.values = [], T.isValueMenuOpen = !1;
    }, P = (M) => {
      const T = l.value[M];
      T.isValueMenuOpen = !1;
    };
    return (M, T) => {
      const L = Pe("v-list-item"), A = Pe("v-list"), D = Pe("v-menu"), B = Pe("v-checkbox-btn"), j = Pe("v-divider"), I = Pe("v-list-item-action");
      return N(), Ce(D, {
        modelValue: r.value,
        "onUpdate:modelValue": T[0] || (T[0] = (Z) => r.value = Z),
        class: "s-key-value-selector",
        "close-on-content-click": !1,
        "close-on-click": !1,
        "max-height": 300,
        location: "bottom",
        offset: 5,
        transition: "scroll-y-transition",
        "onClick:outside": _
      }, {
        activator: re(({ props: Z, isActive: R }) => [
          p(X(_n), fe(Z, {
            width: e.width,
            class: "s-key-value-selector__button",
            variant: "outlined",
            color: "black",
            density: e.density,
            "append-icon": R ? "mdi-menu-up" : "mdi-menu-down"
          }), {
            default: re(() => [
              Ee(xe(c.value), 1)
            ]),
            _: 2
          }, 1040, ["width", "density", "append-icon"])
        ]),
        default: re(() => [
          p(A, { class: "s-key-value-selector__list" }, {
            default: re(() => [
              ie("div", gT, [
                ie("table", pT, [
                  ie("thead", null, [
                    ie("tr", null, [
                      ie("th", null, xe(e.typeText.key), 1),
                      ie("th", null, xe(e.typeText.value), 1),
                      T[1] || (T[1] = ie("th", { width: "40" }, null, -1))
                    ])
                  ]),
                  ie("tbody", null, [
                    !u.value && !l.value.length ? (N(), ee("tr", yT, [
                      ie("td", OT, [
                        ie("div", bT, xe(e.typeText.empty), 1)
                      ])
                    ])) : de("", !0),
                    (N(!0), ee(ge, null, Ge(O.value, (Z, R) => (N(), ee("tr", {
                      key: "adding-" + R
                    }, [
                      ie("td", null, [
                        Z ? (N(), Ce(D, {
                          key: 0,
                          "close-on-content-click": !1,
                          "close-on-click": !1,
                          modelValue: Z.isKeyMenuOpen,
                          "onUpdate:modelValue": (J) => Z.isKeyMenuOpen = J,
                          "max-height": 300,
                          location: "bottom",
                          offset: 5,
                          density: "compact",
                          transition: "scroll-y-transition",
                          "onClick:outside": $t((J) => w(Z, J), ["stop"])
                        }, {
                          activator: re(({ props: J, isActive: F }) => [
                            p(X(_n), fe({ ref_for: !0 }, J, {
                              variant: "outlined",
                              color: "black",
                              class: "s-key-value-selector__button",
                              "append-icon": F ? "mdi-menu-up" : "mdi-menu-down"
                            }), {
                              default: re(() => [
                                Ee(xe(Z.key || e.typeText.select), 1)
                              ]),
                              _: 2
                            }, 1040, ["append-icon"])
                          ]),
                          default: re(() => [
                            p(A, null, {
                              default: re(() => [
                                (N(!0), ee(ge, null, Ge(d(), (J) => (N(), Ce(L, {
                                  class: "s-key-value-selector__list-item",
                                  key: J,
                                  value: J,
                                  onClick: (F) => m(J, R)
                                }, {
                                  default: re(() => [
                                    Ee(xe(J), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["value", "onClick"]))), 128))
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1032, ["modelValue", "onUpdate:modelValue", "onClick:outside"])) : de("", !0)
                      ]),
                      ie("td", null, [
                        Z ? (N(), Ce(D, {
                          key: 0,
                          "close-on-content-click": !1,
                          "close-on-click": !1,
                          modelValue: Z.isValueMenuOpen,
                          "onUpdate:modelValue": (J) => Z.isValueMenuOpen = J,
                          "max-height": 300,
                          location: "bottom",
                          offset: 5,
                          transition: "scroll-y-transition",
                          "onClick:outside": $t((J) => V(Z, J), ["stop"])
                        }, {
                          activator: re(({ props: J, isActive: F }) => [
                            p(X(_n), fe({ ref_for: !0 }, J, {
                              variant: "outlined",
                              color: "black",
                              class: "s-key-value-selector__button",
                              disabled: !Z.key,
                              "append-icon": F ? "mdi-menu-up" : "mdi-menu-down"
                            }), {
                              default: re(() => [
                                Ee(xe(Z.values.length ? `${e.typeText.value} ${Z.values.length}개` : e.typeText.selectValue), 1)
                              ]),
                              _: 2
                            }, 1040, ["disabled", "append-icon"])
                          ]),
                          default: re(() => [
                            p(A, { density: e.density }, {
                              default: re(() => [
                                p(L, {
                                  class: "s-key-value-selector__list-item",
                                  title: e.allSelectButtonText,
                                  onClick: $t((J) => b(R), ["stop"]),
                                  disabled: !Z.key
                                }, {
                                  prepend: re(() => [
                                    p(B, {
                                      density: "compact",
                                      class: "s-key-value-selector__checkbox-btn",
                                      "model-value": v(R),
                                      indeterminate: y(R),
                                      disabled: !Z.key
                                    }, null, 8, ["model-value", "indeterminate", "disabled"])
                                  ]),
                                  _: 2
                                }, 1032, ["title", "onClick", "disabled"]),
                                p(j),
                                (N(!0), ee(ge, null, Ge(f(R), (J) => (N(), Ce(L, {
                                  key: J,
                                  value: J,
                                  class: Ie(["s-key-value-selector__list-item", { "v-list-item--active": Z.values.includes(J) }]),
                                  onClick: $t((F) => g(J, R), ["stop"]),
                                  disabled: !Z.key
                                }, {
                                  prepend: re(() => [
                                    p(B, {
                                      density: "compact",
                                      class: "s-key-value-selector__checkbox-btn",
                                      "model-value": Z.values.includes(J),
                                      disabled: !Z.key
                                    }, null, 8, ["model-value", "disabled"])
                                  ]),
                                  default: re(() => [
                                    Ee(" " + xe(J), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["value", "class", "onClick", "disabled"]))), 128)),
                                f(R).length > 0 ? (N(), Ce(j, { key: 0 })) : de("", !0),
                                p(I, { class: "s-key-value-selector__value-actions" }, {
                                  default: re(() => [
                                    p(X(_n), {
                                      variant: "text",
                                      density: "compact",
                                      class: "s-key-value-selector__value-btn",
                                      onClick: $t((J) => $(R), ["stop"])
                                    }, {
                                      default: re(() => [
                                        Ee(xe(e.resetButtonText), 1)
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"]),
                                    p(X(_n), {
                                      variant: "text",
                                      density: "compact",
                                      class: "s-key-value-selector__value-btn s-key-value-selector__value-btn--apply",
                                      onClick: $t((J) => P(R), ["stop"])
                                    }, {
                                      default: re(() => [
                                        Ee(xe(e.applyButtonText), 1)
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"])
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1032, ["density"])
                          ]),
                          _: 2
                        }, 1032, ["modelValue", "onUpdate:modelValue", "onClick:outside"])) : de("", !0)
                      ]),
                      ie("td", null, [
                        p(X(_n), {
                          density: "compact",
                          icon: "mdi-minus-circle",
                          variant: "text",
                          color: "red",
                          onClick: (J) => C(R)
                        }, null, 8, ["onClick"])
                      ])
                    ]))), 128))
                  ])
                ])
              ]),
              ie("div", CT, [
                p(X(_n), {
                  class: "s-key-value-selector__add-btn",
                  variant: "text",
                  "prepend-icon": "mdi-plus",
                  onClick: h
                }, {
                  default: re(() => [
                    Ee(xe(e.typeText.add), 1)
                  ]),
                  _: 1
                }),
                ie("div", wT, [
                  p(X(_n), {
                    variant: "outlined",
                    onClick: S
                  }, {
                    default: re(() => [
                      Ee(xe(e.cancelButtonText), 1)
                    ]),
                    _: 1
                  }),
                  p(X(_n), {
                    onClick: x,
                    disabled: l.value.length > 0 && !l.value.some((Z) => Z.key && Z.values.length)
                  }, {
                    default: re(() => [
                      Ee(xe(e.applyButtonText), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]);
    };
  }
}, ST = /* @__PURE__ */ Ut(kT, [["__scopeId", "data-v-2479e319"]]), xT = { class: "s-alert" }, PT = {
  key: 1,
  class: "s-alert__hidden-measure"
}, $T = {
  __name: "SAlert",
  props: {
    titleName: {
      type: String,
      default: "",
      description: "알림 내용"
    },
    modelValue: {
      type: Boolean,
      default: !1,
      description: "알림 오픈 여부"
    },
    multiLine: {
      type: Boolean,
      default: !0,
      description: "최소 높이를 더 높게 설정합니다."
    },
    color: {
      type: String,
      default: "#036EB8",
      description: "알림 색상"
    },
    height: {
      type: [String, Number],
      default: "48px",
      description: "알림 높이"
    },
    width: {
      type: [String, Number],
      default: "450px",
      description: "알림 넓이"
    },
    timeout: {
      type: Number,
      default: 5e3,
      description: "알림 오픈 시간"
    },
    isClose: {
      type: Boolean,
      default: !0,
      description: "Close 버튼 노출 유무"
    },
    alertStyle: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:model-value"],
  setup(e, { emit: t }) {
    const n = t, a = e, i = Y(a.modelValue), l = Y(null), r = Y(48), s = Y(!1), o = Y(!1), u = k(() => a.multiLine ? `${Math.max(r.value, 48)}px` : a.height), c = k(() => i.value ? a.multiLine ? o.value : !0 : !1), d = async () => {
      if (!(!l.value || !i.value || s.value)) {
        s.value = !0, o.value = !1;
        try {
          await et(), await new Promise((C) => setTimeout(C, 100));
          const m = l.value.scrollHeight, g = l.value.clientHeight, b = Math.max(48, m + 26);
          Math.abs(b - r.value) > 2 && (r.value = b), o.value = !0;
        } finally {
          s.value = !1;
        }
      }
    }, f = (m) => {
      i.value = m, n("update:model-value", m), m ? a.multiLine ? (o.value = !1, setTimeout(() => {
        d();
      }, 300)) : o.value = !0 : o.value = !1;
    }, h = () => {
      i.value = !1, n("update:model-value", !1);
    };
    return jt(() => {
      i.value = a.modelValue, a.modelValue ? a.multiLine ? (o.value = !1, setTimeout(() => {
        d();
      }, 300)) : o.value = !0 : o.value = !1;
    }), jt(() => {
      i.value && a.multiLine && (o.value = !1, setTimeout(() => {
        d();
      }, 300));
    }), (m, g) => {
      const v = Pe("v-snackbar");
      return N(), ee("div", xT, [
        c.value ? (N(), Ce(v, {
          key: 0,
          style: Ot(e.alertStyle),
          "model-value": i.value,
          "multi-line": e.multiLine,
          timeout: e.timeout,
          color: e.color,
          height: u.value,
          elevation: "0",
          "min-width": "600",
          location: "top",
          "onUpdate:modelValue": f
        }, {
          actions: re(() => [
            e.isClose ? (N(), Ce(_n, {
              key: 0,
              color: "#fff",
              variant: "text",
              onClick: h
            }, {
              default: re(() => g[0] || (g[0] = [
                Ee("Close")
              ])),
              _: 1
            })) : de("", !0)
          ]),
          default: re(() => [
            ke(m.$slots, "alert-icon"),
            ie("pre", {
              ref_key: "titleRef",
              ref: l,
              class: "s-alert__title",
              style: Ot({ width: e.width })
            }, xe(e.titleName), 5)
          ]),
          _: 3
        }, 8, ["style", "model-value", "multi-line", "timeout", "color", "height"])) : de("", !0),
        i.value && !c.value ? (N(), ee("div", PT, [
          ie("pre", {
            ref_key: "titleRef",
            ref: l,
            class: "s-alert__title",
            style: Ot({ width: e.width })
          }, xe(e.titleName), 5)
        ])) : de("", !0)
      ]);
    };
  }
}, _T = { class: "s-empty" }, MT = {
  key: 0,
  class: "s-empty__card-title"
}, VT = { class: "s-empty__card-content" }, TT = { style: { color: "#007bff", "font-size": "18px" } }, LT = {
  __name: "SEmpty",
  props: {
    title: {
      type: String,
      default: "",
      description: "empty 제목"
    },
    description: {
      type: String,
      default: "",
      description: "empty 내용"
    },
    elevation: {
      type: [Number, String],
      description: "카드의 입체감 조절 0~24까지 가능",
      default: void 0
    },
    outlined: {
      type: Boolean,
      description: "카드의 외곽선 설정",
      default: !0
    },
    shadowed: {
      type: Boolean,
      description: "카드에 그림자 효과 부여 on/off",
      default: !0
    },
    onClick: {
      type: Function,
      description: "description 클릭 이벤트",
      default: void 0
    }
  },
  setup(e) {
    return (t, n) => {
      const a = Pe("v-btn"), i = Pe("v-sheet");
      return N(), ee("div", _T, [
        p(i, {
          class: "s-empty__card",
          elevation: e.elevation,
          border: "",
          rounded: "",
          shadowed: e.shadowed
        }, {
          default: re(() => [
            e.title ? (N(), ee("div", MT, xe(e.title), 1)) : de("", !0),
            ie("div", VT, [
              e.onClick ? (N(), Ce(a, {
                key: 0,
                flat: "",
                onClick: e.onClick
              }, {
                default: re(() => [
                  ie("span", TT, xe(e.description), 1)
                ]),
                _: 1
              }, 8, ["onClick"])) : (N(), ee(ge, { key: 1 }, [
                Ee(xe(e.description), 1)
              ], 64))
            ]),
            ke(t.$slots, "default", {}, void 0, !0)
          ]),
          _: 3
        }, 8, ["elevation", "shadowed"])
      ]);
    };
  }
}, C7 = /* @__PURE__ */ Ut(LT, [["__scopeId", "data-v-3cf38698"]]);
let Th = [], w7 = [];
(() => {
  let e = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
  for (let t = 0, n = 0; t < e.length; t++)
    (t % 2 ? w7 : Th).push(n = n + e[t]);
})();
function QT(e) {
  if (e < 768) return !1;
  for (let t = 0, n = Th.length; ; ) {
    let a = t + n >> 1;
    if (e < Th[a]) n = a;
    else if (e >= w7[a]) t = a + 1;
    else return !0;
    if (t == n) return !1;
  }
}
function Qg(e) {
  return e >= 127462 && e <= 127487;
}
const Ag = 8205;
function AT(e, t, n = !0, a = !0) {
  return (n ? k7 : DT)(e, t, a);
}
function k7(e, t, n) {
  if (t == e.length) return t;
  t && S7(e.charCodeAt(t)) && x7(e.charCodeAt(t - 1)) && t--;
  let a = tf(e, t);
  for (t += Dg(a); t < e.length; ) {
    let i = tf(e, t);
    if (a == Ag || i == Ag || n && QT(i))
      t += Dg(i), a = i;
    else if (Qg(i)) {
      let l = 0, r = t - 2;
      for (; r >= 0 && Qg(tf(e, r)); )
        l++, r -= 2;
      if (l % 2 == 0) break;
      t += 2;
    } else
      break;
  }
  return t;
}
function DT(e, t, n) {
  for (; t > 0; ) {
    let a = k7(e, t - 2, n);
    if (a < t) return a;
    t--;
  }
  return 0;
}
function tf(e, t) {
  let n = e.charCodeAt(t);
  if (!x7(n) || t + 1 == e.length) return n;
  let a = e.charCodeAt(t + 1);
  return S7(a) ? (n - 55296 << 10) + (a - 56320) + 65536 : n;
}
function S7(e) {
  return e >= 56320 && e < 57344;
}
function x7(e) {
  return e >= 55296 && e < 56320;
}
function Dg(e) {
  return e < 65536 ? 1 : 2;
}
class gt {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, n, a) {
    [t, n] = ks(this, t, n);
    let i = [];
    return this.decompose(
      0,
      t,
      i,
      2
      /* Open.To */
    ), a.length && a.decompose(
      0,
      a.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      i,
      1
      /* Open.From */
    ), hi.from(i, this.length - (n - t) + a.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, n = this.length) {
    [t, n] = ks(this, t, n);
    let a = [];
    return this.decompose(t, n, a, 0), hi.from(a, n - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let n = this.scanIdentical(t, 1), a = this.length - this.scanIdentical(t, -1), i = new ko(this), l = new ko(t);
    for (let r = n, s = n; ; ) {
      if (i.next(r), l.next(r), r = 0, i.lineBreak != l.lineBreak || i.done != l.done || i.value != l.value)
        return !1;
      if (s += i.value.length, i.done || s >= a)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new ko(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, n = this.length) {
    return new P7(this, t, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, n) {
    let a;
    if (t == null)
      a = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(t).from;
      a = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new $7(a);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? gt.empty : t.length <= 32 ? new un(t) : hi.from(un.split(t, []));
  }
}
class un extends gt {
  constructor(t, n = RT(t)) {
    super(), this.text = t, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, n, a, i) {
    for (let l = 0; ; l++) {
      let r = this.text[l], s = i + r.length;
      if ((n ? a : s) >= t)
        return new IT(i, s, a, r);
      i = s + 1, a++;
    }
  }
  decompose(t, n, a, i) {
    let l = t <= 0 && n >= this.length ? this : new un(Rg(this.text, t, n), Math.min(n, this.length) - Math.max(0, t));
    if (i & 1) {
      let r = a.pop(), s = xc(l.text, r.text.slice(), 0, l.length);
      if (s.length <= 32)
        a.push(new un(s, r.length + l.length));
      else {
        let o = s.length >> 1;
        a.push(new un(s.slice(0, o)), new un(s.slice(o)));
      }
    } else
      a.push(l);
  }
  replace(t, n, a) {
    if (!(a instanceof un))
      return super.replace(t, n, a);
    [t, n] = ks(this, t, n);
    let i = xc(this.text, xc(a.text, Rg(this.text, 0, t)), n), l = this.length + a.length - (n - t);
    return i.length <= 32 ? new un(i, l) : hi.from(un.split(i, []), l);
  }
  sliceString(t, n = this.length, a = `
`) {
    [t, n] = ks(this, t, n);
    let i = "";
    for (let l = 0, r = 0; l <= n && r < this.text.length; r++) {
      let s = this.text[r], o = l + s.length;
      l > t && r && (i += a), t < o && n > l && (i += s.slice(Math.max(0, t - l), n - l)), l = o + 1;
    }
    return i;
  }
  flatten(t) {
    for (let n of this.text)
      t.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, n) {
    let a = [], i = -1;
    for (let l of t)
      a.push(l), i += l.length + 1, a.length == 32 && (n.push(new un(a, i)), a = [], i = -1);
    return i > -1 && n.push(new un(a, i)), n;
  }
}
class hi extends gt {
  constructor(t, n) {
    super(), this.children = t, this.length = n, this.lines = 0;
    for (let a of t)
      this.lines += a.lines;
  }
  lineInner(t, n, a, i) {
    for (let l = 0; ; l++) {
      let r = this.children[l], s = i + r.length, o = a + r.lines - 1;
      if ((n ? o : s) >= t)
        return r.lineInner(t, n, a, i);
      i = s + 1, a = o + 1;
    }
  }
  decompose(t, n, a, i) {
    for (let l = 0, r = 0; r <= n && l < this.children.length; l++) {
      let s = this.children[l], o = r + s.length;
      if (t <= o && n >= r) {
        let u = i & ((r <= t ? 1 : 0) | (o >= n ? 2 : 0));
        r >= t && o <= n && !u ? a.push(s) : s.decompose(t - r, n - r, a, u);
      }
      r = o + 1;
    }
  }
  replace(t, n, a) {
    if ([t, n] = ks(this, t, n), a.lines < this.lines)
      for (let i = 0, l = 0; i < this.children.length; i++) {
        let r = this.children[i], s = l + r.length;
        if (t >= l && n <= s) {
          let o = r.replace(t - l, n - l, a), u = this.lines - r.lines + o.lines;
          if (o.lines < u >> 4 && o.lines > u >> 6) {
            let c = this.children.slice();
            return c[i] = o, new hi(c, this.length - (n - t) + a.length);
          }
          return super.replace(l, s, o);
        }
        l = s + 1;
      }
    return super.replace(t, n, a);
  }
  sliceString(t, n = this.length, a = `
`) {
    [t, n] = ks(this, t, n);
    let i = "";
    for (let l = 0, r = 0; l < this.children.length && r <= n; l++) {
      let s = this.children[l], o = r + s.length;
      r > t && l && (i += a), t < o && n > r && (i += s.sliceString(t - r, n - r, a)), r = o + 1;
    }
    return i;
  }
  flatten(t) {
    for (let n of this.children)
      n.flatten(t);
  }
  scanIdentical(t, n) {
    if (!(t instanceof hi))
      return 0;
    let a = 0, [i, l, r, s] = n > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; i += n, l += n) {
      if (i == r || l == s)
        return a;
      let o = this.children[i], u = t.children[l];
      if (o != u)
        return a + o.scanIdentical(u, n);
      a += o.length + 1;
    }
  }
  static from(t, n = t.reduce((a, i) => a + i.length + 1, -1)) {
    let a = 0;
    for (let h of t)
      a += h.lines;
    if (a < 32) {
      let h = [];
      for (let m of t)
        m.flatten(h);
      return new un(h, n);
    }
    let i = Math.max(
      32,
      a >> 5
      /* Tree.BranchShift */
    ), l = i << 1, r = i >> 1, s = [], o = 0, u = -1, c = [];
    function d(h) {
      let m;
      if (h.lines > l && h instanceof hi)
        for (let g of h.children)
          d(g);
      else h.lines > r && (o > r || !o) ? (f(), s.push(h)) : h instanceof un && o && (m = c[c.length - 1]) instanceof un && h.lines + m.lines <= 32 ? (o += h.lines, u += h.length + 1, c[c.length - 1] = new un(m.text.concat(h.text), m.length + 1 + h.length)) : (o + h.lines > i && f(), o += h.lines, u += h.length + 1, c.push(h));
    }
    function f() {
      o != 0 && (s.push(c.length == 1 ? c[0] : hi.from(c, u)), u = -1, o = c.length = 0);
    }
    for (let h of t)
      d(h);
    return f(), s.length == 1 ? s[0] : new hi(s, n);
  }
}
gt.empty = /* @__PURE__ */ new un([""], 0);
function RT(e) {
  let t = -1;
  for (let n of e)
    t += n.length + 1;
  return t;
}
function xc(e, t, n = 0, a = 1e9) {
  for (let i = 0, l = 0, r = !0; l < e.length && i <= a; l++) {
    let s = e[l], o = i + s.length;
    o >= n && (o > a && (s = s.slice(0, a - i)), i < n && (s = s.slice(n - i)), r ? (t[t.length - 1] += s, r = !1) : t.push(s)), i = o + 1;
  }
  return t;
}
function Rg(e, t, n) {
  return xc(e, [""], t, n);
}
class ko {
  constructor(t, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [n > 0 ? 1 : (t instanceof un ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let a = this.nodes.length - 1, i = this.nodes[a], l = this.offsets[a], r = l >> 1, s = i instanceof un ? i.text.length : i.children.length;
      if (r == (n > 0 ? s : 0)) {
        if (a == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[a - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((l & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[a] += n, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (i instanceof un) {
        let o = i.text[r + (n < 0 ? -1 : 0)];
        if (this.offsets[a] += n, o.length > Math.max(0, t))
          return this.value = t == 0 ? o : n > 0 ? o.slice(t) : o.slice(0, o.length - t), this;
        t -= o.length;
      } else {
        let o = i.children[r + (n < 0 ? -1 : 0)];
        t > o.length ? (t -= o.length, this.offsets[a] += n) : (n < 0 && this.offsets[a]--, this.nodes.push(o), this.offsets.push(n > 0 ? 1 : (o instanceof un ? o.text.length : o.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}
class P7 {
  constructor(t, n, a) {
    this.value = "", this.done = !1, this.cursor = new ko(t, n > a ? -1 : 1), this.pos = n > a ? t.length : 0, this.from = Math.min(n, a), this.to = Math.max(n, a);
  }
  nextInner(t, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let a = n < 0 ? this.pos - this.from : this.to - this.pos;
    t > a && (t = a), a -= t;
    let { value: i } = this.cursor.next(t);
    return this.pos += (i.length + t) * n, this.value = i.length <= a ? i : n < 0 ? i.slice(i.length - a) : i.slice(0, a), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class $7 {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: n, lineBreak: a, value: i } = this.inner.next(t);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : a ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (gt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, ko.prototype[Symbol.iterator] = P7.prototype[Symbol.iterator] = $7.prototype[Symbol.iterator] = function() {
  return this;
});
class IT {
  /**
  @internal
  */
  constructor(t, n, a, i) {
    this.from = t, this.to = n, this.number = a, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function ks(e, t, n) {
  return t = Math.max(0, Math.min(e.length, t)), [t, Math.max(t, Math.min(e.length, n))];
}
function jn(e, t, n = !0, a = !0) {
  return AT(e, t, n, a);
}
function BT(e) {
  return e >= 56320 && e < 57344;
}
function ZT(e) {
  return e >= 55296 && e < 56320;
}
function ca(e, t) {
  let n = e.charCodeAt(t);
  if (!ZT(n) || t + 1 == e.length)
    return n;
  let a = e.charCodeAt(t + 1);
  return BT(a) ? (n - 55296 << 10) + (a - 56320) + 65536 : n;
}
function im(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
function mi(e) {
  return e < 65536 ? 1 : 2;
}
const Lh = /\r\n?|\n/;
var Hn = /* @__PURE__ */ function(e) {
  return e[e.Simple = 0] = "Simple", e[e.TrackDel = 1] = "TrackDel", e[e.TrackBefore = 2] = "TrackBefore", e[e.TrackAfter = 3] = "TrackAfter", e;
}(Hn || (Hn = {}));
class Pi {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      t += this.sections[n];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let a = this.sections[n + 1];
      t += a < 0 ? this.sections[n] : a;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let n = 0, a = 0, i = 0; n < this.sections.length; ) {
      let l = this.sections[n++], r = this.sections[n++];
      r < 0 ? (t(a, i, l), i += l) : i += r, a += l;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, n = !1) {
    Qh(this, t, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let n = 0; n < this.sections.length; ) {
      let a = this.sections[n++], i = this.sections[n++];
      i < 0 ? t.push(a, i) : t.push(i, a);
    }
    return new Pi(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : _7(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(t, n = !1) {
    return t.empty ? this : Ah(this, t, n);
  }
  mapPos(t, n = -1, a = Hn.Simple) {
    let i = 0, l = 0;
    for (let r = 0; r < this.sections.length; ) {
      let s = this.sections[r++], o = this.sections[r++], u = i + s;
      if (o < 0) {
        if (u > t)
          return l + (t - i);
        l += s;
      } else {
        if (a != Hn.Simple && u >= t && (a == Hn.TrackDel && i < t && u > t || a == Hn.TrackBefore && i < t || a == Hn.TrackAfter && u > t))
          return null;
        if (u > t || u == t && n < 0 && !s)
          return t == i || n < 0 ? l : l + o;
        l += o;
      }
      i = u;
    }
    if (t > i)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${i}`);
    return l;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, n = t) {
    for (let a = 0, i = 0; a < this.sections.length && i <= n; ) {
      let l = this.sections[a++], r = this.sections[a++], s = i + l;
      if (r >= 0 && i <= n && s >= t)
        return i < t && s > n ? "cover" : !0;
      i = s;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let n = 0; n < this.sections.length; ) {
      let a = this.sections[n++], i = this.sections[n++];
      t += (t ? " " : "") + a + (i >= 0 ? ":" + i : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Pi(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new Pi(t);
  }
}
class Mn extends Pi {
  constructor(t, n) {
    super(t), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Qh(this, (n, a, i, l, r) => t = t.replace(i, i + (a - n), r), !1), t;
  }
  mapDesc(t, n = !1) {
    return Ah(this, t, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let n = this.sections.slice(), a = [];
    for (let i = 0, l = 0; i < n.length; i += 2) {
      let r = n[i], s = n[i + 1];
      if (s >= 0) {
        n[i] = s, n[i + 1] = r;
        let o = i >> 1;
        for (; a.length < o; )
          a.push(gt.empty);
        a.push(r ? t.slice(l, l + r) : gt.empty);
      }
      l += r;
    }
    return new Mn(n, a);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : _7(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, n = !1) {
    return t.empty ? this : Ah(this, t, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, n = !1) {
    Qh(this, t, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Pi.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let n = [], a = [], i = [], l = new Yo(this);
    e: for (let r = 0, s = 0; ; ) {
      let o = r == t.length ? 1e9 : t[r++];
      for (; s < o || s == o && l.len == 0; ) {
        if (l.done)
          break e;
        let c = Math.min(l.len, o - s);
        Wn(i, c, -1);
        let d = l.ins == -1 ? -1 : l.off == 0 ? l.ins : 0;
        Wn(n, c, d), d > 0 && Ol(a, n, l.text), l.forward(c), s += c;
      }
      let u = t[r++];
      for (; s < u; ) {
        if (l.done)
          break e;
        let c = Math.min(l.len, u - s);
        Wn(n, c, -1), Wn(i, c, l.ins == -1 ? -1 : l.off == 0 ? l.ins : 0), l.forward(c), s += c;
      }
    }
    return {
      changes: new Mn(n, a),
      filtered: Pi.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let a = this.sections[n], i = this.sections[n + 1];
      i < 0 ? t.push(a) : i == 0 ? t.push([a]) : t.push([a].concat(this.inserted[n >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, n, a) {
    let i = [], l = [], r = 0, s = null;
    function o(c = !1) {
      if (!c && !i.length)
        return;
      r < n && Wn(i, n - r, -1);
      let d = new Mn(i, l);
      s = s ? s.compose(d.map(s)) : d, i = [], l = [], r = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let d of c)
          u(d);
      else if (c instanceof Mn) {
        if (c.length != n)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${n})`);
        o(), s = s ? s.compose(c.map(s)) : c;
      } else {
        let { from: d, to: f = d, insert: h } = c;
        if (d > f || d < 0 || f > n)
          throw new RangeError(`Invalid change range ${d} to ${f} (in doc of length ${n})`);
        let m = h ? typeof h == "string" ? gt.of(h.split(a || Lh)) : h : gt.empty, g = m.length;
        if (d == f && g == 0)
          return;
        d < r && o(), d > r && Wn(i, d - r, -1), Wn(i, f - d, g), Ol(l, i, m), r = f;
      }
    }
    return u(t), o(!s), s;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new Mn(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], a = [];
    for (let i = 0; i < t.length; i++) {
      let l = t[i];
      if (typeof l == "number")
        n.push(l, -1);
      else {
        if (!Array.isArray(l) || typeof l[0] != "number" || l.some((r, s) => s && typeof r != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (l.length == 1)
          n.push(l[0], 0);
        else {
          for (; a.length < i; )
            a.push(gt.empty);
          a[i] = gt.of(l.slice(1)), n.push(l[0], a[i].length);
        }
      }
    }
    return new Mn(n, a);
  }
  /**
  @internal
  */
  static createSet(t, n) {
    return new Mn(t, n);
  }
}
function Wn(e, t, n, a = !1) {
  if (t == 0 && n <= 0)
    return;
  let i = e.length - 2;
  i >= 0 && n <= 0 && n == e[i + 1] ? e[i] += t : i >= 0 && t == 0 && e[i] == 0 ? e[i + 1] += n : a ? (e[i] += t, e[i + 1] += n) : e.push(t, n);
}
function Ol(e, t, n) {
  if (n.length == 0)
    return;
  let a = t.length - 2 >> 1;
  if (a < e.length)
    e[e.length - 1] = e[e.length - 1].append(n);
  else {
    for (; e.length < a; )
      e.push(gt.empty);
    e.push(n);
  }
}
function Qh(e, t, n) {
  let a = e.inserted;
  for (let i = 0, l = 0, r = 0; r < e.sections.length; ) {
    let s = e.sections[r++], o = e.sections[r++];
    if (o < 0)
      i += s, l += s;
    else {
      let u = i, c = l, d = gt.empty;
      for (; u += s, c += o, o && a && (d = d.append(a[r - 2 >> 1])), !(n || r == e.sections.length || e.sections[r + 1] < 0); )
        s = e.sections[r++], o = e.sections[r++];
      t(i, u, l, c, d), i = u, l = c;
    }
  }
}
function Ah(e, t, n, a = !1) {
  let i = [], l = a ? [] : null, r = new Yo(e), s = new Yo(t);
  for (let o = -1; ; ) {
    if (r.done && s.len || s.done && r.len)
      throw new Error("Mismatched change set lengths");
    if (r.ins == -1 && s.ins == -1) {
      let u = Math.min(r.len, s.len);
      Wn(i, u, -1), r.forward(u), s.forward(u);
    } else if (s.ins >= 0 && (r.ins < 0 || o == r.i || r.off == 0 && (s.len < r.len || s.len == r.len && !n))) {
      let u = s.len;
      for (Wn(i, s.ins, -1); u; ) {
        let c = Math.min(r.len, u);
        r.ins >= 0 && o < r.i && r.len <= c && (Wn(i, 0, r.ins), l && Ol(l, i, r.text), o = r.i), r.forward(c), u -= c;
      }
      s.next();
    } else if (r.ins >= 0) {
      let u = 0, c = r.len;
      for (; c; )
        if (s.ins == -1) {
          let d = Math.min(c, s.len);
          u += d, c -= d, s.forward(d);
        } else if (s.ins == 0 && s.len < c)
          c -= s.len, s.next();
        else
          break;
      Wn(i, u, o < r.i ? r.ins : 0), l && o < r.i && Ol(l, i, r.text), o = r.i, r.forward(r.len - c);
    } else {
      if (r.done && s.done)
        return l ? Mn.createSet(i, l) : Pi.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function _7(e, t, n = !1) {
  let a = [], i = n ? [] : null, l = new Yo(e), r = new Yo(t);
  for (let s = !1; ; ) {
    if (l.done && r.done)
      return i ? Mn.createSet(a, i) : Pi.create(a);
    if (l.ins == 0)
      Wn(a, l.len, 0, s), l.next();
    else if (r.len == 0 && !r.done)
      Wn(a, 0, r.ins, s), i && Ol(i, a, r.text), r.next();
    else {
      if (l.done || r.done)
        throw new Error("Mismatched change set lengths");
      {
        let o = Math.min(l.len2, r.len), u = a.length;
        if (l.ins == -1) {
          let c = r.ins == -1 ? -1 : r.off ? 0 : r.ins;
          Wn(a, o, c, s), i && c && Ol(i, a, r.text);
        } else r.ins == -1 ? (Wn(a, l.off ? 0 : l.len, o, s), i && Ol(i, a, l.textBit(o))) : (Wn(a, l.off ? 0 : l.len, r.off ? 0 : r.ins, s), i && !r.off && Ol(i, a, r.text));
        s = (l.ins > o || r.ins >= 0 && r.len > o) && (s || a.length > u), l.forward2(o), r.forward(o);
      }
    }
  }
}
class Yo {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, n = this.i - 2 >> 1;
    return n >= t.length ? gt.empty : t[n];
  }
  textBit(t) {
    let { inserted: n } = this.set, a = this.i - 2 >> 1;
    return a >= n.length && !t ? gt.empty : n[a].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}
class nr {
  constructor(t, n, a) {
    this.from = t, this.to = n, this.flags = a;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, n = -1) {
    let a, i;
    return this.empty ? a = i = t.mapPos(this.from, n) : (a = t.mapPos(this.from, 1), i = t.mapPos(this.to, -1)), a == this.from && i == this.to ? this : new nr(a, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, n = t) {
    if (t <= this.anchor && n >= this.anchor)
      return we.range(t, n);
    let a = Math.abs(t - this.anchor) > Math.abs(n - this.anchor) ? t : n;
    return we.range(this.anchor, a);
  }
  /**
  Compare this range to another range.
  */
  eq(t, n = !1) {
    return this.anchor == t.anchor && this.head == t.head && (!n || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return we.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, n, a) {
    return new nr(t, n, a);
  }
}
class we {
  constructor(t, n) {
    this.ranges = t, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, n = -1) {
    return t.empty ? this : we.create(this.ranges.map((a) => a.map(t, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, n = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let a = 0; a < this.ranges.length; a++)
      if (!this.ranges[a].eq(t.ranges[a], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new we([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, n = !0) {
    return we.create([t].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, n = this.mainIndex) {
    let a = this.ranges.slice();
    return a[n] = t, we.create(a, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new we(t.ranges.map((n) => nr.fromJSON(n)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, n = t) {
    return new we([we.range(t, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, n = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let a = 0, i = 0; i < t.length; i++) {
      let l = t[i];
      if (l.empty ? l.from <= a : l.from < a)
        return we.normalized(t.slice(), n);
      a = l.to;
    }
    return new we(t, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, n = 0, a, i) {
    return nr.create(t, t, (n == 0 ? 0 : n < 0 ? 8 : 16) | (a == null ? 7 : Math.min(6, a)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, n, a, i) {
    let l = (a ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return n < t ? nr.create(n, t, 48 | l) : nr.create(t, n, (n > t ? 8 : 0) | l);
  }
  /**
  @internal
  */
  static normalized(t, n = 0) {
    let a = t[n];
    t.sort((i, l) => i.from - l.from), n = t.indexOf(a);
    for (let i = 1; i < t.length; i++) {
      let l = t[i], r = t[i - 1];
      if (l.empty ? l.from <= r.to : l.from < r.to) {
        let s = r.from, o = Math.max(l.to, r.to);
        i <= n && n--, t.splice(--i, 2, l.anchor > l.head ? we.range(o, s) : we.range(s, o));
      }
    }
    return new we(t, n);
  }
}
function M7(e, t) {
  for (let n of e.ranges)
    if (n.to > t)
      throw new RangeError("Selection points outside of document");
}
let lm = 0;
class He {
  constructor(t, n, a, i, l) {
    this.combine = t, this.compareInput = n, this.compare = a, this.isStatic = i, this.id = lm++, this.default = t([]), this.extensions = typeof l == "function" ? l(this) : l;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new He(t.combine || ((n) => n), t.compareInput || ((n, a) => n === a), t.compare || (t.combine ? (n, a) => n === a : rm), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new Pc([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Pc(t, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Pc(t, this, 2, n);
  }
  from(t, n) {
    return n || (n = (a) => a), this.compute([t], (a) => n(a.field(t)));
  }
}
function rm(e, t) {
  return e == t || e.length == t.length && e.every((n, a) => n === t[a]);
}
class Pc {
  constructor(t, n, a, i) {
    this.dependencies = t, this.facet = n, this.type = a, this.value = i, this.id = lm++;
  }
  dynamicSlot(t) {
    var n;
    let a = this.value, i = this.facet.compareInput, l = this.id, r = t[l] >> 1, s = this.type == 2, o = !1, u = !1, c = [];
    for (let d of this.dependencies)
      d == "doc" ? o = !0 : d == "selection" ? u = !0 : ((n = t[d.id]) !== null && n !== void 0 ? n : 1) & 1 || c.push(t[d.id]);
    return {
      create(d) {
        return d.values[r] = a(d), 1;
      },
      update(d, f) {
        if (o && f.docChanged || u && (f.docChanged || f.selection) || Dh(d, c)) {
          let h = a(d);
          if (s ? !Ig(h, d.values[r], i) : !i(h, d.values[r]))
            return d.values[r] = h, 1;
        }
        return 0;
      },
      reconfigure: (d, f) => {
        let h, m = f.config.address[l];
        if (m != null) {
          let g = Jc(f, m);
          if (this.dependencies.every((v) => v instanceof He ? f.facet(v) === d.facet(v) : v instanceof $n ? f.field(v, !1) == d.field(v, !1) : !0) || (s ? Ig(h = a(d), g, i) : i(h = a(d), g)))
            return d.values[r] = g, 0;
        } else
          h = a(d);
        return d.values[r] = h, 1;
      }
    };
  }
}
function Ig(e, t, n) {
  if (e.length != t.length)
    return !1;
  for (let a = 0; a < e.length; a++)
    if (!n(e[a], t[a]))
      return !1;
  return !0;
}
function Dh(e, t) {
  let n = !1;
  for (let a of t)
    So(e, a) & 1 && (n = !0);
  return n;
}
function ET(e, t, n) {
  let a = n.map((o) => e[o.id]), i = n.map((o) => o.type), l = a.filter((o) => !(o & 1)), r = e[t.id] >> 1;
  function s(o) {
    let u = [];
    for (let c = 0; c < a.length; c++) {
      let d = Jc(o, a[c]);
      if (i[c] == 2)
        for (let f of d)
          u.push(f);
      else
        u.push(d);
    }
    return t.combine(u);
  }
  return {
    create(o) {
      for (let u of a)
        So(o, u);
      return o.values[r] = s(o), 1;
    },
    update(o, u) {
      if (!Dh(o, l))
        return 0;
      let c = s(o);
      return t.compare(c, o.values[r]) ? 0 : (o.values[r] = c, 1);
    },
    reconfigure(o, u) {
      let c = Dh(o, a), d = u.config.facets[t.id], f = u.facet(t);
      if (d && !c && rm(n, d))
        return o.values[r] = f, 0;
      let h = s(o);
      return t.compare(h, f) ? (o.values[r] = f, 0) : (o.values[r] = h, 1);
    }
  };
}
const qu = /* @__PURE__ */ He.define({ static: !0 });
class $n {
  constructor(t, n, a, i, l) {
    this.id = t, this.createF = n, this.updateF = a, this.compareF = i, this.spec = l, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let n = new $n(lm++, t.create, t.update, t.compare || ((a, i) => a === i), t);
    return t.provide && (n.provides = t.provide(n)), n;
  }
  create(t) {
    let n = t.facet(qu).find((a) => a.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let n = t[this.id] >> 1;
    return {
      create: (a) => (a.values[n] = this.create(a), 1),
      update: (a, i) => {
        let l = a.values[n], r = this.updateF(l, i);
        return this.compareF(l, r) ? 0 : (a.values[n] = r, 1);
      },
      reconfigure: (a, i) => {
        let l = a.facet(qu), r = i.facet(qu), s;
        return (s = l.find((o) => o.field == this)) && s != r.find((o) => o.field == this) ? (a.values[n] = s.create(a), 1) : i.config.address[this.id] != null ? (a.values[n] = i.field(this), 0) : (a.values[n] = this.create(a), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, qu.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Gl = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ro(e) {
  return (t) => new V7(t, e);
}
const El = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ ro(Gl.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ ro(Gl.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ ro(Gl.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ ro(Gl.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ ro(Gl.lowest)
};
class V7 {
  constructor(t, n) {
    this.inner = t, this.prec = n;
  }
}
class Ss {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new Rh(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return Ss.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}
class Rh {
  constructor(t, n) {
    this.compartment = t, this.inner = n;
  }
}
class Kc {
  constructor(t, n, a, i, l, r) {
    for (this.base = t, this.compartments = n, this.dynamicSlots = a, this.address = i, this.staticValues = l, this.facets = r, this.statusTemplate = []; this.statusTemplate.length < a.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let n = this.address[t.id];
    return n == null ? t.default : this.staticValues[n >> 1];
  }
  static resolve(t, n, a) {
    let i = [], l = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Map();
    for (let f of NT(t, n, r))
      f instanceof $n ? i.push(f) : (l[f.facet.id] || (l[f.facet.id] = [])).push(f);
    let s = /* @__PURE__ */ Object.create(null), o = [], u = [];
    for (let f of i)
      s[f.id] = u.length << 1, u.push((h) => f.slot(h));
    let c = a == null ? void 0 : a.config.facets;
    for (let f in l) {
      let h = l[f], m = h[0].facet, g = c && c[f] || [];
      if (h.every(
        (v) => v.type == 0
        /* Provider.Static */
      ))
        if (s[m.id] = o.length << 1 | 1, rm(g, h))
          o.push(a.facet(m));
        else {
          let v = m.combine(h.map((y) => y.value));
          o.push(a && m.compare(v, a.facet(m)) ? a.facet(m) : v);
        }
      else {
        for (let v of h)
          v.type == 0 ? (s[v.id] = o.length << 1 | 1, o.push(v.value)) : (s[v.id] = u.length << 1, u.push((y) => v.dynamicSlot(y)));
        s[m.id] = u.length << 1, u.push((v) => ET(v, m, h));
      }
    }
    let d = u.map((f) => f(s));
    return new Kc(t, r, d, s, o, l);
  }
}
function NT(e, t, n) {
  let a = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function l(r, s) {
    let o = i.get(r);
    if (o != null) {
      if (o <= s)
        return;
      let u = a[o].indexOf(r);
      u > -1 && a[o].splice(u, 1), r instanceof Rh && n.delete(r.compartment);
    }
    if (i.set(r, s), Array.isArray(r))
      for (let u of r)
        l(u, s);
    else if (r instanceof Rh) {
      if (n.has(r.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = t.get(r.compartment) || r.inner;
      n.set(r.compartment, u), l(u, s);
    } else if (r instanceof V7)
      l(r.inner, r.prec);
    else if (r instanceof $n)
      a[s].push(r), r.provides && l(r.provides, s);
    else if (r instanceof Pc)
      a[s].push(r), r.facet.extensions && l(r.facet.extensions, Gl.default);
    else {
      let u = r.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${r}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      l(u, s);
    }
  }
  return l(e, Gl.default), a.reduce((r, s) => r.concat(s));
}
function So(e, t) {
  if (t & 1)
    return 2;
  let n = t >> 1, a = e.status[n];
  if (a == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (a & 2)
    return a;
  e.status[n] = 4;
  let i = e.computeSlot(e, e.config.dynamicSlots[n]);
  return e.status[n] = 2 | i;
}
function Jc(e, t) {
  return t & 1 ? e.config.staticValues[t >> 1] : e.values[t >> 1];
}
const T7 = /* @__PURE__ */ He.define(), Ih = /* @__PURE__ */ He.define({
  combine: (e) => e.some((t) => t),
  static: !0
}), L7 = /* @__PURE__ */ He.define({
  combine: (e) => e.length ? e[0] : void 0,
  static: !0
}), Q7 = /* @__PURE__ */ He.define(), A7 = /* @__PURE__ */ He.define(), D7 = /* @__PURE__ */ He.define(), R7 = /* @__PURE__ */ He.define({
  combine: (e) => e.length ? e[0] : !1
});
class rl {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new HT();
  }
}
class HT {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new rl(this, t);
  }
}
class jT {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new at(this, t);
  }
}
class at {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let n = this.type.map(this.value, t);
    return n === void 0 ? void 0 : n == this.value ? this : new at(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new jT(t.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, n) {
    if (!t.length)
      return t;
    let a = [];
    for (let i of t) {
      let l = i.map(n);
      l && a.push(l);
    }
    return a;
  }
}
at.reconfigure = /* @__PURE__ */ at.define();
at.appendConfig = /* @__PURE__ */ at.define();
class wn {
  constructor(t, n, a, i, l, r) {
    this.startState = t, this.changes = n, this.selection = a, this.effects = i, this.annotations = l, this.scrollIntoView = r, this._doc = null, this._state = null, a && M7(a, n.newLength), l.some((s) => s.type == wn.time) || (this.annotations = l.concat(wn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, n, a, i, l, r) {
    return new wn(t, n, a, i, l, r);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let n of this.annotations)
      if (n.type == t)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let n = this.annotation(wn.userEvent);
    return !!(n && (n == t || n.length > t.length && n.slice(0, t.length) == t && n[t.length] == "."));
  }
}
wn.time = /* @__PURE__ */ rl.define();
wn.userEvent = /* @__PURE__ */ rl.define();
wn.addToHistory = /* @__PURE__ */ rl.define();
wn.remote = /* @__PURE__ */ rl.define();
function zT(e, t) {
  let n = [];
  for (let a = 0, i = 0; ; ) {
    let l, r;
    if (a < e.length && (i == t.length || t[i] >= e[a]))
      l = e[a++], r = e[a++];
    else if (i < t.length)
      l = t[i++], r = t[i++];
    else
      return n;
    !n.length || n[n.length - 1] < l ? n.push(l, r) : n[n.length - 1] < r && (n[n.length - 1] = r);
  }
}
function I7(e, t, n) {
  var a;
  let i, l, r;
  return n ? (i = t.changes, l = Mn.empty(t.changes.length), r = e.changes.compose(t.changes)) : (i = t.changes.map(e.changes), l = e.changes.mapDesc(t.changes, !0), r = e.changes.compose(i)), {
    changes: r,
    selection: t.selection ? t.selection.map(l) : (a = e.selection) === null || a === void 0 ? void 0 : a.map(i),
    effects: at.mapEffects(e.effects, i).concat(at.mapEffects(t.effects, l)),
    annotations: e.annotations.length ? e.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: e.scrollIntoView || t.scrollIntoView
  };
}
function Bh(e, t, n) {
  let a = t.selection, i = cs(t.annotations);
  return t.userEvent && (i = i.concat(wn.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof Mn ? t.changes : Mn.of(t.changes || [], n, e.facet(L7)),
    selection: a && (a instanceof we ? a : we.single(a.anchor, a.head)),
    effects: cs(t.effects),
    annotations: i,
    scrollIntoView: !!t.scrollIntoView
  };
}
function B7(e, t, n) {
  let a = Bh(e, t.length ? t[0] : {}, e.doc.length);
  t.length && t[0].filter === !1 && (n = !1);
  for (let l = 1; l < t.length; l++) {
    t[l].filter === !1 && (n = !1);
    let r = !!t[l].sequential;
    a = I7(a, Bh(e, t[l], r ? a.changes.newLength : e.doc.length), r);
  }
  let i = wn.create(e, a.changes, a.selection, a.effects, a.annotations, a.scrollIntoView);
  return XT(n ? FT(i) : i);
}
function FT(e) {
  let t = e.startState, n = !0;
  for (let i of t.facet(Q7)) {
    let l = i(e);
    if (l === !1) {
      n = !1;
      break;
    }
    Array.isArray(l) && (n = n === !0 ? l : zT(n, l));
  }
  if (n !== !0) {
    let i, l;
    if (n === !1)
      l = e.changes.invertedDesc, i = Mn.empty(t.doc.length);
    else {
      let r = e.changes.filter(n);
      i = r.changes, l = r.filtered.mapDesc(r.changes).invertedDesc;
    }
    e = wn.create(t, i, e.selection && e.selection.map(l), at.mapEffects(e.effects, l), e.annotations, e.scrollIntoView);
  }
  let a = t.facet(A7);
  for (let i = a.length - 1; i >= 0; i--) {
    let l = a[i](e);
    l instanceof wn ? e = l : Array.isArray(l) && l.length == 1 && l[0] instanceof wn ? e = l[0] : e = B7(t, cs(l), !1);
  }
  return e;
}
function XT(e) {
  let t = e.startState, n = t.facet(D7), a = e;
  for (let i = n.length - 1; i >= 0; i--) {
    let l = n[i](e);
    l && Object.keys(l).length && (a = I7(a, Bh(t, l, e.changes.newLength), !0));
  }
  return a == e ? e : wn.create(t, e.changes, e.selection, a.effects, a.annotations, a.scrollIntoView);
}
const YT = [];
function cs(e) {
  return e == null ? YT : Array.isArray(e) ? e : [e];
}
var Ft = /* @__PURE__ */ function(e) {
  return e[e.Word = 0] = "Word", e[e.Space = 1] = "Space", e[e.Other = 2] = "Other", e;
}(Ft || (Ft = {}));
const WT = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Zh;
try {
  Zh = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function qT(e) {
  if (Zh)
    return Zh.test(e);
  for (let t = 0; t < e.length; t++) {
    let n = e[t];
    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || WT.test(n)))
      return !0;
  }
  return !1;
}
function UT(e) {
  return (t) => {
    if (!/\S/.test(t))
      return Ft.Space;
    if (qT(t))
      return Ft.Word;
    for (let n = 0; n < e.length; n++)
      if (t.indexOf(e[n]) > -1)
        return Ft.Word;
    return Ft.Other;
  };
}
class ot {
  constructor(t, n, a, i, l, r) {
    this.config = t, this.doc = n, this.selection = a, this.values = i, this.status = t.statusTemplate.slice(), this.computeSlot = l, r && (r._state = this);
    for (let s = 0; s < this.config.dynamicSlots.length; s++)
      So(this, s << 1);
    this.computeSlot = null;
  }
  field(t, n = !0) {
    let a = this.config.address[t.id];
    if (a == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return So(this, a), Jc(this, a);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return B7(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let n = this.config, { base: a, compartments: i } = n;
    for (let s of t.effects)
      s.is(Ss.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((o, u) => i.set(u, o)), n = null), i.set(s.value.compartment, s.value.extension)) : s.is(at.reconfigure) ? (n = null, a = s.value) : s.is(at.appendConfig) && (n = null, a = cs(a).concat(s.value));
    let l;
    n ? l = t.startState.values.slice() : (n = Kc.resolve(a, i, this), l = new ot(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (o, u) => u.reconfigure(o, this), null).values);
    let r = t.startState.facet(Ih) ? t.newSelection : t.newSelection.asSingle();
    new ot(n, t.newDoc, r, l, (s, o) => o.update(s, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: t },
      range: we.cursor(n.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let n = this.selection, a = t(n.ranges[0]), i = this.changes(a.changes), l = [a.range], r = cs(a.effects);
    for (let s = 1; s < n.ranges.length; s++) {
      let o = t(n.ranges[s]), u = this.changes(o.changes), c = u.map(i);
      for (let f = 0; f < s; f++)
        l[f] = l[f].map(c);
      let d = i.mapDesc(u, !0);
      l.push(o.range.map(d)), i = i.compose(c), r = at.mapEffects(r, c).concat(at.mapEffects(cs(o.effects), d));
    }
    return {
      changes: i,
      selection: we.create(l, n.mainIndex),
      effects: r
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof Mn ? t : Mn.of(t, this.doc.length, this.facet(ot.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return gt.of(t.split(this.facet(ot.lineSeparator) || Lh));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, n = this.doc.length) {
    return this.doc.sliceString(t, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let n = this.config.address[t.id];
    return n == null ? t.default : (So(this, n), Jc(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let a in t) {
        let i = t[a];
        i instanceof $n && this.config.address[i.id] != null && (n[a] = i.spec.toJSON(this.field(t[a]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, n = {}, a) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (a) {
      for (let l in a)
        if (Object.prototype.hasOwnProperty.call(t, l)) {
          let r = a[l], s = t[l];
          i.push(r.init((o) => r.spec.fromJSON(s, o)));
        }
    }
    return ot.create({
      doc: t.doc,
      selection: we.fromJSON(t.selection),
      extensions: n.extensions ? i.concat([n.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let n = Kc.resolve(t.extensions || [], /* @__PURE__ */ new Map()), a = t.doc instanceof gt ? t.doc : gt.of((t.doc || "").split(n.staticFacet(ot.lineSeparator) || Lh)), i = t.selection ? t.selection instanceof we ? t.selection : we.single(t.selection.anchor, t.selection.head) : we.single(0);
    return M7(i, a.length), n.staticFacet(Ih) || (i = i.asSingle()), new ot(n, a, i, n.dynamicSlots.map(() => null), (l, r) => r.create(l), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ot.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ot.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(R7);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...n) {
    for (let a of this.facet(ot.phrases))
      if (Object.prototype.hasOwnProperty.call(a, t)) {
        t = a[t];
        break;
      }
    return n.length && (t = t.replace(/\$(\$|\d*)/g, (a, i) => {
      if (i == "$")
        return "$";
      let l = +(i || 1);
      return !l || l > n.length ? a : n[l - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, n, a = -1) {
    let i = [];
    for (let l of this.facet(T7))
      for (let r of l(this, n, a))
        Object.prototype.hasOwnProperty.call(r, t) && i.push(r[t]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    return UT(this.languageDataAt("wordChars", t).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: n, from: a, length: i } = this.doc.lineAt(t), l = this.charCategorizer(t), r = t - a, s = t - a;
    for (; r > 0; ) {
      let o = jn(n, r, !1);
      if (l(n.slice(o, r)) != Ft.Word)
        break;
      r = o;
    }
    for (; s < i; ) {
      let o = jn(n, s);
      if (l(n.slice(s, o)) != Ft.Word)
        break;
      s = o;
    }
    return r == s ? null : we.range(r + a, s + a);
  }
}
ot.allowMultipleSelections = Ih;
ot.tabSize = /* @__PURE__ */ He.define({
  combine: (e) => e.length ? e[0] : 4
});
ot.lineSeparator = L7;
ot.readOnly = R7;
ot.phrases = /* @__PURE__ */ He.define({
  compare(e, t) {
    let n = Object.keys(e), a = Object.keys(t);
    return n.length == a.length && n.every((i) => e[i] == t[i]);
  }
});
ot.languageData = T7;
ot.changeFilter = Q7;
ot.transactionFilter = A7;
ot.transactionExtender = D7;
Ss.reconfigure = /* @__PURE__ */ at.define();
function ii(e, t, n = {}) {
  let a = {};
  for (let i of e)
    for (let l of Object.keys(i)) {
      let r = i[l], s = a[l];
      if (s === void 0)
        a[l] = r;
      else if (!(s === r || r === void 0)) if (Object.hasOwnProperty.call(n, l))
        a[l] = n[l](s, r);
      else
        throw new Error("Config merge conflict for field " + l);
    }
  for (let i in t)
    a[i] === void 0 && (a[i] = t[i]);
  return a;
}
class Sr {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, n = t) {
    return Eh.create(t, n, this);
  }
}
Sr.prototype.startSide = Sr.prototype.endSide = 0;
Sr.prototype.point = !1;
Sr.prototype.mapMode = Hn.TrackDel;
let Eh = class Z7 {
  constructor(t, n, a) {
    this.from = t, this.to = n, this.value = a;
  }
  /**
  @internal
  */
  static create(t, n, a) {
    return new Z7(t, n, a);
  }
};
function Nh(e, t) {
  return e.from - t.from || e.value.startSide - t.value.startSide;
}
class sm {
  constructor(t, n, a, i) {
    this.from = t, this.to = n, this.value = a, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, n, a, i = 0) {
    let l = a ? this.to : this.from;
    for (let r = i, s = l.length; ; ) {
      if (r == s)
        return r;
      let o = r + s >> 1, u = l[o] - t || (a ? this.value[o].endSide : this.value[o].startSide) - n;
      if (o == r)
        return u >= 0 ? r : s;
      u >= 0 ? s = o : r = o + 1;
    }
  }
  between(t, n, a, i) {
    for (let l = this.findIndex(n, -1e9, !0), r = this.findIndex(a, 1e9, !1, l); l < r; l++)
      if (i(this.from[l] + t, this.to[l] + t, this.value[l]) === !1)
        return !1;
  }
  map(t, n) {
    let a = [], i = [], l = [], r = -1, s = -1;
    for (let o = 0; o < this.value.length; o++) {
      let u = this.value[o], c = this.from[o] + t, d = this.to[o] + t, f, h;
      if (c == d) {
        let m = n.mapPos(c, u.startSide, u.mapMode);
        if (m == null || (f = h = m, u.startSide != u.endSide && (h = n.mapPos(c, u.endSide), h < f)))
          continue;
      } else if (f = n.mapPos(c, u.startSide), h = n.mapPos(d, u.endSide), f > h || f == h && u.startSide > 0 && u.endSide <= 0)
        continue;
      (h - f || u.endSide - u.startSide) < 0 || (r < 0 && (r = f), u.point && (s = Math.max(s, h - f)), a.push(u), i.push(f - r), l.push(h - r));
    }
    return { mapped: a.length ? new sm(i, l, a, s) : null, pos: r };
  }
}
class mt {
  constructor(t, n, a, i) {
    this.chunkPos = t, this.chunk = n, this.nextLayer = a, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(t, n, a, i) {
    return new mt(t, n, a, i);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let n of this.chunk)
      t += n.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: n = [], sort: a = !1, filterFrom: i = 0, filterTo: l = this.length } = t, r = t.filter;
    if (n.length == 0 && !r)
      return this;
    if (a && (n = n.slice().sort(Nh)), this.isEmpty)
      return n.length ? mt.of(n) : this;
    let s = new E7(this, null, -1).goto(0), o = 0, u = [], c = new Gi();
    for (; s.value || o < n.length; )
      if (o < n.length && (s.from - n[o].from || s.startSide - n[o].value.startSide) >= 0) {
        let d = n[o++];
        c.addInner(d.from, d.to, d.value) || u.push(d);
      } else s.rangeIndex == 1 && s.chunkIndex < this.chunk.length && (o == n.length || this.chunkEnd(s.chunkIndex) < n[o].from) && (!r || i > this.chunkEnd(s.chunkIndex) || l < this.chunkPos[s.chunkIndex]) && c.addChunk(this.chunkPos[s.chunkIndex], this.chunk[s.chunkIndex]) ? s.nextChunk() : ((!r || i > s.to || l < s.from || r(s.from, s.to, s.value)) && (c.addInner(s.from, s.to, s.value) || u.push(Eh.create(s.from, s.to, s.value))), s.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? mt.empty : this.nextLayer.update({ add: u, filter: r, filterFrom: i, filterTo: l }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let n = [], a = [], i = -1;
    for (let r = 0; r < this.chunk.length; r++) {
      let s = this.chunkPos[r], o = this.chunk[r], u = t.touchesRange(s, s + o.length);
      if (u === !1)
        i = Math.max(i, o.maxPoint), n.push(o), a.push(t.mapPos(s));
      else if (u === !0) {
        let { mapped: c, pos: d } = o.map(s, t);
        c && (i = Math.max(i, c.maxPoint), n.push(c), a.push(d));
      }
    }
    let l = this.nextLayer.map(t);
    return n.length == 0 ? l : new mt(a, n, l || mt.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, n, a) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let l = this.chunkPos[i], r = this.chunk[i];
        if (n >= l && t <= l + r.length && r.between(l, t - l, n - l, a) === !1)
          return;
      }
      this.nextLayer.between(t, n, a);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return Wo.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, n = 0) {
    return Wo.from(t).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, n, a, i, l = -1) {
    let r = t.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= l), s = n.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= l), o = Bg(r, s, a), u = new so(r, o, l), c = new so(s, o, l);
    a.iterGaps((d, f, h) => Zg(u, d, c, f, h, i)), a.empty && a.length == 0 && Zg(u, 0, c, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, n, a = 0, i) {
    i == null && (i = 999999999);
    let l = t.filter((c) => !c.isEmpty && n.indexOf(c) < 0), r = n.filter((c) => !c.isEmpty && t.indexOf(c) < 0);
    if (l.length != r.length)
      return !1;
    if (!l.length)
      return !0;
    let s = Bg(l, r), o = new so(l, s, 0).goto(a), u = new so(r, s, 0).goto(a);
    for (; ; ) {
      if (o.to != u.to || !Hh(o.active, u.active) || o.point && (!u.point || !o.point.eq(u.point)))
        return !1;
      if (o.to > i)
        return !0;
      o.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, n, a, i, l = -1) {
    let r = new so(t, null, l).goto(n), s = n, o = r.openStart;
    for (; ; ) {
      let u = Math.min(r.to, a);
      if (r.point) {
        let c = r.activeForPoint(r.to), d = r.pointFrom < n ? c.length + 1 : r.point.startSide < 0 ? c.length : Math.min(c.length, o);
        i.point(s, u, r.point, c, d, r.pointRank), o = Math.min(r.openEnd(u), c.length);
      } else u > s && (i.span(s, u, r.active, o), o = r.openEnd(u));
      if (r.to > a)
        return o + (r.point && r.to > a ? 1 : 0);
      s = r.to, r.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, n = !1) {
    let a = new Gi();
    for (let i of t instanceof Eh ? [t] : n ? GT(t) : t)
      a.add(i.from, i.to, i.value);
    return a.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return mt.empty;
    let n = t[t.length - 1];
    for (let a = t.length - 2; a >= 0; a--)
      for (let i = t[a]; i != mt.empty; i = i.nextLayer)
        n = new mt(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
    return n;
  }
}
mt.empty = /* @__PURE__ */ new mt([], [], null, -1);
function GT(e) {
  if (e.length > 1)
    for (let t = e[0], n = 1; n < e.length; n++) {
      let a = e[n];
      if (Nh(t, a) > 0)
        return e.slice().sort(Nh);
      t = a;
    }
  return e;
}
mt.empty.nextLayer = mt.empty;
class Gi {
  finishChunk(t) {
    this.chunks.push(new sm(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, n, a) {
    this.addInner(t, n, a) || (this.nextLayer || (this.nextLayer = new Gi())).add(t, n, a);
  }
  /**
  @internal
  */
  addInner(t, n, a) {
    let i = t - this.lastTo || a.startSide - this.last.endSide;
    if (i <= 0 && (t - this.lastFrom || a.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(n - this.chunkStart), this.last = a, this.lastFrom = t, this.lastTo = n, this.value.push(a), a.point && (this.maxPoint = Math.max(this.maxPoint, n - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, n) {
    if ((t - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(t);
    let a = n.value.length - 1;
    return this.last = n.value[a], this.lastFrom = n.from[a] + t, this.lastTo = n.to[a] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(mt.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let n = mt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, n;
  }
}
function Bg(e, t, n) {
  let a = /* @__PURE__ */ new Map();
  for (let l of e)
    for (let r = 0; r < l.chunk.length; r++)
      l.chunk[r].maxPoint <= 0 && a.set(l.chunk[r], l.chunkPos[r]);
  let i = /* @__PURE__ */ new Set();
  for (let l of t)
    for (let r = 0; r < l.chunk.length; r++) {
      let s = a.get(l.chunk[r]);
      s != null && (n ? n.mapPos(s) : s) == l.chunkPos[r] && !(n != null && n.touchesRange(s, s + l.chunk[r].length)) && i.add(l.chunk[r]);
    }
  return i;
}
class E7 {
  constructor(t, n, a, i = 0) {
    this.layer = t, this.skip = n, this.minPoint = a, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, n, !1), this;
  }
  gotoInner(t, n, a) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < t || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, a = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!a || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(t, n) {
    (this.to - t || this.endSide - n) < 0 && this.gotoInner(t, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], a = t + n.from[this.rangeIndex];
        if (this.from = a, this.to = t + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}
class Wo {
  constructor(t) {
    this.heap = t;
  }
  static from(t, n = null, a = -1) {
    let i = [];
    for (let l = 0; l < t.length; l++)
      for (let r = t[l]; !r.isEmpty; r = r.nextLayer)
        r.maxPoint >= a && i.push(new E7(r, n, a, l));
    return i.length == 1 ? i[0] : new Wo(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, n = -1e9) {
    for (let a of this.heap)
      a.goto(t, n);
    for (let a = this.heap.length >> 1; a >= 0; a--)
      nf(this.heap, a);
    return this.next(), this;
  }
  forward(t, n) {
    for (let a of this.heap)
      a.forward(t, n);
    for (let a = this.heap.length >> 1; a >= 0; a--)
      nf(this.heap, a);
    (this.to - t || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), nf(this.heap, 0);
    }
  }
}
function nf(e, t) {
  for (let n = e[t]; ; ) {
    let a = (t << 1) + 1;
    if (a >= e.length)
      break;
    let i = e[a];
    if (a + 1 < e.length && i.compare(e[a + 1]) >= 0 && (i = e[a + 1], a++), n.compare(i) < 0)
      break;
    e[a] = n, e[t] = i, t = a;
  }
}
class so {
  constructor(t, n, a) {
    this.minPoint = a, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Wo.from(t, n, a);
  }
  goto(t, n = -1e9) {
    return this.cursor.goto(t, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(t, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, n);
  }
  removeActive(t) {
    Uu(this.active, t), Uu(this.activeTo, t), Uu(this.activeRank, t), this.minActive = Eg(this.active, this.activeTo);
  }
  addActive(t) {
    let n = 0, { value: a, to: i, rank: l } = this.cursor;
    for (; n < this.activeRank.length && (l - this.activeRank[n] || i - this.activeTo[n]) > 0; )
      n++;
    Gu(this.active, n, a), Gu(this.activeTo, n, i), Gu(this.activeRank, n, l), t && Gu(t, n, this.cursor.from), this.minActive = Eg(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, n = this.point;
    this.point = null;
    let a = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > t) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), a && Uu(a, i);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let l = this.cursor.value;
          if (!l.point)
            this.addActive(a), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = l, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = l.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (a) {
      this.openStart = 0;
      for (let i = a.length - 1; i >= 0 && a[i] < t; i--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let a = this.active.length - 1; a >= 0 && !(this.activeRank[a] < this.pointRank); a--)
      (this.activeTo[a] > t || this.activeTo[a] == t && this.active[a].endSide >= this.point.endSide) && n.push(this.active[a]);
    return n.reverse();
  }
  openEnd(t) {
    let n = 0;
    for (let a = this.activeTo.length - 1; a >= 0 && this.activeTo[a] > t; a--)
      n++;
    return n;
  }
}
function Zg(e, t, n, a, i, l) {
  e.goto(t), n.goto(a);
  let r = a + i, s = a, o = a - t;
  for (; ; ) {
    let u = e.to + o - n.to, c = u || e.endSide - n.endSide, d = c < 0 ? e.to + o : n.to, f = Math.min(d, r);
    if (e.point || n.point ? e.point && n.point && (e.point == n.point || e.point.eq(n.point)) && Hh(e.activeForPoint(e.to), n.activeForPoint(n.to)) || l.comparePoint(s, f, e.point, n.point) : f > s && !Hh(e.active, n.active) && l.compareRange(s, f, e.active, n.active), d > r)
      break;
    (u || e.openEnd != n.openEnd) && l.boundChange && l.boundChange(d), s = d, c <= 0 && e.next(), c >= 0 && n.next();
  }
}
function Hh(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n] && !e[n].eq(t[n]))
      return !1;
  return !0;
}
function Uu(e, t) {
  for (let n = t, a = e.length - 1; n < a; n++)
    e[n] = e[n + 1];
  e.pop();
}
function Gu(e, t, n) {
  for (let a = e.length - 1; a >= t; a--)
    e[a + 1] = e[a];
  e[t] = n;
}
function Eg(e, t) {
  let n = -1, a = 1e9;
  for (let i = 0; i < t.length; i++)
    (t[i] - a || e[i].endSide - e[n].endSide) < 0 && (n = i, a = t[i]);
  return n;
}
function Js(e, t, n = e.length) {
  let a = 0;
  for (let i = 0; i < n && i < e.length; )
    e.charCodeAt(i) == 9 ? (a += t - a % t, i++) : (a++, i = jn(e, i));
  return a;
}
function jh(e, t, n, a) {
  for (let i = 0, l = 0; ; ) {
    if (l >= t)
      return i;
    if (i == e.length)
      break;
    l += e.charCodeAt(i) == 9 ? n - l % n : 1, i = jn(e, i);
  }
  return a === !0 ? -1 : e.length;
}
const zh = "ͼ", Ng = typeof Symbol > "u" ? "__" + zh : Symbol.for(zh), Fh = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Hg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class _l {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, n) {
    this.rules = [];
    let { finish: a } = n || {};
    function i(r) {
      return /^@/.test(r) ? [r] : r.split(/,\s*/);
    }
    function l(r, s, o, u) {
      let c = [], d = /^@(\w+)\b/.exec(r[0]), f = d && d[1] == "keyframes";
      if (d && s == null) return o.push(r[0] + ";");
      for (let h in s) {
        let m = s[h];
        if (/&/.test(h))
          l(
            h.split(/,\s*/).map((g) => r.map((v) => g.replace(/&/, v))).reduce((g, v) => g.concat(v)),
            m,
            o
          );
        else if (m && typeof m == "object") {
          if (!d) throw new RangeError("The value of a property (" + h + ") should be a primitive value.");
          l(i(h), m, c, f);
        } else m != null && c.push(h.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + m + ";");
      }
      (c.length || f) && o.push((a && !d && !u ? r.map(a) : r).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let r in t) l(i(r), t[r], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let t = Hg[Ng] || 1;
    return Hg[Ng] = t + 1, zh + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, n, a) {
    let i = t[Fh], l = a && a.nonce;
    i ? l && i.setNonce(l) : i = new KT(t, l), i.mount(Array.isArray(n) ? n : [n], t);
  }
}
let jg = /* @__PURE__ */ new Map();
class KT {
  constructor(t, n) {
    let a = t.ownerDocument || t, i = a.defaultView;
    if (!t.head && t.adoptedStyleSheets && i.CSSStyleSheet) {
      let l = jg.get(a);
      if (l) return t[Fh] = l;
      this.sheet = new i.CSSStyleSheet(), jg.set(a, this);
    } else
      this.styleTag = a.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], t[Fh] = this;
  }
  mount(t, n) {
    let a = this.sheet, i = 0, l = 0;
    for (let r = 0; r < t.length; r++) {
      let s = t[r], o = this.modules.indexOf(s);
      if (o < l && o > -1 && (this.modules.splice(o, 1), l--, o = -1), o == -1) {
        if (this.modules.splice(l++, 0, s), a) for (let u = 0; u < s.rules.length; u++)
          a.insertRule(s.rules[u], i++);
      } else {
        for (; l < o; ) i += this.modules[l++].rules.length;
        i += s.rules.length, l++;
      }
    }
    if (a)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let r = "";
      for (let o = 0; o < this.modules.length; o++)
        r += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = r;
      let s = n.head || n;
      this.styleTag.parentNode != s && s.insertBefore(this.styleTag, s.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}
var Ml = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, qo = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, JT = typeof navigator < "u" && /Mac/.test(navigator.platform), eL = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Nn = 0; Nn < 10; Nn++) Ml[48 + Nn] = Ml[96 + Nn] = String(Nn);
for (var Nn = 1; Nn <= 24; Nn++) Ml[Nn + 111] = "F" + Nn;
for (var Nn = 65; Nn <= 90; Nn++)
  Ml[Nn] = String.fromCharCode(Nn + 32), qo[Nn] = String.fromCharCode(Nn);
for (var af in Ml) qo.hasOwnProperty(af) || (qo[af] = Ml[af]);
function tL(e) {
  var t = JT && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || eL && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified", n = !t && e.key || (e.shiftKey ? qo : Ml)[e.keyCode] || e.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function Uo(e) {
  let t;
  return e.nodeType == 11 ? t = e.getSelection ? e : e.ownerDocument : t = e, t.getSelection();
}
function Xh(e, t) {
  return t ? e == t || e.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
function $c(e, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return Xh(e, t.anchorNode);
  } catch {
    return !1;
  }
}
function xs(e) {
  return e.nodeType == 3 ? Pr(e, 0, e.nodeValue.length).getClientRects() : e.nodeType == 1 ? e.getClientRects() : [];
}
function xo(e, t, n, a) {
  return n ? zg(e, t, n, a, -1) || zg(e, t, n, a, 1) : !1;
}
function xr(e) {
  for (var t = 0; ; t++)
    if (e = e.previousSibling, !e)
      return t;
}
function ed(e) {
  return e.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName);
}
function zg(e, t, n, a, i) {
  for (; ; ) {
    if (e == n && t == a)
      return !0;
    if (t == (i < 0 ? 0 : Vi(e))) {
      if (e.nodeName == "DIV")
        return !1;
      let l = e.parentNode;
      if (!l || l.nodeType != 1)
        return !1;
      t = xr(e) + (i < 0 ? 0 : 1), e = l;
    } else if (e.nodeType == 1) {
      if (e = e.childNodes[t + (i < 0 ? -1 : 0)], e.nodeType == 1 && e.contentEditable == "false")
        return !1;
      t = i < 0 ? Vi(e) : 0;
    } else
      return !1;
  }
}
function Vi(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function _u(e, t) {
  let n = t ? e.left : e.right;
  return { left: n, right: n, top: e.top, bottom: e.bottom };
}
function nL(e) {
  let t = e.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: e.innerWidth,
    top: 0,
    bottom: e.innerHeight
  };
}
function N7(e, t) {
  let n = t.width / e.offsetWidth, a = t.height / e.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(t.width - e.offsetWidth) < 1) && (n = 1), (a > 0.995 && a < 1.005 || !isFinite(a) || Math.abs(t.height - e.offsetHeight) < 1) && (a = 1), { scaleX: n, scaleY: a };
}
function aL(e, t, n, a, i, l, r, s) {
  let o = e.ownerDocument, u = o.defaultView || window;
  for (let c = e, d = !1; c && !d; )
    if (c.nodeType == 1) {
      let f, h = c == o.body, m = 1, g = 1;
      if (h)
        f = nL(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (d = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let b = c.getBoundingClientRect();
        ({ scaleX: m, scaleY: g } = N7(c, b)), f = {
          left: b.left,
          right: b.left + c.clientWidth * m,
          top: b.top,
          bottom: b.top + c.clientHeight * g
        };
      }
      let v = 0, y = 0;
      if (i == "nearest")
        t.top < f.top ? (y = -(f.top - t.top + r), n > 0 && t.bottom > f.bottom + y && (y = t.bottom - f.bottom + y + r)) : t.bottom > f.bottom && (y = t.bottom - f.bottom + r, n < 0 && t.top - y < f.top && (y = -(f.top + y - t.top + r)));
      else {
        let b = t.bottom - t.top, C = f.bottom - f.top;
        y = (i == "center" && b <= C ? t.top + b / 2 - C / 2 : i == "start" || i == "center" && n < 0 ? t.top - r : t.bottom - C + r) - f.top;
      }
      if (a == "nearest" ? t.left < f.left ? (v = -(f.left - t.left + l), n > 0 && t.right > f.right + v && (v = t.right - f.right + v + l)) : t.right > f.right && (v = t.right - f.right + l, n < 0 && t.left < f.left + v && (v = -(f.left + v - t.left + l))) : v = (a == "center" ? t.left + (t.right - t.left) / 2 - (f.right - f.left) / 2 : a == "start" == s ? t.left - l : t.right - (f.right - f.left) + l) - f.left, v || y)
        if (h)
          u.scrollBy(v, y);
        else {
          let b = 0, C = 0;
          if (y) {
            let S = c.scrollTop;
            c.scrollTop += y / g, C = (c.scrollTop - S) * g;
          }
          if (v) {
            let S = c.scrollLeft;
            c.scrollLeft += v / m, b = (c.scrollLeft - S) * m;
          }
          t = {
            left: t.left - b,
            top: t.top - C,
            right: t.right - b,
            bottom: t.bottom - C
          }, b && Math.abs(b - v) < 1 && (a = "nearest"), C && Math.abs(C - y) < 1 && (i = "nearest");
        }
      if (h)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function iL(e) {
  let t = e.ownerDocument, n, a;
  for (let i = e.parentNode; i && !(i == t.body || n && a); )
    if (i.nodeType == 1)
      !a && i.scrollHeight > i.clientHeight && (a = i), !n && i.scrollWidth > i.clientWidth && (n = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: n, y: a };
}
class lL {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: n, focusNode: a } = t;
    this.set(n, Math.min(t.anchorOffset, n ? Vi(n) : 0), a, Math.min(t.focusOffset, a ? Vi(a) : 0));
  }
  set(t, n, a, i) {
    this.anchorNode = t, this.anchorOffset = n, this.focusNode = a, this.focusOffset = i;
  }
}
let Ur = null;
function H7(e) {
  if (e.setActive)
    return e.setActive();
  if (Ur)
    return e.focus(Ur);
  let t = [];
  for (let n = e; n && (t.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (e.focus(Ur == null ? {
    get preventScroll() {
      return Ur = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ur) {
    Ur = !1;
    for (let n = 0; n < t.length; ) {
      let a = t[n++], i = t[n++], l = t[n++];
      a.scrollTop != i && (a.scrollTop = i), a.scrollLeft != l && (a.scrollLeft = l);
    }
  }
}
let Fg;
function Pr(e, t, n = t) {
  let a = Fg || (Fg = document.createRange());
  return a.setEnd(e, n), a.setStart(e, t), a;
}
function ds(e, t, n, a) {
  let i = { key: t, code: t, keyCode: n, which: n, cancelable: !0 };
  a && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = a);
  let l = new KeyboardEvent("keydown", i);
  l.synthetic = !0, e.dispatchEvent(l);
  let r = new KeyboardEvent("keyup", i);
  return r.synthetic = !0, e.dispatchEvent(r), l.defaultPrevented || r.defaultPrevented;
}
function rL(e) {
  for (; e; ) {
    if (e && (e.nodeType == 9 || e.nodeType == 11 && e.host))
      return e;
    e = e.assignedSlot || e.parentNode;
  }
  return null;
}
function j7(e) {
  for (; e.attributes.length; )
    e.removeAttributeNode(e.attributes[0]);
}
function sL(e, t) {
  let n = t.focusNode, a = t.focusOffset;
  if (!n || t.anchorNode != n || t.anchorOffset != a)
    return !1;
  for (a = Math.min(a, Vi(n)); ; )
    if (a) {
      if (n.nodeType != 1)
        return !1;
      let i = n.childNodes[a - 1];
      i.contentEditable == "false" ? a-- : (n = i, a = Vi(n));
    } else {
      if (n == e)
        return !0;
      a = xr(n), n = n.parentNode;
    }
}
function z7(e) {
  return e.scrollTop > Math.max(1, e.scrollHeight - e.clientHeight - 4);
}
function F7(e, t) {
  for (let n = e, a = t; ; ) {
    if (n.nodeType == 3 && a > 0)
      return { node: n, offset: a };
    if (n.nodeType == 1 && a > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[a - 1], a = Vi(n);
    } else if (n.parentNode && !ed(n))
      a = xr(n), n = n.parentNode;
    else
      return null;
  }
}
function X7(e, t) {
  for (let n = e, a = t; ; ) {
    if (n.nodeType == 3 && a < n.nodeValue.length)
      return { node: n, offset: a };
    if (n.nodeType == 1 && a < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[a], a = 0;
    } else if (n.parentNode && !ed(n))
      a = xr(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class Un {
  constructor(t, n, a = !0) {
    this.node = t, this.offset = n, this.precise = a;
  }
  static before(t, n) {
    return new Un(t.parentNode, xr(t), n);
  }
  static after(t, n) {
    return new Un(t.parentNode, xr(t) + 1, n);
  }
}
const om = [];
class Vt {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let n = this.posAtStart;
    for (let a of this.children) {
      if (a == t)
        return n;
      n += a.length + a.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, n) {
    if (this.flags & 2) {
      let a = this.dom, i = null, l;
      for (let r of this.children) {
        if (r.flags & 7) {
          if (!r.dom && (l = i ? i.nextSibling : a.firstChild)) {
            let s = Vt.get(l);
            (!s || !s.parent && s.canReuseDOM(r)) && r.reuseDOM(l);
          }
          r.sync(t, n), r.flags &= -8;
        }
        if (l = i ? i.nextSibling : a.firstChild, n && !n.written && n.node == a && l != r.dom && (n.written = !0), r.dom.parentNode == a)
          for (; l && l != r.dom; )
            l = Xg(l);
        else
          a.insertBefore(r.dom, l);
        i = r.dom;
      }
      for (l = i ? i.nextSibling : a.firstChild, l && n && n.node == a && (n.written = !0); l; )
        l = Xg(l);
    } else if (this.flags & 1)
      for (let a of this.children)
        a.flags & 7 && (a.sync(t, n), a.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, n) {
    let a;
    if (t == this.dom)
      a = this.dom.childNodes[n];
    else {
      let i = Vi(t) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let l = t.parentNode;
        if (l == this.dom)
          break;
        i == 0 && l.firstChild != l.lastChild && (t == l.firstChild ? i = -1 : i = 1), t = l;
      }
      i < 0 ? a = t : a = t.nextSibling;
    }
    if (a == this.dom.firstChild)
      return 0;
    for (; a && !Vt.get(a); )
      a = a.nextSibling;
    if (!a)
      return this.length;
    for (let i = 0, l = 0; ; i++) {
      let r = this.children[i];
      if (r.dom == a)
        return l;
      l += r.length + r.breakAfter;
    }
  }
  domBoundsAround(t, n, a = 0) {
    let i = -1, l = -1, r = -1, s = -1;
    for (let o = 0, u = a, c = a; o < this.children.length; o++) {
      let d = this.children[o], f = u + d.length;
      if (u < t && f > n)
        return d.domBoundsAround(t, n, u);
      if (f >= t && i == -1 && (i = o, l = u), u > n && d.dom.parentNode == this.dom) {
        r = o, s = c;
        break;
      }
      c = f, u = f + d.breakAfter;
    }
    return {
      from: l,
      to: s < 0 ? a + this.length : s,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: r < this.children.length && r >= 0 ? this.children[r].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let n = this.parent; n; n = n.parent) {
      if (t && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let n = t.parent;
      if (!n)
        return t;
      t = n;
    }
  }
  replaceChildren(t, n, a = om) {
    this.markDirty();
    for (let i = t; i < n; i++) {
      let l = this.children[i];
      l.parent == this && a.indexOf(l) < 0 && l.destroy();
    }
    a.length < 250 ? this.children.splice(t, n - t, ...a) : this.children = [].concat(this.children.slice(0, t), a, this.children.slice(n));
    for (let i = 0; i < a.length; i++)
      a[i].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new Y7(this.children, t, this.children.length);
  }
  childPos(t, n = 1) {
    return this.childCursor().findPos(t, n);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, n, a, i, l, r) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}
Vt.prototype.breakAfter = 0;
function Xg(e) {
  let t = e.nextSibling;
  return e.parentNode.removeChild(e), t;
}
class Y7 {
  constructor(t, n, a) {
    this.children = t, this.pos = n, this.i = a, this.off = 0;
  }
  findPos(t, n = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let a = this.children[--this.i];
      this.pos -= a.length + a.breakAfter;
    }
  }
}
function W7(e, t, n, a, i, l, r, s, o) {
  let { children: u } = e, c = u.length ? u[t] : null, d = l.length ? l[l.length - 1] : null, f = d ? d.breakAfter : r;
  if (!(t == a && c && !r && !f && l.length < 2 && c.merge(n, i, l.length ? d : null, n == 0, s, o))) {
    if (a < u.length) {
      let h = u[a];
      h && (i < h.length || h.breakAfter && (d != null && d.breakAfter)) ? (t == a && (h = h.split(i), i = 0), !f && d && h.merge(0, i, d, !0, 0, o) ? l[l.length - 1] = h : ((i || h.children.length && !h.children[0].length) && h.merge(0, i, null, !1, 0, o), l.push(h))) : h != null && h.breakAfter && (d ? d.breakAfter = 1 : r = 1), a++;
    }
    for (c && (c.breakAfter = r, n > 0 && (!r && l.length && c.merge(n, c.length, l[0], !1, s, 0) ? c.breakAfter = l.shift().breakAfter : (n < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(n, c.length, null, !1, s, 0), t++)); t < a && l.length; )
      if (u[a - 1].become(l[l.length - 1]))
        a--, l.pop(), o = l.length ? 0 : s;
      else if (u[t].become(l[0]))
        t++, l.shift(), s = l.length ? 0 : o;
      else
        break;
    !l.length && t && a < u.length && !u[t - 1].breakAfter && u[a].merge(0, 0, u[t - 1], !1, s, o) && t--, (t < a || l.length) && e.replaceChildren(t, a, l);
  }
}
function q7(e, t, n, a, i, l) {
  let r = e.childCursor(), { i: s, off: o } = r.findPos(n, 1), { i: u, off: c } = r.findPos(t, -1), d = t - n;
  for (let f of a)
    d += f.length;
  e.length += d, W7(e, u, c, s, o, a, 0, i, l);
}
let da = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Yh = typeof document < "u" ? document : { documentElement: { style: {} } };
const Wh = /* @__PURE__ */ /Edge\/(\d+)/.exec(da.userAgent), U7 = /* @__PURE__ */ /MSIE \d/.test(da.userAgent), qh = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(da.userAgent), v1 = !!(U7 || qh || Wh), Yg = !v1 && /* @__PURE__ */ /gecko\/(\d+)/i.test(da.userAgent), lf = !v1 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(da.userAgent), Wg = "webkitFontSmoothing" in Yh.documentElement.style, G7 = !v1 && /* @__PURE__ */ /Apple Computer/.test(da.vendor), qg = G7 && (/* @__PURE__ */ /Mobile\/\w+/.test(da.userAgent) || da.maxTouchPoints > 2);
var Ne = {
  mac: qg || /* @__PURE__ */ /Mac/.test(da.platform),
  windows: /* @__PURE__ */ /Win/.test(da.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(da.platform),
  ie: v1,
  ie_version: U7 ? Yh.documentMode || 6 : qh ? +qh[1] : Wh ? +Wh[1] : 0,
  gecko: Yg,
  gecko_version: Yg ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(da.userAgent) || [0, 0])[1] : 0,
  chrome: !!lf,
  chrome_version: lf ? +lf[1] : 0,
  ios: qg,
  android: /* @__PURE__ */ /Android\b/.test(da.userAgent),
  webkit: Wg,
  safari: G7,
  webkit_version: Wg ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(da.userAgent) || [0, 0])[1] : 0,
  tabSize: Yh.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const oL = 256;
class Ja extends Vt {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, n, a) {
    return this.flags & 8 || a && (!(a instanceof Ja) || this.length - (n - t) + a.length > oL || a.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (a ? a.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(t) {
    let n = new Ja(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(t, n) {
    return t == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(t) {
    return new Un(this.dom, t);
  }
  domBoundsAround(t, n, a) {
    return { from: a, to: a + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, n) {
    return uL(this.dom, t, n);
  }
}
class Ki extends Vt {
  constructor(t, n = [], a = 0) {
    super(), this.mark = t, this.children = n, this.length = a;
    for (let i of n)
      i.setParent(this);
  }
  setAttrs(t) {
    if (j7(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        t.setAttribute(n, this.mark.attrs[n]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, n);
  }
  merge(t, n, a, i, l, r) {
    return a && (!(a instanceof Ki && a.mark.eq(this.mark)) || t && l <= 0 || n < this.length && r <= 0) ? !1 : (q7(this, t, n, a ? a.children.slice() : [], l - 1, r - 1), this.markDirty(), !0);
  }
  split(t) {
    let n = [], a = 0, i = -1, l = 0;
    for (let s of this.children) {
      let o = a + s.length;
      o > t && n.push(a < t ? s.split(t - a) : s), i < 0 && a >= t && (i = l), a = o, l++;
    }
    let r = this.length - t;
    return this.length = t, i > -1 && (this.children.length = i, this.markDirty()), new Ki(this.mark, n, r);
  }
  domAtPos(t) {
    return K7(this, t);
  }
  coordsAt(t, n) {
    return e6(this, t, n);
  }
}
function uL(e, t, n) {
  let a = e.nodeValue.length;
  t > a && (t = a);
  let i = t, l = t, r = 0;
  t == 0 && n < 0 || t == a && n >= 0 ? Ne.chrome || Ne.gecko || (t ? (i--, r = 1) : l < a && (l++, r = -1)) : n < 0 ? i-- : l < a && l++;
  let s = Pr(e, i, l).getClientRects();
  if (!s.length)
    return null;
  let o = s[(r ? r < 0 : n >= 0) ? 0 : s.length - 1];
  return Ne.safari && !r && o.width == 0 && (o = Array.prototype.find.call(s, (u) => u.width) || o), r ? _u(o, r < 0) : o || null;
}
class bl extends Vt {
  static create(t, n, a) {
    return new bl(t, n, a);
  }
  constructor(t, n, a) {
    super(), this.widget = t, this.length = n, this.side = a, this.prevWidget = null;
  }
  split(t) {
    let n = bl.create(this.widget, this.length - t, this.side);
    return this.length -= t, n;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t, n, a, i, l, r) {
    return a && (!(a instanceof bl) || !this.widget.compare(a.widget) || t > 0 && l <= 0 || n < this.length && r <= 0) ? !1 : (this.length = t + (a ? a.length : 0) + (this.length - n), !0);
  }
  become(t) {
    return t instanceof bl && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return gt.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: n } = t, a = n && n.state.doc, i = this.posAtStart;
    return a ? a.slice(i, i + this.length) : gt.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? Un.before(this.dom) : Un.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, n) {
    let a = this.widget.coordsAt(this.dom, t, n);
    if (a)
      return a;
    let i = this.dom.getClientRects(), l = null;
    if (!i.length)
      return null;
    let r = this.side ? this.side < 0 : t > 0;
    for (let s = r ? i.length - 1 : 0; l = i[s], !(t > 0 ? s == 0 : s == i.length - 1 || l.top < l.bottom); s += r ? -1 : 1)
      ;
    return _u(l, !r);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Ps extends Vt {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof Ps && t.side == this.side;
  }
  split() {
    return new Ps(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? Un.before(this.dom) : Un.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return gt.empty;
  }
  get isHidden() {
    return !0;
  }
}
Ja.prototype.children = bl.prototype.children = Ps.prototype.children = om;
function K7(e, t) {
  let n = e.dom, { children: a } = e, i = 0;
  for (let l = 0; i < a.length; i++) {
    let r = a[i], s = l + r.length;
    if (!(s == l && r.getSide() <= 0)) {
      if (t > l && t < s && r.dom.parentNode == n)
        return r.domAtPos(t - l);
      if (t <= l)
        break;
      l = s;
    }
  }
  for (let l = i; l > 0; l--) {
    let r = a[l - 1];
    if (r.dom.parentNode == n)
      return r.domAtPos(r.length);
  }
  for (let l = i; l < a.length; l++) {
    let r = a[l];
    if (r.dom.parentNode == n)
      return r.domAtPos(0);
  }
  return new Un(n, 0);
}
function J7(e, t, n) {
  let a, { children: i } = e;
  n > 0 && t instanceof Ki && i.length && (a = i[i.length - 1]) instanceof Ki && a.mark.eq(t.mark) ? J7(a, t.children[0], n - 1) : (i.push(t), t.setParent(e)), e.length += t.length;
}
function e6(e, t, n) {
  let a = null, i = -1, l = null, r = -1;
  function s(u, c) {
    for (let d = 0, f = 0; d < u.children.length && f <= c; d++) {
      let h = u.children[d], m = f + h.length;
      m >= c && (h.children.length ? s(h, c - f) : (!l || l.isHidden && n > 0) && (m > c || f == m && h.getSide() > 0) ? (l = h, r = c - f) : (f < c || f == m && h.getSide() < 0 && !h.isHidden) && (a = h, i = c - f)), f = m;
    }
  }
  s(e, t);
  let o = (n < 0 ? a : l) || a || l;
  return o ? o.coordsAt(Math.max(0, o == a ? i : r), n) : cL(e);
}
function cL(e) {
  let t = e.dom.lastChild;
  if (!t)
    return e.dom.getBoundingClientRect();
  let n = xs(t);
  return n[n.length - 1] || null;
}
function Uh(e, t) {
  for (let n in e)
    n == "class" && t.class ? t.class += " " + e.class : n == "style" && t.style ? t.style += ";" + e.style : t[n] = e[n];
  return t;
}
const Ug = /* @__PURE__ */ Object.create(null);
function td(e, t, n) {
  if (e == t)
    return !0;
  e || (e = Ug), t || (t = Ug);
  let a = Object.keys(e), i = Object.keys(t);
  if (a.length - (n && a.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let l of a)
    if (l != n && (i.indexOf(l) == -1 || e[l] !== t[l]))
      return !1;
  return !0;
}
function Gh(e, t, n) {
  let a = !1;
  if (t)
    for (let i in t)
      n && i in n || (a = !0, i == "style" ? e.style.cssText = "" : e.removeAttribute(i));
  if (n)
    for (let i in n)
      t && t[i] == n[i] || (a = !0, i == "style" ? e.style.cssText = n[i] : e.setAttribute(i, n[i]));
  return a;
}
function dL(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < e.attributes.length; n++) {
    let a = e.attributes[n];
    t[a.name] = a.value;
  }
  return t;
}
class Ii {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, n, a) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}
var ra = /* @__PURE__ */ function(e) {
  return e[e.Text = 0] = "Text", e[e.WidgetBefore = 1] = "WidgetBefore", e[e.WidgetAfter = 2] = "WidgetAfter", e[e.WidgetRange = 3] = "WidgetRange", e;
}(ra || (ra = {}));
class qe extends Sr {
  constructor(t, n, a, i) {
    super(), this.startSide = t, this.endSide = n, this.widget = a, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new Mu(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let n = Math.max(-1e4, Math.min(1e4, t.side || 0)), a = !!t.block;
    return n += a && !t.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new Vl(t, n, n, a, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let n = !!t.block, a, i;
    if (t.isBlockGap)
      a = -5e8, i = 4e8;
    else {
      let { start: l, end: r } = t6(t, n);
      a = (l ? n ? -3e8 : -1 : 5e8) - 1, i = (r ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new Vl(t, a, i, n, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new Vu(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, n = !1) {
    return mt.of(t, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
qe.none = mt.empty;
class Mu extends qe {
  constructor(t) {
    let { start: n, end: a } = t6(t);
    super(n ? -1 : 5e8, a ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var n, a;
    return this == t || t instanceof Mu && this.tagName == t.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (t.class || ((a = t.attrs) === null || a === void 0 ? void 0 : a.class)) && td(this.attrs, t.attrs, "class");
  }
  range(t, n = t) {
    if (t >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, n);
  }
}
Mu.prototype.point = !1;
class Vu extends qe {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof Vu && this.spec.class == t.spec.class && td(this.spec.attributes, t.spec.attributes);
  }
  range(t, n = t) {
    if (n != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, n);
  }
}
Vu.prototype.mapMode = Hn.TrackBefore;
Vu.prototype.point = !0;
class Vl extends qe {
  constructor(t, n, a, i, l, r) {
    super(n, a, l, t), this.block = i, this.isReplace = r, this.mapMode = i ? n <= 0 ? Hn.TrackBefore : Hn.TrackAfter : Hn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? ra.WidgetRange : this.startSide <= 0 ? ra.WidgetBefore : ra.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof Vl && fL(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, n = t) {
    if (this.isReplace && (t > n || t == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, n);
  }
}
Vl.prototype.point = !0;
function t6(e, t = !1) {
  let { inclusiveStart: n, inclusiveEnd: a } = e;
  return n == null && (n = e.inclusive), a == null && (a = e.inclusive), { start: n ?? t, end: a ?? t };
}
function fL(e, t) {
  return e == t || !!(e && t && e.compare(t));
}
function _c(e, t, n, a = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + a >= e ? n[i] = Math.max(n[i], t) : n.push(e, t);
}
class On extends Vt {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(t, n, a, i, l, r) {
    if (a) {
      if (!(a instanceof On))
        return !1;
      this.dom || a.transferDOM(this);
    }
    return i && this.setDeco(a ? a.attrs : null), q7(this, t, n, a ? a.children.slice() : [], l, r), !0;
  }
  split(t) {
    let n = new On();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: a, off: i } = this.childPos(t);
    i && (n.append(this.children[a].split(i), 0), this.children[a].merge(i, this.children[a].length, null, !1, 0, 0), a++);
    for (let l = a; l < this.children.length; l++)
      n.append(this.children[l], 0);
    for (; a > 0 && this.children[a - 1].length == 0; )
      this.children[--a].destroy();
    return this.children.length = a, this.markDirty(), this.length = t, n;
  }
  transferDOM(t) {
    this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    td(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, n) {
    J7(this, t, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(t) {
    let n = t.spec.attributes, a = t.spec.class;
    n && (this.attrs = Uh(n, this.attrs || {})), a && (this.attrs = Uh({ class: a }, this.attrs || {}));
  }
  domAtPos(t) {
    return K7(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, n) {
    var a;
    this.dom ? this.flags & 4 && (j7(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Gh(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, n);
    let i = this.dom.lastChild;
    for (; i && Vt.get(i) instanceof Ki; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((a = Vt.get(i)) === null || a === void 0 ? void 0 : a.isEditable) == !1 && (!Ne.ios || !this.children.some((l) => l instanceof Ja))) {
      let l = document.createElement("BR");
      l.cmIgnore = !0, this.dom.appendChild(l);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, n;
    for (let a of this.children) {
      if (!(a instanceof Ja) || /[^ -~]/.test(a.text))
        return null;
      let i = xs(a.dom);
      if (i.length != 1)
        return null;
      t += i[0].width, n = i[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(t, n) {
    let a = e6(this, t, n);
    if (!this.children.length && a && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, l = a.bottom - a.top;
      if (Math.abs(l - i.lineHeight) < 2 && i.textHeight < l) {
        let r = (l - i.textHeight) / 2;
        return { top: a.top + r, bottom: a.bottom - r, left: a.left, right: a.left };
      }
    }
    return a;
  }
  become(t) {
    return t instanceof On && this.children.length == 0 && t.children.length == 0 && td(this.attrs, t.attrs) && this.breakAfter == t.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(t, n) {
    for (let a = 0, i = 0; a < t.children.length; a++) {
      let l = t.children[a], r = i + l.length;
      if (r >= n) {
        if (l instanceof On)
          return l;
        if (r > n)
          break;
      }
      i = r + l.breakAfter;
    }
    return null;
  }
}
class Xi extends Vt {
  constructor(t, n, a) {
    super(), this.widget = t, this.length = n, this.deco = a, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, n, a, i, l, r) {
    return a && (!(a instanceof Xi) || !this.widget.compare(a.widget) || t > 0 && l <= 0 || n < this.length && r <= 0) ? !1 : (this.length = t + (a ? a.length : 0) + (this.length - n), !0);
  }
  domAtPos(t) {
    return t == 0 ? Un.before(this.dom) : Un.after(this.dom, t == this.length);
  }
  split(t) {
    let n = this.length - t;
    this.length = t;
    let a = new Xi(this.widget, n, this.deco);
    return a.breakAfter = this.breakAfter, a;
  }
  get children() {
    return om;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : gt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof Xi && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, n) {
    let a = this.widget.coordsAt(this.dom, t, n);
    return a || (this.widget instanceof Kh ? null : _u(this.dom.getBoundingClientRect(), this.length ? t == 0 : n <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: n, endSide: a } = this.deco;
    return n == a ? !1 : t < 0 ? n < 0 : a > 0;
  }
}
class Kh extends Ii {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Po {
  constructor(t, n, a, i) {
    this.doc = t, this.pos = n, this.end = a, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof Xi && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new On()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Ku(new Ps(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof Xi) && this.getLine();
  }
  buildText(t, n, a) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: l, lineBreak: r, done: s } = this.cursor.next(this.skip);
        if (this.skip = 0, s)
          throw new Error("Ran out of text content when drawing inline views");
        if (r) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = l, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        t,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - a)), this.getLine().append(Ku(new Ja(this.text.slice(this.textOff, this.textOff + i)), n), a), this.atCursorPos = !0, this.textOff += i, t -= i, a = 0;
    }
  }
  span(t, n, a, i) {
    this.buildText(n - t, a, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
  }
  point(t, n, a, i, l, r) {
    if (this.disallowBlockEffectsFor[r] && a instanceof Vl) {
      if (a.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let s = n - t;
    if (a instanceof Vl)
      if (a.block)
        a.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Xi(a.widget || $s.block, s, a));
      else {
        let o = bl.create(a.widget || $s.inline, s, s ? 0 : a.startSide), u = this.atCursorPos && !o.isEditable && l <= i.length && (t < n || a.startSide > 0), c = !o.isEditable && (t < n || l > i.length || a.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !u && !o.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), u && (d.append(Ku(new Ps(1), i), l), l = i.length + Math.max(0, l - i.length)), d.append(Ku(o, i), l), this.atCursorPos = c, this.pendingBuffer = c ? t < n || l > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(a);
    s && (this.textOff + s <= this.text.length ? this.textOff += s : (this.skip += s - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = l);
  }
  static build(t, n, a, i, l) {
    let r = new Po(t, n, a, l);
    return r.openEnd = mt.spans(i, n, a, r), r.openStart < 0 && (r.openStart = r.openEnd), r.finish(r.openEnd), r;
  }
}
function Ku(e, t) {
  for (let n of t)
    e = new Ki(n, [e], e.length);
  return e;
}
class $s extends Ii {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
$s.inline = /* @__PURE__ */ new $s("span");
$s.block = /* @__PURE__ */ new $s("div");
var Nt = /* @__PURE__ */ function(e) {
  return e[e.LTR = 0] = "LTR", e[e.RTL = 1] = "RTL", e;
}(Nt || (Nt = {}));
const $r = Nt.LTR, um = Nt.RTL;
function n6(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
    t.push(1 << +e[n]);
  return t;
}
const hL = /* @__PURE__ */ n6("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), mL = /* @__PURE__ */ n6("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Jh = /* @__PURE__ */ Object.create(null), ui = [];
for (let e of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ e.charCodeAt(0), n = /* @__PURE__ */ e.charCodeAt(1);
  Jh[t] = n, Jh[n] = -t;
}
function a6(e) {
  return e <= 247 ? hL[e] : 1424 <= e && e <= 1524 ? 2 : 1536 <= e && e <= 1785 ? mL[e - 1536] : 1774 <= e && e <= 2220 ? 4 : 8192 <= e && e <= 8204 ? 256 : 64336 <= e && e <= 65023 ? 4 : 1;
}
const vL = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Cl {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? um : $r;
  }
  /**
  @internal
  */
  constructor(t, n, a) {
    this.from = t, this.to = n, this.level = a;
  }
  /**
  @internal
  */
  side(t, n) {
    return this.dir == n == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, n) {
    return t == (this.dir == n);
  }
  /**
  @internal
  */
  static find(t, n, a, i) {
    let l = -1;
    for (let r = 0; r < t.length; r++) {
      let s = t[r];
      if (s.from <= n && s.to >= n) {
        if (s.level == a)
          return r;
        (l < 0 || (i != 0 ? i < 0 ? s.from < n : s.to > n : t[l].level > s.level)) && (l = r);
      }
    }
    if (l < 0)
      throw new RangeError("Index out of range");
    return l;
  }
}
function i6(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++) {
    let a = e[n], i = t[n];
    if (a.from != i.from || a.to != i.to || a.direction != i.direction || !i6(a.inner, i.inner))
      return !1;
  }
  return !0;
}
const Mt = [];
function gL(e, t, n, a, i) {
  for (let l = 0; l <= a.length; l++) {
    let r = l ? a[l - 1].to : t, s = l < a.length ? a[l].from : n, o = l ? 256 : i;
    for (let u = r, c = o, d = o; u < s; u++) {
      let f = a6(e.charCodeAt(u));
      f == 512 ? f = c : f == 8 && d == 4 && (f = 16), Mt[u] = f == 4 ? 2 : f, f & 7 && (d = f), c = f;
    }
    for (let u = r, c = o, d = o; u < s; u++) {
      let f = Mt[u];
      if (f == 128)
        u < s - 1 && c == Mt[u + 1] && c & 24 ? f = Mt[u] = c : Mt[u] = 256;
      else if (f == 64) {
        let h = u + 1;
        for (; h < s && Mt[h] == 64; )
          h++;
        let m = u && c == 8 || h < n && Mt[h] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let g = u; g < h; g++)
          Mt[g] = m;
        u = h - 1;
      } else f == 8 && d == 1 && (Mt[u] = 1);
      c = f, f & 7 && (d = f);
    }
  }
}
function pL(e, t, n, a, i) {
  let l = i == 1 ? 2 : 1;
  for (let r = 0, s = 0, o = 0; r <= a.length; r++) {
    let u = r ? a[r - 1].to : t, c = r < a.length ? a[r].from : n;
    for (let d = u, f, h, m; d < c; d++)
      if (h = Jh[f = e.charCodeAt(d)])
        if (h < 0) {
          for (let g = s - 3; g >= 0; g -= 3)
            if (ui[g + 1] == -h) {
              let v = ui[g + 2], y = v & 2 ? i : v & 4 ? v & 1 ? l : i : 0;
              y && (Mt[d] = Mt[ui[g]] = y), s = g;
              break;
            }
        } else {
          if (ui.length == 189)
            break;
          ui[s++] = d, ui[s++] = f, ui[s++] = o;
        }
      else if ((m = Mt[d]) == 2 || m == 1) {
        let g = m == i;
        o = g ? 0 : 1;
        for (let v = s - 3; v >= 0; v -= 3) {
          let y = ui[v + 2];
          if (y & 2)
            break;
          if (g)
            ui[v + 2] |= 2;
          else {
            if (y & 4)
              break;
            ui[v + 2] |= 4;
          }
        }
      }
  }
}
function yL(e, t, n, a) {
  for (let i = 0, l = a; i <= n.length; i++) {
    let r = i ? n[i - 1].to : e, s = i < n.length ? n[i].from : t;
    for (let o = r; o < s; ) {
      let u = Mt[o];
      if (u == 256) {
        let c = o + 1;
        for (; ; )
          if (c == s) {
            if (i == n.length)
              break;
            c = n[i++].to, s = i < n.length ? n[i].from : t;
          } else if (Mt[c] == 256)
            c++;
          else
            break;
        let d = l == 1, f = (c < t ? Mt[c] : a) == 1, h = d == f ? d ? 1 : 2 : a;
        for (let m = c, g = i, v = g ? n[g - 1].to : e; m > o; )
          m == v && (m = n[--g].from, v = g ? n[g - 1].to : e), Mt[--m] = h;
        o = c;
      } else
        l = u, o++;
    }
  }
}
function e0(e, t, n, a, i, l, r) {
  let s = a % 2 ? 2 : 1;
  if (a % 2 == i % 2)
    for (let o = t, u = 0; o < n; ) {
      let c = !0, d = !1;
      if (u == l.length || o < l[u].from) {
        let g = Mt[o];
        g != s && (c = !1, d = g == 16);
      }
      let f = !c && s == 1 ? [] : null, h = c ? a : a + 1, m = o;
      e: for (; ; )
        if (u < l.length && m == l[u].from) {
          if (d)
            break e;
          let g = l[u];
          if (!c)
            for (let v = g.to, y = u + 1; ; ) {
              if (v == n)
                break e;
              if (y < l.length && l[y].from == v)
                v = l[y++].to;
              else {
                if (Mt[v] == s)
                  break e;
                break;
              }
            }
          if (u++, f)
            f.push(g);
          else {
            g.from > o && r.push(new Cl(o, g.from, h));
            let v = g.direction == $r != !(h % 2);
            t0(e, v ? a + 1 : a, i, g.inner, g.from, g.to, r), o = g.to;
          }
          m = g.to;
        } else {
          if (m == n || (c ? Mt[m] != s : Mt[m] == s))
            break;
          m++;
        }
      f ? e0(e, o, m, a + 1, i, f, r) : o < m && r.push(new Cl(o, m, h)), o = m;
    }
  else
    for (let o = n, u = l.length; o > t; ) {
      let c = !0, d = !1;
      if (!u || o > l[u - 1].to) {
        let g = Mt[o - 1];
        g != s && (c = !1, d = g == 16);
      }
      let f = !c && s == 1 ? [] : null, h = c ? a : a + 1, m = o;
      e: for (; ; )
        if (u && m == l[u - 1].to) {
          if (d)
            break e;
          let g = l[--u];
          if (!c)
            for (let v = g.from, y = u; ; ) {
              if (v == t)
                break e;
              if (y && l[y - 1].to == v)
                v = l[--y].from;
              else {
                if (Mt[v - 1] == s)
                  break e;
                break;
              }
            }
          if (f)
            f.push(g);
          else {
            g.to < o && r.push(new Cl(g.to, o, h));
            let v = g.direction == $r != !(h % 2);
            t0(e, v ? a + 1 : a, i, g.inner, g.from, g.to, r), o = g.from;
          }
          m = g.from;
        } else {
          if (m == t || (c ? Mt[m - 1] != s : Mt[m - 1] == s))
            break;
          m--;
        }
      f ? e0(e, m, o, a + 1, i, f, r) : m < o && r.push(new Cl(m, o, h)), o = m;
    }
}
function t0(e, t, n, a, i, l, r) {
  let s = t % 2 ? 2 : 1;
  gL(e, i, l, a, s), pL(e, i, l, a, s), yL(i, l, a, s), e0(e, i, l, t, n, a, r);
}
function OL(e, t, n) {
  if (!e)
    return [new Cl(0, 0, t == um ? 1 : 0)];
  if (t == $r && !n.length && !vL.test(e))
    return l6(e.length);
  if (n.length)
    for (; e.length > Mt.length; )
      Mt[Mt.length] = 256;
  let a = [], i = t == $r ? 0 : 1;
  return t0(e, i, i, n, 0, e.length, a), a;
}
function l6(e) {
  return [new Cl(0, e, 0)];
}
let r6 = "";
function bL(e, t, n, a, i) {
  var l;
  let r = a.head - e.from, s = Cl.find(t, r, (l = a.bidiLevel) !== null && l !== void 0 ? l : -1, a.assoc), o = t[s], u = o.side(i, n);
  if (r == u) {
    let f = s += i ? 1 : -1;
    if (f < 0 || f >= t.length)
      return null;
    o = t[s = f], r = o.side(!i, n), u = o.side(i, n);
  }
  let c = jn(e.text, r, o.forward(i, n));
  (c < o.from || c > o.to) && (c = u), r6 = e.text.slice(Math.min(r, c), Math.max(r, c));
  let d = s == (i ? t.length - 1 : 0) ? null : t[s + (i ? 1 : -1)];
  return d && c == u && d.level + (i ? 0 : 1) < o.level ? we.cursor(d.side(!i, n) + e.from, d.forward(i, n) ? 1 : -1, d.level) : we.cursor(c + e.from, o.forward(i, n) ? -1 : 1, o.level);
}
function CL(e, t, n) {
  for (let a = t; a < n; a++) {
    let i = a6(e.charCodeAt(a));
    if (i == 1)
      return $r;
    if (i == 2 || i == 4)
      return um;
  }
  return $r;
}
const s6 = /* @__PURE__ */ He.define(), o6 = /* @__PURE__ */ He.define(), u6 = /* @__PURE__ */ He.define(), c6 = /* @__PURE__ */ He.define(), n0 = /* @__PURE__ */ He.define(), d6 = /* @__PURE__ */ He.define(), f6 = /* @__PURE__ */ He.define(), cm = /* @__PURE__ */ He.define(), dm = /* @__PURE__ */ He.define(), h6 = /* @__PURE__ */ He.define({
  combine: (e) => e.some((t) => t)
}), m6 = /* @__PURE__ */ He.define({
  combine: (e) => e.some((t) => t)
}), v6 = /* @__PURE__ */ He.define();
class fs {
  constructor(t, n = "nearest", a = "nearest", i = 5, l = 5, r = !1) {
    this.range = t, this.y = n, this.x = a, this.yMargin = i, this.xMargin = l, this.isSnapshot = r;
  }
  map(t) {
    return t.empty ? this : new fs(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new fs(we.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Ju = /* @__PURE__ */ at.define({ map: (e, t) => e.map(t) }), g6 = /* @__PURE__ */ at.define();
function aa(e, t, n) {
  let a = e.facet(c6);
  a.length ? a[0](t) : window.onerror ? window.onerror(String(t), n, void 0, void 0, t) : n ? console.error(n + ":", t) : console.error(t);
}
const ji = /* @__PURE__ */ He.define({ combine: (e) => e.length ? e[0] : !0 });
let wL = 0;
const po = /* @__PURE__ */ He.define();
class rn {
  constructor(t, n, a, i, l) {
    this.id = t, this.create = n, this.domEventHandlers = a, this.domEventObservers = i, this.extension = l(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, n) {
    const { eventHandlers: a, eventObservers: i, provide: l, decorations: r } = n || {};
    return new rn(wL++, t, a, i, (s) => {
      let o = [po.of(s)];
      return r && o.push(Go.of((u) => {
        let c = u.plugin(s);
        return c ? r(c) : qe.none;
      })), l && o.push(l(s)), o;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, n) {
    return rn.define((a) => new t(a), n);
  }
}
class rf {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (a) {
            if (aa(n.state, a, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(t);
      } catch (n) {
        aa(t.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (a) {
        aa(t.state, a, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const p6 = /* @__PURE__ */ He.define(), fm = /* @__PURE__ */ He.define(), Go = /* @__PURE__ */ He.define(), y6 = /* @__PURE__ */ He.define(), hm = /* @__PURE__ */ He.define(), O6 = /* @__PURE__ */ He.define();
function Gg(e, t) {
  let n = e.state.facet(O6);
  if (!n.length)
    return n;
  let a = n.map((l) => l instanceof Function ? l(e) : l), i = [];
  return mt.spans(a, t.from, t.to, {
    point() {
    },
    span(l, r, s, o) {
      let u = l - t.from, c = r - t.from, d = i;
      for (let f = s.length - 1; f >= 0; f--, o--) {
        let h = s[f].spec.bidiIsolate, m;
        if (h == null && (h = CL(t.text, u, c)), o > 0 && d.length && (m = d[d.length - 1]).to == u && m.direction == h)
          m.to = c, d = m.inner;
        else {
          let g = { from: u, to: c, direction: h, inner: [] };
          d.push(g), d = g.inner;
        }
      }
    }
  }), i;
}
const b6 = /* @__PURE__ */ He.define();
function mm(e) {
  let t = 0, n = 0, a = 0, i = 0;
  for (let l of e.state.facet(b6)) {
    let r = l(e);
    r && (r.left != null && (t = Math.max(t, r.left)), r.right != null && (n = Math.max(n, r.right)), r.top != null && (a = Math.max(a, r.top)), r.bottom != null && (i = Math.max(i, r.bottom)));
  }
  return { left: t, right: n, top: a, bottom: i };
}
const yo = /* @__PURE__ */ He.define();
class Aa {
  constructor(t, n, a, i) {
    this.fromA = t, this.toA = n, this.fromB = a, this.toB = i;
  }
  join(t) {
    return new Aa(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let n = t.length, a = this;
    for (; n > 0; n--) {
      let i = t[n - 1];
      if (!(i.fromA > a.toA)) {
        if (i.toA < a.fromA)
          break;
        a = a.join(i), t.splice(n - 1, 1);
      }
    }
    return t.splice(n, 0, a), t;
  }
  static extendWithRanges(t, n) {
    if (n.length == 0)
      return t;
    let a = [];
    for (let i = 0, l = 0, r = 0, s = 0; ; i++) {
      let o = i == t.length ? null : t[i], u = r - s, c = o ? o.fromB : 1e9;
      for (; l < n.length && n[l] < c; ) {
        let d = n[l], f = n[l + 1], h = Math.max(s, d), m = Math.min(c, f);
        if (h <= m && new Aa(h + u, m + u, h, m).addToSet(a), f > c)
          break;
        l += 2;
      }
      if (!o)
        return a;
      new Aa(o.fromA, o.toA, o.fromB, o.toB).addToSet(a), r = o.toA, s = o.toB;
    }
  }
}
class nd {
  constructor(t, n, a) {
    this.view = t, this.state = n, this.transactions = a, this.flags = 0, this.startState = t.state, this.changes = Mn.empty(this.startState.doc.length);
    for (let l of a)
      this.changes = this.changes.compose(l.changes);
    let i = [];
    this.changes.iterChangedRanges((l, r, s, o) => i.push(new Aa(l, r, s, o))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(t, n, a) {
    return new nd(t, n, a);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class Kg extends Vt {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = qe.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new On()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Aa(0, 0, 0, t.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(t) {
    var n;
    let a = t.changedRanges;
    this.minWidth > 0 && a.length && (a.every(({ fromA: u, toA: c }) => c < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !ML(t.changes, this.hasComposition) && !t.selectionSet && (i = t.state.selection.main.head));
    let l = i > -1 ? SL(this.view, t.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u, to: c } = this.hasComposition;
      a = new Aa(u, c, t.changes.mapPos(u, -1), t.changes.mapPos(c, 1)).addToSet(a.slice());
    }
    this.hasComposition = l ? { from: l.range.fromB, to: l.range.toB } : null, (Ne.ie || Ne.chrome) && !l && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let r = this.decorations, s = this.updateDeco(), o = $L(r, s, t.changes);
    return a = Aa.extendWithRanges(a, o), !(this.flags & 7) && a.length == 0 ? !1 : (this.updateInner(a, t.startState.doc.length, l), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, n, a) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, n, a);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let r = Ne.chrome || Ne.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, r), this.flags &= -8, r && (r.written || i.selectionRange.focusNode != r.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (r) => r.flags &= -9
      /* ViewFlag.Composition */
    );
    let l = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let r of this.children)
        r instanceof Xi && r.widget instanceof Kh && l.push(r.dom);
    i.updateGaps(l);
  }
  updateChildren(t, n, a) {
    let i = a ? a.range.addToSet(t.slice()) : t, l = this.childCursor(n);
    for (let r = i.length - 1; ; r--) {
      let s = r >= 0 ? i[r] : null;
      if (!s)
        break;
      let { fromA: o, toA: u, fromB: c, toB: d } = s, f, h, m, g;
      if (a && a.range.fromB < d && a.range.toB > c) {
        let S = Po.build(this.view.state.doc, c, a.range.fromB, this.decorations, this.dynamicDecorationMap), x = Po.build(this.view.state.doc, a.range.toB, d, this.decorations, this.dynamicDecorationMap);
        h = S.breakAtStart, m = S.openStart, g = x.openEnd;
        let w = this.compositionView(a);
        x.breakAtStart ? w.breakAfter = 1 : x.content.length && w.merge(w.length, w.length, x.content[0], !1, x.openStart, 0) && (w.breakAfter = x.content[0].breakAfter, x.content.shift()), S.content.length && w.merge(0, 0, S.content[S.content.length - 1], !0, 0, S.openEnd) && S.content.pop(), f = S.content.concat(w).concat(x.content);
      } else
        ({ content: f, breakAtStart: h, openStart: m, openEnd: g } = Po.build(this.view.state.doc, c, d, this.decorations, this.dynamicDecorationMap));
      let { i: v, off: y } = l.findPos(u, 1), { i: b, off: C } = l.findPos(o, -1);
      W7(this, b, C, v, y, f, h, m, g);
    }
    a && this.fixCompositionDOM(a);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let n of t.transactions)
      for (let a of n.effects)
        a.is(g6) && (this.editContextFormatting = a.value);
  }
  compositionView(t) {
    let n = new Ja(t.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of t.marks)
      n = new Ki(i, [n], n.length);
    let a = new On();
    return a.append(n, 0), a;
  }
  fixCompositionDOM(t) {
    let n = (l, r) => {
      r.flags |= 8 | (r.children.some(
        (o) => o.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(r);
      let s = Vt.get(l);
      s && s != r && (s.dom = null), r.setDOM(l);
    }, a = this.childPos(t.range.fromB, 1), i = this.children[a.i];
    n(t.line, i);
    for (let l = t.marks.length - 1; l >= -1; l--)
      a = i.childPos(a.off, 1), i = i.children[a.i], n(l >= 0 ? t.marks[l].node : t.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, n = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let a = this.view.root.activeElement, i = a == this.dom, l = !i && !(this.view.state.facet(ji) || this.dom.tabIndex > -1) && $c(this.dom, this.view.observer.selectionRange) && !(a && this.dom.contains(a));
    if (!(i || n || l))
      return;
    let r = this.forceSelection;
    this.forceSelection = !1;
    let s = this.view.state.selection.main, o = this.moveToLine(this.domAtPos(s.anchor)), u = s.empty ? o : this.moveToLine(this.domAtPos(s.head));
    if (Ne.gecko && s.empty && !this.hasComposition && kL(o)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => o.node.insertBefore(d, o.node.childNodes[o.offset] || null)), o = u = new Un(d, 0), r = !0;
    }
    let c = this.view.observer.selectionRange;
    (r || !c.focusNode || (!xo(o.node, o.offset, c.anchorNode, c.anchorOffset) || !xo(u.node, u.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, s)) && (this.view.observer.ignore(() => {
      Ne.android && Ne.chrome && this.dom.contains(c.focusNode) && _L(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = Uo(this.view.root);
      if (d) if (s.empty) {
        if (Ne.gecko) {
          let f = xL(o.node, o.offset);
          if (f && f != 3) {
            let h = (f == 1 ? F7 : X7)(o.node, o.offset);
            h && (o = new Un(h.node, h.offset));
          }
        }
        d.collapse(o.node, o.offset), s.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = s.bidiLevel);
      } else if (d.extend) {
        d.collapse(o.node, o.offset);
        try {
          d.extend(u.node, u.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        s.anchor > s.head && ([o, u] = [u, o]), f.setEnd(u.node, u.offset), f.setStart(o.node, o.offset), d.removeAllRanges(), d.addRange(f);
      }
      l && this.view.root.activeElement == this.dom && (this.dom.blur(), a && a.focus());
    }), this.view.observer.setSelectionRange(o, u)), this.impreciseAnchor = o.precise ? null : new Un(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new Un(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, n) {
    return this.hasComposition && n.empty && xo(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, n = t.state.selection.main, a = Uo(t.root), { anchorNode: i, anchorOffset: l } = t.observer.selectionRange;
    if (!a || !n.empty || !n.assoc || !a.modify)
      return;
    let r = On.find(this, n.head);
    if (!r)
      return;
    let s = r.posAtStart;
    if (n.head == s || n.head == s + r.length)
      return;
    let o = this.coordsAt(n.head, -1), u = this.coordsAt(n.head, 1);
    if (!o || !u || o.bottom > u.top)
      return;
    let c = this.domAtPos(n.head + n.assoc);
    a.collapse(c.node, c.offset), a.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let d = t.observer.selectionRange;
    t.docView.posFromDOM(d.anchorNode, d.anchorOffset) != n.from && a.collapse(i, l);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(t) {
    let n = this.dom, a;
    if (t.node != n)
      return t;
    for (let i = t.offset; !a && i < n.childNodes.length; i++) {
      let l = Vt.get(n.childNodes[i]);
      l instanceof On && (a = l.domAtPos(0));
    }
    for (let i = t.offset - 1; !a && i >= 0; i--) {
      let l = Vt.get(n.childNodes[i]);
      l instanceof On && (a = l.domAtPos(l.length));
    }
    return a ? new Un(a.node, a.offset, !0) : t;
  }
  nearest(t) {
    for (let n = t; n; ) {
      let a = Vt.get(n);
      if (a && a.rootView == this)
        return a;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(t, n) {
    let a = this.nearest(t);
    if (!a)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return a.localPosFromDOM(t, n) + a.posAtStart;
  }
  domAtPos(t) {
    let { i: n, off: a } = this.childCursor().findPos(t, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (a < i.length || i instanceof On)
        break;
      n++, a = 0;
    }
    return this.children[n].domAtPos(a);
  }
  coordsAt(t, n) {
    let a = null, i = 0;
    for (let l = this.length, r = this.children.length - 1; r >= 0; r--) {
      let s = this.children[r], o = l - s.breakAfter, u = o - s.length;
      if (o < t)
        break;
      if (u <= t && (u < t || s.covers(-1)) && (o > t || s.covers(1)) && (!a || s instanceof On && !(a instanceof On && n >= 0)))
        a = s, i = u;
      else if (a && u == t && o == t && s instanceof Xi && Math.abs(n) < 2) {
        if (s.deco.startSide < 0)
          break;
        r && (a = null);
      }
      l = u;
    }
    return a ? a.coordsAt(t - i, n) : null;
  }
  coordsForChar(t) {
    let { i: n, off: a } = this.childPos(t, 1), i = this.children[n];
    if (!(i instanceof On))
      return null;
    for (; i.children.length; ) {
      let { i: s, off: o } = i.childPos(a, 1);
      for (; ; s++) {
        if (s == i.children.length)
          return null;
        if ((i = i.children[s]).length)
          break;
      }
      a = o;
    }
    if (!(i instanceof Ja))
      return null;
    let l = jn(i.text, a);
    if (l == a)
      return null;
    let r = Pr(i.dom, a, l).getClientRects();
    for (let s = 0; s < r.length; s++) {
      let o = r[s];
      if (s == r.length - 1 || o.top < o.bottom && o.left < o.right)
        return o;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let n = [], { from: a, to: i } = t, l = this.view.contentDOM.clientWidth, r = l > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, s = -1, o = this.view.textDirection == Nt.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let d = this.children[c], f = u + d.length;
      if (f > i)
        break;
      if (u >= a) {
        let h = d.dom.getBoundingClientRect();
        if (n.push(h.height), r) {
          let m = d.dom.lastChild, g = m ? xs(m) : [];
          if (g.length) {
            let v = g[g.length - 1], y = o ? v.right - h.left : h.right - v.left;
            y > s && (s = y, this.minWidth = l, this.minWidthFrom = u, this.minWidthTo = f);
          }
        }
      }
      u = f + d.breakAfter;
    }
    return n;
  }
  textDirectionAt(t) {
    let { i: n } = this.childPos(t, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? Nt.RTL : Nt.LTR;
  }
  measureTextSize() {
    for (let l of this.children)
      if (l instanceof On) {
        let r = l.measureTextSize();
        if (r)
          return r;
      }
    let t = document.createElement("div"), n, a, i;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let l = xs(t.firstChild)[0];
      n = t.getBoundingClientRect().height, a = l ? l.width / 27 : 7, i = l ? l.height : n, t.remove();
    }), { lineHeight: n, charWidth: a, textHeight: i };
  }
  childCursor(t = this.length) {
    let n = this.children.length;
    return n && (t -= this.children[--n].length), new Y7(this.children, t, n);
  }
  computeBlockGapDeco() {
    let t = [], n = this.view.viewState;
    for (let a = 0, i = 0; ; i++) {
      let l = i == n.viewports.length ? null : n.viewports[i], r = l ? l.from - 1 : this.length;
      if (r > a) {
        let s = (n.lineBlockAt(r).bottom - n.lineBlockAt(a).top) / this.view.scaleY;
        t.push(qe.replace({
          widget: new Kh(s),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(a, r));
      }
      if (!l)
        break;
      a = l.to + 1;
    }
    return qe.set(t);
  }
  updateDeco() {
    let t = 1, n = this.view.state.facet(Go).map((l) => (this.dynamicDecorationMap[t++] = typeof l == "function") ? l(this.view) : l), a = !1, i = this.view.state.facet(y6).map((l, r) => {
      let s = typeof l == "function";
      return s && (a = !0), s ? l(this.view) : l;
    });
    for (i.length && (this.dynamicDecorationMap[t++] = a, n.push(mt.join(i))), this.decorations = [
      this.editContextFormatting,
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    return this.decorations;
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let u = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = u.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let u of this.view.state.facet(v6))
      try {
        if (u(this.view, t.range, t))
          return !0;
      } catch (c) {
        aa(this.view.state, c, "scroll handler");
      }
    let { range: n } = t, a = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
    if (!a)
      return;
    !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (a = {
      left: Math.min(a.left, i.left),
      top: Math.min(a.top, i.top),
      right: Math.max(a.right, i.right),
      bottom: Math.max(a.bottom, i.bottom)
    });
    let l = mm(this.view), r = {
      left: a.left - l.left,
      top: a.top - l.top,
      right: a.right + l.right,
      bottom: a.bottom + l.bottom
    }, { offsetWidth: s, offsetHeight: o } = this.view.scrollDOM;
    aL(this.view.scrollDOM, r, n.head < n.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, s), -s), Math.max(Math.min(t.yMargin, o), -o), this.view.textDirection == Nt.LTR);
  }
}
function kL(e) {
  return e.node.nodeType == 1 && e.node.firstChild && (e.offset == 0 || e.node.childNodes[e.offset - 1].contentEditable == "false") && (e.offset == e.node.childNodes.length || e.node.childNodes[e.offset].contentEditable == "false");
}
function C6(e, t) {
  let n = e.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let a = F7(n.focusNode, n.focusOffset), i = X7(n.focusNode, n.focusOffset), l = a || i;
  if (i && a && i.node != a.node) {
    let s = Vt.get(i.node);
    if (!s || s instanceof Ja && s.text != i.node.nodeValue)
      l = i;
    else if (e.docView.lastCompositionAfterCursor) {
      let o = Vt.get(a.node);
      !o || o instanceof Ja && o.text != a.node.nodeValue || (l = i);
    }
  }
  if (e.docView.lastCompositionAfterCursor = l != a, !l)
    return null;
  let r = t - l.offset;
  return { from: r, to: r + l.node.nodeValue.length, node: l.node };
}
function SL(e, t, n) {
  let a = C6(e, n);
  if (!a)
    return null;
  let { node: i, from: l, to: r } = a, s = i.nodeValue;
  if (/[\n\r]/.test(s) || e.state.doc.sliceString(a.from, a.to) != s)
    return null;
  let o = t.invertedDesc, u = new Aa(o.mapPos(l), o.mapPos(r), l, r), c = [];
  for (let d = i.parentNode; ; d = d.parentNode) {
    let f = Vt.get(d);
    if (f instanceof Ki)
      c.push({ node: d, deco: f.mark });
    else {
      if (f instanceof On || d.nodeName == "DIV" && d.parentNode == e.contentDOM)
        return { range: u, text: i, marks: c, line: d };
      if (d != e.contentDOM)
        c.push({ node: d, deco: new Mu({
          inclusive: !0,
          attributes: dL(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function xL(e, t) {
  return e.nodeType != 1 ? 0 : (t && e.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < e.childNodes.length && e.childNodes[t].contentEditable == "false" ? 2 : 0);
}
let PL = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, n) {
    _c(t, n, this.changes);
  }
  comparePoint(t, n) {
    _c(t, n, this.changes);
  }
  boundChange(t) {
    _c(t, t, this.changes);
  }
};
function $L(e, t, n) {
  let a = new PL();
  return mt.compare(e, t, n, a), a.changes;
}
function _L(e, t) {
  for (let n = e; n && n != t; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function ML(e, t) {
  let n = !1;
  return t && e.iterChangedRanges((a, i) => {
    a < t.to && i > t.from && (n = !0);
  }), n;
}
function VL(e, t, n = 1) {
  let a = e.charCategorizer(t), i = e.doc.lineAt(t), l = t - i.from;
  if (i.length == 0)
    return we.cursor(t);
  l == 0 ? n = 1 : l == i.length && (n = -1);
  let r = l, s = l;
  n < 0 ? r = jn(i.text, l, !1) : s = jn(i.text, l);
  let o = a(i.text.slice(r, s));
  for (; r > 0; ) {
    let u = jn(i.text, r, !1);
    if (a(i.text.slice(u, r)) != o)
      break;
    r = u;
  }
  for (; s < i.length; ) {
    let u = jn(i.text, s);
    if (a(i.text.slice(s, u)) != o)
      break;
    s = u;
  }
  return we.range(r + i.from, s + i.from);
}
function TL(e, t) {
  return t.left > e ? t.left - e : Math.max(0, e - t.right);
}
function LL(e, t) {
  return t.top > e ? t.top - e : Math.max(0, e - t.bottom);
}
function sf(e, t) {
  return e.top < t.bottom - 1 && e.bottom > t.top + 1;
}
function Jg(e, t) {
  return t < e.top ? { top: t, left: e.left, right: e.right, bottom: e.bottom } : e;
}
function ep(e, t) {
  return t > e.bottom ? { top: e.top, left: e.left, right: e.right, bottom: t } : e;
}
function a0(e, t, n) {
  let a, i, l, r, s = !1, o, u, c, d;
  for (let m = e.firstChild; m; m = m.nextSibling) {
    let g = xs(m);
    for (let v = 0; v < g.length; v++) {
      let y = g[v];
      i && sf(i, y) && (y = Jg(ep(y, i.bottom), i.top));
      let b = TL(t, y), C = LL(n, y);
      if (b == 0 && C == 0)
        return m.nodeType == 3 ? tp(m, t, n) : a0(m, t, n);
      if (!a || r > C || r == C && l > b) {
        a = m, i = y, l = b, r = C;
        let S = C ? n < y.top ? -1 : 1 : b ? t < y.left ? -1 : 1 : 0;
        s = !S || (S > 0 ? v < g.length - 1 : v > 0);
      }
      b == 0 ? n > y.bottom && (!c || c.bottom < y.bottom) ? (o = m, c = y) : n < y.top && (!d || d.top > y.top) && (u = m, d = y) : c && sf(c, y) ? c = ep(c, y.bottom) : d && sf(d, y) && (d = Jg(d, y.top));
    }
  }
  if (c && c.bottom >= n ? (a = o, i = c) : d && d.top <= n && (a = u, i = d), !a)
    return { node: e, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, t));
  if (a.nodeType == 3)
    return tp(a, f, n);
  if (s && a.contentEditable != "false")
    return a0(a, f, n);
  let h = Array.prototype.indexOf.call(e.childNodes, a) + (t >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: e, offset: h };
}
function tp(e, t, n) {
  let a = e.nodeValue.length, i = -1, l = 1e9, r = 0;
  for (let s = 0; s < a; s++) {
    let o = Pr(e, s, s + 1).getClientRects();
    for (let u = 0; u < o.length; u++) {
      let c = o[u];
      if (c.top == c.bottom)
        continue;
      r || (r = t - c.left);
      let d = (c.top > n ? c.top - n : n - c.bottom) - 1;
      if (c.left - 1 <= t && c.right + 1 >= t && d < l) {
        let f = t >= (c.left + c.right) / 2, h = f;
        if ((Ne.chrome || Ne.gecko) && Pr(e, s).getBoundingClientRect().left == c.right && (h = !f), d <= 0)
          return { node: e, offset: s + (h ? 1 : 0) };
        i = s + (h ? 1 : 0), l = d;
      }
    }
  }
  return { node: e, offset: i > -1 ? i : r > 0 ? e.nodeValue.length : 0 };
}
function w6(e, t, n, a = -1) {
  var i, l;
  let r = e.contentDOM.getBoundingClientRect(), s = r.top + e.viewState.paddingTop, o, { docHeight: u } = e.viewState, { x: c, y: d } = t, f = d - s;
  if (f < 0)
    return 0;
  if (f > u)
    return e.state.doc.length;
  for (let S = e.viewState.heightOracle.textHeight / 2, x = !1; o = e.elementAtHeight(f), o.type != ra.Text; )
    for (; f = a > 0 ? o.bottom + S : o.top - S, !(f >= 0 && f <= u); ) {
      if (x)
        return n ? null : 0;
      x = !0, a = -a;
    }
  d = s + f;
  let h = o.from;
  if (h < e.viewport.from)
    return e.viewport.from == 0 ? 0 : n ? null : np(e, r, o, c, d);
  if (h > e.viewport.to)
    return e.viewport.to == e.state.doc.length ? e.state.doc.length : n ? null : np(e, r, o, c, d);
  let m = e.dom.ownerDocument, g = e.root.elementFromPoint ? e.root : m, v = g.elementFromPoint(c, d);
  v && !e.contentDOM.contains(v) && (v = null), v || (c = Math.max(r.left + 1, Math.min(r.right - 1, c)), v = g.elementFromPoint(c, d), v && !e.contentDOM.contains(v) && (v = null));
  let y, b = -1;
  if (v && ((i = e.docView.nearest(v)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (m.caretPositionFromPoint) {
      let S = m.caretPositionFromPoint(c, d);
      S && ({ offsetNode: y, offset: b } = S);
    } else if (m.caretRangeFromPoint) {
      let S = m.caretRangeFromPoint(c, d);
      S && ({ startContainer: y, startOffset: b } = S, (!e.contentDOM.contains(y) || Ne.safari && QL(y, b, c) || Ne.chrome && AL(y, b, c)) && (y = void 0));
    }
    y && (b = Math.min(Vi(y), b));
  }
  if (!y || !e.docView.dom.contains(y)) {
    let S = On.find(e.docView, h);
    if (!S)
      return f > o.top + o.height / 2 ? o.to : o.from;
    ({ node: y, offset: b } = a0(S.dom, c, d));
  }
  let C = e.docView.nearest(y);
  if (!C)
    return null;
  if (C.isWidget && ((l = C.dom) === null || l === void 0 ? void 0 : l.nodeType) == 1) {
    let S = C.dom.getBoundingClientRect();
    return t.y < S.top || t.y <= S.bottom && t.x <= (S.left + S.right) / 2 ? C.posAtStart : C.posAtEnd;
  } else
    return C.localPosFromDOM(y, b) + C.posAtStart;
}
function np(e, t, n, a, i) {
  let l = Math.round((a - t.left) * e.defaultCharacterWidth);
  if (e.lineWrapping && n.height > e.defaultLineHeight * 1.5) {
    let s = e.viewState.heightOracle.textHeight, o = Math.floor((i - n.top - (e.defaultLineHeight - s) * 0.5) / s);
    l += o * e.viewState.heightOracle.lineLength;
  }
  let r = e.state.sliceDoc(n.from, n.to);
  return n.from + jh(r, l, e.state.tabSize);
}
function QL(e, t, n) {
  let a;
  if (e.nodeType != 3 || t != (a = e.nodeValue.length))
    return !1;
  for (let i = e.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return Pr(e, a - 1, a).getBoundingClientRect().left > n;
}
function AL(e, t, n) {
  if (t != 0)
    return !1;
  for (let i = e; ; ) {
    let l = i.parentNode;
    if (!l || l.nodeType != 1 || l.firstChild != i)
      return !1;
    if (l.classList.contains("cm-line"))
      break;
    i = l;
  }
  let a = e.nodeType == 1 ? e.getBoundingClientRect() : Pr(e, 0, Math.max(e.nodeValue.length, 1)).getBoundingClientRect();
  return n - a.left > 5;
}
function i0(e, t) {
  let n = e.lineBlockAt(t);
  if (Array.isArray(n.type)) {
    for (let a of n.type)
      if (a.to > t || a.to == t && (a.to == n.to || a.type == ra.Text))
        return a;
  }
  return n;
}
function DL(e, t, n, a) {
  let i = i0(e, t.head), l = !a || i.type != ra.Text || !(e.lineWrapping || i.widgetLineBreaks) ? null : e.coordsAtPos(t.assoc < 0 && t.head > i.from ? t.head - 1 : t.head);
  if (l) {
    let r = e.dom.getBoundingClientRect(), s = e.textDirectionAt(i.from), o = e.posAtCoords({
      x: n == (s == Nt.LTR) ? r.right - 1 : r.left + 1,
      y: (l.top + l.bottom) / 2
    });
    if (o != null)
      return we.cursor(o, n ? -1 : 1);
  }
  return we.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function ap(e, t, n, a) {
  let i = e.state.doc.lineAt(t.head), l = e.bidiSpans(i), r = e.textDirectionAt(i.from);
  for (let s = t, o = null; ; ) {
    let u = bL(i, l, r, s, n), c = r6;
    if (!u) {
      if (i.number == (n ? e.state.doc.lines : 1))
        return s;
      c = `
`, i = e.state.doc.line(i.number + (n ? 1 : -1)), l = e.bidiSpans(i), u = e.visualLineSide(i, !n);
    }
    if (o) {
      if (!o(c))
        return s;
    } else {
      if (!a)
        return u;
      o = a(c);
    }
    s = u;
  }
}
function RL(e, t, n) {
  let a = e.state.charCategorizer(t), i = a(n);
  return (l) => {
    let r = a(l);
    return i == Ft.Space && (i = r), i == r;
  };
}
function IL(e, t, n, a) {
  let i = t.head, l = n ? 1 : -1;
  if (i == (n ? e.state.doc.length : 0))
    return we.cursor(i, t.assoc);
  let r = t.goalColumn, s, o = e.contentDOM.getBoundingClientRect(), u = e.coordsAtPos(i, t.assoc || -1), c = e.documentTop;
  if (u)
    r == null && (r = u.left - o.left), s = l < 0 ? u.top : u.bottom;
  else {
    let h = e.viewState.lineBlockAt(i);
    r == null && (r = Math.min(o.right - o.left, e.defaultCharacterWidth * (i - h.from))), s = (l < 0 ? h.top : h.bottom) + c;
  }
  let d = o.left + r, f = a ?? e.viewState.heightOracle.textHeight >> 1;
  for (let h = 0; ; h += 10) {
    let m = s + (f + h) * l, g = w6(e, { x: d, y: m }, !1, l);
    if (m < o.top || m > o.bottom || (l < 0 ? g < i : g > i)) {
      let v = e.docView.coordsForChar(g), y = !v || m < v.top ? -1 : 1;
      return we.cursor(g, y, void 0, r);
    }
  }
}
function Mc(e, t, n) {
  for (; ; ) {
    let a = 0;
    for (let i of e)
      i.between(t - 1, t + 1, (l, r, s) => {
        if (t > l && t < r) {
          let o = a || n || (t - l < r - t ? -1 : 1);
          t = o < 0 ? l : r, a = o;
        }
      });
    if (!a)
      return t;
  }
}
function of(e, t, n) {
  let a = Mc(e.state.facet(hm).map((i) => i(e)), n.from, t.head > n.from ? -1 : 1);
  return a == n.from ? n : we.cursor(a, a < n.from ? 1 : -1);
}
const Oo = "￿";
class BL {
  constructor(t, n) {
    this.points = t, this.text = "", this.lineSeparator = n.facet(ot.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += Oo;
  }
  readRange(t, n) {
    if (!t)
      return this;
    let a = t.parentNode;
    for (let i = t; ; ) {
      this.findPointBefore(a, i);
      let l = this.text.length;
      this.readNode(i);
      let r = i.nextSibling;
      if (r == n)
        break;
      let s = Vt.get(i), o = Vt.get(r);
      (s && o ? s.breakAfter : (s ? s.breakAfter : ed(i)) || ed(r) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > l) && this.lineBreak(), i = r;
    }
    return this.findPointBefore(a, n), this;
  }
  readTextNode(t) {
    let n = t.nodeValue;
    for (let a of this.points)
      a.node == t && (a.pos = this.text.length + Math.min(a.offset, n.length));
    for (let a = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let l = -1, r = 1, s;
      if (this.lineSeparator ? (l = n.indexOf(this.lineSeparator, a), r = this.lineSeparator.length) : (s = i.exec(n)) && (l = s.index, r = s[0].length), this.append(n.slice(a, l < 0 ? n.length : l)), l < 0)
        break;
      if (this.lineBreak(), r > 1)
        for (let o of this.points)
          o.node == t && o.pos > this.text.length && (o.pos -= r - 1);
      a = l + r;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let n = Vt.get(t), a = n && n.overrideDOMText;
    if (a != null) {
      this.findPointInside(t, a.length);
      for (let i = a.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, n) {
    for (let a of this.points)
      a.node == t && t.childNodes[a.offset] == n && (a.pos = this.text.length);
  }
  findPointInside(t, n) {
    for (let a of this.points)
      (t.nodeType == 3 ? a.node == t : t.contains(a.node)) && (a.pos = this.text.length + (ZL(t, a.node, a.offset) ? n : 0));
  }
}
function ZL(e, t, n) {
  for (; ; ) {
    if (!t || n < Vi(t))
      return !1;
    if (t == e)
      return !0;
    n = xr(t) + 1, t = t.parentNode;
  }
}
class ip {
  constructor(t, n) {
    this.node = t, this.offset = n, this.pos = -1;
  }
}
class EL {
  constructor(t, n, a, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = n > -1;
    let { impreciseHead: l, impreciseAnchor: r } = t.docView;
    if (t.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = t.docView.domBoundsAround(n, a, 0))) {
      let s = l || r ? [] : jL(t), o = new BL(s, t.state);
      o.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = o.text, this.newSel = zL(s, this.bounds.from);
    } else {
      let s = t.observer.selectionRange, o = l && l.node == s.focusNode && l.offset == s.focusOffset || !Xh(t.contentDOM, s.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(s.focusNode, s.focusOffset), u = r && r.node == s.anchorNode && r.offset == s.anchorOffset || !Xh(t.contentDOM, s.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(s.anchorNode, s.anchorOffset), c = t.viewport;
      if ((Ne.ios || Ne.chrome) && t.state.selection.main.empty && o != u && (c.from > 0 || c.to < t.state.doc.length)) {
        let d = Math.min(o, u), f = Math.max(o, u), h = c.from - d, m = c.to - f;
        (h == 0 || h == 1 || d == 0) && (m == 0 || m == -1 || f == t.state.doc.length) && (o = 0, u = t.state.doc.length);
      }
      this.newSel = we.single(u, o);
    }
  }
}
function k6(e, t) {
  let n, { newSel: a } = t, i = e.state.selection.main, l = e.inputState.lastKeyTime > Date.now() - 100 ? e.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: r, to: s } = t.bounds, o = i.from, u = null;
    (l === 8 || Ne.android && t.text.length < s - r) && (o = i.to, u = "end");
    let c = HL(e.state.doc.sliceString(r, s, Oo), t.text, o - r, u);
    c && (Ne.chrome && l == 13 && c.toB == c.from + 2 && t.text.slice(c.from, c.toB) == Oo + Oo && c.toB--, n = {
      from: r + c.from,
      to: r + c.toA,
      insert: gt.of(t.text.slice(c.from, c.toB).split(Oo))
    });
  } else a && (!e.hasFocus && e.state.facet(ji) || a.main.eq(i)) && (a = null);
  if (!n && !a)
    return !1;
  if (!n && t.typeOver && !i.empty && a && a.main.empty ? n = { from: i.from, to: i.to, insert: e.state.doc.slice(i.from, i.to) } : (Ne.mac || Ne.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && e.contentDOM.getAttribute("autocorrect") == "off" ? (a && n.insert.length == 2 && (a = we.single(a.main.anchor - 1, a.main.head - 1)), n = { from: n.from, to: n.to, insert: gt.of([n.insert.toString().replace(".", " ")]) }) : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
    from: i.from,
    to: i.to,
    insert: e.state.doc.slice(i.from, n.from).append(n.insert).append(e.state.doc.slice(n.to, i.to))
  } : Ne.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && e.lineWrapping && (a && (a = we.single(a.main.anchor - 1, a.main.head - 1)), n = { from: i.from, to: i.to, insert: gt.of([" "]) }), n)
    return vm(e, n, a, l);
  if (a && !a.main.eq(i)) {
    let r = !1, s = "select";
    return e.inputState.lastSelectionTime > Date.now() - 50 && (e.inputState.lastSelectionOrigin == "select" && (r = !0), s = e.inputState.lastSelectionOrigin), e.dispatch({ selection: a, scrollIntoView: r, userEvent: s }), !0;
  } else
    return !1;
}
function vm(e, t, n, a = -1) {
  if (Ne.ios && e.inputState.flushIOSKey(t))
    return !0;
  let i = e.state.selection.main;
  if (Ne.android && (t.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == i.from || t.from == i.from - 1 && e.state.sliceDoc(t.from, i.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && ds(e.contentDOM, "Enter", 13) || (t.from == i.from - 1 && t.to == i.to && t.insert.length == 0 || a == 8 && t.insert.length < t.to - t.from && t.to > i.head) && ds(e.contentDOM, "Backspace", 8) || t.from == i.from && t.to == i.to + 1 && t.insert.length == 0 && ds(e.contentDOM, "Delete", 46)))
    return !0;
  let l = t.insert.toString();
  e.inputState.composing >= 0 && e.inputState.composing++;
  let r, s = () => r || (r = NL(e, t, n));
  return e.state.facet(d6).some((o) => o(e, t.from, t.to, l, s)) || e.dispatch(s()), !0;
}
function NL(e, t, n) {
  let a, i = e.state, l = i.selection.main;
  if (t.from >= l.from && t.to <= l.to && t.to - t.from >= (l.to - l.from) / 3 && (!n || n.main.empty && n.main.from == t.from + t.insert.length) && e.inputState.composing < 0) {
    let s = l.from < t.from ? i.sliceDoc(l.from, t.from) : "", o = l.to > t.to ? i.sliceDoc(t.to, l.to) : "";
    a = i.replaceSelection(e.state.toText(s + t.insert.sliceString(0, void 0, e.state.lineBreak) + o));
  } else {
    let s = i.changes(t), o = n && n.main.to <= s.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && e.inputState.composing >= 0 && t.to <= l.to && t.to >= l.to - 10) {
      let u = e.state.sliceDoc(t.from, t.to), c, d = n && C6(e, n.main.head);
      if (d) {
        let m = t.insert.length - (t.to - t.from);
        c = { from: d.from, to: d.to - m };
      } else
        c = e.state.doc.lineAt(l.head);
      let f = l.to - t.to, h = l.to - l.from;
      a = i.changeByRange((m) => {
        if (m.from == l.from && m.to == l.to)
          return { changes: s, range: o || m.map(s) };
        let g = m.to - f, v = g - u.length;
        if (m.to - m.from != h || e.state.sliceDoc(v, g) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        m.to >= c.from && m.from <= c.to)
          return { range: m };
        let y = i.changes({ from: v, to: g, insert: t.insert }), b = m.to - l.to;
        return {
          changes: y,
          range: o ? we.range(Math.max(0, o.anchor + b), Math.max(0, o.head + b)) : m.map(y)
        };
      });
    } else
      a = {
        changes: s,
        selection: o && i.selection.replaceRange(o)
      };
  }
  let r = "input.type";
  return (e.composing || e.inputState.compositionPendingChange && e.inputState.compositionEndedAt > Date.now() - 50) && (e.inputState.compositionPendingChange = !1, r += ".compose", e.inputState.compositionFirstChange && (r += ".start", e.inputState.compositionFirstChange = !1)), i.update(a, { userEvent: r, scrollIntoView: !0 });
}
function HL(e, t, n, a) {
  let i = Math.min(e.length, t.length), l = 0;
  for (; l < i && e.charCodeAt(l) == t.charCodeAt(l); )
    l++;
  if (l == i && e.length == t.length)
    return null;
  let r = e.length, s = t.length;
  for (; r > 0 && s > 0 && e.charCodeAt(r - 1) == t.charCodeAt(s - 1); )
    r--, s--;
  if (a == "end") {
    let o = Math.max(0, l - Math.min(r, s));
    n -= r + o - l;
  }
  if (r < l && e.length < t.length) {
    let o = n <= l && n >= r ? l - n : 0;
    l -= o, s = l + (s - r), r = l;
  } else if (s < l) {
    let o = n <= l && n >= s ? l - n : 0;
    l -= o, r = l + (r - s), s = l;
  }
  return { from: l, toA: r, toB: s };
}
function jL(e) {
  let t = [];
  if (e.root.activeElement != e.contentDOM)
    return t;
  let { anchorNode: n, anchorOffset: a, focusNode: i, focusOffset: l } = e.observer.selectionRange;
  return n && (t.push(new ip(n, a)), (i != n || l != a) && t.push(new ip(i, l))), t;
}
function zL(e, t) {
  if (e.length == 0)
    return null;
  let n = e[0].pos, a = e.length == 2 ? e[1].pos : n;
  return n > -1 && a > -1 ? we.single(n + t, a + t) : null;
}
class FL {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, Ne.safari && t.contentDOM.addEventListener("input", () => null), Ne.gecko && sQ(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !JL(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || this.runHandlers(t.type, t);
  }
  runHandlers(t, n) {
    let a = this.handlers[t];
    if (a) {
      for (let i of a.observers)
        i(this.view, n);
      for (let i of a.handlers) {
        if (n.defaultPrevented)
          break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let n = XL(t), a = this.handlers, i = this.view.contentDOM;
    for (let l in n)
      if (l != "scroll") {
        let r = !n[l].handlers.length, s = a[l];
        s && r != !s.handlers.length && (i.removeEventListener(l, this.handleEvent), s = null), s || i.addEventListener(l, this.handleEvent, { passive: r });
      }
    for (let l in a)
      l != "scroll" && !n[l] && i.removeEventListener(l, this.handleEvent);
    this.handlers = n;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && x6.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), Ne.android && Ne.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let n;
    return Ne.ios && !t.synthetic && !t.altKey && !t.metaKey && ((n = S6.find((a) => a.keyCode == t.keyCode)) && !t.ctrlKey || YL.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = n || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, ds(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(t) {
    return /^key/.test(t.type) ? this.composing > 0 ? !0 : Ne.safari && !Ne.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function lp(e, t) {
  return (n, a) => {
    try {
      return t.call(e, a, n);
    } catch (i) {
      aa(n.state, i);
    }
  };
}
function XL(e) {
  let t = /* @__PURE__ */ Object.create(null);
  function n(a) {
    return t[a] || (t[a] = { observers: [], handlers: [] });
  }
  for (let a of e) {
    let i = a.spec;
    if (i && i.domEventHandlers)
      for (let l in i.domEventHandlers) {
        let r = i.domEventHandlers[l];
        r && n(l).handlers.push(lp(a.value, r));
      }
    if (i && i.domEventObservers)
      for (let l in i.domEventObservers) {
        let r = i.domEventObservers[l];
        r && n(l).observers.push(lp(a.value, r));
      }
  }
  for (let a in ei)
    n(a).handlers.push(ei[a]);
  for (let a in Ra)
    n(a).observers.push(Ra[a]);
  return t;
}
const S6 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], YL = "dthko", x6 = [16, 17, 18, 20, 91, 92, 224, 225], ec = 6;
function tc(e) {
  return Math.max(0, e) * 0.7 + 8;
}
function WL(e, t) {
  return Math.max(Math.abs(e.clientX - t.clientX), Math.abs(e.clientY - t.clientY));
}
class qL {
  constructor(t, n, a, i) {
    this.view = t, this.startEvent = n, this.style = a, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = iL(t.contentDOM), this.atoms = t.state.facet(hm).map((r) => r(t));
    let l = t.contentDOM.ownerDocument;
    l.addEventListener("mousemove", this.move = this.move.bind(this)), l.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = t.state.facet(ot.allowMultipleSelections) && UL(t, n), this.dragging = KL(t, n) && _6(n) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && WL(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let n = 0, a = 0, i = 0, l = 0, r = this.view.win.innerWidth, s = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: r } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: l, bottom: s } = this.scrollParents.y.getBoundingClientRect());
    let o = mm(this.view);
    t.clientX - o.left <= i + ec ? n = -tc(i - t.clientX) : t.clientX + o.right >= r - ec && (n = tc(t.clientX - r)), t.clientY - o.top <= l + ec ? a = -tc(l - t.clientY) : t.clientY + o.bottom >= s - ec && (a = tc(t.clientY - s)), this.setScrollSpeed(n, a);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, n) {
    this.scrollSpeed = { x: t, y: n }, t || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: n } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (t || n) && this.view.win.scrollBy(t, n), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(t) {
    let n = null;
    for (let a = 0; a < t.ranges.length; a++) {
      let i = t.ranges[a], l = null;
      if (i.empty) {
        let r = Mc(this.atoms, i.from, 0);
        r != i.from && (l = we.cursor(r, -1));
      } else {
        let r = Mc(this.atoms, i.from, -1), s = Mc(this.atoms, i.to, 1);
        (r != i.from || s != i.to) && (l = we.range(i.from == i.anchor ? r : s, i.from == i.head ? r : s));
      }
      l && (n || (n = t.ranges.slice()), n[a] = l);
    }
    return n ? we.create(n, t.mainIndex) : t;
  }
  select(t) {
    let { view: n } = this, a = this.skipAtoms(this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !a.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: a,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function UL(e, t) {
  let n = e.state.facet(s6);
  return n.length ? n[0](t) : Ne.mac ? t.metaKey : t.ctrlKey;
}
function GL(e, t) {
  let n = e.state.facet(o6);
  return n.length ? n[0](t) : Ne.mac ? !t.altKey : !t.ctrlKey;
}
function KL(e, t) {
  let { main: n } = e.state.selection;
  if (n.empty)
    return !1;
  let a = Uo(e.root);
  if (!a || a.rangeCount == 0)
    return !0;
  let i = a.getRangeAt(0).getClientRects();
  for (let l = 0; l < i.length; l++) {
    let r = i[l];
    if (r.left <= t.clientX && r.right >= t.clientX && r.top <= t.clientY && r.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
function JL(e, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let n = t.target, a; n != e.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (a = Vt.get(n)) && a.ignoreEvent(t))
      return !1;
  return !0;
}
const ei = /* @__PURE__ */ Object.create(null), Ra = /* @__PURE__ */ Object.create(null), P6 = Ne.ie && Ne.ie_version < 15 || Ne.ios && Ne.webkit_version < 604;
function eQ(e) {
  let t = e.dom.parentNode;
  if (!t)
    return;
  let n = t.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    e.focus(), n.remove(), $6(e, n.value);
  }, 50);
}
function g1(e, t, n) {
  for (let a of e.facet(t))
    n = a(n, e);
  return n;
}
function $6(e, t) {
  t = g1(e.state, cm, t);
  let { state: n } = e, a, i = 1, l = n.toText(t), r = l.lines == n.selection.ranges.length;
  if (l0 != null && n.selection.ranges.every((o) => o.empty) && l0 == l.toString()) {
    let o = -1;
    a = n.changeByRange((u) => {
      let c = n.doc.lineAt(u.from);
      if (c.from == o)
        return { range: u };
      o = c.from;
      let d = n.toText((r ? l.line(i++).text : t) + n.lineBreak);
      return {
        changes: { from: c.from, insert: d },
        range: we.cursor(u.from + d.length)
      };
    });
  } else r ? a = n.changeByRange((o) => {
    let u = l.line(i++);
    return {
      changes: { from: o.from, to: o.to, insert: u.text },
      range: we.cursor(o.from + u.length)
    };
  }) : a = n.replaceSelection(l);
  e.dispatch(a, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Ra.scroll = (e) => {
  e.inputState.lastScrollTop = e.scrollDOM.scrollTop, e.inputState.lastScrollLeft = e.scrollDOM.scrollLeft;
};
ei.keydown = (e, t) => (e.inputState.setSelectionOrigin("select"), t.keyCode == 27 && e.inputState.tabFocusMode != 0 && (e.inputState.tabFocusMode = Date.now() + 2e3), !1);
Ra.touchstart = (e, t) => {
  e.inputState.lastTouchTime = Date.now(), e.inputState.setSelectionOrigin("select.pointer");
};
Ra.touchmove = (e) => {
  e.inputState.setSelectionOrigin("select.pointer");
};
ei.mousedown = (e, t) => {
  if (e.observer.flush(), e.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let a of e.state.facet(u6))
    if (n = a(e, t), n)
      break;
  if (!n && t.button == 0 && (n = aQ(e, t)), n) {
    let a = !e.hasFocus;
    e.inputState.startMouseSelection(new qL(e, t, n, a)), a && e.observer.ignore(() => {
      H7(e.contentDOM);
      let l = e.root.activeElement;
      l && !l.contains(e.contentDOM) && l.blur();
    });
    let i = e.inputState.mouseSelection;
    if (i)
      return i.start(t), i.dragging === !1;
  }
  return !1;
};
function rp(e, t, n, a) {
  if (a == 1)
    return we.cursor(t, n);
  if (a == 2)
    return VL(e.state, t, n);
  {
    let i = On.find(e.docView, t), l = e.state.doc.lineAt(i ? i.posAtEnd : t), r = i ? i.posAtStart : l.from, s = i ? i.posAtEnd : l.to;
    return s < e.state.doc.length && s == l.to && s++, we.range(r, s);
  }
}
let sp = (e, t, n) => t >= n.top && t <= n.bottom && e >= n.left && e <= n.right;
function tQ(e, t, n, a) {
  let i = On.find(e.docView, t);
  if (!i)
    return 1;
  let l = t - i.posAtStart;
  if (l == 0)
    return 1;
  if (l == i.length)
    return -1;
  let r = i.coordsAt(l, -1);
  if (r && sp(n, a, r))
    return -1;
  let s = i.coordsAt(l, 1);
  return s && sp(n, a, s) ? 1 : r && r.bottom >= a ? -1 : 1;
}
function op(e, t) {
  let n = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: n, bias: tQ(e, n, t.clientX, t.clientY) };
}
const nQ = Ne.ie && Ne.ie_version <= 11;
let up = null, cp = 0, dp = 0;
function _6(e) {
  if (!nQ)
    return e.detail;
  let t = up, n = dp;
  return up = e, dp = Date.now(), cp = !t || n > Date.now() - 400 && Math.abs(t.clientX - e.clientX) < 2 && Math.abs(t.clientY - e.clientY) < 2 ? (cp + 1) % 3 : 1;
}
function aQ(e, t) {
  let n = op(e, t), a = _6(t), i = e.state.selection;
  return {
    update(l) {
      l.docChanged && (n.pos = l.changes.mapPos(n.pos), i = i.map(l.changes));
    },
    get(l, r, s) {
      let o = op(e, l), u, c = rp(e, o.pos, o.bias, a);
      if (n.pos != o.pos && !r) {
        let d = rp(e, n.pos, n.bias, a), f = Math.min(d.from, c.from), h = Math.max(d.to, c.to);
        c = f < c.from ? we.range(f, h) : we.range(h, f);
      }
      return r ? i.replaceRange(i.main.extend(c.from, c.to)) : s && a == 1 && i.ranges.length > 1 && (u = iQ(i, o.pos)) ? u : s ? i.addRange(c) : we.create([c]);
    }
  };
}
function iQ(e, t) {
  for (let n = 0; n < e.ranges.length; n++) {
    let { from: a, to: i } = e.ranges[n];
    if (a <= t && i >= t)
      return we.create(e.ranges.slice(0, n).concat(e.ranges.slice(n + 1)), e.mainIndex == n ? 0 : e.mainIndex - (e.mainIndex > n ? 1 : 0));
  }
  return null;
}
ei.dragstart = (e, t) => {
  let { selection: { main: n } } = e.state;
  if (t.target.draggable) {
    let i = e.docView.nearest(t.target);
    if (i && i.isWidget) {
      let l = i.posAtStart, r = l + i.length;
      (l >= n.to || r <= n.from) && (n = we.range(l, r));
    }
  }
  let { inputState: a } = e;
  return a.mouseSelection && (a.mouseSelection.dragging = !0), a.draggedContent = n, t.dataTransfer && (t.dataTransfer.setData("Text", g1(e.state, dm, e.state.sliceDoc(n.from, n.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
ei.dragend = (e) => (e.inputState.draggedContent = null, !1);
function fp(e, t, n, a) {
  if (n = g1(e.state, cm, n), !n)
    return;
  let i = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: l } = e.inputState, r = a && l && GL(e, t) ? { from: l.from, to: l.to } : null, s = { from: i, insert: n }, o = e.state.changes(r ? [r, s] : s);
  e.focus(), e.dispatch({
    changes: o,
    selection: { anchor: o.mapPos(i, -1), head: o.mapPos(i, 1) },
    userEvent: r ? "move.drop" : "input.drop"
  }), e.inputState.draggedContent = null;
}
ei.drop = (e, t) => {
  if (!t.dataTransfer)
    return !1;
  if (e.state.readOnly)
    return !0;
  let n = t.dataTransfer.files;
  if (n && n.length) {
    let a = Array(n.length), i = 0, l = () => {
      ++i == n.length && fp(e, t, a.filter((r) => r != null).join(e.state.lineBreak), !1);
    };
    for (let r = 0; r < n.length; r++) {
      let s = new FileReader();
      s.onerror = l, s.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(s.result) || (a[r] = s.result), l();
      }, s.readAsText(n[r]);
    }
    return !0;
  } else {
    let a = t.dataTransfer.getData("Text");
    if (a)
      return fp(e, t, a, !0), !0;
  }
  return !1;
};
ei.paste = (e, t) => {
  if (e.state.readOnly)
    return !0;
  e.observer.flush();
  let n = P6 ? null : t.clipboardData;
  return n ? ($6(e, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (eQ(e), !1);
};
function lQ(e, t) {
  let n = e.dom.parentNode;
  if (!n)
    return;
  let a = n.appendChild(document.createElement("textarea"));
  a.style.cssText = "position: fixed; left: -10000px; top: 10px", a.value = t, a.focus(), a.selectionEnd = t.length, a.selectionStart = 0, setTimeout(() => {
    a.remove(), e.focus();
  }, 50);
}
function rQ(e) {
  let t = [], n = [], a = !1;
  for (let i of e.selection.ranges)
    i.empty || (t.push(e.sliceDoc(i.from, i.to)), n.push(i));
  if (!t.length) {
    let i = -1;
    for (let { from: l } of e.selection.ranges) {
      let r = e.doc.lineAt(l);
      r.number > i && (t.push(r.text), n.push({ from: r.from, to: Math.min(e.doc.length, r.to + 1) })), i = r.number;
    }
    a = !0;
  }
  return { text: g1(e, dm, t.join(e.lineBreak)), ranges: n, linewise: a };
}
let l0 = null;
ei.copy = ei.cut = (e, t) => {
  let { text: n, ranges: a, linewise: i } = rQ(e.state);
  if (!n && !i)
    return !1;
  l0 = i ? n : null, t.type == "cut" && !e.state.readOnly && e.dispatch({
    changes: a,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let l = P6 ? null : t.clipboardData;
  return l ? (l.clearData(), l.setData("text/plain", n), !0) : (lQ(e, n), !1);
};
const M6 = /* @__PURE__ */ rl.define();
function V6(e, t) {
  let n = [];
  for (let a of e.facet(f6)) {
    let i = a(e, t);
    i && n.push(i);
  }
  return n ? e.update({ effects: n, annotations: M6.of(!0) }) : null;
}
function T6(e) {
  setTimeout(() => {
    let t = e.hasFocus;
    if (t != e.inputState.notifiedFocused) {
      let n = V6(e.state, t);
      n ? e.dispatch(n) : e.update([]);
    }
  }, 10);
}
Ra.focus = (e) => {
  e.inputState.lastFocusTime = Date.now(), !e.scrollDOM.scrollTop && (e.inputState.lastScrollTop || e.inputState.lastScrollLeft) && (e.scrollDOM.scrollTop = e.inputState.lastScrollTop, e.scrollDOM.scrollLeft = e.inputState.lastScrollLeft), T6(e);
};
Ra.blur = (e) => {
  e.observer.clearSelectionRange(), T6(e);
};
Ra.compositionstart = Ra.compositionupdate = (e) => {
  e.observer.editContext || (e.inputState.compositionFirstChange == null && (e.inputState.compositionFirstChange = !0), e.inputState.composing < 0 && (e.inputState.composing = 0));
};
Ra.compositionend = (e) => {
  e.observer.editContext || (e.inputState.composing = -1, e.inputState.compositionEndedAt = Date.now(), e.inputState.compositionPendingKey = !0, e.inputState.compositionPendingChange = e.observer.pendingRecords().length > 0, e.inputState.compositionFirstChange = null, Ne.chrome && Ne.android ? e.observer.flushSoon() : e.inputState.compositionPendingChange ? Promise.resolve().then(() => e.observer.flush()) : setTimeout(() => {
    e.inputState.composing < 0 && e.docView.hasComposition && e.update([]);
  }, 50));
};
Ra.contextmenu = (e) => {
  e.inputState.lastContextMenu = Date.now();
};
ei.beforeinput = (e, t) => {
  var n, a;
  if (t.inputType == "insertReplacementText" && e.observer.editContext) {
    let l = (n = t.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), r = t.getTargetRanges();
    if (l && r.length) {
      let s = r[0], o = e.posAtDOM(s.startContainer, s.startOffset), u = e.posAtDOM(s.endContainer, s.endOffset);
      return vm(e, { from: o, to: u, insert: e.state.toText(l) }, null), !0;
    }
  }
  let i;
  if (Ne.chrome && Ne.android && (i = S6.find((l) => l.inputType == t.inputType)) && (e.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let l = ((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0;
    setTimeout(() => {
      var r;
      (((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0) > l + 10 && e.hasFocus && (e.contentDOM.blur(), e.focus());
    }, 100);
  }
  return Ne.ios && t.inputType == "deleteContentForward" && e.observer.flushSoon(), Ne.safari && t.inputType == "insertText" && e.inputState.composing >= 0 && setTimeout(() => Ra.compositionend(e, t), 20), !1;
};
const hp = /* @__PURE__ */ new Set();
function sQ(e) {
  hp.has(e) || (hp.add(e), e.addEventListener("copy", () => {
  }), e.addEventListener("cut", () => {
  }));
}
const mp = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let _s = !1;
function vp() {
  _s = !1;
}
class oQ {
  constructor(t) {
    this.lineWrapping = t, this.doc = gt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, n) {
    let a = this.doc.lineAt(n).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (a += Math.max(0, Math.ceil((n - t - a * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * a;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return mp.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let n = !1;
    for (let a = 0; a < t.length; a++) {
      let i = t[a];
      i < 0 ? a++ : this.heightSamples[Math.floor(i * 10)] || (n = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return n;
  }
  refresh(t, n, a, i, l, r) {
    let s = mp.indexOf(t) > -1, o = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != s;
    if (this.lineWrapping = s, this.lineHeight = n, this.charWidth = a, this.textHeight = i, this.lineLength = l, o) {
      this.heightSamples = {};
      for (let u = 0; u < r.length; u++) {
        let c = r[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return o;
  }
}
class uQ {
  constructor(t, n) {
    this.from = t, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class vi {
  /**
  @internal
  */
  constructor(t, n, a, i, l) {
    this.from = t, this.length = n, this.top = a, this.height = i, this._content = l;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? ra.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Vl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new vi(this.from, this.length + t.length, this.top, this.height + t.height, n);
  }
}
var Et = /* @__PURE__ */ function(e) {
  return e[e.ByPos = 0] = "ByPos", e[e.ByHeight = 1] = "ByHeight", e[e.ByPosNoHeight = 2] = "ByPosNoHeight", e;
}(Et || (Et = {}));
const Vc = 1e-3;
class sa {
  constructor(t, n, a = 2) {
    this.length = t, this.height = n, this.flags = a;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > Vc && (_s = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, n, a) {
    return sa.of(a);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, n) {
    n.push(this);
  }
  decomposeRight(t, n) {
    n.push(this);
  }
  applyChanges(t, n, a, i) {
    let l = this, r = a.doc;
    for (let s = i.length - 1; s >= 0; s--) {
      let { fromA: o, toA: u, fromB: c, toB: d } = i[s], f = l.lineAt(o, Et.ByPosNoHeight, a.setDoc(n), 0, 0), h = f.to >= u ? f : l.lineAt(u, Et.ByPosNoHeight, a, 0, 0);
      for (d += h.to - u, u = h.to; s > 0 && f.from <= i[s - 1].toA; )
        o = i[s - 1].fromA, c = i[s - 1].fromB, s--, o < f.from && (f = l.lineAt(o, Et.ByPosNoHeight, a, 0, 0));
      c += f.from - o, o = f.from;
      let m = gm.build(a.setDoc(r), t, c, d);
      l = ad(l, l.replace(o, u, m));
    }
    return l.updateHeight(a, 0);
  }
  static empty() {
    return new Ca(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let n = 0, a = t.length, i = 0, l = 0;
    for (; ; )
      if (n == a)
        if (i > l * 2) {
          let s = t[n - 1];
          s.break ? t.splice(--n, 1, s.left, null, s.right) : t.splice(--n, 1, s.left, s.right), a += 1 + s.break, i -= s.size;
        } else if (l > i * 2) {
          let s = t[a];
          s.break ? t.splice(a, 1, s.left, null, s.right) : t.splice(a, 1, s.left, s.right), a += 2 + s.break, l -= s.size;
        } else
          break;
      else if (i < l) {
        let s = t[n++];
        s && (i += s.size);
      } else {
        let s = t[--a];
        s && (l += s.size);
      }
    let r = 0;
    return t[n - 1] == null ? (r = 1, n--) : t[n] == null && (r = 1, a++), new cQ(sa.of(t.slice(0, n)), r, sa.of(t.slice(a)));
  }
}
function ad(e, t) {
  return e == t ? e : (e.constructor != t.constructor && (_s = !0), t);
}
sa.prototype.size = 1;
class L6 extends sa {
  constructor(t, n, a) {
    super(t, n), this.deco = a;
  }
  blockAt(t, n, a, i) {
    return new vi(i, this.length, a, this.height, this.deco || 0);
  }
  lineAt(t, n, a, i, l) {
    return this.blockAt(0, a, i, l);
  }
  forEachLine(t, n, a, i, l, r) {
    t <= l + this.length && n >= l && r(this.blockAt(0, a, i, l));
  }
  updateHeight(t, n = 0, a = !1, i) {
    return i && i.from <= n && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Ca extends L6 {
  constructor(t, n) {
    super(t, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, n, a, i) {
    return new vi(i, this.length, a, this.height, this.breaks);
  }
  replace(t, n, a) {
    let i = a[0];
    return a.length == 1 && (i instanceof Ca || i instanceof En && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof En ? i = new Ca(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : sa.of(a);
  }
  updateHeight(t, n = 0, a = !1, i) {
    return i && i.from <= n && i.more ? this.setHeight(i.heights[i.index++]) : (a || this.outdated) && this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class En extends sa {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, n) {
    let a = t.doc.lineAt(n).number, i = t.doc.lineAt(n + this.length).number, l = i - a + 1, r, s = 0;
    if (t.lineWrapping) {
      let o = Math.min(this.height, t.lineHeight * l);
      r = o / l, this.length > l + 1 && (s = (this.height - o) / (this.length - l - 1));
    } else
      r = this.height / l;
    return { firstLine: a, lastLine: i, perLine: r, perChar: s };
  }
  blockAt(t, n, a, i) {
    let { firstLine: l, lastLine: r, perLine: s, perChar: o } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let u = i + (t < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - a) / this.height)) * this.length)), c = n.doc.lineAt(u), d = s + c.length * o, f = Math.max(a, t - d / 2);
      return new vi(c.from, c.length, f, d, 0);
    } else {
      let u = Math.max(0, Math.min(r - l, Math.floor((t - a) / s))), { from: c, length: d } = n.doc.line(l + u);
      return new vi(c, d, a + s * u, s, 0);
    }
  }
  lineAt(t, n, a, i, l) {
    if (n == Et.ByHeight)
      return this.blockAt(t, a, i, l);
    if (n == Et.ByPosNoHeight) {
      let { from: h, to: m } = a.doc.lineAt(t);
      return new vi(h, m - h, 0, 0, 0);
    }
    let { firstLine: r, perLine: s, perChar: o } = this.heightMetrics(a, l), u = a.doc.lineAt(t), c = s + u.length * o, d = u.number - r, f = i + s * d + o * (u.from - l - d);
    return new vi(u.from, u.length, Math.max(i, Math.min(f, i + this.height - c)), c, 0);
  }
  forEachLine(t, n, a, i, l, r) {
    t = Math.max(t, l), n = Math.min(n, l + this.length);
    let { firstLine: s, perLine: o, perChar: u } = this.heightMetrics(a, l);
    for (let c = t, d = i; c <= n; ) {
      let f = a.doc.lineAt(c);
      if (c == t) {
        let m = f.number - s;
        d += o * m + u * (t - l - m);
      }
      let h = o + u * f.length;
      r(new vi(f.from, f.length, d, h, 0)), d += h, c = f.to + 1;
    }
  }
  replace(t, n, a) {
    let i = this.length - n;
    if (i > 0) {
      let l = a[a.length - 1];
      l instanceof En ? a[a.length - 1] = new En(l.length + i) : a.push(null, new En(i - 1));
    }
    if (t > 0) {
      let l = a[0];
      l instanceof En ? a[0] = new En(t + l.length) : a.unshift(new En(t - 1), null);
    }
    return sa.of(a);
  }
  decomposeLeft(t, n) {
    n.push(new En(t - 1), null);
  }
  decomposeRight(t, n) {
    n.push(null, new En(this.length - t - 1));
  }
  updateHeight(t, n = 0, a = !1, i) {
    let l = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let r = [], s = Math.max(n, i.from), o = -1;
      for (i.from > n && r.push(new En(i.from - n - 1).updateHeight(t, n)); s <= l && i.more; ) {
        let c = t.doc.lineAt(s).length;
        r.length && r.push(null);
        let d = i.heights[i.index++];
        o == -1 ? o = d : Math.abs(d - o) >= Vc && (o = -2);
        let f = new Ca(c, d);
        f.outdated = !1, r.push(f), s += c + 1;
      }
      s <= l && r.push(null, new En(l - s).updateHeight(t, s));
      let u = sa.of(r);
      return (o < 0 || Math.abs(u.height - this.height) >= Vc || Math.abs(o - this.heightMetrics(t, n).perLine) >= Vc) && (_s = !0), ad(this, u);
    } else (a || this.outdated) && (this.setHeight(t.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class cQ extends sa {
  constructor(t, n, a) {
    super(t.length + n + a.length, t.height + a.height, n | (t.outdated || a.outdated ? 2 : 0)), this.left = t, this.right = a, this.size = t.size + a.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, n, a, i) {
    let l = a + this.left.height;
    return t < l ? this.left.blockAt(t, n, a, i) : this.right.blockAt(t, n, l, i + this.left.length + this.break);
  }
  lineAt(t, n, a, i, l) {
    let r = i + this.left.height, s = l + this.left.length + this.break, o = n == Et.ByHeight ? t < r : t < s, u = o ? this.left.lineAt(t, n, a, i, l) : this.right.lineAt(t, n, a, r, s);
    if (this.break || (o ? u.to < s : u.from > s))
      return u;
    let c = n == Et.ByPosNoHeight ? Et.ByPosNoHeight : Et.ByPos;
    return o ? u.join(this.right.lineAt(s, c, a, r, s)) : this.left.lineAt(s, c, a, i, l).join(u);
  }
  forEachLine(t, n, a, i, l, r) {
    let s = i + this.left.height, o = l + this.left.length + this.break;
    if (this.break)
      t < o && this.left.forEachLine(t, n, a, i, l, r), n >= o && this.right.forEachLine(t, n, a, s, o, r);
    else {
      let u = this.lineAt(o, Et.ByPos, a, i, l);
      t < u.from && this.left.forEachLine(t, u.from - 1, a, i, l, r), u.to >= t && u.from <= n && r(u), n > u.to && this.right.forEachLine(u.to + 1, n, a, s, o, r);
    }
  }
  replace(t, n, a) {
    let i = this.left.length + this.break;
    if (n < i)
      return this.balanced(this.left.replace(t, n, a), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - i, n - i, a));
    let l = [];
    t > 0 && this.decomposeLeft(t, l);
    let r = l.length;
    for (let s of a)
      l.push(s);
    if (t > 0 && gp(l, r - 1), n < this.length) {
      let s = l.length;
      this.decomposeRight(n, l), gp(l, s);
    }
    return sa.of(l);
  }
  decomposeLeft(t, n) {
    let a = this.left.length;
    if (t <= a)
      return this.left.decomposeLeft(t, n);
    n.push(this.left), this.break && (a++, t >= a && n.push(null)), t > a && this.right.decomposeLeft(t - a, n);
  }
  decomposeRight(t, n) {
    let a = this.left.length, i = a + this.break;
    if (t >= i)
      return this.right.decomposeRight(t - i, n);
    t < a && this.left.decomposeRight(t, n), this.break && t < i && n.push(null), n.push(this.right);
  }
  balanced(t, n) {
    return t.size > 2 * n.size || n.size > 2 * t.size ? sa.of(this.break ? [t, null, n] : [t, n]) : (this.left = ad(this.left, t), this.right = ad(this.right, n), this.setHeight(t.height + n.height), this.outdated = t.outdated || n.outdated, this.size = t.size + n.size, this.length = t.length + this.break + n.length, this);
  }
  updateHeight(t, n = 0, a = !1, i) {
    let { left: l, right: r } = this, s = n + l.length + this.break, o = null;
    return i && i.from <= n + l.length && i.more ? o = l = l.updateHeight(t, n, a, i) : l.updateHeight(t, n, a), i && i.from <= s + r.length && i.more ? o = r = r.updateHeight(t, s, a, i) : r.updateHeight(t, s, a), o ? this.balanced(l, r) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function gp(e, t) {
  let n, a;
  e[t] == null && (n = e[t - 1]) instanceof En && (a = e[t + 1]) instanceof En && e.splice(t - 1, 3, new En(n.length + 1 + a.length));
}
const dQ = 5;
class gm {
  constructor(t, n) {
    this.pos = t, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, n) {
    if (this.lineStart > -1) {
      let a = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Ca ? i.length += a - this.pos : (a > this.pos || !this.isCovered) && this.nodes.push(new Ca(a - this.pos, -1)), this.writtenTo = a, n > a && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(t, n, a) {
    if (t < n || a.heightRelevant) {
      let i = a.widget ? a.widget.estimatedHeight : 0, l = a.widget ? a.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let r = n - t;
      a.block ? this.addBlock(new L6(r, i, a)) : (r || l || i >= dQ) && this.addLineDeco(i, l, r);
    } else n > t && this.span(t, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = n, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new Ca(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, n) {
    let a = new En(n - t);
    return this.oracle.doc.lineAt(t).to == n && (a.flags |= 4), a;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof Ca)
      return t;
    let n = new Ca(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(t) {
    this.enterLine();
    let n = t.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, n && n.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, n, a) {
    let i = this.ensureLine();
    i.length += a, i.collapsed += a, i.widgetHeight = Math.max(i.widgetHeight, t), i.breaks += n, this.writtenTo = this.pos = this.pos + a;
  }
  finish(t) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Ca) && !this.isCovered ? this.nodes.push(new Ca(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let a = t;
    for (let i of this.nodes)
      i instanceof Ca && i.updateHeight(this.oracle, a), a += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, n, a, i) {
    let l = new gm(a, t);
    return mt.spans(n, a, i, l, 0), l.finish(a);
  }
}
function fQ(e, t, n) {
  let a = new hQ();
  return mt.compare(e, t, n, a, 0), a.changes;
}
class hQ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, n, a, i) {
    (t < n || a && a.heightRelevant || i && i.heightRelevant) && _c(t, n, this.changes, 5);
  }
}
function mQ(e, t) {
  let n = e.getBoundingClientRect(), a = e.ownerDocument, i = a.defaultView || window, l = Math.max(0, n.left), r = Math.min(i.innerWidth, n.right), s = Math.max(0, n.top), o = Math.min(i.innerHeight, n.bottom);
  for (let u = e.parentNode; u && u != a.body; )
    if (u.nodeType == 1) {
      let c = u, d = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && d.overflow != "visible") {
        let f = c.getBoundingClientRect();
        l = Math.max(l, f.left), r = Math.min(r, f.right), s = Math.max(s, f.top), o = Math.min(u == e.parentNode ? i.innerHeight : o, f.bottom);
      }
      u = d.position == "absolute" || d.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: l - n.left,
    right: Math.max(l, r) - n.left,
    top: s - (n.top + t),
    bottom: Math.max(s, o) - (n.top + t)
  };
}
function vQ(e) {
  let t = e.getBoundingClientRect(), n = e.ownerDocument.defaultView || window;
  return t.left < n.innerWidth && t.right > 0 && t.top < n.innerHeight && t.bottom > 0;
}
function gQ(e, t) {
  let n = e.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: t,
    bottom: n.bottom - (n.top + t)
  };
}
class uf {
  constructor(t, n, a, i) {
    this.from = t, this.to = n, this.size = a, this.displaySize = i;
  }
  static same(t, n) {
    if (t.length != n.length)
      return !1;
    for (let a = 0; a < t.length; a++) {
      let i = t[a], l = n[a];
      if (i.from != l.from || i.to != l.to || i.size != l.size)
        return !1;
    }
    return !0;
  }
  draw(t, n) {
    return qe.replace({
      widget: new pQ(this.displaySize * (n ? t.scaleY : t.scaleX), n)
    }).range(this.from, this.to);
  }
}
class pQ extends Ii {
  constructor(t, n) {
    super(), this.size = t, this.vertical = n;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class pp {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = yp, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Nt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = t.facet(fm).some((a) => typeof a != "function" && a.class == "cm-lineWrapping");
    this.heightOracle = new oQ(n), this.stateDeco = t.facet(Go).filter((a) => typeof a != "function"), this.heightMap = sa.empty().applyChanges(this.stateDeco, gt.empty, this.heightOracle.setDoc(t.doc), [new Aa(0, 0, 0, t.doc.length)]);
    for (let a = 0; a < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); a++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = qe.set(this.lineGaps.map((a) => a.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: n } = this.state.selection;
    for (let a = 0; a <= 1; a++) {
      let i = a ? n.head : n.anchor;
      if (!t.some(({ from: l, to: r }) => i >= l && i <= r)) {
        let { from: l, to: r } = this.lineBlockAt(i);
        t.push(new nc(l, r));
      }
    }
    return this.viewports = t.sort((a, i) => a.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? yp : new pm(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(bo(t, this.scaler));
    });
  }
  update(t, n = null) {
    this.state = t.state;
    let a = this.stateDeco;
    this.stateDeco = this.state.facet(Go).filter((c) => typeof c != "function");
    let i = t.changedRanges, l = Aa.extendWithRanges(i, fQ(a, this.stateDeco, t ? t.changes : Mn.empty(this.state.doc.length))), r = this.heightMap.height, s = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    vp(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), l), (this.heightMap.height != r || _s) && (t.flags |= 2), s ? (this.scrollAnchorPos = t.changes.mapPos(s.from, -1), this.scrollAnchorHeight = s.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let o = l.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (n && (n.range.head < o.from || n.range.head > o.to) || !this.viewportIsAppropriate(o)) && (o = this.getViewport(0, n));
    let u = o.from != this.viewport.from || o.to != this.viewport.to;
    this.viewport = o, t.flags |= this.updateForViewport(), (u || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(t.changes), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(m6) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let n = t.contentDOM, a = window.getComputedStyle(n), i = this.heightOracle, l = a.whiteSpace;
    this.defaultTextDirection = a.direction == "rtl" ? Nt.RTL : Nt.LTR;
    let r = this.heightOracle.mustRefreshForWrapping(l), s = n.getBoundingClientRect(), o = r || this.mustMeasureContent || this.contentDOMHeight != s.height;
    this.contentDOMHeight = s.height, this.mustMeasureContent = !1;
    let u = 0, c = 0;
    if (s.width && s.height) {
      let { scaleX: S, scaleY: x } = N7(n, s);
      (S > 5e-3 && Math.abs(this.scaleX - S) > 5e-3 || x > 5e-3 && Math.abs(this.scaleY - x) > 5e-3) && (this.scaleX = S, this.scaleY = x, u |= 16, r = o = !0);
    }
    let d = (parseInt(a.paddingTop) || 0) * this.scaleY, f = (parseInt(a.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != f) && (this.paddingTop = d, this.paddingBottom = f, u |= 18), this.editorWidth != t.scrollDOM.clientWidth && (i.lineWrapping && (o = !0), this.editorWidth = t.scrollDOM.clientWidth, u |= 16);
    let h = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != h && (this.scrollAnchorHeight = -1, this.scrollTop = h), this.scrolledToBottom = z7(t.scrollDOM);
    let m = (this.printing ? gQ : mQ)(n, this.paddingTop), g = m.top - this.pixelViewport.top, v = m.bottom - this.pixelViewport.bottom;
    this.pixelViewport = m;
    let y = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (y != this.inView && (this.inView = y, y && (o = !0)), !this.inView && !this.scrollTarget && !vQ(t.dom))
      return 0;
    let b = s.width;
    if ((this.contentDOMWidth != b || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = s.width, this.editorHeight = t.scrollDOM.clientHeight, u |= 16), o) {
      let S = t.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(S) && (r = !0), r || i.lineWrapping && Math.abs(b - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: x, charWidth: w, textHeight: V } = t.docView.measureTextSize();
        r = x > 0 && i.refresh(l, x, w, V, b / w, S), r && (t.docView.minWidth = 0, u |= 16);
      }
      g > 0 && v > 0 ? c = Math.max(g, v) : g < 0 && v < 0 && (c = Math.min(g, v)), vp();
      for (let x of this.viewports) {
        let w = x.from == this.viewport.from ? S : t.docView.measureVisibleLineHeights(x);
        this.heightMap = (r ? sa.empty().applyChanges(this.stateDeco, gt.empty, this.heightOracle, [new Aa(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(i, 0, r, new uQ(x.from, w));
      }
      _s && (u |= 2);
    }
    let C = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return C && (u & 2 && (u |= this.updateScaler()), this.viewport = this.getViewport(c, this.scrollTarget), u |= this.updateForViewport()), (u & 2 || C) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(r ? [] : this.lineGaps, t)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, n) {
    let a = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), i = this.heightMap, l = this.heightOracle, { visibleTop: r, visibleBottom: s } = this, o = new nc(i.lineAt(r - a * 1e3, Et.ByHeight, l, 0, 0).from, i.lineAt(s + (1 - a) * 1e3, Et.ByHeight, l, 0, 0).to);
    if (n) {
      let { head: u } = n.range;
      if (u < o.from || u > o.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = i.lineAt(u, Et.ByPos, l, 0, 0), f;
        n.y == "center" ? f = (d.top + d.bottom) / 2 - c / 2 : n.y == "start" || n.y == "nearest" && u < o.from ? f = d.top : f = d.bottom - c, o = new nc(i.lineAt(f - 1e3 / 2, Et.ByHeight, l, 0, 0).from, i.lineAt(f + c + 1e3 / 2, Et.ByHeight, l, 0, 0).to);
      }
    }
    return o;
  }
  mapViewport(t, n) {
    let a = n.mapPos(t.from, -1), i = n.mapPos(t.to, 1);
    return new nc(this.heightMap.lineAt(a, Et.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Et.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: n }, a = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(t, Et.ByPos, this.heightOracle, 0, 0), { bottom: l } = this.heightMap.lineAt(n, Et.ByPos, this.heightOracle, 0, 0), { visibleTop: r, visibleBottom: s } = this;
    return (t == 0 || i <= r - Math.max(10, Math.min(
      -a,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || l >= s + Math.max(10, Math.min(
      a,
      250
      /* VP.MaxCoverMargin */
    ))) && i > r - 2 * 1e3 && l < s + 2 * 1e3;
  }
  mapLineGaps(t, n) {
    if (!t.length || n.empty)
      return t;
    let a = [];
    for (let i of t)
      n.touchesRange(i.from, i.to) || a.push(new uf(n.mapPos(i.from), n.mapPos(i.to), i.size, i.displaySize));
    return a;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, n) {
    let a = this.heightOracle.lineWrapping, i = a ? 1e4 : 2e3, l = i >> 1, r = i << 1;
    if (this.defaultTextDirection != Nt.LTR && !a)
      return [];
    let s = [], o = (c, d, f, h) => {
      if (d - c < l)
        return;
      let m = this.state.selection.main, g = [m.from];
      m.empty || g.push(m.to);
      for (let y of g)
        if (y > c && y < d) {
          o(c, y - 10, f, h), o(y + 10, d, f, h);
          return;
        }
      let v = OQ(t, (y) => y.from >= f.from && y.to <= f.to && Math.abs(y.from - c) < l && Math.abs(y.to - d) < l && !g.some((b) => y.from < b && y.to > b));
      if (!v) {
        if (d < f.to && n && a && n.visibleRanges.some((C) => C.from <= d && C.to >= d)) {
          let C = n.moveToLineBoundary(we.cursor(d), !1, !0).head;
          C > c && (d = C);
        }
        let y = this.gapSize(f, c, d, h), b = a || y < 2e6 ? y : 2e6;
        v = new uf(c, d, y, b);
      }
      s.push(v);
    }, u = (c) => {
      if (c.length < r || c.type != ra.Text)
        return;
      let d = yQ(c.from, c.to, this.stateDeco);
      if (d.total < r)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, h, m;
      if (a) {
        let g = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, v, y;
        if (f != null) {
          let b = ic(d, f), C = ((this.visibleBottom - this.visibleTop) / 2 + g) / c.height;
          v = b - C, y = b + C;
        } else
          v = (this.visibleTop - c.top - g) / c.height, y = (this.visibleBottom - c.top + g) / c.height;
        h = ac(d, v), m = ac(d, y);
      } else {
        let g = d.total * this.heightOracle.charWidth, v = i * this.heightOracle.charWidth, y = 0;
        if (g > 2e6)
          for (let w of t)
            w.from >= c.from && w.from < c.to && w.size != w.displaySize && w.from * this.heightOracle.charWidth + y < this.pixelViewport.left && (y = w.size - w.displaySize);
        let b = this.pixelViewport.left + y, C = this.pixelViewport.right + y, S, x;
        if (f != null) {
          let w = ic(d, f), V = ((C - b) / 2 + v) / g;
          S = w - V, x = w + V;
        } else
          S = (b - v) / g, x = (C + v) / g;
        h = ac(d, S), m = ac(d, x);
      }
      h > c.from && o(c.from, h, c, d), m < c.to && o(m, c.to, c, d);
    };
    for (let c of this.viewportLines)
      Array.isArray(c.type) ? c.type.forEach(u) : u(c);
    return s;
  }
  gapSize(t, n, a, i) {
    let l = ic(i, a) - ic(i, n);
    return this.heightOracle.lineWrapping ? t.height * l : i.total * this.heightOracle.charWidth * l;
  }
  updateLineGaps(t) {
    uf.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = qe.set(t.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(t) {
    let n = this.stateDeco;
    this.lineGaps.length && (n = n.concat(this.lineGapDeco));
    let a = [];
    mt.spans(n, this.viewport.from, this.viewport.to, {
      span(l, r) {
        a.push({ from: l, to: r });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (a.length != this.visibleRanges.length)
      i = 12;
    else
      for (let l = 0; l < a.length && !(i & 8); l++) {
        let r = this.visibleRanges[l], s = a[l];
        (r.from != s.from || r.to != s.to) && (i |= 4, t && t.mapPos(r.from, -1) == s.from && t.mapPos(r.to, 1) == s.to || (i |= 8));
      }
    return this.visibleRanges = a, i;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((n) => n.from <= t && n.to >= t) || bo(this.heightMap.lineAt(t, Et.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= t && n.bottom >= t) || bo(this.heightMap.lineAt(this.scaler.fromDOM(t), Et.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let n = this.lineBlockAtHeight(t + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return bo(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class nc {
  constructor(t, n) {
    this.from = t, this.to = n;
  }
}
function yQ(e, t, n) {
  let a = [], i = e, l = 0;
  return mt.spans(n, e, t, {
    span() {
    },
    point(r, s) {
      r > i && (a.push({ from: i, to: r }), l += r - i), i = s;
    }
  }, 20), i < t && (a.push({ from: i, to: t }), l += t - i), { total: l, ranges: a };
}
function ac({ total: e, ranges: t }, n) {
  if (n <= 0)
    return t[0].from;
  if (n >= 1)
    return t[t.length - 1].to;
  let a = Math.floor(e * n);
  for (let i = 0; ; i++) {
    let { from: l, to: r } = t[i], s = r - l;
    if (a <= s)
      return l + a;
    a -= s;
  }
}
function ic(e, t) {
  let n = 0;
  for (let { from: a, to: i } of e.ranges) {
    if (t <= i) {
      n += t - a;
      break;
    }
    n += i - a;
  }
  return n / e.total;
}
function OQ(e, t) {
  for (let n of e)
    if (t(n))
      return n;
}
const yp = {
  toDOM(e) {
    return e;
  },
  fromDOM(e) {
    return e;
  },
  scale: 1,
  eq(e) {
    return e == this;
  }
};
class pm {
  constructor(t, n, a) {
    let i = 0, l = 0, r = 0;
    this.viewports = a.map(({ from: s, to: o }) => {
      let u = n.lineAt(s, Et.ByPos, t, 0, 0).top, c = n.lineAt(o, Et.ByPos, t, 0, 0).bottom;
      return i += c - u, { from: s, to: o, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (n.height - i);
    for (let s of this.viewports)
      s.domTop = r + (s.top - l) * this.scale, r = s.domBottom = s.domTop + (s.bottom - s.top), l = s.bottom;
  }
  toDOM(t) {
    for (let n = 0, a = 0, i = 0; ; n++) {
      let l = n < this.viewports.length ? this.viewports[n] : null;
      if (!l || t < l.top)
        return i + (t - a) * this.scale;
      if (t <= l.bottom)
        return l.domTop + (t - l.top);
      a = l.bottom, i = l.domBottom;
    }
  }
  fromDOM(t) {
    for (let n = 0, a = 0, i = 0; ; n++) {
      let l = n < this.viewports.length ? this.viewports[n] : null;
      if (!l || t < l.domTop)
        return a + (t - i) / this.scale;
      if (t <= l.domBottom)
        return l.top + (t - l.domTop);
      a = l.bottom, i = l.domBottom;
    }
  }
  eq(t) {
    return t instanceof pm ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((n, a) => n.from == t.viewports[a].from && n.to == t.viewports[a].to) : !1;
  }
}
function bo(e, t) {
  if (t.scale == 1)
    return e;
  let n = t.toDOM(e.top), a = t.toDOM(e.bottom);
  return new vi(e.from, e.length, n, a - n, Array.isArray(e._content) ? e._content.map((i) => bo(i, t)) : e._content);
}
const lc = /* @__PURE__ */ He.define({ combine: (e) => e.join(" ") }), r0 = /* @__PURE__ */ He.define({ combine: (e) => e.indexOf(!0) > -1 }), s0 = /* @__PURE__ */ _l.newName(), Q6 = /* @__PURE__ */ _l.newName(), A6 = /* @__PURE__ */ _l.newName(), D6 = { "&light": "." + Q6, "&dark": "." + A6 };
function o0(e, t, n) {
  return new _l(t, {
    finish(a) {
      return /&/.test(a) ? a.replace(/&\w*/, (i) => {
        if (i == "&")
          return e;
        if (!n || !n[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return n[i];
      }) : e + " " + a;
    }
  });
}
const bQ = /* @__PURE__ */ o0("." + s0, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, D6), CQ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, cf = Ne.ie && Ne.ie_version <= 11;
class wQ {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new lL(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((n) => {
      for (let a of n)
        this.queue.push(a);
      (Ne.ie && Ne.ie_version <= 11 || Ne.ios && t.composing) && n.some((a) => a.type == "childList" && a.removedNodes.length || a.type == "characterData" && a.oldValue.length > a.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(Ne.chrome && Ne.chrome_version < 126) && (this.editContext = new SQ(t), t.state.facet(ji) && (t.contentDOM.editContext = this.editContext.editContext)), cf && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((n, a) => n != t[a]))) {
      this.gapIntersection.disconnect();
      for (let n of t)
        this.gapIntersection.observe(n);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: a } = this, i = this.selectionRange;
    if (a.state.facet(ji) ? a.root.activeElement != this.dom : !$c(this.dom, i))
      return;
    let l = i.anchorNode && a.docView.nearest(i.anchorNode);
    if (l && l.ignoreEvent(t)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (Ne.ie && Ne.ie_version <= 11 || Ne.android && Ne.chrome) && !a.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && xo(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, n = Uo(t.root);
    if (!n)
      return !1;
    let a = Ne.safari && t.root.nodeType == 11 && t.root.activeElement == this.dom && kQ(this.view, n) || n;
    if (!a || this.selectionRange.eq(a))
      return !1;
    let i = $c(this.dom, a);
    return i && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && sL(this.dom, a) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(a), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, n) {
    this.selectionRange.set(t.node, t.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, n = null;
    for (let a = this.dom; a; )
      if (a.nodeType == 1)
        !n && t < this.scrollTargets.length && this.scrollTargets[t] == a ? t++ : n || (n = this.scrollTargets.slice(0, t)), n && n.push(a), a = a.assignedSlot || a.parentNode;
      else if (a.nodeType == 11)
        a = a.host;
      else
        break;
    if (t < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, t)), n) {
      for (let a of this.scrollTargets)
        a.removeEventListener("scroll", this.onScroll);
      for (let a of this.scrollTargets = n)
        a.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, CQ), cf && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), cf && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, n) {
    var a;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let l = this.delayedAndroidKey;
        l && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = l.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && l.force && ds(this.dom, l.key, l.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((a = this.delayedAndroidKey) === null || a === void 0) && a.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let n = -1, a = -1, i = !1;
    for (let l of t) {
      let r = this.readMutation(l);
      r && (r.typeOver && (i = !0), n == -1 ? { from: n, to: a } = r : (n = Math.min(r.from, n), a = Math.max(r.to, a)));
    }
    return { from: n, to: a, typeOver: i };
  }
  readChange() {
    let { from: t, to: n, typeOver: a } = this.processRecords(), i = this.selectionChanged && $c(this.dom, this.selectionRange);
    if (t < 0 && !i)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let l = new EL(this.view, t, n, a);
    return this.view.docView.domChanged = { newSel: l.newSel ? l.newSel.main : null }, l;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let a = this.view.state, i = k6(this.view, n);
    return this.view.state == a && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(t) {
    let n = this.view.docView.nearest(t.target);
    if (!n || n.ignoreMutation(t))
      return null;
    if (n.markDirty(t.type == "attributes"), t.type == "attributes" && (n.flags |= 4), t.type == "childList") {
      let a = Op(n, t.previousSibling || t.target.previousSibling, -1), i = Op(n, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: a ? n.posAfter(a) : n.posAtStart,
        to: i ? n.posBefore(i) : n.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet(ji) != t.state.facet(ji) && (t.view.contentDOM.editContext = t.state.facet(ji) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, n, a;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (a = this.resizeScroll) === null || a === void 0 || a.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function Op(e, t, n) {
  for (; t; ) {
    let a = Vt.get(t);
    if (a && a.parent == e)
      return a;
    let i = t.parentNode;
    t = i != e.dom ? i : n > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
function bp(e, t) {
  let n = t.startContainer, a = t.startOffset, i = t.endContainer, l = t.endOffset, r = e.docView.domAtPos(e.state.selection.main.anchor);
  return xo(r.node, r.offset, i, l) && ([n, a, i, l] = [i, l, n, a]), { anchorNode: n, anchorOffset: a, focusNode: i, focusOffset: l };
}
function kQ(e, t) {
  if (t.getComposedRanges) {
    let i = t.getComposedRanges(e.root)[0];
    if (i)
      return bp(e, i);
  }
  let n = null;
  function a(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return e.contentDOM.addEventListener("beforeinput", a, !0), e.dom.ownerDocument.execCommand("indent"), e.contentDOM.removeEventListener("beforeinput", a, !0), n ? bp(e, n) : null;
}
class SQ {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(t.state);
    let n = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (a) => {
      let i = t.state.selection.main, { anchor: l, head: r } = i, s = this.toEditorPos(a.updateRangeStart), o = this.toEditorPos(a.updateRangeEnd);
      t.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: a.updateRangeStart, editorBase: s, drifted: !1 });
      let u = { from: s, to: o, insert: gt.of(a.text.split(`
`)) };
      if (u.from == this.from && l < this.from ? u.from = l : u.to == this.to && l > this.to && (u.to = l), u.from == u.to && !u.insert.length) {
        let c = we.single(this.toEditorPos(a.selectionStart), this.toEditorPos(a.selectionEnd));
        c.main.eq(i) || t.dispatch({ selection: c, userEvent: "select" });
        return;
      }
      if ((Ne.mac || Ne.android) && u.from == r - 1 && /^\. ?$/.test(a.text) && t.contentDOM.getAttribute("autocorrect") == "off" && (u = { from: s, to: o, insert: gt.of([a.text.replace(".", " ")]) }), this.pendingContextChange = u, !t.state.readOnly) {
        let c = this.to - this.from + (u.to - u.from + u.insert.length);
        vm(t, u, we.single(this.toEditorPos(a.selectionStart, c), this.toEditorPos(a.selectionEnd, c)));
      }
      this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state));
    }, this.handlers.characterboundsupdate = (a) => {
      let i = [], l = null;
      for (let r = this.toEditorPos(a.rangeStart), s = this.toEditorPos(a.rangeEnd); r < s; r++) {
        let o = t.coordsForChar(r);
        l = o && new DOMRect(o.left, o.top, o.right - o.left, o.bottom - o.top) || l || new DOMRect(), i.push(l);
      }
      n.updateCharacterBounds(a.rangeStart, i);
    }, this.handlers.textformatupdate = (a) => {
      let i = [];
      for (let l of a.getTextFormats()) {
        let r = l.underlineStyle, s = l.underlineThickness;
        if (r != "None" && s != "None") {
          let o = this.toEditorPos(l.rangeStart), u = this.toEditorPos(l.rangeEnd);
          if (o < u) {
            let c = `text-decoration: underline ${r == "Dashed" ? "dashed " : r == "Squiggle" ? "wavy " : ""}${s == "Thin" ? 1 : 2}px`;
            i.push(qe.mark({ attributes: { style: c } }).range(o, u));
          }
        }
      }
      t.dispatch({ effects: g6.of(qe.set(i)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (t.inputState.composing = -1, t.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: a } = this.composing;
        this.composing = null, a && this.reset(t.state);
      }
    };
    for (let a in this.handlers)
      n.addEventListener(a, this.handlers[a]);
    this.measureReq = { read: (a) => {
      this.editContext.updateControlBounds(a.contentDOM.getBoundingClientRect());
      let i = Uo(a.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(t) {
    let n = 0, a = !1, i = this.pendingContextChange;
    return t.changes.iterChanges((l, r, s, o, u) => {
      if (a)
        return;
      let c = u.length - (r - l);
      if (i && r >= i.to)
        if (i.from == l && i.to == r && i.insert.eq(u)) {
          i = this.pendingContextChange = null, n += c, this.to += c;
          return;
        } else
          i = null, this.revertPending(t.state);
      if (l += n, r += n, r <= this.from)
        this.from += c, this.to += c;
      else if (l < this.to) {
        if (l < this.from || r > this.to || this.to - this.from + u.length > 3e4) {
          a = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(l), this.toContextPos(r), u.toString()), this.to += c;
      }
      n += c;
    }), i && !a && this.revertPending(t.state), !a;
  }
  update(t) {
    let n = this.pendingContextChange;
    this.composing && (this.composing.drifted || t.transactions.some((a) => !a.isUserEvent("input.type") && a.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = t.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.reset(t.state)) : (t.docChanged || t.selectionSet || n) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: n } = t.selection.main;
    this.from = Math.max(
      0,
      n - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      n + 1e4
      /* CxVp.Margin */
    );
  }
  reset(t) {
    this.resetRange(t), this.editContext.updateText(0, this.editContext.text.length, t.doc.sliceString(this.from, this.to)), this.setSelection(t);
  }
  revertPending(t) {
    let n = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), t.doc.sliceString(n.from, n.to));
  }
  setSelection(t) {
    let { main: n } = t.selection, a = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), i = this.toContextPos(n.head);
    (this.editContext.selectionStart != a || this.editContext.selectionEnd != i) && this.editContext.updateSelection(a, i);
  }
  rangeIsValid(t) {
    let { head: n } = t.selection.main;
    return !(this.from > 0 && n - this.from < 500 || this.to < t.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t, n = this.to - this.from) {
    t = Math.min(t, n);
    let a = this.composing;
    return a && a.drifted ? a.editorBase + (t - a.contextBase) : t + this.from;
  }
  toContextPos(t) {
    let n = this.composing;
    return n && n.drifted ? n.contextBase + (t - n.editorBase) : t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}
class Re {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var n;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: a } = t;
    this.dispatchTransactions = t.dispatchTransactions || a && ((i) => i.forEach((l) => a(l, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = t.root || rL(t.parent) || document, this.viewState = new pp(t.state || ot.create(t)), t.scrollTo && t.scrollTo.is(Ju) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(po).map((i) => new rf(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new wQ(this), this.inputState = new FL(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Kg(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...t) {
    let n = t.length == 1 && t[0] instanceof wn ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, a = !1, i, l = this.state;
    for (let f of t) {
      if (f.startState != l)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      l = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = l;
      return;
    }
    let r = this.hasFocus, s = 0, o = null;
    t.some((f) => f.annotation(M6)) ? (this.inputState.notifiedFocused = r, s = 1) : r != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = r, o = V6(l, r), o || (s = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(l.doc) || !this.state.selection.eq(l.selection)) && (c = null)) : this.observer.clear(), l.facet(ot.phrases) != this.state.facet(ot.phrases))
      return this.setState(l);
    i = nd.create(this, l, t), i.flags |= s;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of t) {
        if (d && (d = d.map(f.changes)), f.scrollIntoView) {
          let { main: h } = f.state.selection;
          d = new fs(h.empty ? h : we.cursor(h.head, h.head > h.anchor ? -1 : 1));
        }
        for (let h of f.effects)
          h.is(Ju) && (d = h.value.clip(this.state));
      }
      this.viewState.update(i, d), this.bidiCache = id.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(yo) != this.styleModules && this.mountStyles(), a = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(n, t.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(lc) != i.state.facet(lc) && (this.viewState.mustMeasureContent = !0), (n || a || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !i.empty)
      for (let f of this.state.facet(n0))
        try {
          f(i);
        } catch (h) {
          aa(this.state, h, "update listener");
        }
    (o || c) && Promise.resolve().then(() => {
      o && this.state == o.startState && this.dispatch(o), c && !k6(this, c) && u.force && ds(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let a of this.plugins)
        a.destroy(this);
      this.viewState = new pp(t), this.plugins = t.facet(po).map((a) => new rf(a)), this.pluginMap.clear();
      for (let a of this.plugins)
        a.update(this);
      this.docView.destroy(), this.docView = new Kg(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let n = t.startState.facet(po), a = t.state.facet(po);
    if (n != a) {
      let i = [];
      for (let l of a) {
        let r = n.indexOf(l);
        if (r < 0)
          i.push(new rf(l));
        else {
          let s = this.plugins[r];
          s.mustUpdate = t, i.push(s);
        }
      }
      for (let l of this.plugins)
        l.mustUpdate != t && l.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = t;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    n != a && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let n = t.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (a) {
          aa(this.state, a, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let n = null, a = this.scrollDOM, i = a.scrollTop * this.scaleY, { scrollAnchorPos: l, scrollAnchorHeight: r } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (r = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let s = 0; ; s++) {
        if (r < 0)
          if (z7(a))
            l = -1, r = this.viewState.heightMap.height;
          else {
            let h = this.viewState.scrollAnchorAt(i);
            l = h.from, r = h.top;
          }
        this.updateState = 1;
        let o = this.viewState.measure(this);
        if (!o && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (s > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        o & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((h) => {
          try {
            return h.read(this);
          } catch (m) {
            return aa(this.state, m), Cp;
          }
        }), d = nd.create(this, this.state, []), f = !1;
        d.flags |= o, n ? n.flags |= o : n = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), f = this.docView.update(d), f && this.docViewUpdate());
        for (let h = 0; h < u.length; h++)
          if (c[h] != Cp)
            try {
              let m = u[h];
              m.write && m.write(c[h], this);
            } catch (m) {
              aa(this.state, m);
            }
        if (f && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, r = -1;
              continue;
            } else {
              let m = (l < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(l).top) - r;
              if (m > 1 || m < -1) {
                i = i + m, a.scrollTop = i / this.scaleY, r = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let s of this.state.facet(n0))
        s(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return s0 + " " + (this.state.facet(r0) ? A6 : Q6) + " " + this.state.facet(lc);
  }
  updateAttrs() {
    let t = wp(this, p6, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(ji) ? "true" : "false",
      class: "cm-content",
      style: `${Ne.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), wp(this, fm, n);
    let a = this.observer.ignore(() => {
      let i = Gh(this.contentDOM, this.contentAttrs, n), l = Gh(this.dom, this.editorAttrs, t);
      return i || l;
    });
    return this.editorAttrs = t, this.contentAttrs = n, a;
  }
  showAnnouncements(t) {
    let n = !0;
    for (let a of t)
      for (let i of a.effects)
        if (i.is(Re.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let l = this.announceDOM.appendChild(document.createElement("div"));
          l.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(yo);
    let t = this.state.facet(Re.cspNonce);
    _l.mount(this.root, this.styleModules.concat(bQ).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === t.key) {
            this.measureRequests[n] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let n = this.pluginMap.get(t);
    return (n === void 0 || n && n.spec != t) && this.pluginMap.set(t, n = this.plugins.find((a) => a.spec == t) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, n, a) {
    return of(this, t, ap(this, t, n, a));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, n) {
    return of(this, t, ap(this, t, n, (a) => RL(this, t.head, a)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, n) {
    let a = this.bidiSpans(t), i = this.textDirectionAt(t.from), l = a[n ? a.length - 1 : 0];
    return we.cursor(l.side(n, i) + t.from, l.forward(!n, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, n, a = !0) {
    return DL(this, t, n, a);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, n, a) {
    return of(this, t, IL(this, t, n, a));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, n = 0) {
    return this.docView.posFromDOM(t, n);
  }
  posAtCoords(t, n = !0) {
    return this.readMeasured(), w6(this, t, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, n = 1) {
    this.readMeasured();
    let a = this.docView.coordsAt(t, n);
    if (!a || a.left == a.right)
      return a;
    let i = this.state.doc.lineAt(t), l = this.bidiSpans(i), r = l[Cl.find(l, t - i.from, -1, n)];
    return _u(a, r.dir == Nt.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(h6) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > xQ)
      return l6(t.length);
    let n = this.textDirectionAt(t.from), a;
    for (let l of this.bidiCache)
      if (l.from == t.from && l.dir == n && (l.fresh || i6(l.isolates, a = Gg(this, t))))
        return l.order;
    a || (a = Gg(this, t));
    let i = OL(t.text, n, a);
    return this.bidiCache.push(new id(t.from, t.to, n, a, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || Ne.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      H7(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, n = {}) {
    return Ju.of(new fs(typeof t == "number" ? we.cursor(t) : t, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: n } = this.scrollDOM, a = this.viewState.scrollAnchorAt(t);
    return Ju.of(new fs(we.cursor(a.from), "start", "start", a.top - t, n, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return rn.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return rn.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, n) {
    let a = _l.newName(), i = [lc.of(a), yo.of(o0(`.${a}`, t))];
    return n && n.dark && i.push(r0.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return El.lowest(yo.of(o0("." + s0, t, D6)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var n;
    let a = t.querySelector(".cm-content"), i = a && Vt.get(a) || Vt.get(t);
    return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
Re.styleModule = yo;
Re.inputHandler = d6;
Re.clipboardInputFilter = cm;
Re.clipboardOutputFilter = dm;
Re.scrollHandler = v6;
Re.focusChangeEffect = f6;
Re.perLineTextDirection = h6;
Re.exceptionSink = c6;
Re.updateListener = n0;
Re.editable = ji;
Re.mouseSelectionStyle = u6;
Re.dragMovesSelection = o6;
Re.clickAddsSelectionRange = s6;
Re.decorations = Go;
Re.outerDecorations = y6;
Re.atomicRanges = hm;
Re.bidiIsolatedRanges = O6;
Re.scrollMargins = b6;
Re.darkTheme = r0;
Re.cspNonce = /* @__PURE__ */ He.define({ combine: (e) => e.length ? e[0] : "" });
Re.contentAttributes = fm;
Re.editorAttributes = p6;
Re.lineWrapping = /* @__PURE__ */ Re.contentAttributes.of({ class: "cm-lineWrapping" });
Re.announce = /* @__PURE__ */ at.define();
const xQ = 4096, Cp = {};
class id {
  constructor(t, n, a, i, l, r) {
    this.from = t, this.to = n, this.dir = a, this.isolates = i, this.fresh = l, this.order = r;
  }
  static update(t, n) {
    if (n.empty && !t.some((l) => l.fresh))
      return t;
    let a = [], i = t.length ? t[t.length - 1].dir : Nt.LTR;
    for (let l = Math.max(0, t.length - 10); l < t.length; l++) {
      let r = t[l];
      r.dir == i && !n.touchesRange(r.from, r.to) && a.push(new id(n.mapPos(r.from, 1), n.mapPos(r.to, -1), r.dir, r.isolates, !1, r.order));
    }
    return a;
  }
}
function wp(e, t, n) {
  for (let a = e.state.facet(t), i = a.length - 1; i >= 0; i--) {
    let l = a[i], r = typeof l == "function" ? l(e) : l;
    r && Uh(r, n);
  }
  return n;
}
const PQ = Ne.mac ? "mac" : Ne.windows ? "win" : Ne.linux ? "linux" : "key";
function $Q(e, t) {
  const n = e.split(/-(?!$)/);
  let a = n[n.length - 1];
  a == "Space" && (a = " ");
  let i, l, r, s;
  for (let o = 0; o < n.length - 1; ++o) {
    const u = n[o];
    if (/^(cmd|meta|m)$/i.test(u))
      s = !0;
    else if (/^a(lt)?$/i.test(u))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      l = !0;
    else if (/^s(hift)?$/i.test(u))
      r = !0;
    else if (/^mod$/i.test(u))
      t == "mac" ? s = !0 : l = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return i && (a = "Alt-" + a), l && (a = "Ctrl-" + a), s && (a = "Meta-" + a), r && (a = "Shift-" + a), a;
}
function rc(e, t, n) {
  return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n !== !1 && t.shiftKey && (e = "Shift-" + e), e;
}
const _Q = /* @__PURE__ */ El.default(/* @__PURE__ */ Re.domEventHandlers({
  keydown(e, t) {
    return I6(R6(t.state), e, t, "editor");
  }
})), Tl = /* @__PURE__ */ He.define({ enables: _Q }), kp = /* @__PURE__ */ new WeakMap();
function R6(e) {
  let t = e.facet(Tl), n = kp.get(t);
  return n || kp.set(t, n = TQ(t.reduce((a, i) => a.concat(i), []))), n;
}
function MQ(e, t, n) {
  return I6(R6(e.state), t, e, n);
}
let yl = null;
const VQ = 4e3;
function TQ(e, t = PQ) {
  let n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null), i = (r, s) => {
    let o = a[r];
    if (o == null)
      a[r] = s;
    else if (o != s)
      throw new Error("Key binding " + r + " is used both as a regular binding and as a multi-stroke prefix");
  }, l = (r, s, o, u, c) => {
    var d, f;
    let h = n[r] || (n[r] = /* @__PURE__ */ Object.create(null)), m = s.split(/ (?!$)/).map((y) => $Q(y, t));
    for (let y = 1; y < m.length; y++) {
      let b = m.slice(0, y).join(" ");
      i(b, !0), h[b] || (h[b] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(C) => {
          let S = yl = { view: C, prefix: b, scope: r };
          return setTimeout(() => {
            yl == S && (yl = null);
          }, VQ), !0;
        }]
      });
    }
    let g = m.join(" ");
    i(g, !1);
    let v = h[g] || (h[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (d = h._any) === null || d === void 0 ? void 0 : d.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    o && v.run.push(o), u && (v.preventDefault = !0), c && (v.stopPropagation = !0);
  };
  for (let r of e) {
    let s = r.scope ? r.scope.split(" ") : ["editor"];
    if (r.any)
      for (let u of s) {
        let c = n[u] || (n[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: d } = r;
        for (let f in c)
          c[f].run.push((h) => d(h, u0));
      }
    let o = r[t] || r.key;
    if (o)
      for (let u of s)
        l(u, o, r.run, r.preventDefault, r.stopPropagation), r.shift && l(u, "Shift-" + o, r.shift, r.preventDefault, r.stopPropagation);
  }
  return n;
}
let u0 = null;
function I6(e, t, n, a) {
  u0 = t;
  let i = tL(t), l = ca(i, 0), r = mi(l) == i.length && i != " ", s = "", o = !1, u = !1, c = !1;
  yl && yl.view == n && yl.scope == a && (s = yl.prefix + " ", x6.indexOf(t.keyCode) < 0 && (u = !0, yl = null));
  let d = /* @__PURE__ */ new Set(), f = (v) => {
    if (v) {
      for (let y of v.run)
        if (!d.has(y) && (d.add(y), y(n)))
          return v.stopPropagation && (c = !0), !0;
      v.preventDefault && (v.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, h = e[a], m, g;
  return h && (f(h[s + rc(i, t, !r)]) ? o = !0 : r && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Ne.windows && t.ctrlKey && t.altKey) && (m = Ml[t.keyCode]) && m != i ? (f(h[s + rc(m, t, !0)]) || t.shiftKey && (g = qo[t.keyCode]) != i && g != m && f(h[s + rc(g, t, !1)])) && (o = !0) : r && t.shiftKey && f(h[s + rc(i, t, !0)]) && (o = !0), !o && f(h._any) && (o = !0)), u && (o = !0), o && c && t.stopPropagation(), u0 = null, o;
}
class Tu {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(t, n, a, i, l) {
    this.className = t, this.left = n, this.top = a, this.width = i, this.height = l;
  }
  draw() {
    let t = document.createElement("div");
    return t.className = this.className, this.adjust(t), t;
  }
  update(t, n) {
    return n.className != this.className ? !1 : (this.adjust(t), !0);
  }
  adjust(t) {
    t.style.left = this.left + "px", t.style.top = this.top + "px", this.width != null && (t.style.width = this.width + "px"), t.style.height = this.height + "px";
  }
  eq(t) {
    return this.left == t.left && this.top == t.top && this.width == t.width && this.height == t.height && this.className == t.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(t, n, a) {
    if (a.empty) {
      let i = t.coordsAtPos(a.head, a.assoc || 1);
      if (!i)
        return [];
      let l = B6(t);
      return [new Tu(n, i.left - l.left, i.top - l.top, null, i.bottom - i.top)];
    } else
      return LQ(t, n, a);
  }
}
function B6(e) {
  let t = e.scrollDOM.getBoundingClientRect();
  return { left: (e.textDirection == Nt.LTR ? t.left : t.right - e.scrollDOM.clientWidth * e.scaleX) - e.scrollDOM.scrollLeft * e.scaleX, top: t.top - e.scrollDOM.scrollTop * e.scaleY };
}
function Sp(e, t, n, a) {
  let i = e.coordsAtPos(t, n * 2);
  if (!i)
    return a;
  let l = e.dom.getBoundingClientRect(), r = (i.top + i.bottom) / 2, s = e.posAtCoords({ x: l.left + 1, y: r }), o = e.posAtCoords({ x: l.right - 1, y: r });
  return s == null || o == null ? a : { from: Math.max(a.from, Math.min(s, o)), to: Math.min(a.to, Math.max(s, o)) };
}
function LQ(e, t, n) {
  if (n.to <= e.viewport.from || n.from >= e.viewport.to)
    return [];
  let a = Math.max(n.from, e.viewport.from), i = Math.min(n.to, e.viewport.to), l = e.textDirection == Nt.LTR, r = e.contentDOM, s = r.getBoundingClientRect(), o = B6(e), u = r.querySelector(".cm-line"), c = u && window.getComputedStyle(u), d = s.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), f = s.right - (c ? parseInt(c.paddingRight) : 0), h = i0(e, a), m = i0(e, i), g = h.type == ra.Text ? h : null, v = m.type == ra.Text ? m : null;
  if (g && (e.lineWrapping || h.widgetLineBreaks) && (g = Sp(e, a, 1, g)), v && (e.lineWrapping || m.widgetLineBreaks) && (v = Sp(e, i, -1, v)), g && v && g.from == v.from && g.to == v.to)
    return b(C(n.from, n.to, g));
  {
    let x = g ? C(n.from, null, g) : S(h, !1), w = v ? C(null, n.to, v) : S(m, !0), V = [];
    return (g || h).to < (v || m).from - (g && v ? 1 : 0) || h.widgetLineBreaks > 1 && x.bottom + e.defaultLineHeight / 2 < w.top ? V.push(y(d, x.bottom, f, w.top)) : x.bottom < w.top && e.elementAtHeight((x.bottom + w.top) / 2).type == ra.Text && (x.bottom = w.top = (x.bottom + w.top) / 2), b(x).concat(V).concat(b(w));
  }
  function y(x, w, V, _) {
    return new Tu(t, x - o.left, w - o.top, V - x, _ - w);
  }
  function b({ top: x, bottom: w, horizontal: V }) {
    let _ = [];
    for (let O = 0; O < V.length; O += 2)
      _.push(y(V[O], x, V[O + 1], w));
    return _;
  }
  function C(x, w, V) {
    let _ = 1e9, O = -1e9, $ = [];
    function P(L, A, D, B, j) {
      let I = e.coordsAtPos(L, L == V.to ? -2 : 2), Z = e.coordsAtPos(D, D == V.from ? 2 : -2);
      !I || !Z || (_ = Math.min(I.top, Z.top, _), O = Math.max(I.bottom, Z.bottom, O), j == Nt.LTR ? $.push(l && A ? d : I.left, l && B ? f : Z.right) : $.push(!l && B ? d : Z.left, !l && A ? f : I.right));
    }
    let M = x ?? V.from, T = w ?? V.to;
    for (let L of e.visibleRanges)
      if (L.to > M && L.from < T)
        for (let A = Math.max(L.from, M), D = Math.min(L.to, T); ; ) {
          let B = e.state.doc.lineAt(A);
          for (let j of e.bidiSpans(B)) {
            let I = j.from + B.from, Z = j.to + B.from;
            if (I >= D)
              break;
            Z > A && P(Math.max(I, A), x == null && I <= M, Math.min(Z, D), w == null && Z >= T, j.dir);
          }
          if (A = B.to + 1, A >= D)
            break;
        }
    return $.length == 0 && P(M, x == null, T, w == null, e.textDirection), { top: _, bottom: O, horizontal: $ };
  }
  function S(x, w) {
    let V = s.top + (w ? x.top : x.bottom);
    return { top: V, bottom: V, horizontal: [] };
  }
}
function QQ(e, t) {
  return e.constructor == t.constructor && e.eq(t);
}
class AQ {
  constructor(t, n) {
    this.view = t, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = t.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(t.state), t.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, t);
  }
  update(t) {
    t.startState.facet(Tc) != t.state.facet(Tc) && this.setOrder(t.state), (this.layer.update(t, this.dom) || t.geometryChanged) && (this.scale(), t.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(t) {
    this.layer.updateOnDocViewUpdate !== !1 && t.requestMeasure(this.measureReq);
  }
  setOrder(t) {
    let n = 0, a = t.facet(Tc);
    for (; n < a.length && a[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: t, scaleY: n } = this.view;
    (t != this.scaleX || n != this.scaleY) && (this.scaleX = t, this.scaleY = n, this.dom.style.transform = `scale(${1 / t}, ${1 / n})`);
  }
  draw(t) {
    if (t.length != this.drawn.length || t.some((n, a) => !QQ(n, this.drawn[a]))) {
      let n = this.dom.firstChild, a = 0;
      for (let i of t)
        i.update && n && i.constructor && this.drawn[a].constructor && i.update(n, this.drawn[a]) ? (n = n.nextSibling, a++) : this.dom.insertBefore(i.draw(), n);
      for (; n; ) {
        let i = n.nextSibling;
        n.remove(), n = i;
      }
      this.drawn = t;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Tc = /* @__PURE__ */ He.define();
function Z6(e) {
  return [
    rn.define((t) => new AQ(t, e)),
    Tc.of(e)
  ];
}
const E6 = !(Ne.ios && Ne.webkit && Ne.webkit_version < 534), Ko = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (t, n) => Math.min(t, n),
      drawRangeCursor: (t, n) => t || n
    });
  }
});
function N6(e = {}) {
  return [
    Ko.of(e),
    DQ,
    RQ,
    IQ,
    m6.of(!0)
  ];
}
function H6(e) {
  return e.startState.facet(Ko) != e.state.facet(Ko);
}
const DQ = /* @__PURE__ */ Z6({
  above: !0,
  markers(e) {
    let { state: t } = e, n = t.facet(Ko), a = [];
    for (let i of t.selection.ranges) {
      let l = i == t.selection.main;
      if (i.empty ? !l || E6 : n.drawRangeCursor) {
        let r = l ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", s = i.empty ? i : we.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let o of Tu.forRange(e, r, s))
          a.push(o);
      }
    }
    return a;
  },
  update(e, t) {
    e.transactions.some((a) => a.selection) && (t.style.animationName = t.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = H6(e);
    return n && xp(e.state, t), e.docChanged || e.selectionSet || n;
  },
  mount(e, t) {
    xp(t.state, e);
  },
  class: "cm-cursorLayer"
});
function xp(e, t) {
  t.style.animationDuration = e.facet(Ko).cursorBlinkRate + "ms";
}
const RQ = /* @__PURE__ */ Z6({
  above: !1,
  markers(e) {
    return e.state.selection.ranges.map((t) => t.empty ? [] : Tu.forRange(e, "cm-selectionBackground", t)).reduce((t, n) => t.concat(n));
  },
  update(e, t) {
    return e.docChanged || e.selectionSet || e.viewportChanged || H6(e);
  },
  class: "cm-selectionLayer"
}), c0 = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
E6 && (c0[".cm-line"].caretColor = c0[".cm-content"].caretColor = "transparent !important");
const IQ = /* @__PURE__ */ El.highest(/* @__PURE__ */ Re.theme(c0)), j6 = /* @__PURE__ */ at.define({
  map(e, t) {
    return e == null ? null : t.mapPos(e);
  }
}), Co = /* @__PURE__ */ $n.define({
  create() {
    return null;
  },
  update(e, t) {
    return e != null && (e = t.changes.mapPos(e)), t.effects.reduce((n, a) => a.is(j6) ? a.value : n, e);
  }
}), BQ = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.view = e, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(e) {
    var t;
    let n = e.state.field(Co);
    n == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (e.startState.field(Co) != n || e.docChanged || e.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: e } = this, t = e.state.field(Co), n = t != null && e.coordsAtPos(t);
    if (!n)
      return null;
    let a = e.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - a.left + e.scrollDOM.scrollLeft * e.scaleX,
      top: n.top - a.top + e.scrollDOM.scrollTop * e.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(e) {
    if (this.cursor) {
      let { scaleX: t, scaleY: n } = this.view;
      e ? (this.cursor.style.left = e.left / t + "px", this.cursor.style.top = e.top / n + "px", this.cursor.style.height = e.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(e) {
    this.view.state.field(Co) != e && this.view.dispatch({ effects: j6.of(e) });
  }
}, {
  eventObservers: {
    dragover(e) {
      this.setDropPos(this.view.posAtCoords({ x: e.clientX, y: e.clientY }));
    },
    dragleave(e) {
      (e.target == this.view.contentDOM || !this.view.contentDOM.contains(e.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function ZQ() {
  return [Co, BQ];
}
function Pp(e, t, n, a, i) {
  t.lastIndex = 0;
  for (let l = e.iterRange(n, a), r = n, s; !l.next().done; r += l.value.length)
    if (!l.lineBreak)
      for (; s = t.exec(l.value); )
        i(r + s.index, s);
}
function EQ(e, t) {
  let n = e.visibleRanges;
  if (n.length == 1 && n[0].from == e.viewport.from && n[0].to == e.viewport.to)
    return n;
  let a = [];
  for (let { from: i, to: l } of n)
    i = Math.max(e.state.doc.lineAt(i).from, i - t), l = Math.min(e.state.doc.lineAt(l).to, l + t), a.length && a[a.length - 1].to >= i ? a[a.length - 1].to = l : a.push({ from: i, to: l });
  return a;
}
class NQ {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: n, decoration: a, decorate: i, boundary: l, maxLength: r = 1e3 } = t;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, i)
      this.addMatch = (s, o, u, c) => i(c, u, u + s[0].length, s, o);
    else if (typeof a == "function")
      this.addMatch = (s, o, u, c) => {
        let d = a(s, o, u);
        d && c(u, u + s[0].length, d);
      };
    else if (a)
      this.addMatch = (s, o, u, c) => c(u, u + s[0].length, a);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = l, this.maxLength = r;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let n = new Gi(), a = n.add.bind(n);
    for (let { from: i, to: l } of EQ(t, this.maxLength))
      Pp(t.state.doc, this.regexp, i, l, (r, s) => this.addMatch(s, t, r, a));
    return n.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, n) {
    let a = 1e9, i = -1;
    return t.docChanged && t.changes.iterChanges((l, r, s, o) => {
      o >= t.view.viewport.from && s <= t.view.viewport.to && (a = Math.min(s, a), i = Math.max(o, i));
    }), t.viewportMoved || i - a > 1e3 ? this.createDeco(t.view) : i > -1 ? this.updateRange(t.view, n.map(t.changes), a, i) : n;
  }
  updateRange(t, n, a, i) {
    for (let l of t.visibleRanges) {
      let r = Math.max(l.from, a), s = Math.min(l.to, i);
      if (s > r) {
        let o = t.state.doc.lineAt(r), u = o.to < s ? t.state.doc.lineAt(s) : o, c = Math.max(l.from, o.from), d = Math.min(l.to, u.to);
        if (this.boundary) {
          for (; r > o.from; r--)
            if (this.boundary.test(o.text[r - 1 - o.from])) {
              c = r;
              break;
            }
          for (; s < u.to; s++)
            if (this.boundary.test(u.text[s - u.from])) {
              d = s;
              break;
            }
        }
        let f = [], h, m = (g, v, y) => f.push(y.range(g, v));
        if (o == u)
          for (this.regexp.lastIndex = c - o.from; (h = this.regexp.exec(o.text)) && h.index < d - o.from; )
            this.addMatch(h, t, h.index + o.from, m);
        else
          Pp(t.state.doc, this.regexp, c, d, (g, v) => this.addMatch(v, t, g, m));
        n = n.update({ filterFrom: c, filterTo: d, filter: (g, v) => g < c || v > d, add: f });
      }
    }
    return n;
  }
}
const d0 = /x/.unicode != null ? "gu" : "g", HQ = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, d0), jQ = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let df = null;
function zQ() {
  var e;
  if (df == null && typeof document < "u" && document.body) {
    let t = document.body.style;
    df = ((e = t.tabSize) !== null && e !== void 0 ? e : t.MozTabSize) != null;
  }
  return df || !1;
}
const Lc = /* @__PURE__ */ He.define({
  combine(e) {
    let t = ii(e, {
      render: null,
      specialChars: HQ,
      addSpecialChars: null
    });
    return (t.replaceTabs = !zQ()) && (t.specialChars = new RegExp("	|" + t.specialChars.source, d0)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, d0)), t;
  }
});
function z6(e = {}) {
  return [Lc.of(e), FQ()];
}
let $p = null;
function FQ() {
  return $p || ($p = rn.fromClass(class {
    constructor(e) {
      this.view = e, this.decorations = qe.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(e.state.facet(Lc)), this.decorations = this.decorator.createDeco(e);
    }
    makeDecorator(e) {
      return new NQ({
        regexp: e.specialChars,
        decoration: (t, n, a) => {
          let { doc: i } = n.state, l = ca(t[0], 0);
          if (l == 9) {
            let r = i.lineAt(a), s = n.state.tabSize, o = Js(r.text, s, a - r.from);
            return qe.replace({
              widget: new qQ((s - o % s) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[l] || (this.decorationCache[l] = qe.replace({ widget: new WQ(e, l) }));
        },
        boundary: e.replaceTabs ? void 0 : /[^]/
      });
    }
    update(e) {
      let t = e.state.facet(Lc);
      e.startState.facet(Lc) != t ? (this.decorator = this.makeDecorator(t), this.decorations = this.decorator.createDeco(e.view)) : this.decorations = this.decorator.updateDeco(e, this.decorations);
    }
  }, {
    decorations: (e) => e.decorations
  }));
}
const XQ = "•";
function YQ(e) {
  return e >= 32 ? XQ : e == 10 ? "␤" : String.fromCharCode(9216 + e);
}
class WQ extends Ii {
  constructor(t, n) {
    super(), this.options = t, this.code = n;
  }
  eq(t) {
    return t.code == this.code;
  }
  toDOM(t) {
    let n = YQ(this.code), a = t.state.phrase("Control character") + " " + (jQ[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, a, n);
    if (i)
      return i;
    let l = document.createElement("span");
    return l.textContent = n, l.title = a, l.setAttribute("aria-label", a), l.className = "cm-specialChar", l;
  }
  ignoreEvent() {
    return !1;
  }
}
class qQ extends Ii {
  constructor(t) {
    super(), this.width = t;
  }
  eq(t) {
    return t.width == this.width;
  }
  toDOM() {
    let t = document.createElement("span");
    return t.textContent = "	", t.className = "cm-tab", t.style.width = this.width + "px", t;
  }
  ignoreEvent() {
    return !1;
  }
}
function UQ() {
  return KQ;
}
const GQ = /* @__PURE__ */ qe.line({ class: "cm-activeLine" }), KQ = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.decorations = this.getDeco(e);
  }
  update(e) {
    (e.docChanged || e.selectionSet) && (this.decorations = this.getDeco(e.view));
  }
  getDeco(e) {
    let t = -1, n = [];
    for (let a of e.state.selection.ranges) {
      let i = e.lineBlockAt(a.head);
      i.from > t && (n.push(GQ.range(i.from)), t = i.from);
    }
    return qe.set(n);
  }
}, {
  decorations: (e) => e.decorations
});
class JQ extends Ii {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM(t) {
    let n = document.createElement("span");
    return n.className = "cm-placeholder", n.style.pointerEvents = "none", n.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(t) : this.content.cloneNode(!0)), typeof this.content == "string" ? n.setAttribute("aria-label", "placeholder " + this.content) : n.setAttribute("aria-hidden", "true"), n;
  }
  coordsAt(t) {
    let n = t.firstChild ? xs(t.firstChild) : [];
    if (!n.length)
      return null;
    let a = window.getComputedStyle(t.parentNode), i = _u(n[0], a.direction != "rtl"), l = parseInt(a.lineHeight);
    return i.bottom - i.top > l * 1.5 ? { left: i.left, right: i.right, top: i.top, bottom: i.top + l } : i;
  }
  ignoreEvent() {
    return !1;
  }
}
function eA(e) {
  return rn.fromClass(class {
    constructor(t) {
      this.view = t, this.placeholder = e ? qe.set([qe.widget({ widget: new JQ(e), side: 1 }).range(0)]) : qe.none;
    }
    get decorations() {
      return this.view.state.doc.length ? qe.none : this.placeholder;
    }
  }, { decorations: (t) => t.decorations });
}
const f0 = 2e3;
function tA(e, t, n) {
  let a = Math.min(t.line, n.line), i = Math.max(t.line, n.line), l = [];
  if (t.off > f0 || n.off > f0 || t.col < 0 || n.col < 0) {
    let r = Math.min(t.off, n.off), s = Math.max(t.off, n.off);
    for (let o = a; o <= i; o++) {
      let u = e.doc.line(o);
      u.length <= s && l.push(we.range(u.from + r, u.to + s));
    }
  } else {
    let r = Math.min(t.col, n.col), s = Math.max(t.col, n.col);
    for (let o = a; o <= i; o++) {
      let u = e.doc.line(o), c = jh(u.text, r, e.tabSize, !0);
      if (c < 0)
        l.push(we.cursor(u.to));
      else {
        let d = jh(u.text, s, e.tabSize);
        l.push(we.range(u.from + c, u.from + d));
      }
    }
  }
  return l;
}
function nA(e, t) {
  let n = e.coordsAtPos(e.viewport.from);
  return n ? Math.round(Math.abs((n.left - t) / e.defaultCharacterWidth)) : -1;
}
function _p(e, t) {
  let n = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1), a = e.state.doc.lineAt(n), i = n - a.from, l = i > f0 ? -1 : i == a.length ? nA(e, t.clientX) : Js(a.text, e.state.tabSize, n - a.from);
  return { line: a.number, col: l, off: i };
}
function aA(e, t) {
  let n = _p(e, t), a = e.state.selection;
  return n ? {
    update(i) {
      if (i.docChanged) {
        let l = i.changes.mapPos(i.startState.doc.line(n.line).from), r = i.state.doc.lineAt(l);
        n = { line: r.number, col: n.col, off: Math.min(n.off, r.length) }, a = a.map(i.changes);
      }
    },
    get(i, l, r) {
      let s = _p(e, i);
      if (!s)
        return a;
      let o = tA(e.state, n, s);
      return o.length ? r ? we.create(o.concat(a.ranges)) : we.create(o) : a;
    }
  } : null;
}
function iA(e) {
  let t = (n) => n.altKey && n.button == 0;
  return Re.mouseSelectionStyle.of((n, a) => t(a) ? aA(n, a) : null);
}
const lA = {
  Alt: [18, (e) => !!e.altKey],
  Control: [17, (e) => !!e.ctrlKey],
  Shift: [16, (e) => !!e.shiftKey],
  Meta: [91, (e) => !!e.metaKey]
}, rA = { style: "cursor: crosshair" };
function sA(e = {}) {
  let [t, n] = lA[e.key || "Alt"], a = rn.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == t || n(i));
      },
      keyup(i) {
        (i.keyCode == t || !n(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(n(i));
      }
    }
  });
  return [
    a,
    Re.contentAttributes.of((i) => {
      var l;
      return !((l = i.plugin(a)) === null || l === void 0) && l.isDown ? rA : null;
    })
  ];
}
const oo = "-10000px";
class F6 {
  constructor(t, n, a, i) {
    this.facet = n, this.createTooltipView = a, this.removeTooltipView = i, this.input = t.state.facet(n), this.tooltips = this.input.filter((r) => r);
    let l = null;
    this.tooltipViews = this.tooltips.map((r) => l = a(r, l));
  }
  update(t, n) {
    var a;
    let i = t.state.facet(this.facet), l = i.filter((o) => o);
    if (i === this.input) {
      for (let o of this.tooltipViews)
        o.update && o.update(t);
      return !1;
    }
    let r = [], s = n ? [] : null;
    for (let o = 0; o < l.length; o++) {
      let u = l[o], c = -1;
      if (u) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let f = this.tooltips[d];
          f && f.create == u.create && (c = d);
        }
        if (c < 0)
          r[o] = this.createTooltipView(u, o ? r[o - 1] : null), s && (s[o] = !!u.above);
        else {
          let d = r[o] = this.tooltipViews[c];
          s && (s[o] = n[c]), d.update && d.update(t);
        }
      }
    }
    for (let o of this.tooltipViews)
      r.indexOf(o) < 0 && (this.removeTooltipView(o), (a = o.destroy) === null || a === void 0 || a.call(o));
    return n && (s.forEach((o, u) => n[u] = o), n.length = s.length), this.input = i, this.tooltips = l, this.tooltipViews = r, !0;
  }
}
function oA(e) {
  let { win: t } = e;
  return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth };
}
const ff = /* @__PURE__ */ He.define({
  combine: (e) => {
    var t, n, a;
    return {
      position: Ne.ios ? "absolute" : ((t = e.find((i) => i.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((n = e.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((a = e.find((i) => i.tooltipSpace)) === null || a === void 0 ? void 0 : a.tooltipSpace) || oA
    };
  }
}), Mp = /* @__PURE__ */ new WeakMap(), ym = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.view = e, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = e.state.facet(ff);
    this.position = t.position, this.parent = t.parent, this.classes = e.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new F6(e, p1, (n, a) => this.createTooltip(n, a), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), e.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let e of this.manager.tooltipViews)
        this.intersectionObserver.observe(e.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(e) {
    e.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(e, this.above);
    t && this.observeIntersection();
    let n = t || e.geometryChanged, a = e.state.facet(ff);
    if (a.position != this.position && !this.madeAbsolute) {
      this.position = a.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      n = !0;
    }
    if (a.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = a.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      n = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(e, t) {
    let n = e.create(this.view), a = t ? t.dom : null;
    if (n.dom.classList.add("cm-tooltip"), e.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", n.dom.appendChild(i);
    }
    return n.dom.style.position = this.position, n.dom.style.top = oo, n.dom.style.left = "0px", this.container.insertBefore(n.dom, a), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var e, t, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let a of this.manager.tooltipViews)
      a.dom.remove(), (e = a.destroy) === null || e === void 0 || e.call(a);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let e = 1, t = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: l } = this.manager.tooltipViews[0];
      if (Ne.gecko)
        n = l.offsetParent != this.container.ownerDocument.body;
      else if (l.style.top == oo && l.style.left == "0px") {
        let r = l.getBoundingClientRect();
        n = Math.abs(r.top + 1e4) > 1 || Math.abs(r.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let l = this.parent.getBoundingClientRect();
        l.width && l.height && (e = l.width / this.parent.offsetWidth, t = l.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: t } = this.view.viewState);
    let a = this.view.scrollDOM.getBoundingClientRect(), i = mm(this.view);
    return {
      visible: {
        left: a.left + i.left,
        top: a.top + i.top,
        right: a.right - i.right,
        bottom: a.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((l, r) => {
        let s = this.manager.tooltipViews[r];
        return s.getCoords ? s.getCoords(l.pos) : this.view.coordsAtPos(l.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: l }) => l.getBoundingClientRect()),
      space: this.view.state.facet(ff).tooltipSpace(this.view),
      scaleX: e,
      scaleY: t,
      makeAbsolute: n
    };
  }
  writeMeasure(e) {
    var t;
    if (e.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = "absolute";
    }
    let { visible: n, space: a, scaleX: i, scaleY: l } = e, r = [];
    for (let s = 0; s < this.manager.tooltips.length; s++) {
      let o = this.manager.tooltips[s], u = this.manager.tooltipViews[s], { dom: c } = u, d = e.pos[s], f = e.size[s];
      if (!d || o.clip !== !1 && (d.bottom <= Math.max(n.top, a.top) || d.top >= Math.min(n.bottom, a.bottom) || d.right < Math.max(n.left, a.left) - 0.1 || d.left > Math.min(n.right, a.right) + 0.1)) {
        c.style.top = oo;
        continue;
      }
      let h = o.arrow ? u.dom.querySelector(".cm-tooltip-arrow") : null, m = h ? 7 : 0, g = f.right - f.left, v = (t = Mp.get(u)) !== null && t !== void 0 ? t : f.bottom - f.top, y = u.offset || cA, b = this.view.textDirection == Nt.LTR, C = f.width > a.right - a.left ? b ? a.left : a.right - f.width : b ? Math.max(a.left, Math.min(d.left - (h ? 14 : 0) + y.x, a.right - g)) : Math.min(Math.max(a.left, d.left - g + (h ? 14 : 0) - y.x), a.right - g), S = this.above[s];
      !o.strictSide && (S ? d.top - v - m - y.y < a.top : d.bottom + v + m + y.y > a.bottom) && S == a.bottom - d.bottom > d.top - a.top && (S = this.above[s] = !S);
      let x = (S ? d.top - a.top : a.bottom - d.bottom) - m;
      if (x < v && u.resize !== !1) {
        if (x < this.view.defaultLineHeight) {
          c.style.top = oo;
          continue;
        }
        Mp.set(u, v), c.style.height = (v = x) / l + "px";
      } else c.style.height && (c.style.height = "");
      let w = S ? d.top - v - m - y.y : d.bottom + m + y.y, V = C + g;
      if (u.overlap !== !0)
        for (let _ of r)
          _.left < V && _.right > C && _.top < w + v && _.bottom > w && (w = S ? _.top - v - 2 - m : _.bottom + m + 2);
      if (this.position == "absolute" ? (c.style.top = (w - e.parent.top) / l + "px", Vp(c, (C - e.parent.left) / i)) : (c.style.top = w / l + "px", Vp(c, C / i)), h) {
        let _ = d.left + (b ? y.x : -y.x) - (C + 14 - 7);
        h.style.left = _ / i + "px";
      }
      u.overlap !== !0 && r.push({ left: C, top: w, right: V, bottom: w + v }), c.classList.toggle("cm-tooltip-above", S), c.classList.toggle("cm-tooltip-below", !S), u.positioned && u.positioned(e.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let e of this.manager.tooltipViews)
        e.dom.style.top = oo;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function Vp(e, t) {
  let n = parseInt(e.style.left, 10);
  (isNaN(n) || Math.abs(t - n) > 1) && (e.style.left = t + "px");
}
const uA = /* @__PURE__ */ Re.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), cA = { x: 0, y: 0 }, p1 = /* @__PURE__ */ He.define({
  enables: [ym, uA]
}), ld = /* @__PURE__ */ He.define({
  combine: (e) => e.reduce((t, n) => t.concat(n), [])
});
class y1 {
  // Needs to be static so that host tooltip instances always match
  static create(t) {
    return new y1(t);
  }
  constructor(t) {
    this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new F6(t, ld, (n, a) => this.createHostedView(n, a), (n) => n.dom.remove());
  }
  createHostedView(t, n) {
    let a = t.create(this.view);
    return a.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(a.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && a.mount && a.mount(this.view), a;
  }
  mount(t) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(t);
    this.mounted = !0;
  }
  positioned(t) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(t);
  }
  update(t) {
    this.manager.update(t);
  }
  destroy() {
    var t;
    for (let n of this.manager.tooltipViews)
      (t = n.destroy) === null || t === void 0 || t.call(n);
  }
  passProp(t) {
    let n;
    for (let a of this.manager.tooltipViews) {
      let i = a[t];
      if (i !== void 0) {
        if (n === void 0)
          n = i;
        else if (n !== i)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const dA = /* @__PURE__ */ p1.compute([ld], (e) => {
  let t = e.facet(ld);
  return t.length === 0 ? null : {
    pos: Math.min(...t.map((n) => n.pos)),
    end: Math.max(...t.map((n) => {
      var a;
      return (a = n.end) !== null && a !== void 0 ? a : n.pos;
    })),
    create: y1.create,
    above: t[0].above,
    arrow: t.some((n) => n.arrow)
  };
});
class fA {
  constructor(t, n, a, i, l) {
    this.view = t, this.source = n, this.field = a, this.setHover = i, this.hoverTime = l, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let t = Date.now() - this.lastMove.time;
    t < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: t, lastMove: n } = this, a = t.docView.nearest(n.target);
    if (!a)
      return;
    let i, l = 1;
    if (a instanceof bl)
      i = a.posAtStart;
    else {
      if (i = t.posAtCoords(n), i == null)
        return;
      let s = t.coordsAtPos(i);
      if (!s || n.y < s.top || n.y > s.bottom || n.x < s.left - t.defaultCharacterWidth || n.x > s.right + t.defaultCharacterWidth)
        return;
      let o = t.bidiSpans(t.state.doc.lineAt(i)).find((c) => c.from <= i && c.to >= i), u = o && o.dir == Nt.RTL ? -1 : 1;
      l = n.x < s.left ? -u : u;
    }
    let r = this.source(t, i, l);
    if (r != null && r.then) {
      let s = this.pending = { pos: i };
      r.then((o) => {
        this.pending == s && (this.pending = null, o && !(Array.isArray(o) && !o.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) }));
      }, (o) => aa(t.state, o, "hover tooltip"));
    } else r && !(Array.isArray(r) && !r.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(r) ? r : [r]) });
  }
  get tooltip() {
    let t = this.view.plugin(ym), n = t ? t.manager.tooltips.findIndex((a) => a.create == y1.create) : -1;
    return n > -1 ? t.manager.tooltipViews[n] : null;
  }
  mousemove(t) {
    var n, a;
    this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: l } = this;
    if (i.length && l && !hA(l.dom, t) || this.pending) {
      let { pos: r } = i[0] || this.pending, s = (a = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && a !== void 0 ? a : r;
      (r == s ? this.view.posAtCoords(this.lastMove) != r : !mA(this.view, r, s, t.clientX, t.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(t) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: a } = this;
      a && a.dom.contains(t.relatedTarget) ? this.watchTooltipLeave(a.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(t) {
    let n = (a) => {
      t.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(a.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    t.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const sc = 4;
function hA(e, t) {
  let { left: n, right: a, top: i, bottom: l } = e.getBoundingClientRect(), r;
  if (r = e.querySelector(".cm-tooltip-arrow")) {
    let s = r.getBoundingClientRect();
    i = Math.min(s.top, i), l = Math.max(s.bottom, l);
  }
  return t.clientX >= n - sc && t.clientX <= a + sc && t.clientY >= i - sc && t.clientY <= l + sc;
}
function mA(e, t, n, a, i, l) {
  let r = e.scrollDOM.getBoundingClientRect(), s = e.documentTop + e.documentPadding.top + e.contentHeight;
  if (r.left > a || r.right < a || r.top > i || Math.min(r.bottom, s) < i)
    return !1;
  let o = e.posAtCoords({ x: a, y: i }, !1);
  return o >= t && o <= n;
}
function vA(e, t = {}) {
  let n = at.define(), a = $n.define({
    create() {
      return [];
    },
    update(i, l) {
      if (i.length && (t.hideOnChange && (l.docChanged || l.selection) ? i = [] : t.hideOn && (i = i.filter((r) => !t.hideOn(l, r))), l.docChanged)) {
        let r = [];
        for (let s of i) {
          let o = l.changes.mapPos(s.pos, -1, Hn.TrackDel);
          if (o != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), s);
            u.pos = o, u.end != null && (u.end = l.changes.mapPos(u.end)), r.push(u);
          }
        }
        i = r;
      }
      for (let r of l.effects)
        r.is(n) && (i = r.value), r.is(gA) && (i = []);
      return i;
    },
    provide: (i) => ld.from(i)
  });
  return {
    active: a,
    extension: [
      a,
      rn.define((i) => new fA(
        i,
        e,
        a,
        n,
        t.hoverTime || 300
        /* Hover.Time */
      )),
      dA
    ]
  };
}
function X6(e, t) {
  let n = e.plugin(ym);
  if (!n)
    return null;
  let a = n.manager.tooltips.indexOf(t);
  return a < 0 ? null : n.manager.tooltipViews[a];
}
const gA = /* @__PURE__ */ at.define(), Tp = /* @__PURE__ */ He.define({
  combine(e) {
    let t, n;
    for (let a of e)
      t = t || a.topContainer, n = n || a.bottomContainer;
    return { topContainer: t, bottomContainer: n };
  }
});
function Jo(e, t) {
  let n = e.plugin(Y6), a = n ? n.specs.indexOf(t) : -1;
  return a > -1 ? n.panels[a] : null;
}
const Y6 = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.input = e.state.facet(eu), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(e));
    let t = e.state.facet(Tp);
    this.top = new oc(e, !0, t.topContainer), this.bottom = new oc(e, !1, t.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(e) {
    let t = e.state.facet(Tp);
    this.top.container != t.topContainer && (this.top.sync([]), this.top = new oc(e.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new oc(e.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = e.state.facet(eu);
    if (n != this.input) {
      let a = n.filter((o) => o), i = [], l = [], r = [], s = [];
      for (let o of a) {
        let u = this.specs.indexOf(o), c;
        u < 0 ? (c = o(e.view), s.push(c)) : (c = this.panels[u], c.update && c.update(e)), i.push(c), (c.top ? l : r).push(c);
      }
      this.specs = a, this.panels = i, this.top.sync(l), this.bottom.sync(r);
      for (let o of s)
        o.dom.classList.add("cm-panel"), o.mount && o.mount();
    } else
      for (let a of this.panels)
        a.update && a.update(e);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (e) => Re.scrollMargins.of((t) => {
    let n = t.plugin(e);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class oc {
  constructor(t, n, a) {
    this.view = t, this.top = n, this.container = a, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(t) {
    for (let n of this.panels)
      n.destroy && t.indexOf(n) < 0 && n.destroy();
    this.panels = t, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let t = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; t != n.dom; )
          t = Lp(t);
        t = t.nextSibling;
      } else
        this.dom.insertBefore(n.dom, t);
    for (; t; )
      t = Lp(t);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let t of this.classes.split(" "))
        t && this.container.classList.remove(t);
      for (let t of (this.classes = this.view.themeClasses).split(" "))
        t && this.container.classList.add(t);
    }
  }
}
function Lp(e) {
  let t = e.nextSibling;
  return e.remove(), t;
}
const eu = /* @__PURE__ */ He.define({
  enables: Y6
});
class Ti extends Sr {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}
Ti.prototype.elementClass = "";
Ti.prototype.toDOM = void 0;
Ti.prototype.mapMode = Hn.TrackBefore;
Ti.prototype.startSide = Ti.prototype.endSide = -1;
Ti.prototype.point = !0;
const Qc = /* @__PURE__ */ He.define(), pA = /* @__PURE__ */ He.define(), yA = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => mt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, $o = /* @__PURE__ */ He.define();
function W6(e) {
  return [q6(), $o.of(Object.assign(Object.assign({}, yA), e))];
}
const Qp = /* @__PURE__ */ He.define({
  combine: (e) => e.some((t) => t)
});
function q6(e) {
  return [
    OA
  ];
}
const OA = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.view = e, this.prevViewport = e.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = e.state.facet($o).map((t) => new Dp(e, t));
    for (let t of this.gutters)
      this.dom.appendChild(t.dom);
    this.fixed = !e.state.facet(Qp), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), e.scrollDOM.insertBefore(this.dom, e.contentDOM);
  }
  update(e) {
    if (this.updateGutters(e)) {
      let t = this.prevViewport, n = e.view.viewport, a = Math.min(t.to, n.to) - Math.max(t.from, n.from);
      this.syncGutters(a < (n.to - n.from) * 0.8);
    }
    e.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(Qp) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = e.view.viewport;
  }
  syncGutters(e) {
    let t = this.dom.nextSibling;
    e && this.dom.remove();
    let n = mt.iter(this.view.state.facet(Qc), this.view.viewport.from), a = [], i = this.gutters.map((l) => new bA(l, this.view.viewport, -this.view.documentPadding.top));
    for (let l of this.view.viewportLineBlocks)
      if (a.length && (a = []), Array.isArray(l.type)) {
        let r = !0;
        for (let s of l.type)
          if (s.type == ra.Text && r) {
            h0(n, a, s.from);
            for (let o of i)
              o.line(this.view, s, a);
            r = !1;
          } else if (s.widget)
            for (let o of i)
              o.widget(this.view, s);
      } else if (l.type == ra.Text) {
        h0(n, a, l.from);
        for (let r of i)
          r.line(this.view, l, a);
      } else if (l.widget)
        for (let r of i)
          r.widget(this.view, l);
    for (let l of i)
      l.finish();
    e && this.view.scrollDOM.insertBefore(this.dom, t);
  }
  updateGutters(e) {
    let t = e.startState.facet($o), n = e.state.facet($o), a = e.docChanged || e.heightChanged || e.viewportChanged || !mt.eq(e.startState.facet(Qc), e.state.facet(Qc), e.view.viewport.from, e.view.viewport.to);
    if (t == n)
      for (let i of this.gutters)
        i.update(e) && (a = !0);
    else {
      a = !0;
      let i = [];
      for (let l of n) {
        let r = t.indexOf(l);
        r < 0 ? i.push(new Dp(this.view, l)) : (this.gutters[r].update(e), i.push(this.gutters[r]));
      }
      for (let l of this.gutters)
        l.dom.remove(), i.indexOf(l) < 0 && l.destroy();
      for (let l of i)
        this.dom.appendChild(l.dom);
      this.gutters = i;
    }
    return a;
  }
  destroy() {
    for (let e of this.gutters)
      e.destroy();
    this.dom.remove();
  }
}, {
  provide: (e) => Re.scrollMargins.of((t) => {
    let n = t.plugin(e);
    return !n || n.gutters.length == 0 || !n.fixed ? null : t.textDirection == Nt.LTR ? { left: n.dom.offsetWidth * t.scaleX } : { right: n.dom.offsetWidth * t.scaleX };
  })
});
function Ap(e) {
  return Array.isArray(e) ? e : [e];
}
function h0(e, t, n) {
  for (; e.value && e.from <= n; )
    e.from == n && t.push(e.value), e.next();
}
class bA {
  constructor(t, n, a) {
    this.gutter = t, this.height = a, this.i = 0, this.cursor = mt.iter(t.markers, n.from);
  }
  addElement(t, n, a) {
    let { gutter: i } = this, l = (n.top - this.height) / t.scaleY, r = n.height / t.scaleY;
    if (this.i == i.elements.length) {
      let s = new U6(t, r, l, a);
      i.elements.push(s), i.dom.appendChild(s.dom);
    } else
      i.elements[this.i].update(t, r, l, a);
    this.height = n.bottom, this.i++;
  }
  line(t, n, a) {
    let i = [];
    h0(this.cursor, i, n.from), a.length && (i = i.concat(a));
    let l = this.gutter.config.lineMarker(t, n, i);
    l && i.unshift(l);
    let r = this.gutter;
    i.length == 0 && !r.config.renderEmptyElements || this.addElement(t, n, i);
  }
  widget(t, n) {
    let a = this.gutter.config.widgetMarker(t, n.widget, n), i = a ? [a] : null;
    for (let l of t.state.facet(pA)) {
      let r = l(t, n.widget, n);
      r && (i || (i = [])).push(r);
    }
    i && this.addElement(t, n, i);
  }
  finish() {
    let t = this.gutter;
    for (; t.elements.length > this.i; ) {
      let n = t.elements.pop();
      t.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class Dp {
  constructor(t, n) {
    this.view = t, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let a in n.domEventHandlers)
      this.dom.addEventListener(a, (i) => {
        let l = i.target, r;
        if (l != this.dom && this.dom.contains(l)) {
          for (; l.parentNode != this.dom; )
            l = l.parentNode;
          let o = l.getBoundingClientRect();
          r = (o.top + o.bottom) / 2;
        } else
          r = i.clientY;
        let s = t.lineBlockAtHeight(r - t.documentTop);
        n.domEventHandlers[a](t, s, i) && i.preventDefault();
      });
    this.markers = Ap(n.markers(t)), n.initialSpacer && (this.spacer = new U6(t, 0, 0, [n.initialSpacer(t)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t) {
    let n = this.markers;
    if (this.markers = Ap(this.config.markers(t.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], t);
      i != this.spacer.markers[0] && this.spacer.update(t.view, 0, 0, [i]);
    }
    let a = t.view.viewport;
    return !mt.eq(this.markers, n, a.from, a.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(t) : !1);
  }
  destroy() {
    for (let t of this.elements)
      t.destroy();
  }
}
class U6 {
  constructor(t, n, a, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t, n, a, i);
  }
  update(t, n, a, i) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != a && (this.dom.style.marginTop = (this.above = a) ? a + "px" : ""), CA(this.markers, i) || this.setMarkers(t, i);
  }
  setMarkers(t, n) {
    let a = "cm-gutterElement", i = this.dom.firstChild;
    for (let l = 0, r = 0; ; ) {
      let s = r, o = l < n.length ? n[l++] : null, u = !1;
      if (o) {
        let c = o.elementClass;
        c && (a += " " + c);
        for (let d = r; d < this.markers.length; d++)
          if (this.markers[d].compare(o)) {
            s = d, u = !0;
            break;
          }
      } else
        s = this.markers.length;
      for (; r < s; ) {
        let c = this.markers[r++];
        if (c.toDOM) {
          c.destroy(i);
          let d = i.nextSibling;
          i.remove(), i = d;
        }
      }
      if (!o)
        break;
      o.toDOM && (u ? i = i.nextSibling : this.dom.insertBefore(o.toDOM(t), i)), u && r++;
    }
    this.dom.className = a, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function CA(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!e[n].compare(t[n]))
      return !1;
  return !0;
}
const wA = /* @__PURE__ */ He.define(), kA = /* @__PURE__ */ He.define(), rs = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(t, n) {
        let a = Object.assign({}, t);
        for (let i in n) {
          let l = a[i], r = n[i];
          a[i] = l ? (s, o, u) => l(s, o, u) || r(s, o, u) : r;
        }
        return a;
      }
    });
  }
});
class hf extends Ti {
  constructor(t) {
    super(), this.number = t;
  }
  eq(t) {
    return this.number == t.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function mf(e, t) {
  return e.state.facet(rs).formatNumber(t, e.state);
}
const SA = /* @__PURE__ */ $o.compute([rs], (e) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(t) {
    return t.state.facet(wA);
  },
  lineMarker(t, n, a) {
    return a.some((i) => i.toDOM) ? null : new hf(mf(t, t.state.doc.lineAt(n.from).number));
  },
  widgetMarker: (t, n, a) => {
    for (let i of t.state.facet(kA)) {
      let l = i(t, n, a);
      if (l)
        return l;
    }
    return null;
  },
  lineMarkerChange: (t) => t.startState.facet(rs) != t.state.facet(rs),
  initialSpacer(t) {
    return new hf(mf(t, Rp(t.state.doc.lines)));
  },
  updateSpacer(t, n) {
    let a = mf(n.view, Rp(n.view.state.doc.lines));
    return a == t.number ? t : new hf(a);
  },
  domEventHandlers: e.facet(rs).domEventHandlers
}));
function xA(e = {}) {
  return [
    rs.of(e),
    q6(),
    SA
  ];
}
function Rp(e) {
  let t = 9;
  for (; t < e; )
    t = t * 10 + 9;
  return t;
}
const PA = /* @__PURE__ */ new class extends Ti {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), $A = /* @__PURE__ */ Qc.compute(["selection"], (e) => {
  let t = [], n = -1;
  for (let a of e.selection.ranges) {
    let i = e.doc.lineAt(a.head).from;
    i > n && (n = i, t.push(PA.range(i)));
  }
  return mt.of(t);
});
function _A() {
  return $A;
}
const G6 = 1024;
let MA = 0;
class vf {
  constructor(t, n) {
    this.from = t, this.to = n;
  }
}
class ut {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = MA++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = pa.match(t)), (n) => {
      let a = t(n);
      return a === void 0 ? null : [this, a];
    };
  }
}
ut.closedBy = new ut({ deserialize: (e) => e.split(" ") });
ut.openedBy = new ut({ deserialize: (e) => e.split(" ") });
ut.group = new ut({ deserialize: (e) => e.split(" ") });
ut.isolate = new ut({ deserialize: (e) => {
  if (e && e != "rtl" && e != "ltr" && e != "auto")
    throw new RangeError("Invalid value for isolate: " + e);
  return e || "auto";
} });
ut.contextHash = new ut({ perNode: !0 });
ut.lookAhead = new ut({ perNode: !0 });
ut.mounted = new ut({ perNode: !0 });
class rd {
  constructor(t, n, a) {
    this.tree = t, this.overlay = n, this.parser = a;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[ut.mounted.id];
  }
}
const VA = /* @__PURE__ */ Object.create(null);
class pa {
  /**
  @internal
  */
  constructor(t, n, a, i = 0) {
    this.name = t, this.props = n, this.id = a, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let n = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : VA, a = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), i = new pa(t.name || "", n, t.id, a);
    if (t.props) {
      for (let l of t.props)
        if (Array.isArray(l) || (l = l(i)), l) {
          if (l[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[l[0].id] = l[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let n = this.prop(ut.group);
      return n ? n.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let a in t)
      for (let i of a.split(" "))
        n[i] = t[a];
    return (a) => {
      for (let i = a.prop(ut.group), l = -1; l < (i ? i.length : 0); l++) {
        let r = n[l < 0 ? a.name : i[l]];
        if (r)
          return r;
      }
    };
  }
}
pa.none = new pa(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Om {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let n = 0; n < t.length; n++)
      if (t[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let n = [];
    for (let a of this.types) {
      let i = null;
      for (let l of t) {
        let r = l(a);
        r && (i || (i = Object.assign({}, a.props)), i[r[0].id] = r[1]);
      }
      n.push(i ? new pa(a.name, i, a.id, a.flags) : a);
    }
    return new Om(n);
  }
}
const uc = /* @__PURE__ */ new WeakMap(), Ip = /* @__PURE__ */ new WeakMap();
var Vn;
(function(e) {
  e[e.ExcludeBuffers = 1] = "ExcludeBuffers", e[e.IncludeAnonymous = 2] = "IncludeAnonymous", e[e.IgnoreMounts = 4] = "IgnoreMounts", e[e.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Vn || (Vn = {}));
class kn {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, n, a, i, l) {
    if (this.type = t, this.children = n, this.positions = a, this.length = i, this.props = null, l && l.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [r, s] of l)
        this.props[typeof r == "number" ? r : r.id] = s;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = rd.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let n = "";
    for (let a of this.children) {
      let i = a.toString();
      i && (n && (n += ","), n += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new v0(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, n = 0, a = 0) {
    let i = uc.get(this) || this.topNode, l = new v0(i);
    return l.moveTo(t, n), uc.set(this, l._tree), l;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new va(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, n = 0) {
    let a = tu(uc.get(this) || this.topNode, t, n, !1);
    return uc.set(this, a), a;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, n = 0) {
    let a = tu(Ip.get(this) || this.topNode, t, n, !0);
    return Ip.set(this, a), a;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, n = 0) {
    return QA(this, t, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: n, leave: a, from: i = 0, to: l = this.length } = t, r = t.mode || 0, s = (r & Vn.IncludeAnonymous) > 0;
    for (let o = this.cursor(r | Vn.IncludeAnonymous); ; ) {
      let u = !1;
      if (o.from <= l && o.to >= i && (!s && o.type.isAnonymous || n(o) !== !1)) {
        if (o.firstChild())
          continue;
        u = !0;
      }
      for (; u && a && (s || !o.type.isAnonymous) && a(o), !o.nextSibling(); ) {
        if (!o.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let n in this.props)
        t.push([+n, this.props[n]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : wm(pa.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, a, i) => new kn(this.type, n, a, i, this.propValues), t.makeTree || ((n, a, i) => new kn(pa.none, n, a, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return AA(t);
  }
}
kn.empty = new kn(pa.none, [], [], 0);
class bm {
  constructor(t, n) {
    this.buffer = t, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new bm(this.buffer, this.index);
  }
}
class Ll {
  /**
  Create a tree buffer.
  */
  constructor(t, n, a) {
    this.buffer = t, this.length = n, this.set = a;
  }
  /**
  @internal
  */
  get type() {
    return pa.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let n = 0; n < this.buffer.length; )
      t.push(this.childString(n)), n = this.buffer[n + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let n = this.buffer[t], a = this.buffer[t + 3], i = this.set.types[n], l = i.name;
    if (/\W/.test(l) && !i.isError && (l = JSON.stringify(l)), t += 4, a == t)
      return l;
    let r = [];
    for (; t < a; )
      r.push(this.childString(t)), t = this.buffer[t + 3];
    return l + "(" + r.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, n, a, i, l) {
    let { buffer: r } = this, s = -1;
    for (let o = t; o != n && !(K6(l, i, r[o + 1], r[o + 2]) && (s = o, a > 0)); o = r[o + 3])
      ;
    return s;
  }
  /**
  @internal
  */
  slice(t, n, a) {
    let i = this.buffer, l = new Uint16Array(n - t), r = 0;
    for (let s = t, o = 0; s < n; ) {
      l[o++] = i[s++], l[o++] = i[s++] - a;
      let u = l[o++] = i[s++] - a;
      l[o++] = i[s++] - t, r = Math.max(r, u);
    }
    return new Ll(l, r, this.set);
  }
}
function K6(e, t, n, a) {
  switch (e) {
    case -2:
      return n < t;
    case -1:
      return a >= t && n < t;
    case 0:
      return n < t && a > t;
    case 1:
      return n <= t && a > t;
    case 2:
      return a > t;
    case 4:
      return !0;
  }
}
function tu(e, t, n, a) {
  for (var i; e.from == e.to || (n < 1 ? e.from >= t : e.from > t) || (n > -1 ? e.to <= t : e.to < t); ) {
    let r = !a && e instanceof va && e.index < 0 ? null : e.parent;
    if (!r)
      return e;
    e = r;
  }
  let l = a ? 0 : Vn.IgnoreOverlays;
  if (a)
    for (let r = e, s = r.parent; s; r = s, s = r.parent)
      r instanceof va && r.index < 0 && ((i = s.enter(t, n, l)) === null || i === void 0 ? void 0 : i.from) != r.from && (e = s);
  for (; ; ) {
    let r = e.enter(t, n, l);
    if (!r)
      return e;
    e = r;
  }
}
class J6 {
  cursor(t = 0) {
    return new v0(this, t);
  }
  getChild(t, n = null, a = null) {
    let i = Bp(this, t, n, a);
    return i.length ? i[0] : null;
  }
  getChildren(t, n = null, a = null) {
    return Bp(this, t, n, a);
  }
  resolve(t, n = 0) {
    return tu(this, t, n, !1);
  }
  resolveInner(t, n = 0) {
    return tu(this, t, n, !0);
  }
  matchContext(t) {
    return m0(this.parent, t);
  }
  enterUnfinishedNodesBefore(t) {
    let n = this.childBefore(t), a = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to)
        break;
      i.type.isError && i.from == i.to ? (a = n, n = i.prevSibling) : n = i;
    }
    return a;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class va extends J6 {
  constructor(t, n, a, i) {
    super(), this._tree = t, this.from = n, this.index = a, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, n, a, i, l = 0) {
    for (let r = this; ; ) {
      for (let { children: s, positions: o } = r._tree, u = n > 0 ? s.length : -1; t != u; t += n) {
        let c = s[t], d = o[t] + r.from;
        if (K6(i, a, d, d + c.length)) {
          if (c instanceof Ll) {
            if (l & Vn.ExcludeBuffers)
              continue;
            let f = c.findChild(0, c.buffer.length, n, a - d, i);
            if (f > -1)
              return new Ci(new TA(r, c, t, d), null, f);
          } else if (l & Vn.IncludeAnonymous || !c.type.isAnonymous || Cm(c)) {
            let f;
            if (!(l & Vn.IgnoreMounts) && (f = rd.get(c)) && !f.overlay)
              return new va(f.tree, d, t, r);
            let h = new va(c, d, t, r);
            return l & Vn.IncludeAnonymous || !h.type.isAnonymous ? h : h.nextChild(n < 0 ? c.children.length - 1 : 0, n, a, i);
          }
        }
      }
      if (l & Vn.IncludeAnonymous || !r.type.isAnonymous || (r.index >= 0 ? t = r.index + n : t = n < 0 ? -1 : r._parent._tree.children.length, r = r._parent, !r))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, n, a = 0) {
    let i;
    if (!(a & Vn.IgnoreOverlays) && (i = rd.get(this._tree)) && i.overlay) {
      let l = t - this.from;
      for (let { from: r, to: s } of i.overlay)
        if ((n > 0 ? r <= l : r < l) && (n < 0 ? s >= l : s > l))
          return new va(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, n, a);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function Bp(e, t, n, a) {
  let i = e.cursor(), l = [];
  if (!i.firstChild())
    return l;
  if (n != null) {
    for (let r = !1; !r; )
      if (r = i.type.is(n), !i.nextSibling())
        return l;
  }
  for (; ; ) {
    if (a != null && i.type.is(a))
      return l;
    if (i.type.is(t) && l.push(i.node), !i.nextSibling())
      return a == null ? l : [];
  }
}
function m0(e, t, n = t.length - 1) {
  for (let a = e; n >= 0; a = a.parent) {
    if (!a)
      return !1;
    if (!a.type.isAnonymous) {
      if (t[n] && t[n] != a.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class TA {
  constructor(t, n, a, i) {
    this.parent = t, this.buffer = n, this.index = a, this.start = i;
  }
}
class Ci extends J6 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, n, a) {
    super(), this.context = t, this._parent = n, this.index = a, this.type = t.buffer.set.types[t.buffer.buffer[a]];
  }
  child(t, n, a) {
    let { buffer: i } = this.context, l = i.findChild(this.index + 4, i.buffer[this.index + 3], t, n - this.context.start, a);
    return l < 0 ? null : new Ci(this.context, this, l);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, n, a = 0) {
    if (a & Vn.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, l = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, t - this.context.start, n);
    return l < 0 ? null : new Ci(this.context, this, l);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, n = t.buffer[this.index + 3];
    return n < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Ci(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Ci(this.context, this._parent, t.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], n = [], { buffer: a } = this.context, i = this.index + 4, l = a.buffer[this.index + 3];
    if (l > i) {
      let r = a.buffer[this.index + 1];
      t.push(a.slice(i, l, r)), n.push(0);
    }
    return new kn(this.type, t, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function ey(e) {
  if (!e.length)
    return null;
  let t = 0, n = e[0];
  for (let l = 1; l < e.length; l++) {
    let r = e[l];
    (r.from > n.from || r.to < n.to) && (n = r, t = l);
  }
  let a = n instanceof va && n.index < 0 ? null : n.parent, i = e.slice();
  return a ? i[t] = a : i.splice(t, 1), new LA(i, n);
}
class LA {
  constructor(t, n) {
    this.heads = t, this.node = n;
  }
  get next() {
    return ey(this.heads);
  }
}
function QA(e, t, n) {
  let a = e.resolveInner(t, n), i = null;
  for (let l = a instanceof va ? a : a.context.parent; l; l = l.parent)
    if (l.index < 0) {
      let r = l.parent;
      (i || (i = [a])).push(r.resolve(t, n)), l = r;
    } else {
      let r = rd.get(l.tree);
      if (r && r.overlay && r.overlay[0].from <= t && r.overlay[r.overlay.length - 1].to >= t) {
        let s = new va(r.tree, r.overlay[0].from + l.from, -1, l);
        (i || (i = [a])).push(tu(s, t, n, !1));
      }
    }
  return i ? ey(i) : a;
}
class v0 {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof va)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let a = t._parent; a; a = a._parent)
        this.stack.unshift(a.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, n) {
    this.index = t;
    let { start: a, buffer: i } = this.buffer;
    return this.type = n || i.set.types[i.buffer[t]], this.from = a + i.buffer[t + 1], this.to = a + i.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof va ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, n, a) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, n, a, this.mode));
    let { buffer: i } = this.buffer, l = i.findChild(this.index + 4, i.buffer[this.index + 3], t, n - this.buffer.start, a);
    return l < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(l));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, n, a = this.mode) {
    return this.buffer ? a & Vn.ExcludeBuffers ? !1 : this.enterChild(1, t, n) : this.yield(this._tree.enter(t, n, a));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Vn.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & Vn.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, a = this.stack.length - 1;
    if (t < 0) {
      let i = a < 0 ? 0 : this.stack[a] + 4;
      if (this.index != i)
        return this.yieldBuf(n.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (a < 0 ? n.buffer.length : n.buffer[this.stack[a] + 3]))
        return this.yieldBuf(i);
    }
    return a < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let n, a, { buffer: i } = this;
    if (i) {
      if (t > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let l = 0; l < this.index; l++)
          if (i.buffer.buffer[l + 3] < this.index)
            return !1;
      ({ index: n, parent: a } = i);
    } else
      ({ index: n, _parent: a } = this._tree);
    for (; a; { index: n, _parent: a } = a)
      if (n > -1)
        for (let l = n + t, r = t < 0 ? -1 : a._tree.children.length; l != r; l += t) {
          let s = a._tree.children[l];
          if (this.mode & Vn.IncludeAnonymous || s instanceof Ll || !s.type.isAnonymous || Cm(s))
            return !1;
        }
    return !0;
  }
  move(t, n) {
    if (n && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= t : this.from > t) || (n > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, n = null, a = 0;
    if (t && t.context == this.buffer)
      e: for (let i = this.index, l = this.stack.length; l >= 0; ) {
        for (let r = t; r; r = r._parent)
          if (r.index == i) {
            if (i == this.index)
              return r;
            n = r, a = l + 1;
            break e;
          }
        i = this.stack[--l];
      }
    for (let i = a; i < this.stack.length; i++)
      n = new Ci(this.buffer, n, this.stack[i]);
    return this.bufferNode = new Ci(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, n) {
    for (let a = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          a++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && n && n(this), i = this.type.isAnonymous, !a)
          return;
        if (this.nextSibling())
          break;
        this.parent(), a--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return m0(this.node.parent, t);
    let { buffer: n } = this.buffer, { types: a } = n.set;
    for (let i = t.length - 1, l = this.stack.length - 1; i >= 0; l--) {
      if (l < 0)
        return m0(this._tree, t, i);
      let r = a[n.buffer[this.stack[l]]];
      if (!r.isAnonymous) {
        if (t[i] && t[i] != r.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function Cm(e) {
  return e.children.some((t) => t instanceof Ll || !t.type.isAnonymous || Cm(t));
}
function AA(e) {
  var t;
  let { buffer: n, nodeSet: a, maxBufferLength: i = G6, reused: l = [], minRepeatType: r = a.types.length } = e, s = Array.isArray(n) ? new bm(n, n.length) : n, o = a.types, u = 0, c = 0;
  function d(x, w, V, _, O, $) {
    let { id: P, start: M, end: T, size: L } = s, A = c, D = u;
    for (; L < 0; )
      if (s.next(), L == -1) {
        let R = l[P];
        V.push(R), _.push(M - x);
        return;
      } else if (L == -3) {
        u = P;
        return;
      } else if (L == -4) {
        c = P;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${L}`);
    let B = o[P], j, I, Z = M - x;
    if (T - M <= i && (I = v(s.pos - w, O))) {
      let R = new Uint16Array(I.size - I.skip), J = s.pos - I.size, F = R.length;
      for (; s.pos > J; )
        F = y(I.start, R, F);
      j = new Ll(R, T - I.start, a), Z = I.start - x;
    } else {
      let R = s.pos - L;
      s.next();
      let J = [], F = [], q = P >= r ? P : -1, z = 0, E = T;
      for (; s.pos > R; )
        q >= 0 && s.id == q && s.size >= 0 ? (s.end <= E - i && (m(J, F, M, z, s.end, E, q, A, D), z = J.length, E = s.end), s.next()) : $ > 2500 ? f(M, R, J, F) : d(M, R, J, F, q, $ + 1);
      if (q >= 0 && z > 0 && z < J.length && m(J, F, M, z, M, E, q, A, D), J.reverse(), F.reverse(), q > -1 && z > 0) {
        let Q = h(B, D);
        j = wm(B, J, F, 0, J.length, 0, T - M, Q, Q);
      } else
        j = g(B, J, F, T - M, A - T, D);
    }
    V.push(j), _.push(Z);
  }
  function f(x, w, V, _) {
    let O = [], $ = 0, P = -1;
    for (; s.pos > w; ) {
      let { id: M, start: T, end: L, size: A } = s;
      if (A > 4)
        s.next();
      else {
        if (P > -1 && T < P)
          break;
        P < 0 && (P = L - i), O.push(M, T, L), $++, s.next();
      }
    }
    if ($) {
      let M = new Uint16Array($ * 4), T = O[O.length - 2];
      for (let L = O.length - 3, A = 0; L >= 0; L -= 3)
        M[A++] = O[L], M[A++] = O[L + 1] - T, M[A++] = O[L + 2] - T, M[A++] = A;
      V.push(new Ll(M, O[2] - T, a)), _.push(T - x);
    }
  }
  function h(x, w) {
    return (V, _, O) => {
      let $ = 0, P = V.length - 1, M, T;
      if (P >= 0 && (M = V[P]) instanceof kn) {
        if (!P && M.type == x && M.length == O)
          return M;
        (T = M.prop(ut.lookAhead)) && ($ = _[P] + M.length + T);
      }
      return g(x, V, _, O, $, w);
    };
  }
  function m(x, w, V, _, O, $, P, M, T) {
    let L = [], A = [];
    for (; x.length > _; )
      L.push(x.pop()), A.push(w.pop() + V - O);
    x.push(g(a.types[P], L, A, $ - O, M - $, T)), w.push(O - V);
  }
  function g(x, w, V, _, O, $, P) {
    if ($) {
      let M = [ut.contextHash, $];
      P = P ? [M].concat(P) : [M];
    }
    if (O > 25) {
      let M = [ut.lookAhead, O];
      P = P ? [M].concat(P) : [M];
    }
    return new kn(x, w, V, _, P);
  }
  function v(x, w) {
    let V = s.fork(), _ = 0, O = 0, $ = 0, P = V.end - i, M = { size: 0, start: 0, skip: 0 };
    e: for (let T = V.pos - x; V.pos > T; ) {
      let L = V.size;
      if (V.id == w && L >= 0) {
        M.size = _, M.start = O, M.skip = $, $ += 4, _ += 4, V.next();
        continue;
      }
      let A = V.pos - L;
      if (L < 0 || A < T || V.start < P)
        break;
      let D = V.id >= r ? 4 : 0, B = V.start;
      for (V.next(); V.pos > A; ) {
        if (V.size < 0)
          if (V.size == -3)
            D += 4;
          else
            break e;
        else V.id >= r && (D += 4);
        V.next();
      }
      O = B, _ += L, $ += D;
    }
    return (w < 0 || _ == x) && (M.size = _, M.start = O, M.skip = $), M.size > 4 ? M : void 0;
  }
  function y(x, w, V) {
    let { id: _, start: O, end: $, size: P } = s;
    if (s.next(), P >= 0 && _ < r) {
      let M = V;
      if (P > 4) {
        let T = s.pos - (P - 4);
        for (; s.pos > T; )
          V = y(x, w, V);
      }
      w[--V] = M, w[--V] = $ - x, w[--V] = O - x, w[--V] = _;
    } else P == -3 ? u = _ : P == -4 && (c = _);
    return V;
  }
  let b = [], C = [];
  for (; s.pos > 0; )
    d(e.start || 0, e.bufferStart || 0, b, C, -1, 0);
  let S = (t = e.length) !== null && t !== void 0 ? t : b.length ? C[0] + b[0].length : 0;
  return new kn(o[e.topID], b.reverse(), C.reverse(), S);
}
const Zp = /* @__PURE__ */ new WeakMap();
function Ac(e, t) {
  if (!e.isAnonymous || t instanceof Ll || t.type != e)
    return 1;
  let n = Zp.get(t);
  if (n == null) {
    n = 1;
    for (let a of t.children) {
      if (a.type != e || !(a instanceof kn)) {
        n = 1;
        break;
      }
      n += Ac(e, a);
    }
    Zp.set(t, n);
  }
  return n;
}
function wm(e, t, n, a, i, l, r, s, o) {
  let u = 0;
  for (let m = a; m < i; m++)
    u += Ac(e, t[m]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], f = [];
  function h(m, g, v, y, b) {
    for (let C = v; C < y; ) {
      let S = C, x = g[C], w = Ac(e, m[C]);
      for (C++; C < y; C++) {
        let V = Ac(e, m[C]);
        if (w + V >= c)
          break;
        w += V;
      }
      if (C == S + 1) {
        if (w > c) {
          let V = m[S];
          h(V.children, V.positions, 0, V.children.length, g[S] + b);
          continue;
        }
        d.push(m[S]);
      } else {
        let V = g[C - 1] + m[C - 1].length - x;
        d.push(wm(e, m, g, S, C, x, V, null, o));
      }
      f.push(x + b - l);
    }
  }
  return h(t, n, a, i, 0), (s || o)(d, f, r);
}
class DA {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, n, a) {
    let i = this.map.get(t);
    i || this.map.set(t, i = /* @__PURE__ */ new Map()), i.set(n, a);
  }
  getBuffer(t, n) {
    let a = this.map.get(t);
    return a && a.get(n);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, n) {
    t instanceof Ci ? this.setBuffer(t.context.buffer, t.index, n) : t instanceof va && this.map.set(t.tree, n);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof Ci ? this.getBuffer(t.context.buffer, t.index) : t instanceof va ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, n) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, n) : this.map.set(t.tree, n);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}
class dr {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, n, a, i, l = !1, r = !1) {
    this.from = t, this.to = n, this.tree = a, this.offset = i, this.open = (l ? 1 : 0) | (r ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, n = [], a = !1) {
    let i = [new dr(0, t.length, t, 0, !1, a)];
    for (let l of n)
      l.to > t.length && i.push(l);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, n, a = 128) {
    if (!n.length)
      return t;
    let i = [], l = 1, r = t.length ? t[0] : null;
    for (let s = 0, o = 0, u = 0; ; s++) {
      let c = s < n.length ? n[s] : null, d = c ? c.fromA : 1e9;
      if (d - o >= a)
        for (; r && r.from < d; ) {
          let f = r;
          if (o >= f.from || d <= f.to || u) {
            let h = Math.max(f.from, o) - u, m = Math.min(f.to, d) - u;
            f = h >= m ? null : new dr(h, m, f.tree, f.offset + u, s > 0, !!c);
          }
          if (f && i.push(f), r.to > d)
            break;
          r = l < t.length ? t[l++] : null;
        }
      if (!c)
        break;
      o = c.toA, u = c.toA - c.toB;
    }
    return i;
  }
}
let ty = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, n, a) {
    return typeof t == "string" && (t = new RA(t)), a = a ? a.length ? a.map((i) => new vf(i.from, i.to)) : [new vf(0, 0)] : [new vf(0, t.length)], this.createParse(t, n || [], a);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, n, a) {
    let i = this.startParse(t, n, a);
    for (; ; ) {
      let l = i.advance();
      if (l)
        return l;
    }
  }
};
class RA {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, n) {
    return this.string.slice(t, n);
  }
}
new ut({ perNode: !0 });
let IA = 0, Ei = class g0 {
  /**
  @internal
  */
  constructor(t, n, a, i) {
    this.name = t, this.set = n, this.base = a, this.modified = i, this.id = IA++;
  }
  toString() {
    let { name: t } = this;
    for (let n of this.modified)
      n.name && (t = `${n.name}(${t})`);
    return t;
  }
  static define(t, n) {
    let a = typeof t == "string" ? t : "?";
    if (t instanceof g0 && (n = t), n != null && n.base)
      throw new Error("Can not derive from a modified tag");
    let i = new g0(a, [], null, []);
    if (i.set.push(i), n)
      for (let l of n.set)
        i.set.push(l);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let n = new sd(t);
    return (a) => a.modified.indexOf(n) > -1 ? a : sd.get(a.base || a, a.modified.concat(n).sort((i, l) => i.id - l.id));
  }
}, BA = 0;
class sd {
  constructor(t) {
    this.name = t, this.instances = [], this.id = BA++;
  }
  static get(t, n) {
    if (!n.length)
      return t;
    let a = n[0].instances.find((s) => s.base == t && ZA(n, s.modified));
    if (a)
      return a;
    let i = [], l = new Ei(t.name, i, t, n);
    for (let s of n)
      s.instances.push(l);
    let r = EA(n);
    for (let s of t.set)
      if (!s.modified.length)
        for (let o of r)
          i.push(sd.get(s, o));
    return l;
  }
}
function ZA(e, t) {
  return e.length == t.length && e.every((n, a) => n == t[a]);
}
function EA(e) {
  let t = [[]];
  for (let n = 0; n < e.length; n++)
    for (let a = 0, i = t.length; a < i; a++)
      t.push(t[a].concat(e[n]));
  return t.sort((n, a) => a.length - n.length);
}
function km(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e) {
    let a = e[n];
    Array.isArray(a) || (a = [a]);
    for (let i of n.split(" "))
      if (i) {
        let l = [], r = 2, s = i;
        for (let d = 0; ; ) {
          if (s == "..." && d > 0 && d + 3 == i.length) {
            r = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(s);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (l.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), d += f[0].length, d == i.length)
            break;
          let h = i[d++];
          if (d == i.length && h == "!") {
            r = 0;
            break;
          }
          if (h != "/")
            throw new RangeError("Invalid path: " + i);
          s = i.slice(d);
        }
        let o = l.length - 1, u = l[o];
        if (!u)
          throw new RangeError("Invalid path: " + i);
        let c = new od(a, r, o > 0 ? l.slice(0, o) : null);
        t[u] = c.sort(t[u]);
      }
  }
  return ny.add(t);
}
const ny = new ut();
class od {
  constructor(t, n, a, i) {
    this.tags = t, this.mode = n, this.context = a, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
od.empty = new od([], 2, null);
function ay(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let l of e)
    if (!Array.isArray(l.tag))
      n[l.tag.id] = l.class;
    else
      for (let r of l.tag)
        n[r.id] = l.class;
  let { scope: a, all: i = null } = t || {};
  return {
    style: (l) => {
      let r = i;
      for (let s of l)
        for (let o of s.set) {
          let u = n[o.id];
          if (u) {
            r = r ? r + " " + u : u;
            break;
          }
        }
      return r;
    },
    scope: a
  };
}
function NA(e, t) {
  let n = null;
  for (let a of e) {
    let i = a.style(t);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function HA(e, t, n, a = 0, i = e.length) {
  let l = new jA(a, Array.isArray(t) ? t : [t], n);
  l.highlightRange(e.cursor(), a, i, "", l.highlighters), l.flush(i);
}
class jA {
  constructor(t, n, a) {
    this.at = t, this.highlighters = n, this.span = a, this.class = "";
  }
  startSpan(t, n) {
    n != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = n);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, n, a, i, l) {
    let { type: r, from: s, to: o } = t;
    if (s >= a || o <= n)
      return;
    r.isTop && (l = this.highlighters.filter((h) => !h.scope || h.scope(r)));
    let u = i, c = zA(t) || od.empty, d = NA(l, c.tags);
    if (d && (u && (u += " "), u += d, c.mode == 1 && (i += (i ? " " : "") + d)), this.startSpan(Math.max(n, s), u), c.opaque)
      return;
    let f = t.tree && t.tree.prop(ut.mounted);
    if (f && f.overlay) {
      let h = t.node.enter(f.overlay[0].from + s, 1), m = this.highlighters.filter((v) => !v.scope || v.scope(f.tree.type)), g = t.firstChild();
      for (let v = 0, y = s; ; v++) {
        let b = v < f.overlay.length ? f.overlay[v] : null, C = b ? b.from + s : o, S = Math.max(n, y), x = Math.min(a, C);
        if (S < x && g)
          for (; t.from < x && (this.highlightRange(t, S, x, i, l), this.startSpan(Math.min(x, t.to), u), !(t.to >= C || !t.nextSibling())); )
            ;
        if (!b || C > a)
          break;
        y = b.to + s, y > n && (this.highlightRange(h.cursor(), Math.max(n, b.from + s), Math.min(a, y), "", m), this.startSpan(Math.min(a, y), u));
      }
      g && t.parent();
    } else if (t.firstChild()) {
      f && (i = "");
      do
        if (!(t.to <= n)) {
          if (t.from >= a)
            break;
          this.highlightRange(t, n, a, i, l), this.startSpan(Math.min(a, t.to), u);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}
function zA(e) {
  let t = e.type.prop(ny);
  for (; t && t.context && !e.matchContext(t.context); )
    t = t.next;
  return t || null;
}
const De = Ei.define, cc = De(), ml = De(), Ep = De(ml), Np = De(ml), vl = De(), dc = De(vl), gf = De(vl), fi = De(), ql = De(fi), ci = De(), di = De(), p0 = De(), uo = De(p0), fc = De(), ae = {
  /**
  A comment.
  */
  comment: cc,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: De(cc),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: De(cc),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: De(cc),
  /**
  Any kind of identifier.
  */
  name: ml,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: De(ml),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Ep,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: De(Ep),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Np,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: De(Np),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: De(ml),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: De(ml),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: De(ml),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: De(ml),
  /**
  A literal value.
  */
  literal: vl,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: dc,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: De(dc),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: De(dc),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: De(dc),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: gf,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: De(gf),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: De(gf),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: De(vl),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: De(vl),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: De(vl),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: De(vl),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: De(vl),
  /**
  A language keyword.
  */
  keyword: ci,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: De(ci),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: De(ci),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: De(ci),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: De(ci),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: De(ci),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: De(ci),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: De(ci),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: De(ci),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: De(ci),
  /**
  An operator.
  */
  operator: di,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: De(di),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: De(di),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: De(di),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: De(di),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: De(di),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: De(di),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: De(di),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: De(di),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: De(di),
  /**
  Program or markup punctuation.
  */
  punctuation: p0,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: De(p0),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: uo,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: De(uo),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: De(uo),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: De(uo),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: De(uo),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: fi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: ql,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: De(ql),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: De(ql),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: De(ql),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: De(ql),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: De(ql),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: De(ql),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: De(fi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: De(fi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: De(fi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: De(fi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: De(fi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: De(fi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: De(fi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: De(fi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: De(),
  /**
  Deleted text.
  */
  deleted: De(),
  /**
  Changed text.
  */
  changed: De(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: De(),
  /**
  Metadata or meta-instruction.
  */
  meta: fc,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: De(fc),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: De(fc),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: De(fc),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Ei.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Ei.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Ei.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Ei.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Ei.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Ei.defineModifier("special")
};
for (let e in ae) {
  let t = ae[e];
  t instanceof Ei && (t.name = e);
}
ay([
  { tag: ae.link, class: "tok-link" },
  { tag: ae.heading, class: "tok-heading" },
  { tag: ae.emphasis, class: "tok-emphasis" },
  { tag: ae.strong, class: "tok-strong" },
  { tag: ae.keyword, class: "tok-keyword" },
  { tag: ae.atom, class: "tok-atom" },
  { tag: ae.bool, class: "tok-bool" },
  { tag: ae.url, class: "tok-url" },
  { tag: ae.labelName, class: "tok-labelName" },
  { tag: ae.inserted, class: "tok-inserted" },
  { tag: ae.deleted, class: "tok-deleted" },
  { tag: ae.literal, class: "tok-literal" },
  { tag: ae.string, class: "tok-string" },
  { tag: ae.number, class: "tok-number" },
  { tag: [ae.regexp, ae.escape, ae.special(ae.string)], class: "tok-string2" },
  { tag: ae.variableName, class: "tok-variableName" },
  { tag: ae.local(ae.variableName), class: "tok-variableName tok-local" },
  { tag: ae.definition(ae.variableName), class: "tok-variableName tok-definition" },
  { tag: ae.special(ae.variableName), class: "tok-variableName2" },
  { tag: ae.definition(ae.propertyName), class: "tok-propertyName tok-definition" },
  { tag: ae.typeName, class: "tok-typeName" },
  { tag: ae.namespace, class: "tok-namespace" },
  { tag: ae.className, class: "tok-className" },
  { tag: ae.macroName, class: "tok-macroName" },
  { tag: ae.propertyName, class: "tok-propertyName" },
  { tag: ae.operator, class: "tok-operator" },
  { tag: ae.comment, class: "tok-comment" },
  { tag: ae.meta, class: "tok-meta" },
  { tag: ae.invalid, class: "tok-invalid" },
  { tag: ae.punctuation, class: "tok-punctuation" }
]);
var pf;
const ss = /* @__PURE__ */ new ut();
function iy(e) {
  return He.define({
    combine: e ? (t) => t.concat(e) : void 0
  });
}
const Sm = /* @__PURE__ */ new ut();
class Ya {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, n, a = [], i = "") {
    this.data = t, this.name = i, ot.prototype.hasOwnProperty("tree") || Object.defineProperty(ot.prototype, "tree", { get() {
      return Tn(this);
    } }), this.parser = n, this.extension = [
      Ql.of(this),
      ot.languageData.of((l, r, s) => {
        let o = Hp(l, r, s), u = o.type.prop(ss);
        if (!u)
          return [];
        let c = l.facet(u), d = o.type.prop(Sm);
        if (d) {
          let f = o.resolve(r - o.from, s);
          for (let h of d)
            if (h.test(f, l)) {
              let m = l.facet(h.facet);
              return h.type == "replace" ? m : m.concat(c);
            }
        }
        return c;
      })
    ].concat(a);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, n, a = -1) {
    return Hp(t, n, a).type.prop(ss) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let n = t.facet(Ql);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let a = [], i = (l, r) => {
      if (l.prop(ss) == this.data) {
        a.push({ from: r, to: r + l.length });
        return;
      }
      let s = l.prop(ut.mounted);
      if (s) {
        if (s.tree.prop(ss) == this.data) {
          if (s.overlay)
            for (let o of s.overlay)
              a.push({ from: o.from + r, to: o.to + r });
          else
            a.push({ from: r, to: r + l.length });
          return;
        } else if (s.overlay) {
          let o = a.length;
          if (i(s.tree, s.overlay[0].from + r), a.length > o)
            return;
        }
      }
      for (let o = 0; o < l.children.length; o++) {
        let u = l.children[o];
        u instanceof kn && i(u, l.positions[o] + r);
      }
    };
    return i(Tn(t), 0), a;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Ya.setState = /* @__PURE__ */ at.define();
function Hp(e, t, n) {
  let a = e.facet(Ql), i = Tn(e).topNode;
  if (!a || a.allowsNesting)
    for (let l = i; l; l = l.enter(t, n, Vn.ExcludeBuffers))
      l.type.isTop && (i = l);
  return i;
}
class nu extends Ya {
  constructor(t, n, a) {
    super(t, n, [], a), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let n = iy(t.languageData);
    return new nu(n, t.parser.configure({
      props: [ss.add((a) => a.isTop ? n : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, n) {
    return new nu(this.data, this.parser.configure(t), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Tn(e) {
  let t = e.field(Ya.state, !1);
  return t ? t.tree : kn.empty;
}
class FA {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, n) {
    let a = this.cursorPos - this.string.length;
    return t < a || n >= this.cursorPos ? this.doc.sliceString(t, n) : this.string.slice(t - a, n - a);
  }
}
let co = null;
class ud {
  constructor(t, n, a = [], i, l, r, s, o) {
    this.parser = t, this.state = n, this.fragments = a, this.tree = i, this.treeLen = l, this.viewport = r, this.skipped = s, this.scheduleOn = o, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, n, a) {
    return new ud(t, n, [], kn.empty, 0, a, [], null);
  }
  startParse() {
    return this.parser.startParse(new FA(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != kn.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var a;
      if (typeof t == "number") {
        let i = Date.now() + t;
        t = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(dr.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (a = this.parse.stoppedAt) !== null && a !== void 0 ? a : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, n;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = n, this.fragments = this.withoutTempSkipped(dr.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let n = co;
    co = this;
    try {
      return t();
    } finally {
      co = n;
    }
  }
  withoutTempSkipped(t) {
    for (let n; n = this.tempSkipped.pop(); )
      t = jp(t, n.from, n.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, n) {
    let { fragments: a, tree: i, treeLen: l, viewport: r, skipped: s } = this;
    if (this.takeTree(), !t.empty) {
      let o = [];
      if (t.iterChangedRanges((u, c, d, f) => o.push({ fromA: u, toA: c, fromB: d, toB: f })), a = dr.applyChanges(a, o), i = kn.empty, l = 0, r = { from: t.mapPos(r.from, -1), to: t.mapPos(r.to, 1) }, this.skipped.length) {
        s = [];
        for (let u of this.skipped) {
          let c = t.mapPos(u.from, 1), d = t.mapPos(u.to, -1);
          c < d && s.push({ from: c, to: d });
        }
      }
    }
    return new ud(this.parser, n, a, i, l, r, s, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let n = this.skipped.length;
    for (let a = 0; a < this.skipped.length; a++) {
      let { from: i, to: l } = this.skipped[a];
      i < t.to && l > t.from && (this.fragments = jp(this.fragments, i, l), this.skipped.splice(a--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, n) {
    this.skipped.push({ from: t, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends ty {
      createParse(n, a, i) {
        let l = i[0].from, r = i[i.length - 1].to;
        return {
          parsedPos: l,
          advance() {
            let o = co;
            if (o) {
              for (let u of i)
                o.tempSkipped.push(u);
              t && (o.scheduleOn = o.scheduleOn ? Promise.all([o.scheduleOn, t]) : t);
            }
            return this.parsedPos = r, new kn(pa.none, [], [], r - l);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= t && n.length && n[0].from == 0 && n[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return co;
  }
}
function jp(e, t, n) {
  return dr.applyChanges(e, [{ fromA: t, toA: n, fromB: t, toB: n }]);
}
class Ms {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(t.changes, t.state), a = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, a) || n.takeTree(), new Ms(n);
  }
  static init(t) {
    let n = Math.min(3e3, t.doc.length), a = ud.create(t.facet(Ql).parser, t, { from: 0, to: n });
    return a.work(20, n) || a.takeTree(), new Ms(a);
  }
}
Ya.state = /* @__PURE__ */ $n.define({
  create: Ms.init,
  update(e, t) {
    for (let n of t.effects)
      if (n.is(Ya.setState))
        return n.value;
    return t.startState.facet(Ql) != t.state.facet(Ql) ? Ms.init(t.state) : e.apply(t);
  }
});
let ly = (e) => {
  let t = setTimeout(
    () => e(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
};
typeof requestIdleCallback < "u" && (ly = (e) => {
  let t = -1, n = setTimeout(
    () => {
      t = requestIdleCallback(e, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(n) : cancelIdleCallback(t);
});
const yf = typeof navigator < "u" && (!((pf = navigator.scheduling) === null || pf === void 0) && pf.isInputPending) ? () => navigator.scheduling.isInputPending() : null, XA = /* @__PURE__ */ rn.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let n = this.view.state.field(Ya.state).context;
    (n.updateViewport(t.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, n = t.field(Ya.state);
    (n.tree != n.context.tree || !n.context.isDone(t.doc.length)) && (this.working = ly(this.work));
  }
  work(t) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: a, viewport: { to: i } } = this.view, l = a.field(Ya.state);
    if (l.tree == l.context.tree && l.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let r = Date.now() + Math.min(this.chunkBudget, 100, t && !yf ? Math.max(25, t.timeRemaining() - 5) : 1e9), s = l.context.treeLen < i && a.doc.length > i + 1e3, o = l.context.work(() => yf && yf() || Date.now() > r, i + (s ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (o || this.chunkBudget <= 0) && (l.context.takeTree(), this.view.dispatch({ effects: Ya.setState.of(new Ms(l.context)) })), this.chunkBudget > 0 && !(o && !s) && this.scheduleWork(), this.checkAsyncSchedule(l.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((n) => aa(this.view.state, n)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Ql = /* @__PURE__ */ He.define({
  combine(e) {
    return e.length ? e[0] : null;
  },
  enables: (e) => [
    Ya.state,
    XA,
    Re.contentAttributes.compute([e], (t) => {
      let n = t.facet(e);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class ry {
  /**
  Create a language support object.
  */
  constructor(t, n = []) {
    this.language = t, this.support = n, this.extension = [t, n];
  }
}
const YA = /* @__PURE__ */ He.define(), Lu = /* @__PURE__ */ He.define({
  combine: (e) => {
    if (!e.length)
      return "  ";
    let t = e[0];
    if (!t || /\S/.test(t) || Array.from(t).some((n) => n != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(e[0]));
    return t;
  }
});
function cd(e) {
  let t = e.facet(Lu);
  return t.charCodeAt(0) == 9 ? e.tabSize * t.length : t.length;
}
function au(e, t) {
  let n = "", a = e.tabSize, i = e.facet(Lu)[0];
  if (i == "	") {
    for (; t >= a; )
      n += "	", t -= a;
    i = " ";
  }
  for (let l = 0; l < t; l++)
    n += i;
  return n;
}
function xm(e, t) {
  e instanceof ot && (e = new O1(e));
  for (let a of e.state.facet(YA)) {
    let i = a(e, t);
    if (i !== void 0)
      return i;
  }
  let n = Tn(e.state);
  return n.length >= t ? WA(e, n, t) : null;
}
class O1 {
  /**
  Create an indent context.
  */
  constructor(t, n = {}) {
    this.state = t, this.options = n, this.unit = cd(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, n = 1) {
    let a = this.state.doc.lineAt(t), { simulateBreak: i, simulateDoubleBreak: l } = this.options;
    return i != null && i >= a.from && i <= a.to ? l && i == t ? { text: "", from: t } : (n < 0 ? i < t : i <= t) ? { text: a.text.slice(i - a.from), from: i } : { text: a.text.slice(0, i - a.from), from: a.from } : a;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, n = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: a, from: i } = this.lineAt(t, n);
    return a.slice(t - i, Math.min(a.length, t + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(t, n = 1) {
    let { text: a, from: i } = this.lineAt(t, n), l = this.countColumn(a, t - i), r = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return r > -1 && (l += r - this.countColumn(a, a.search(/\S|$/))), l;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, n = t.length) {
    return Js(t, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, n = 1) {
    let { text: a, from: i } = this.lineAt(t, n), l = this.options.overrideIndentation;
    if (l) {
      let r = l(i);
      if (r > -1)
        return r;
    }
    return this.countColumn(a, a.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Pm = /* @__PURE__ */ new ut();
function WA(e, t, n) {
  let a = t.resolveStack(n), i = t.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
  if (i != a.node) {
    let l = [];
    for (let r = i; r && !(r.from == a.node.from && r.type == a.node.type); r = r.parent)
      l.push(r);
    for (let r = l.length - 1; r >= 0; r--)
      a = { node: l[r], next: a };
  }
  return sy(a, e, n);
}
function sy(e, t, n) {
  for (let a = e; a; a = a.next) {
    let i = UA(a.node);
    if (i)
      return i($m.create(t, n, a));
  }
  return 0;
}
function qA(e) {
  return e.pos == e.options.simulateBreak && e.options.simulateDoubleBreak;
}
function UA(e) {
  let t = e.type.prop(Pm);
  if (t)
    return t;
  let n = e.firstChild, a;
  if (n && (a = n.type.prop(ut.closedBy))) {
    let i = e.lastChild, l = i && a.indexOf(i.name) > -1;
    return (r) => oy(r, !0, 1, void 0, l && !qA(r) ? i.from : void 0);
  }
  return e.parent == null ? GA : null;
}
function GA() {
  return 0;
}
class $m extends O1 {
  constructor(t, n, a) {
    super(t.state, t.options), this.base = t, this.pos = n, this.context = a;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, n, a) {
    return new $m(t, n, a);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let n = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let a = t.resolve(n.from);
      for (; a.parent && a.parent.from == a.from; )
        a = a.parent;
      if (KA(a, t))
        break;
      n = this.state.doc.lineAt(a.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return sy(this.context.next, this.base, this.pos);
  }
}
function KA(e, t) {
  for (let n = t; n; n = n.parent)
    if (e == n)
      return !0;
  return !1;
}
function JA(e) {
  let t = e.node, n = t.childAfter(t.from), a = t.lastChild;
  if (!n)
    return null;
  let i = e.options.simulateBreak, l = e.state.doc.lineAt(n.from), r = i == null || i <= l.from ? l.to : Math.min(l.to, i);
  for (let s = n.to; ; ) {
    let o = t.childAfter(s);
    if (!o || o == a)
      return null;
    if (!o.type.isSkipped) {
      if (o.from >= r)
        return null;
      let u = /^ */.exec(l.text.slice(n.to - l.from))[0].length;
      return { from: n.from, to: n.to + u };
    }
    s = o.to;
  }
}
function y0({ closing: e, align: t = !0, units: n = 1 }) {
  return (a) => oy(a, t, n, e);
}
function oy(e, t, n, a, i) {
  let l = e.textAfter, r = l.match(/^\s*/)[0].length, s = a && l.slice(r, r + a.length) == a || i == e.pos + r, o = t ? JA(e) : null;
  return o ? s ? e.column(o.from) : e.column(o.to) : e.baseIndent + (s ? 0 : e.unit * n);
}
const eD = (e) => e.baseIndent;
function Of({ except: e, units: t = 1 } = {}) {
  return (n) => {
    let a = e && e.test(n.textAfter);
    return n.baseIndent + (a ? 0 : t * n.unit);
  };
}
const tD = 200;
function nD() {
  return ot.transactionFilter.of((e) => {
    if (!e.docChanged || !e.isUserEvent("input.type") && !e.isUserEvent("input.complete"))
      return e;
    let t = e.startState.languageDataAt("indentOnInput", e.startState.selection.main.head);
    if (!t.length)
      return e;
    let n = e.newDoc, { head: a } = e.newSelection.main, i = n.lineAt(a);
    if (a > i.from + tD)
      return e;
    let l = n.sliceString(i.from, a);
    if (!t.some((u) => u.test(l)))
      return e;
    let { state: r } = e, s = -1, o = [];
    for (let { head: u } of r.selection.ranges) {
      let c = r.doc.lineAt(u);
      if (c.from == s)
        continue;
      s = c.from;
      let d = xm(r, c.from);
      if (d == null)
        continue;
      let f = /^\s*/.exec(c.text)[0], h = au(r, d);
      f != h && o.push({ from: c.from, to: c.from + f.length, insert: h });
    }
    return o.length ? [e, { changes: o, sequential: !0 }] : e;
  });
}
const aD = /* @__PURE__ */ He.define(), _m = /* @__PURE__ */ new ut();
function uy(e) {
  let t = e.firstChild, n = e.lastChild;
  return t && t.to < n.from ? { from: t.to, to: n.type.isError ? e.to : n.from } : null;
}
function iD(e, t, n) {
  let a = Tn(e);
  if (a.length < n)
    return null;
  let i = a.resolveStack(n, 1), l = null;
  for (let r = i; r; r = r.next) {
    let s = r.node;
    if (s.to <= n || s.from > n)
      continue;
    if (l && s.from < t)
      break;
    let o = s.type.prop(_m);
    if (o && (s.to < a.length - 50 || a.length == e.doc.length || !lD(s))) {
      let u = o(s, e);
      u && u.from <= n && u.from >= t && u.to > n && (l = u);
    }
  }
  return l;
}
function lD(e) {
  let t = e.lastChild;
  return t && t.to == e.to && t.type.isError;
}
function dd(e, t, n) {
  for (let a of e.facet(aD)) {
    let i = a(e, t, n);
    if (i)
      return i;
  }
  return iD(e, t, n);
}
function cy(e, t) {
  let n = t.mapPos(e.from, 1), a = t.mapPos(e.to, -1);
  return n >= a ? void 0 : { from: n, to: a };
}
const b1 = /* @__PURE__ */ at.define({ map: cy }), Qu = /* @__PURE__ */ at.define({ map: cy });
function dy(e) {
  let t = [];
  for (let { head: n } of e.state.selection.ranges)
    t.some((a) => a.from <= n && a.to >= n) || t.push(e.lineBlockAt(n));
  return t;
}
const _r = /* @__PURE__ */ $n.define({
  create() {
    return qe.none;
  },
  update(e, t) {
    e = e.map(t.changes);
    for (let n of t.effects)
      if (n.is(b1) && !rD(e, n.value.from, n.value.to)) {
        let { preparePlaceholder: a } = t.state.facet(my), i = a ? qe.replace({ widget: new hD(a(t.state, n.value)) }) : zp;
        e = e.update({ add: [i.range(n.value.from, n.value.to)] });
      } else n.is(Qu) && (e = e.update({
        filter: (a, i) => n.value.from != a || n.value.to != i,
        filterFrom: n.value.from,
        filterTo: n.value.to
      }));
    if (t.selection) {
      let n = !1, { head: a } = t.selection.main;
      e.between(a, a, (i, l) => {
        i < a && l > a && (n = !0);
      }), n && (e = e.update({
        filterFrom: a,
        filterTo: a,
        filter: (i, l) => l <= a || i >= a
      }));
    }
    return e;
  },
  provide: (e) => Re.decorations.from(e),
  toJSON(e, t) {
    let n = [];
    return e.between(0, t.doc.length, (a, i) => {
      n.push(a, i);
    }), n;
  },
  fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let t = [];
    for (let n = 0; n < e.length; ) {
      let a = e[n++], i = e[n++];
      if (typeof a != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      t.push(zp.range(a, i));
    }
    return qe.set(t, !0);
  }
});
function fd(e, t, n) {
  var a;
  let i = null;
  return (a = e.field(_r, !1)) === null || a === void 0 || a.between(t, n, (l, r) => {
    (!i || i.from > l) && (i = { from: l, to: r });
  }), i;
}
function rD(e, t, n) {
  let a = !1;
  return e.between(t, t, (i, l) => {
    i == t && l == n && (a = !0);
  }), a;
}
function fy(e, t) {
  return e.field(_r, !1) ? t : t.concat(at.appendConfig.of(vy()));
}
const sD = (e) => {
  for (let t of dy(e)) {
    let n = dd(e.state, t.from, t.to);
    if (n)
      return e.dispatch({ effects: fy(e.state, [b1.of(n), hy(e, n)]) }), !0;
  }
  return !1;
}, oD = (e) => {
  if (!e.state.field(_r, !1))
    return !1;
  let t = [];
  for (let n of dy(e)) {
    let a = fd(e.state, n.from, n.to);
    a && t.push(Qu.of(a), hy(e, a, !1));
  }
  return t.length && e.dispatch({ effects: t }), t.length > 0;
};
function hy(e, t, n = !0) {
  let a = e.state.doc.lineAt(t.from).number, i = e.state.doc.lineAt(t.to).number;
  return Re.announce.of(`${e.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${a} ${e.state.phrase("to")} ${i}.`);
}
const uD = (e) => {
  let { state: t } = e, n = [];
  for (let a = 0; a < t.doc.length; ) {
    let i = e.lineBlockAt(a), l = dd(t, i.from, i.to);
    l && n.push(b1.of(l)), a = (l ? e.lineBlockAt(l.to) : i).to + 1;
  }
  return n.length && e.dispatch({ effects: fy(e.state, n) }), !!n.length;
}, cD = (e) => {
  let t = e.state.field(_r, !1);
  if (!t || !t.size)
    return !1;
  let n = [];
  return t.between(0, e.state.doc.length, (a, i) => {
    n.push(Qu.of({ from: a, to: i }));
  }), e.dispatch({ effects: n }), !0;
}, dD = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: sD },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: oD },
  { key: "Ctrl-Alt-[", run: uD },
  { key: "Ctrl-Alt-]", run: cD }
], fD = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, my = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, fD);
  }
});
function vy(e) {
  return [_r, gD];
}
function gy(e, t) {
  let { state: n } = e, a = n.facet(my), i = (r) => {
    let s = e.lineBlockAt(e.posAtDOM(r.target)), o = fd(e.state, s.from, s.to);
    o && e.dispatch({ effects: Qu.of(o) }), r.preventDefault();
  };
  if (a.placeholderDOM)
    return a.placeholderDOM(e, i, t);
  let l = document.createElement("span");
  return l.textContent = a.placeholderText, l.setAttribute("aria-label", n.phrase("folded code")), l.title = n.phrase("unfold"), l.className = "cm-foldPlaceholder", l.onclick = i, l;
}
const zp = /* @__PURE__ */ qe.replace({ widget: /* @__PURE__ */ new class extends Ii {
  toDOM(e) {
    return gy(e, null);
  }
}() });
class hD extends Ii {
  constructor(t) {
    super(), this.value = t;
  }
  eq(t) {
    return this.value == t.value;
  }
  toDOM(t) {
    return gy(t, this.value);
  }
}
const mD = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class bf extends Ti {
  constructor(t, n) {
    super(), this.config = t, this.open = n;
  }
  eq(t) {
    return this.config == t.config && this.open == t.open;
  }
  toDOM(t) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = t.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function vD(e = {}) {
  let t = Object.assign(Object.assign({}, mD), e), n = new bf(t, !0), a = new bf(t, !1), i = rn.fromClass(class {
    constructor(r) {
      this.from = r.viewport.from, this.markers = this.buildMarkers(r);
    }
    update(r) {
      (r.docChanged || r.viewportChanged || r.startState.facet(Ql) != r.state.facet(Ql) || r.startState.field(_r, !1) != r.state.field(_r, !1) || Tn(r.startState) != Tn(r.state) || t.foldingChanged(r)) && (this.markers = this.buildMarkers(r.view));
    }
    buildMarkers(r) {
      let s = new Gi();
      for (let o of r.viewportLineBlocks) {
        let u = fd(r.state, o.from, o.to) ? a : dd(r.state, o.from, o.to) ? n : null;
        u && s.add(o.from, o.from, u);
      }
      return s.finish();
    }
  }), { domEventHandlers: l } = t;
  return [
    i,
    W6({
      class: "cm-foldGutter",
      markers(r) {
        var s;
        return ((s = r.plugin(i)) === null || s === void 0 ? void 0 : s.markers) || mt.empty;
      },
      initialSpacer() {
        return new bf(t, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, l), { click: (r, s, o) => {
        if (l.click && l.click(r, s, o))
          return !0;
        let u = fd(r.state, s.from, s.to);
        if (u)
          return r.dispatch({ effects: Qu.of(u) }), !0;
        let c = dd(r.state, s.from, s.to);
        return c ? (r.dispatch({ effects: b1.of(c) }), !0) : !1;
      } })
    }),
    vy()
  ];
}
const gD = /* @__PURE__ */ Re.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Au {
  constructor(t, n) {
    this.specs = t;
    let a;
    function i(s) {
      let o = _l.newName();
      return (a || (a = /* @__PURE__ */ Object.create(null)))["." + o] = s, o;
    }
    const l = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, r = n.scope;
    this.scope = r instanceof Ya ? (s) => s.prop(ss) == r.data : r ? (s) => s == r : void 0, this.style = ay(t.map((s) => ({
      tag: s.tag,
      class: s.class || i(Object.assign({}, s, { tag: null }))
    })), {
      all: l
    }).style, this.module = a ? new _l(a) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, n) {
    return new Au(t, n || {});
  }
}
const O0 = /* @__PURE__ */ He.define(), py = /* @__PURE__ */ He.define({
  combine(e) {
    return e.length ? [e[0]] : null;
  }
});
function Cf(e) {
  let t = e.facet(O0);
  return t.length ? t : e.facet(py);
}
function Mm(e, t) {
  let n = [yD], a;
  return e instanceof Au && (e.module && n.push(Re.styleModule.of(e.module)), a = e.themeType), t != null && t.fallback ? n.push(py.of(e)) : a ? n.push(O0.computeN([Re.darkTheme], (i) => i.facet(Re.darkTheme) == (a == "dark") ? [e] : [])) : n.push(O0.of(e)), n;
}
class pD {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Tn(t.state), this.decorations = this.buildDeco(t, Cf(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let n = Tn(t.state), a = Cf(t.state), i = a != Cf(t.startState), { viewport: l } = t.view, r = t.changes.mapPos(this.decoratedTo, 1);
    n.length < l.to && !i && n.type == this.tree.type && r >= l.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = r) : (n != this.tree || t.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(t.view, a), this.decoratedTo = l.to);
  }
  buildDeco(t, n) {
    if (!n || !this.tree.length)
      return qe.none;
    let a = new Gi();
    for (let { from: i, to: l } of t.visibleRanges)
      HA(this.tree, n, (r, s, o) => {
        a.add(r, s, this.markCache[o] || (this.markCache[o] = qe.mark({ class: o })));
      }, i, l);
    return a.finish();
  }
}
const yD = /* @__PURE__ */ El.high(/* @__PURE__ */ rn.fromClass(pD, {
  decorations: (e) => e.decorations
})), yy = /* @__PURE__ */ Au.define([
  {
    tag: ae.meta,
    color: "#404740"
  },
  {
    tag: ae.link,
    textDecoration: "underline"
  },
  {
    tag: ae.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: ae.emphasis,
    fontStyle: "italic"
  },
  {
    tag: ae.strong,
    fontWeight: "bold"
  },
  {
    tag: ae.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: ae.keyword,
    color: "#708"
  },
  {
    tag: [ae.atom, ae.bool, ae.url, ae.contentSeparator, ae.labelName],
    color: "#219"
  },
  {
    tag: [ae.literal, ae.inserted],
    color: "#164"
  },
  {
    tag: [ae.string, ae.deleted],
    color: "#a11"
  },
  {
    tag: [ae.regexp, ae.escape, /* @__PURE__ */ ae.special(ae.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ ae.definition(ae.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ ae.local(ae.variableName),
    color: "#30a"
  },
  {
    tag: [ae.typeName, ae.namespace],
    color: "#085"
  },
  {
    tag: ae.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ ae.special(ae.variableName), ae.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ ae.definition(ae.propertyName),
    color: "#00c"
  },
  {
    tag: ae.comment,
    color: "#940"
  },
  {
    tag: ae.invalid,
    color: "#f00"
  }
]), OD = /* @__PURE__ */ Re.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), Oy = 1e4, by = "()[]{}", Cy = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, {
      afterCursor: !0,
      brackets: by,
      maxScanDistance: Oy,
      renderMatch: wD
    });
  }
}), bD = /* @__PURE__ */ qe.mark({ class: "cm-matchingBracket" }), CD = /* @__PURE__ */ qe.mark({ class: "cm-nonmatchingBracket" });
function wD(e) {
  let t = [], n = e.matched ? bD : CD;
  return t.push(n.range(e.start.from, e.start.to)), e.end && t.push(n.range(e.end.from, e.end.to)), t;
}
const kD = /* @__PURE__ */ $n.define({
  create() {
    return qe.none;
  },
  update(e, t) {
    if (!t.docChanged && !t.selection)
      return e;
    let n = [], a = t.state.facet(Cy);
    for (let i of t.state.selection.ranges) {
      if (!i.empty)
        continue;
      let l = wi(t.state, i.head, -1, a) || i.head > 0 && wi(t.state, i.head - 1, 1, a) || a.afterCursor && (wi(t.state, i.head, 1, a) || i.head < t.state.doc.length && wi(t.state, i.head + 1, -1, a));
      l && (n = n.concat(a.renderMatch(l, t.state)));
    }
    return qe.set(n, !0);
  },
  provide: (e) => Re.decorations.from(e)
}), SD = [
  kD,
  OD
];
function xD(e = {}) {
  return [Cy.of(e), SD];
}
const PD = /* @__PURE__ */ new ut();
function b0(e, t, n) {
  let a = e.prop(t < 0 ? ut.openedBy : ut.closedBy);
  if (a)
    return a;
  if (e.name.length == 1) {
    let i = n.indexOf(e.name);
    if (i > -1 && i % 2 == (t < 0 ? 1 : 0))
      return [n[i + t]];
  }
  return null;
}
function C0(e) {
  let t = e.type.prop(PD);
  return t ? t(e.node) : e;
}
function wi(e, t, n, a = {}) {
  let i = a.maxScanDistance || Oy, l = a.brackets || by, r = Tn(e), s = r.resolveInner(t, n);
  for (let o = s; o; o = o.parent) {
    let u = b0(o.type, n, l);
    if (u && o.from < o.to) {
      let c = C0(o);
      if (c && (n > 0 ? t >= c.from && t < c.to : t > c.from && t <= c.to))
        return $D(e, t, n, o, c, u, l);
    }
  }
  return _D(e, t, n, r, s.type, i, l);
}
function $D(e, t, n, a, i, l, r) {
  let s = a.parent, o = { from: i.from, to: i.to }, u = 0, c = s == null ? void 0 : s.cursor();
  if (c && (n < 0 ? c.childBefore(a.from) : c.childAfter(a.to)))
    do
      if (n < 0 ? c.to <= a.from : c.from >= a.to) {
        if (u == 0 && l.indexOf(c.type.name) > -1 && c.from < c.to) {
          let d = C0(c);
          return { start: o, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (b0(c.type, n, r))
          u++;
        else if (b0(c.type, -n, r)) {
          if (u == 0) {
            let d = C0(c);
            return {
              start: o,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (n < 0 ? c.prevSibling() : c.nextSibling());
  return { start: o, matched: !1 };
}
function _D(e, t, n, a, i, l, r) {
  let s = n < 0 ? e.sliceDoc(t - 1, t) : e.sliceDoc(t, t + 1), o = r.indexOf(s);
  if (o < 0 || o % 2 == 0 != n > 0)
    return null;
  let u = { from: n < 0 ? t - 1 : t, to: n > 0 ? t + 1 : t }, c = e.doc.iterRange(t, n > 0 ? e.doc.length : 0), d = 0;
  for (let f = 0; !c.next().done && f <= l; ) {
    let h = c.value;
    n < 0 && (f += h.length);
    let m = t + f * n;
    for (let g = n > 0 ? 0 : h.length - 1, v = n > 0 ? h.length : -1; g != v; g += n) {
      let y = r.indexOf(h[g]);
      if (!(y < 0 || a.resolveInner(m + g, 1).type != i))
        if (y % 2 == 0 == n > 0)
          d++;
        else {
          if (d == 1)
            return { start: u, end: { from: m + g, to: m + g + 1 }, matched: y >> 1 == o >> 1 };
          d--;
        }
    }
    n > 0 && (f += h.length);
  }
  return c.done ? { start: u, matched: !1 } : null;
}
const MD = /* @__PURE__ */ Object.create(null), Fp = [pa.none], Xp = [], Yp = /* @__PURE__ */ Object.create(null), VD = /* @__PURE__ */ Object.create(null);
for (let [e, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  VD[e] = /* @__PURE__ */ TD(MD, t);
function wf(e, t) {
  Xp.indexOf(e) > -1 || (Xp.push(e), console.warn(t));
}
function TD(e, t) {
  let n = [];
  for (let s of t.split(" ")) {
    let o = [];
    for (let u of s.split(".")) {
      let c = e[u] || ae[u];
      c ? typeof c == "function" ? o.length ? o = o.map(c) : wf(u, `Modifier ${u} used at start of tag`) : o.length ? wf(u, `Tag ${u} used as modifier`) : o = Array.isArray(c) ? c : [c] : wf(u, `Unknown highlighting tag ${u}`);
    }
    for (let u of o)
      n.push(u);
  }
  if (!n.length)
    return 0;
  let a = t.replace(/ /g, "_"), i = a + " " + n.map((s) => s.id), l = Yp[i];
  if (l)
    return l.id;
  let r = Yp[i] = pa.define({
    id: Fp.length,
    name: a,
    props: [km({ [a]: n })]
  });
  return Fp.push(r), r.id;
}
Nt.RTL, Nt.LTR;
const LD = (e) => {
  let { state: t } = e, n = t.doc.lineAt(t.selection.main.from), a = Tm(e.state, n.from);
  return a.line ? QD(e) : a.block ? DD(e) : !1;
};
function Vm(e, t) {
  return ({ state: n, dispatch: a }) => {
    if (n.readOnly)
      return !1;
    let i = e(t, n);
    return i ? (a(n.update(i)), !0) : !1;
  };
}
const QD = /* @__PURE__ */ Vm(
  BD,
  0
  /* CommentOption.Toggle */
), AD = /* @__PURE__ */ Vm(
  wy,
  0
  /* CommentOption.Toggle */
), DD = /* @__PURE__ */ Vm(
  (e, t) => wy(e, t, ID(t)),
  0
  /* CommentOption.Toggle */
);
function Tm(e, t) {
  let n = e.languageDataAt("commentTokens", t);
  return n.length ? n[0] : {};
}
const fo = 50;
function RD(e, { open: t, close: n }, a, i) {
  let l = e.sliceDoc(a - fo, a), r = e.sliceDoc(i, i + fo), s = /\s*$/.exec(l)[0].length, o = /^\s*/.exec(r)[0].length, u = l.length - s;
  if (l.slice(u - t.length, u) == t && r.slice(o, o + n.length) == n)
    return {
      open: { pos: a - s, margin: s && 1 },
      close: { pos: i + o, margin: o && 1 }
    };
  let c, d;
  i - a <= 2 * fo ? c = d = e.sliceDoc(a, i) : (c = e.sliceDoc(a, a + fo), d = e.sliceDoc(i - fo, i));
  let f = /^\s*/.exec(c)[0].length, h = /\s*$/.exec(d)[0].length, m = d.length - h - n.length;
  return c.slice(f, f + t.length) == t && d.slice(m, m + n.length) == n ? {
    open: {
      pos: a + f + t.length,
      margin: /\s/.test(c.charAt(f + t.length)) ? 1 : 0
    },
    close: {
      pos: i - h - n.length,
      margin: /\s/.test(d.charAt(m - 1)) ? 1 : 0
    }
  } : null;
}
function ID(e) {
  let t = [];
  for (let n of e.selection.ranges) {
    let a = e.doc.lineAt(n.from), i = n.to <= a.to ? a : e.doc.lineAt(n.to);
    i.from > a.from && i.from == n.to && (i = n.to == a.to + 1 ? a : e.doc.lineAt(n.to - 1));
    let l = t.length - 1;
    l >= 0 && t[l].to > a.from ? t[l].to = i.to : t.push({ from: a.from + /^\s*/.exec(a.text)[0].length, to: i.to });
  }
  return t;
}
function wy(e, t, n = t.selection.ranges) {
  let a = n.map((l) => Tm(t, l.from).block);
  if (!a.every((l) => l))
    return null;
  let i = n.map((l, r) => RD(t, a[r], l.from, l.to));
  if (e != 2 && !i.every((l) => l))
    return { changes: t.changes(n.map((l, r) => i[r] ? [] : [{ from: l.from, insert: a[r].open + " " }, { from: l.to, insert: " " + a[r].close }])) };
  if (e != 1 && i.some((l) => l)) {
    let l = [];
    for (let r = 0, s; r < i.length; r++)
      if (s = i[r]) {
        let o = a[r], { open: u, close: c } = s;
        l.push({ from: u.pos - o.open.length, to: u.pos + u.margin }, { from: c.pos - c.margin, to: c.pos + o.close.length });
      }
    return { changes: l };
  }
  return null;
}
function BD(e, t, n = t.selection.ranges) {
  let a = [], i = -1;
  for (let { from: l, to: r } of n) {
    let s = a.length, o = 1e9, u = Tm(t, l).line;
    if (u) {
      for (let c = l; c <= r; ) {
        let d = t.doc.lineAt(c);
        if (d.from > i && (l == r || r > d.from)) {
          i = d.from;
          let f = /^\s*/.exec(d.text)[0].length, h = f == d.length, m = d.text.slice(f, f + u.length) == u ? f : -1;
          f < d.text.length && f < o && (o = f), a.push({ line: d, comment: m, token: u, indent: f, empty: h, single: !1 });
        }
        c = d.to + 1;
      }
      if (o < 1e9)
        for (let c = s; c < a.length; c++)
          a[c].indent < a[c].line.text.length && (a[c].indent = o);
      a.length == s + 1 && (a[s].single = !0);
    }
  }
  if (e != 2 && a.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let l = [];
    for (let { line: s, token: o, indent: u, empty: c, single: d } of a)
      (d || !c) && l.push({ from: s.from + u, insert: o + " " });
    let r = t.changes(l);
    return { changes: r, selection: t.selection.map(r, 1) };
  } else if (e != 1 && a.some((l) => l.comment >= 0)) {
    let l = [];
    for (let { line: r, comment: s, token: o } of a)
      if (s >= 0) {
        let u = r.from + s, c = u + o.length;
        r.text[c - r.from] == " " && c++, l.push({ from: u, to: c });
      }
    return { changes: l };
  }
  return null;
}
const w0 = /* @__PURE__ */ rl.define(), ZD = /* @__PURE__ */ rl.define(), ED = /* @__PURE__ */ He.define(), ky = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (t, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (t, n) => (a, i) => t(a, i) || n(a, i)
    });
  }
}), Sy = /* @__PURE__ */ $n.define({
  create() {
    return ki.empty;
  },
  update(e, t) {
    let n = t.state.facet(ky), a = t.annotation(w0);
    if (a) {
      let o = ha.fromTransaction(t, a.selection), u = a.side, c = u == 0 ? e.undone : e.done;
      return o ? c = hd(c, c.length, n.minDepth, o) : c = _y(c, t.startState.selection), new ki(u == 0 ? a.rest : c, u == 0 ? c : a.rest);
    }
    let i = t.annotation(ZD);
    if ((i == "full" || i == "before") && (e = e.isolate()), t.annotation(wn.addToHistory) === !1)
      return t.changes.empty ? e : e.addMapping(t.changes.desc);
    let l = ha.fromTransaction(t), r = t.annotation(wn.time), s = t.annotation(wn.userEvent);
    return l ? e = e.addChanges(l, r, s, n, t) : t.selection && (e = e.addSelection(t.startState.selection, r, s, n.newGroupDelay)), (i == "full" || i == "after") && (e = e.isolate()), e;
  },
  toJSON(e) {
    return { done: e.done.map((t) => t.toJSON()), undone: e.undone.map((t) => t.toJSON()) };
  },
  fromJSON(e) {
    return new ki(e.done.map(ha.fromJSON), e.undone.map(ha.fromJSON));
  }
});
function xy(e = {}) {
  return [
    Sy,
    ky.of(e),
    Re.domEventHandlers({
      beforeinput(t, n) {
        let a = t.inputType == "historyUndo" ? Py : t.inputType == "historyRedo" ? k0 : null;
        return a ? (t.preventDefault(), a(n)) : !1;
      }
    })
  ];
}
function C1(e, t) {
  return function({ state: n, dispatch: a }) {
    if (!t && n.readOnly)
      return !1;
    let i = n.field(Sy, !1);
    if (!i)
      return !1;
    let l = i.pop(e, n, t);
    return l ? (a(l), !0) : !1;
  };
}
const Py = /* @__PURE__ */ C1(0, !1), k0 = /* @__PURE__ */ C1(1, !1), ND = /* @__PURE__ */ C1(0, !0), HD = /* @__PURE__ */ C1(1, !0);
class ha {
  constructor(t, n, a, i, l) {
    this.changes = t, this.effects = n, this.mapped = a, this.startSelection = i, this.selectionsAfter = l;
  }
  setSelAfter(t) {
    return new ha(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, n, a;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (a = this.startSelection) === null || a === void 0 ? void 0 : a.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(t) {
    return new ha(t.changes && Mn.fromJSON(t.changes), [], t.mapped && Pi.fromJSON(t.mapped), t.startSelection && we.fromJSON(t.startSelection), t.selectionsAfter.map(we.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, n) {
    let a = La;
    for (let i of t.startState.facet(ED)) {
      let l = i(t);
      l.length && (a = a.concat(l));
    }
    return !a.length && t.changes.empty ? null : new ha(t.changes.invert(t.startState.doc), a, void 0, n || t.startState.selection, La);
  }
  static selection(t) {
    return new ha(void 0, La, void 0, void 0, t);
  }
}
function hd(e, t, n, a) {
  let i = t + 1 > n + 20 ? t - n - 1 : 0, l = e.slice(i, t);
  return l.push(a), l;
}
function jD(e, t) {
  let n = [], a = !1;
  return e.iterChangedRanges((i, l) => n.push(i, l)), t.iterChangedRanges((i, l, r, s) => {
    for (let o = 0; o < n.length; ) {
      let u = n[o++], c = n[o++];
      s >= u && r <= c && (a = !0);
    }
  }), a;
}
function zD(e, t) {
  return e.ranges.length == t.ranges.length && e.ranges.filter((n, a) => n.empty != t.ranges[a].empty).length === 0;
}
function $y(e, t) {
  return e.length ? t.length ? e.concat(t) : e : t;
}
const La = [], FD = 200;
function _y(e, t) {
  if (e.length) {
    let n = e[e.length - 1], a = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - FD));
    return a.length && a[a.length - 1].eq(t) ? e : (a.push(t), hd(e, e.length - 1, 1e9, n.setSelAfter(a)));
  } else
    return [ha.selection([t])];
}
function XD(e) {
  let t = e[e.length - 1], n = e.slice();
  return n[e.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), n;
}
function kf(e, t) {
  if (!e.length)
    return e;
  let n = e.length, a = La;
  for (; n; ) {
    let i = YD(e[n - 1], t, a);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let l = e.slice(0, n);
      return l[n - 1] = i, l;
    } else
      t = i.mapped, n--, a = i.selectionsAfter;
  }
  return a.length ? [ha.selection(a)] : La;
}
function YD(e, t, n) {
  let a = $y(e.selectionsAfter.length ? e.selectionsAfter.map((s) => s.map(t)) : La, n);
  if (!e.changes)
    return ha.selection(a);
  let i = e.changes.map(t), l = t.mapDesc(e.changes, !0), r = e.mapped ? e.mapped.composeDesc(l) : l;
  return new ha(i, at.mapEffects(e.effects, t), r, e.startSelection.map(l), a);
}
const WD = /^(input\.type|delete)($|\.)/;
class ki {
  constructor(t, n, a = 0, i = void 0) {
    this.done = t, this.undone = n, this.prevTime = a, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new ki(this.done, this.undone) : this;
  }
  addChanges(t, n, a, i, l) {
    let r = this.done, s = r[r.length - 1];
    return s && s.changes && !s.changes.empty && t.changes && (!a || WD.test(a)) && (!s.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(l, jD(s.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    a == "input.type.compose") ? r = hd(r, r.length - 1, i.minDepth, new ha(t.changes.compose(s.changes), $y(at.mapEffects(t.effects, s.changes), s.effects), s.mapped, s.startSelection, La)) : r = hd(r, r.length, i.minDepth, t), new ki(r, La, n, a);
  }
  addSelection(t, n, a, i) {
    let l = this.done.length ? this.done[this.done.length - 1].selectionsAfter : La;
    return l.length > 0 && n - this.prevTime < i && a == this.prevUserEvent && a && /^select($|\.)/.test(a) && zD(l[l.length - 1], t) ? this : new ki(_y(this.done, t), this.undone, n, a);
  }
  addMapping(t) {
    return new ki(kf(this.done, t), kf(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, n, a) {
    let i = t == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let l = i[i.length - 1], r = l.selectionsAfter[0] || n.selection;
    if (a && l.selectionsAfter.length)
      return n.update({
        selection: l.selectionsAfter[l.selectionsAfter.length - 1],
        annotations: w0.of({ side: t, rest: XD(i), selection: r }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (l.changes) {
      let s = i.length == 1 ? La : i.slice(0, i.length - 1);
      return l.mapped && (s = kf(s, l.mapped)), n.update({
        changes: l.changes,
        selection: l.startSelection,
        effects: l.effects,
        annotations: w0.of({ side: t, rest: s, selection: r }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
ki.empty = /* @__PURE__ */ new ki(La, La);
const My = [
  { key: "Mod-z", run: Py, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: k0, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: k0, preventDefault: !0 },
  { key: "Mod-u", run: ND, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: HD, preventDefault: !0 }
];
function eo(e, t) {
  return we.create(e.ranges.map(t), e.mainIndex);
}
function Bi(e, t) {
  return e.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
function li({ state: e, dispatch: t }, n) {
  let a = eo(e.selection, n);
  return a.eq(e.selection, !0) ? !1 : (t(Bi(e, a)), !0);
}
function w1(e, t) {
  return we.cursor(t ? e.to : e.from);
}
function Vy(e, t) {
  return li(e, (n) => n.empty ? e.moveByChar(n, t) : w1(n, t));
}
function ta(e) {
  return e.textDirectionAt(e.state.selection.main.head) == Nt.LTR;
}
const Ty = (e) => Vy(e, !ta(e)), Ly = (e) => Vy(e, ta(e));
function Qy(e, t) {
  return li(e, (n) => n.empty ? e.moveByGroup(n, t) : w1(n, t));
}
const qD = (e) => Qy(e, !ta(e)), UD = (e) => Qy(e, ta(e));
function GD(e, t, n) {
  if (t.type.prop(n))
    return !0;
  let a = t.to - t.from;
  return a && (a > 2 || /[^\s,.;:]/.test(e.sliceDoc(t.from, t.to))) || t.firstChild;
}
function k1(e, t, n) {
  let a = Tn(e).resolveInner(t.head), i = n ? ut.closedBy : ut.openedBy;
  for (let o = t.head; ; ) {
    let u = n ? a.childAfter(o) : a.childBefore(o);
    if (!u)
      break;
    GD(e, u, i) ? a = u : o = n ? u.to : u.from;
  }
  let l = a.type.prop(i), r, s;
  return l && (r = n ? wi(e, a.from, 1) : wi(e, a.to, -1)) && r.matched ? s = n ? r.end.to : r.end.from : s = n ? a.to : a.from, we.cursor(s, n ? -1 : 1);
}
const KD = (e) => li(e, (t) => k1(e.state, t, !ta(e))), JD = (e) => li(e, (t) => k1(e.state, t, ta(e)));
function Ay(e, t) {
  return li(e, (n) => {
    if (!n.empty)
      return w1(n, t);
    let a = e.moveVertically(n, t);
    return a.head != n.head ? a : e.moveToLineBoundary(n, t);
  });
}
const Dy = (e) => Ay(e, !1), Ry = (e) => Ay(e, !0);
function Iy(e) {
  let t = e.scrollDOM.clientHeight < e.scrollDOM.scrollHeight - 2, n = 0, a = 0, i;
  if (t) {
    for (let l of e.state.facet(Re.scrollMargins)) {
      let r = l(e);
      r != null && r.top && (n = Math.max(r == null ? void 0 : r.top, n)), r != null && r.bottom && (a = Math.max(r == null ? void 0 : r.bottom, a));
    }
    i = e.scrollDOM.clientHeight - n - a;
  } else
    i = (e.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: a,
    selfScroll: t,
    height: Math.max(e.defaultLineHeight, i - 5)
  };
}
function By(e, t) {
  let n = Iy(e), { state: a } = e, i = eo(a.selection, (r) => r.empty ? e.moveVertically(r, t, n.height) : w1(r, t));
  if (i.eq(a.selection))
    return !1;
  let l;
  if (n.selfScroll) {
    let r = e.coordsAtPos(a.selection.main.head), s = e.scrollDOM.getBoundingClientRect(), o = s.top + n.marginTop, u = s.bottom - n.marginBottom;
    r && r.top > o && r.bottom < u && (l = Re.scrollIntoView(i.main.head, { y: "start", yMargin: r.top - o }));
  }
  return e.dispatch(Bi(a, i), { effects: l }), !0;
}
const Wp = (e) => By(e, !1), S0 = (e) => By(e, !0);
function Nl(e, t, n) {
  let a = e.lineBlockAt(t.head), i = e.moveToLineBoundary(t, n);
  if (i.head == t.head && i.head != (n ? a.to : a.from) && (i = e.moveToLineBoundary(t, n, !1)), !n && i.head == a.from && a.length) {
    let l = /^\s*/.exec(e.state.sliceDoc(a.from, Math.min(a.from + 100, a.to)))[0].length;
    l && t.head != a.from + l && (i = we.cursor(a.from + l));
  }
  return i;
}
const eR = (e) => li(e, (t) => Nl(e, t, !0)), tR = (e) => li(e, (t) => Nl(e, t, !1)), nR = (e) => li(e, (t) => Nl(e, t, !ta(e))), aR = (e) => li(e, (t) => Nl(e, t, ta(e))), iR = (e) => li(e, (t) => we.cursor(e.lineBlockAt(t.head).from, 1)), lR = (e) => li(e, (t) => we.cursor(e.lineBlockAt(t.head).to, -1));
function rR(e, t, n) {
  let a = !1, i = eo(e.selection, (l) => {
    let r = wi(e, l.head, -1) || wi(e, l.head, 1) || l.head > 0 && wi(e, l.head - 1, 1) || l.head < e.doc.length && wi(e, l.head + 1, -1);
    if (!r || !r.end)
      return l;
    a = !0;
    let s = r.start.from == l.head ? r.end.to : r.end.from;
    return we.cursor(s);
  });
  return a ? (t(Bi(e, i)), !0) : !1;
}
const sR = ({ state: e, dispatch: t }) => rR(e, t);
function Ha(e, t) {
  let n = eo(e.state.selection, (a) => {
    let i = t(a);
    return we.range(a.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return n.eq(e.state.selection) ? !1 : (e.dispatch(Bi(e.state, n)), !0);
}
function Zy(e, t) {
  return Ha(e, (n) => e.moveByChar(n, t));
}
const Ey = (e) => Zy(e, !ta(e)), Ny = (e) => Zy(e, ta(e));
function Hy(e, t) {
  return Ha(e, (n) => e.moveByGroup(n, t));
}
const oR = (e) => Hy(e, !ta(e)), uR = (e) => Hy(e, ta(e)), cR = (e) => Ha(e, (t) => k1(e.state, t, !ta(e))), dR = (e) => Ha(e, (t) => k1(e.state, t, ta(e)));
function jy(e, t) {
  return Ha(e, (n) => e.moveVertically(n, t));
}
const zy = (e) => jy(e, !1), Fy = (e) => jy(e, !0);
function Xy(e, t) {
  return Ha(e, (n) => e.moveVertically(n, t, Iy(e).height));
}
const qp = (e) => Xy(e, !1), Up = (e) => Xy(e, !0), fR = (e) => Ha(e, (t) => Nl(e, t, !0)), hR = (e) => Ha(e, (t) => Nl(e, t, !1)), mR = (e) => Ha(e, (t) => Nl(e, t, !ta(e))), vR = (e) => Ha(e, (t) => Nl(e, t, ta(e))), gR = (e) => Ha(e, (t) => we.cursor(e.lineBlockAt(t.head).from)), pR = (e) => Ha(e, (t) => we.cursor(e.lineBlockAt(t.head).to)), Gp = ({ state: e, dispatch: t }) => (t(Bi(e, { anchor: 0 })), !0), Kp = ({ state: e, dispatch: t }) => (t(Bi(e, { anchor: e.doc.length })), !0), Jp = ({ state: e, dispatch: t }) => (t(Bi(e, { anchor: e.selection.main.anchor, head: 0 })), !0), e9 = ({ state: e, dispatch: t }) => (t(Bi(e, { anchor: e.selection.main.anchor, head: e.doc.length })), !0), yR = ({ state: e, dispatch: t }) => (t(e.update({ selection: { anchor: 0, head: e.doc.length }, userEvent: "select" })), !0), OR = ({ state: e, dispatch: t }) => {
  let n = S1(e).map(({ from: a, to: i }) => we.range(a, Math.min(i + 1, e.doc.length)));
  return t(e.update({ selection: we.create(n), userEvent: "select" })), !0;
}, bR = ({ state: e, dispatch: t }) => {
  let n = eo(e.selection, (a) => {
    let i = Tn(e), l = i.resolveStack(a.from, 1);
    if (a.empty) {
      let r = i.resolveStack(a.from, -1);
      r.node.from >= l.node.from && r.node.to <= l.node.to && (l = r);
    }
    for (let r = l; r; r = r.next) {
      let { node: s } = r;
      if ((s.from < a.from && s.to >= a.to || s.to > a.to && s.from <= a.from) && r.next)
        return we.range(s.to, s.from);
    }
    return a;
  });
  return n.eq(e.selection) ? !1 : (t(Bi(e, n)), !0);
}, CR = ({ state: e, dispatch: t }) => {
  let n = e.selection, a = null;
  return n.ranges.length > 1 ? a = we.create([n.main]) : n.main.empty || (a = we.create([we.cursor(n.main.head)])), a ? (t(Bi(e, a)), !0) : !1;
};
function Du(e, t) {
  if (e.state.readOnly)
    return !1;
  let n = "delete.selection", { state: a } = e, i = a.changeByRange((l) => {
    let { from: r, to: s } = l;
    if (r == s) {
      let o = t(l);
      o < r ? (n = "delete.backward", o = hc(e, o, !1)) : o > r && (n = "delete.forward", o = hc(e, o, !0)), r = Math.min(r, o), s = Math.max(s, o);
    } else
      r = hc(e, r, !1), s = hc(e, s, !0);
    return r == s ? { range: l } : { changes: { from: r, to: s }, range: we.cursor(r, r < l.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (e.dispatch(a.update(i, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? Re.announce.of(a.phrase("Selection deleted")) : void 0
  })), !0);
}
function hc(e, t, n) {
  if (e instanceof Re)
    for (let a of e.state.facet(Re.atomicRanges).map((i) => i(e)))
      a.between(t, t, (i, l) => {
        i < t && l > t && (t = n ? l : i);
      });
  return t;
}
const Yy = (e, t, n) => Du(e, (a) => {
  let i = a.from, { state: l } = e, r = l.doc.lineAt(i), s, o;
  if (n && !t && i > r.from && i < r.from + 200 && !/[^ \t]/.test(s = r.text.slice(0, i - r.from))) {
    if (s[s.length - 1] == "	")
      return i - 1;
    let u = Js(s, l.tabSize), c = u % cd(l) || cd(l);
    for (let d = 0; d < c && s[s.length - 1 - d] == " "; d++)
      i--;
    o = i;
  } else
    o = jn(r.text, i - r.from, t, t) + r.from, o == i && r.number != (t ? l.doc.lines : 1) ? o += t ? 1 : -1 : !t && /[\ufe00-\ufe0f]/.test(r.text.slice(o - r.from, i - r.from)) && (o = jn(r.text, o - r.from, !1, !1) + r.from);
  return o;
}), x0 = (e) => Yy(e, !1, !0), Wy = (e) => Yy(e, !0, !1), qy = (e, t) => Du(e, (n) => {
  let a = n.head, { state: i } = e, l = i.doc.lineAt(a), r = i.charCategorizer(a);
  for (let s = null; ; ) {
    if (a == (t ? l.to : l.from)) {
      a == n.head && l.number != (t ? i.doc.lines : 1) && (a += t ? 1 : -1);
      break;
    }
    let o = jn(l.text, a - l.from, t) + l.from, u = l.text.slice(Math.min(a, o) - l.from, Math.max(a, o) - l.from), c = r(u);
    if (s != null && c != s)
      break;
    (u != " " || a != n.head) && (s = c), a = o;
  }
  return a;
}), Uy = (e) => qy(e, !1), wR = (e) => qy(e, !0), kR = (e) => Du(e, (t) => {
  let n = e.lineBlockAt(t.head).to;
  return t.head < n ? n : Math.min(e.state.doc.length, t.head + 1);
}), SR = (e) => Du(e, (t) => {
  let n = e.moveToLineBoundary(t, !1).head;
  return t.head > n ? n : Math.max(0, t.head - 1);
}), xR = (e) => Du(e, (t) => {
  let n = e.moveToLineBoundary(t, !0).head;
  return t.head < n ? n : Math.min(e.state.doc.length, t.head + 1);
}), PR = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = e.changeByRange((a) => ({
    changes: { from: a.from, to: a.to, insert: gt.of(["", ""]) },
    range: we.cursor(a.from)
  }));
  return t(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, $R = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = e.changeByRange((a) => {
    if (!a.empty || a.from == 0 || a.from == e.doc.length)
      return { range: a };
    let i = a.from, l = e.doc.lineAt(i), r = i == l.from ? i - 1 : jn(l.text, i - l.from, !1) + l.from, s = i == l.to ? i + 1 : jn(l.text, i - l.from, !0) + l.from;
    return {
      changes: { from: r, to: s, insert: e.doc.slice(i, s).append(e.doc.slice(r, i)) },
      range: we.cursor(s)
    };
  });
  return n.changes.empty ? !1 : (t(e.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function S1(e) {
  let t = [], n = -1;
  for (let a of e.selection.ranges) {
    let i = e.doc.lineAt(a.from), l = e.doc.lineAt(a.to);
    if (!a.empty && a.to == l.from && (l = e.doc.lineAt(a.to - 1)), n >= i.number) {
      let r = t[t.length - 1];
      r.to = l.to, r.ranges.push(a);
    } else
      t.push({ from: i.from, to: l.to, ranges: [a] });
    n = l.number + 1;
  }
  return t;
}
function Gy(e, t, n) {
  if (e.readOnly)
    return !1;
  let a = [], i = [];
  for (let l of S1(e)) {
    if (n ? l.to == e.doc.length : l.from == 0)
      continue;
    let r = e.doc.lineAt(n ? l.to + 1 : l.from - 1), s = r.length + 1;
    if (n) {
      a.push({ from: l.to, to: r.to }, { from: l.from, insert: r.text + e.lineBreak });
      for (let o of l.ranges)
        i.push(we.range(Math.min(e.doc.length, o.anchor + s), Math.min(e.doc.length, o.head + s)));
    } else {
      a.push({ from: r.from, to: l.from }, { from: l.to, insert: e.lineBreak + r.text });
      for (let o of l.ranges)
        i.push(we.range(o.anchor - s, o.head - s));
    }
  }
  return a.length ? (t(e.update({
    changes: a,
    scrollIntoView: !0,
    selection: we.create(i, e.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const _R = ({ state: e, dispatch: t }) => Gy(e, t, !1), MR = ({ state: e, dispatch: t }) => Gy(e, t, !0);
function Ky(e, t, n) {
  if (e.readOnly)
    return !1;
  let a = [];
  for (let i of S1(e))
    n ? a.push({ from: i.from, insert: e.doc.slice(i.from, i.to) + e.lineBreak }) : a.push({ from: i.to, insert: e.lineBreak + e.doc.slice(i.from, i.to) });
  return t(e.update({ changes: a, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const VR = ({ state: e, dispatch: t }) => Ky(e, t, !1), TR = ({ state: e, dispatch: t }) => Ky(e, t, !0), LR = (e) => {
  if (e.state.readOnly)
    return !1;
  let { state: t } = e, n = t.changes(S1(t).map(({ from: i, to: l }) => (i > 0 ? i-- : l < t.doc.length && l++, { from: i, to: l }))), a = eo(t.selection, (i) => {
    let l;
    if (e.lineWrapping) {
      let r = e.lineBlockAt(i.head), s = e.coordsAtPos(i.head, i.assoc || 1);
      s && (l = r.bottom + e.documentTop - s.bottom + e.defaultLineHeight / 2);
    }
    return e.moveVertically(i, !0, l);
  }).map(n);
  return e.dispatch({ changes: n, selection: a, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function QR(e, t) {
  if (/\(\)|\[\]|\{\}/.test(e.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let n = Tn(e).resolveInner(t), a = n.childBefore(t), i = n.childAfter(t), l;
  return a && i && a.to <= t && i.from >= t && (l = a.type.prop(ut.closedBy)) && l.indexOf(i.name) > -1 && e.doc.lineAt(a.to).from == e.doc.lineAt(i.from).from && !/\S/.test(e.sliceDoc(a.to, i.from)) ? { from: a.to, to: i.from } : null;
}
const t9 = /* @__PURE__ */ Jy(!1), AR = /* @__PURE__ */ Jy(!0);
function Jy(e) {
  return ({ state: t, dispatch: n }) => {
    if (t.readOnly)
      return !1;
    let a = t.changeByRange((i) => {
      let { from: l, to: r } = i, s = t.doc.lineAt(l), o = !e && l == r && QR(t, l);
      e && (l = r = (r <= s.to ? s : t.doc.lineAt(r)).to);
      let u = new O1(t, { simulateBreak: l, simulateDoubleBreak: !!o }), c = xm(u, l);
      for (c == null && (c = Js(/^\s*/.exec(t.doc.lineAt(l).text)[0], t.tabSize)); r < s.to && /\s/.test(s.text[r - s.from]); )
        r++;
      o ? { from: l, to: r } = o : l > s.from && l < s.from + 100 && !/\S/.test(s.text.slice(0, l)) && (l = s.from);
      let d = ["", au(t, c)];
      return o && d.push(au(t, u.lineIndent(s.from, -1))), {
        changes: { from: l, to: r, insert: gt.of(d) },
        range: we.cursor(l + 1 + d[1].length)
      };
    });
    return n(t.update(a, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Lm(e, t) {
  let n = -1;
  return e.changeByRange((a) => {
    let i = [];
    for (let r = a.from; r <= a.to; ) {
      let s = e.doc.lineAt(r);
      s.number > n && (a.empty || a.to > s.from) && (t(s, i, a), n = s.number), r = s.to + 1;
    }
    let l = e.changes(i);
    return {
      changes: i,
      range: we.range(l.mapPos(a.anchor, 1), l.mapPos(a.head, 1))
    };
  });
}
const DR = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), a = new O1(e, { overrideIndentation: (l) => {
    let r = n[l];
    return r ?? -1;
  } }), i = Lm(e, (l, r, s) => {
    let o = xm(a, l.from);
    if (o == null)
      return;
    /\S/.test(l.text) || (o = 0);
    let u = /^\s*/.exec(l.text)[0], c = au(e, o);
    (u != c || s.from < l.from + u.length) && (n[l.from] = o, r.push({ from: l.from, to: l.from + u.length, insert: c }));
  });
  return i.changes.empty || t(e.update(i, { userEvent: "indent" })), !0;
}, eO = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update(Lm(e, (n, a) => {
  a.push({ from: n.from, insert: e.facet(Lu) });
}), { userEvent: "input.indent" })), !0), tO = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update(Lm(e, (n, a) => {
  let i = /^\s*/.exec(n.text)[0];
  if (!i)
    return;
  let l = Js(i, e.tabSize), r = 0, s = au(e, Math.max(0, l - cd(e)));
  for (; r < i.length && r < s.length && i.charCodeAt(r) == s.charCodeAt(r); )
    r++;
  a.push({ from: n.from + r, to: n.from + i.length, insert: s.slice(r) });
}), { userEvent: "delete.dedent" })), !0), RR = (e) => (e.setTabFocusMode(), !0), IR = [
  { key: "Ctrl-b", run: Ty, shift: Ey, preventDefault: !0 },
  { key: "Ctrl-f", run: Ly, shift: Ny },
  { key: "Ctrl-p", run: Dy, shift: zy },
  { key: "Ctrl-n", run: Ry, shift: Fy },
  { key: "Ctrl-a", run: iR, shift: gR },
  { key: "Ctrl-e", run: lR, shift: pR },
  { key: "Ctrl-d", run: Wy },
  { key: "Ctrl-h", run: x0 },
  { key: "Ctrl-k", run: kR },
  { key: "Ctrl-Alt-h", run: Uy },
  { key: "Ctrl-o", run: PR },
  { key: "Ctrl-t", run: $R },
  { key: "Ctrl-v", run: S0 }
], BR = /* @__PURE__ */ [
  { key: "ArrowLeft", run: Ty, shift: Ey, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: qD, shift: oR, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: nR, shift: mR, preventDefault: !0 },
  { key: "ArrowRight", run: Ly, shift: Ny, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: UD, shift: uR, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: aR, shift: vR, preventDefault: !0 },
  { key: "ArrowUp", run: Dy, shift: zy, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Gp, shift: Jp },
  { mac: "Ctrl-ArrowUp", run: Wp, shift: qp },
  { key: "ArrowDown", run: Ry, shift: Fy, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Kp, shift: e9 },
  { mac: "Ctrl-ArrowDown", run: S0, shift: Up },
  { key: "PageUp", run: Wp, shift: qp },
  { key: "PageDown", run: S0, shift: Up },
  { key: "Home", run: tR, shift: hR, preventDefault: !0 },
  { key: "Mod-Home", run: Gp, shift: Jp },
  { key: "End", run: eR, shift: fR, preventDefault: !0 },
  { key: "Mod-End", run: Kp, shift: e9 },
  { key: "Enter", run: t9, shift: t9 },
  { key: "Mod-a", run: yR },
  { key: "Backspace", run: x0, shift: x0 },
  { key: "Delete", run: Wy },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Uy },
  { key: "Mod-Delete", mac: "Alt-Delete", run: wR },
  { mac: "Mod-Backspace", run: SR },
  { mac: "Mod-Delete", run: xR }
].concat(/* @__PURE__ */ IR.map((e) => ({ mac: e.key, run: e.run, shift: e.shift }))), md = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: KD, shift: cR },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: JD, shift: dR },
  { key: "Alt-ArrowUp", run: _R },
  { key: "Shift-Alt-ArrowUp", run: VR },
  { key: "Alt-ArrowDown", run: MR },
  { key: "Shift-Alt-ArrowDown", run: TR },
  { key: "Escape", run: CR },
  { key: "Mod-Enter", run: AR },
  { key: "Alt-l", mac: "Ctrl-l", run: OR },
  { key: "Mod-i", run: bR, preventDefault: !0 },
  { key: "Mod-[", run: tO },
  { key: "Mod-]", run: eO },
  { key: "Mod-Alt-\\", run: DR },
  { key: "Shift-Mod-k", run: LR },
  { key: "Shift-Mod-\\", run: sR },
  { key: "Mod-/", run: LD },
  { key: "Alt-A", run: AD },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: RR }
].concat(BR), ZR = { key: "Tab", run: eO, shift: tO };
function Qt() {
  var e = arguments[0];
  typeof e == "string" && (e = document.createElement(e));
  var t = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var a in n) if (Object.prototype.hasOwnProperty.call(n, a)) {
      var i = n[a];
      typeof i == "string" ? e.setAttribute(a, i) : i != null && (e[a] = i);
    }
    t++;
  }
  for (; t < arguments.length; t++) nO(e, arguments[t]);
  return e;
}
function nO(e, t) {
  if (typeof t == "string")
    e.appendChild(document.createTextNode(t));
  else if (t != null) if (t.nodeType != null)
    e.appendChild(t);
  else if (Array.isArray(t))
    for (var n = 0; n < t.length; n++) nO(e, t[n]);
  else
    throw new RangeError("Unsupported child node: " + t);
}
class n9 {
  constructor(t, n, a) {
    this.from = t, this.to = n, this.diagnostic = a;
  }
}
class Kl {
  constructor(t, n, a) {
    this.diagnostics = t, this.panel = n, this.selected = a;
  }
  static init(t, n, a) {
    let i = t, l = a.facet(Si).markerFilter;
    l && (i = l(i, a));
    let r = t.slice().sort((d, f) => d.from - f.from || d.to - f.to), s = new Gi(), o = [], u = 0;
    for (let d = 0; ; ) {
      let f = d == r.length ? null : r[d];
      if (!f && !o.length)
        break;
      let h, m;
      for (o.length ? (h = u, m = o.reduce((v, y) => Math.min(v, y.to), f && f.from > h ? f.from : 1e8)) : (h = f.from, m = f.to, o.push(f), d++); d < r.length; ) {
        let v = r[d];
        if (v.from == h && (v.to > v.from || v.to == h))
          o.push(v), d++, m = Math.min(v.to, m);
        else {
          m = Math.min(v.from, m);
          break;
        }
      }
      let g = cO(o);
      if (o.some((v) => v.from == v.to || v.from == v.to - 1 && a.doc.lineAt(v.from).to == v.from))
        s.add(h, h, qe.widget({
          widget: new qR(g),
          diagnostics: o.slice()
        }));
      else {
        let v = o.reduce((y, b) => b.markClass ? y + " " + b.markClass : y, "");
        s.add(h, m, qe.mark({
          class: "cm-lintRange cm-lintRange-" + g + v,
          diagnostics: o.slice(),
          inclusiveEnd: o.some((y) => y.to > m)
        }));
      }
      u = m;
      for (let v = 0; v < o.length; v++)
        o[v].to <= u && o.splice(v--, 1);
    }
    let c = s.finish();
    return new Kl(c, n, Vs(c));
  }
}
function Vs(e, t = null, n = 0) {
  let a = null;
  return e.between(n, 1e9, (i, l, { spec: r }) => {
    if (!(t && r.diagnostics.indexOf(t) < 0))
      if (!a)
        a = new n9(i, l, t || r.diagnostics[0]);
      else {
        if (r.diagnostics.indexOf(a.diagnostic) < 0)
          return !1;
        a = new n9(a.from, l, a.diagnostic);
      }
  }), a;
}
function aO(e, t) {
  let n = t.pos, a = t.end || n, i = e.state.facet(Si).hideOn(e, n, a);
  if (i != null)
    return i;
  let l = e.startState.doc.lineAt(t.pos);
  return !!(e.effects.some((r) => r.is(x1)) || e.changes.touchesRange(l.from, Math.max(l.to, a)));
}
function iO(e, t) {
  return e.field(ma, !1) ? t : t.concat(at.appendConfig.of(hO));
}
function ER(e, t) {
  return {
    effects: iO(e, [x1.of(t)])
  };
}
const x1 = /* @__PURE__ */ at.define(), Qm = /* @__PURE__ */ at.define(), lO = /* @__PURE__ */ at.define(), ma = /* @__PURE__ */ $n.define({
  create() {
    return new Kl(qe.none, null, null);
  },
  update(e, t) {
    if (t.docChanged && e.diagnostics.size) {
      let n = e.diagnostics.map(t.changes), a = null, i = e.panel;
      if (e.selected) {
        let l = t.changes.mapPos(e.selected.from, 1);
        a = Vs(n, e.selected.diagnostic, l) || Vs(n, null, l);
      }
      !n.size && i && t.state.facet(Si).autoPanel && (i = null), e = new Kl(n, i, a);
    }
    for (let n of t.effects)
      if (n.is(x1)) {
        let a = t.state.facet(Si).autoPanel ? n.value.length ? iu.open : null : e.panel;
        e = Kl.init(n.value, a, t.state);
      } else n.is(Qm) ? e = new Kl(e.diagnostics, n.value ? iu.open : null, e.selected) : n.is(lO) && (e = new Kl(e.diagnostics, e.panel, n.value));
    return e;
  },
  provide: (e) => [
    eu.from(e, (t) => t.panel),
    Re.decorations.from(e, (t) => t.diagnostics)
  ]
});
function NR(e) {
  let t = e.field(ma, !1);
  return t ? t.diagnostics.size : 0;
}
const HR = /* @__PURE__ */ qe.mark({ class: "cm-lintRange cm-lintRange-active" });
function jR(e, t, n) {
  let { diagnostics: a } = e.state.field(ma), i, l = -1, r = -1;
  a.between(t - (n < 0 ? 1 : 0), t + (n > 0 ? 1 : 0), (o, u, { spec: c }) => {
    if (t >= o && t <= u && (o == u || (t > o || n > 0) && (t < u || n < 0)))
      return i = c.diagnostics, l = o, r = u, !1;
  });
  let s = e.state.facet(Si).tooltipFilter;
  return i && s && (i = s(i, e.state)), i ? {
    pos: l,
    end: r,
    above: e.state.doc.lineAt(l).to < r,
    create() {
      return { dom: rO(e, i) };
    }
  } : null;
}
function rO(e, t) {
  return Qt("ul", { class: "cm-tooltip-lint" }, t.map((n) => uO(e, n, !1)));
}
const zR = (e) => {
  let t = e.state.field(ma, !1);
  (!t || !t.panel) && e.dispatch({ effects: iO(e.state, [Qm.of(!0)]) });
  let n = Jo(e, iu.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, a9 = (e) => {
  let t = e.state.field(ma, !1);
  return !t || !t.panel ? !1 : (e.dispatch({ effects: Qm.of(!1) }), !0);
}, FR = (e) => {
  let t = e.state.field(ma, !1);
  if (!t)
    return !1;
  let n = e.state.selection.main, a = t.diagnostics.iter(n.to + 1);
  return !a.value && (a = t.diagnostics.iter(0), !a.value || a.from == n.from && a.to == n.to) ? !1 : (e.dispatch({ selection: { anchor: a.from, head: a.to }, scrollIntoView: !0 }), !0);
}, XR = [
  { key: "Mod-Shift-m", run: zR, preventDefault: !0 },
  { key: "F8", run: FR }
], sO = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.view = e, this.timeout = -1, this.set = !0;
    let { delay: t } = e.state.facet(Si);
    this.lintTime = Date.now() + t, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, t);
  }
  run() {
    clearTimeout(this.timeout);
    let e = Date.now();
    if (e < this.lintTime - 10)
      this.timeout = setTimeout(this.run, this.lintTime - e);
    else {
      this.set = !1;
      let { state: t } = this.view, { sources: n } = t.facet(Si);
      n.length && YR(n.map((a) => Promise.resolve(a(this.view))), (a) => {
        this.view.state.doc == t.doc && this.view.dispatch(ER(this.view.state, a.reduce((i, l) => i.concat(l))));
      }, (a) => {
        aa(this.view.state, a);
      });
    }
  }
  update(e) {
    let t = e.state.facet(Si);
    (e.docChanged || t != e.startState.facet(Si) || t.needsRefresh && t.needsRefresh(e)) && (this.lintTime = Date.now() + t.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, t.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function YR(e, t, n) {
  let a = [], i = -1;
  for (let l of e)
    l.then((r) => {
      a.push(r), clearTimeout(i), a.length == e.length ? t(a) : i = setTimeout(() => t(a), 200);
    }, n);
}
const Si = /* @__PURE__ */ He.define({
  combine(e) {
    return Object.assign({ sources: e.map((t) => t.source).filter((t) => t != null) }, ii(e.map((t) => t.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (t, n) => t ? n ? (a) => t(a) || n(a) : t : n
    }));
  }
});
function WR(e, t = {}) {
  return [
    Si.of({ source: e, config: t }),
    sO,
    hO
  ];
}
function i9(e) {
  let t = e.plugin(sO);
  t && t.force();
}
function oO(e) {
  let t = [];
  if (e)
    e: for (let { name: n } of e) {
      for (let a = 0; a < n.length; a++) {
        let i = n[a];
        if (/[a-zA-Z]/.test(i) && !t.some((l) => l.toLowerCase() == i.toLowerCase())) {
          t.push(i);
          continue e;
        }
      }
      t.push("");
    }
  return t;
}
function uO(e, t, n) {
  var a;
  let i = n ? oO(t.actions) : [];
  return Qt("li", { class: "cm-diagnostic cm-diagnostic-" + t.severity }, Qt("span", { class: "cm-diagnosticText" }, t.renderMessage ? t.renderMessage(e) : t.message), (a = t.actions) === null || a === void 0 ? void 0 : a.map((l, r) => {
    let s = !1, o = (f) => {
      if (f.preventDefault(), s)
        return;
      s = !0;
      let h = Vs(e.state.field(ma).diagnostics, t);
      h && l.apply(e, h.from, h.to);
    }, { name: u } = l, c = i[r] ? u.indexOf(i[r]) : -1, d = c < 0 ? u : [
      u.slice(0, c),
      Qt("u", u.slice(c, c + 1)),
      u.slice(c + 1)
    ];
    return Qt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: o,
      onmousedown: o,
      "aria-label": ` Action: ${u}${c < 0 ? "" : ` (access key "${i[r]})"`}.`
    }, d);
  }), t.source && Qt("div", { class: "cm-diagnosticSource" }, t.source));
}
class qR extends Ii {
  constructor(t) {
    super(), this.sev = t;
  }
  eq(t) {
    return t.sev == this.sev;
  }
  toDOM() {
    return Qt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class l9 {
  constructor(t, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = uO(t, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class iu {
  constructor(t) {
    this.view = t, this.items = [];
    let n = (i) => {
      if (i.keyCode == 27)
        a9(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: l } = this.items[this.selectedIndex], r = oO(l.actions);
        for (let s = 0; s < r.length; s++)
          if (r[s].toUpperCase().charCodeAt(0) == i.keyCode) {
            let o = Vs(this.view.state.field(ma).diagnostics, l);
            o && l.actions[s].apply(t, o.from, o.to);
          }
      } else
        return;
      i.preventDefault();
    }, a = (i) => {
      for (let l = 0; l < this.items.length; l++)
        this.items[l].dom.contains(i.target) && this.moveSelection(l);
    };
    this.list = Qt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: a
    }), this.dom = Qt("div", { class: "cm-panel-lint" }, this.list, Qt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => a9(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let t = this.view.state.field(ma).selected;
    if (!t)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == t.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: t, selected: n } = this.view.state.field(ma), a = 0, i = !1, l = null, r = /* @__PURE__ */ new Set();
    for (t.between(0, this.view.state.doc.length, (s, o, { spec: u }) => {
      for (let c of u.diagnostics) {
        if (r.has(c))
          continue;
        r.add(c);
        let d = -1, f;
        for (let h = a; h < this.items.length; h++)
          if (this.items[h].diagnostic == c) {
            d = h;
            break;
          }
        d < 0 ? (f = new l9(this.view, c), this.items.splice(a, 0, f), i = !0) : (f = this.items[d], d > a && (this.items.splice(a, d - a), i = !0)), n && f.diagnostic == n.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), l = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), a++;
      }
    }); a < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new l9(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), l ? (this.list.setAttribute("aria-activedescendant", l.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: l.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: s, panel: o }) => {
        let u = o.height / this.list.offsetHeight;
        s.top < o.top ? this.list.scrollTop -= (o.top - s.top) / u : s.bottom > o.bottom && (this.list.scrollTop += (s.bottom - o.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let t = this.list.firstChild;
    function n() {
      let a = t;
      t = a.nextSibling, a.remove();
    }
    for (let a of this.items)
      if (a.dom.parentNode == this.list) {
        for (; t != a.dom; )
          n();
        t = a.dom.nextSibling;
      } else
        this.list.insertBefore(a.dom, t);
    for (; t; )
      n();
  }
  moveSelection(t) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(ma), a = Vs(n.diagnostics, this.items[t].diagnostic);
    a && this.view.dispatch({
      selection: { anchor: a.from, head: a.to },
      scrollIntoView: !0,
      effects: lO.of(a)
    });
  }
  static open(t) {
    return new iu(t);
  }
}
function Dc(e, t = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(e)}</svg>')`;
}
function mc(e) {
  return Dc(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${e}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const UR = /* @__PURE__ */ Re.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ mc("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ mc("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ mc("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ mc("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function GR(e) {
  return e == "error" ? 4 : e == "warning" ? 3 : e == "info" ? 2 : 1;
}
function cO(e) {
  let t = "hint", n = 1;
  for (let a of e) {
    let i = GR(a.severity);
    i > n && (n = i, t = a.severity);
  }
  return t;
}
class dO extends Ti {
  constructor(t) {
    super(), this.diagnostics = t, this.severity = cO(t);
  }
  toDOM(t) {
    let n = document.createElement("div");
    n.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let a = this.diagnostics, i = t.state.facet(P1).tooltipFilter;
    return i && (a = i(a, t.state)), a.length && (n.onmouseover = () => JR(t, n, a)), n;
  }
}
function KR(e, t) {
  let n = (a) => {
    let i = t.getBoundingClientRect();
    if (!(a.clientX > i.left - 10 && a.clientX < i.right + 10 && a.clientY > i.top - 10 && a.clientY < i.bottom + 10)) {
      for (let l = a.target; l; l = l.parentNode)
        if (l.nodeType == 1 && l.classList.contains("cm-tooltip-lint"))
          return;
      window.removeEventListener("mousemove", n), e.state.field(fO) && e.dispatch({ effects: Am.of(null) });
    }
  };
  window.addEventListener("mousemove", n);
}
function JR(e, t, n) {
  function a() {
    let r = e.elementAtHeight(t.getBoundingClientRect().top + 5 - e.documentTop);
    e.coordsAtPos(r.from) && e.dispatch({ effects: Am.of({
      pos: r.from,
      above: !1,
      clip: !1,
      create() {
        return {
          dom: rO(e, n),
          getCoords: () => t.getBoundingClientRect()
        };
      }
    }) }), t.onmouseout = t.onmousemove = null, KR(e, t);
  }
  let { hoverTime: i } = e.state.facet(P1), l = setTimeout(a, i);
  t.onmouseout = () => {
    clearTimeout(l), t.onmouseout = t.onmousemove = null;
  }, t.onmousemove = () => {
    clearTimeout(l), l = setTimeout(a, i);
  };
}
function eI(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let i of t) {
    let l = e.lineAt(i.from);
    (n[l.from] || (n[l.from] = [])).push(i);
  }
  let a = [];
  for (let i in n)
    a.push(new dO(n[i]).range(+i));
  return mt.of(a, !0);
}
const tI = /* @__PURE__ */ W6({
  class: "cm-gutter-lint",
  markers: (e) => e.state.field(P0),
  widgetMarker: (e, t, n) => {
    let a = [];
    return e.state.field(P0).between(n.from, n.to, (i, l, r) => {
      i > n.from && i < n.to && a.push(...r.diagnostics);
    }), a.length ? new dO(a) : null;
  }
}), P0 = /* @__PURE__ */ $n.define({
  create() {
    return mt.empty;
  },
  update(e, t) {
    e = e.map(t.changes);
    let n = t.state.facet(P1).markerFilter;
    for (let a of t.effects)
      if (a.is(x1)) {
        let i = a.value;
        n && (i = n(i || [], t.state)), e = eI(t.state.doc, i.slice(0));
      }
    return e;
  }
}), Am = /* @__PURE__ */ at.define(), fO = /* @__PURE__ */ $n.define({
  create() {
    return null;
  },
  update(e, t) {
    return e && t.docChanged && (e = aO(t, e) ? null : Object.assign(Object.assign({}, e), { pos: t.changes.mapPos(e.pos) })), t.effects.reduce((n, a) => a.is(Am) ? a.value : n, e);
  },
  provide: (e) => p1.from(e)
}), nI = /* @__PURE__ */ Re.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: /* @__PURE__ */ Dc('<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>')
  },
  ".cm-lint-marker-warning": {
    content: /* @__PURE__ */ Dc('<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>')
  },
  ".cm-lint-marker-error": {
    content: /* @__PURE__ */ Dc('<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>')
  }
}), hO = [
  ma,
  /* @__PURE__ */ Re.decorations.compute([ma], (e) => {
    let { selected: t, panel: n } = e.field(ma);
    return !t || !n || t.from == t.to ? qe.none : qe.set([
      HR.range(t.from, t.to)
    ]);
  }),
  /* @__PURE__ */ vA(jR, { hideOn: aO }),
  UR
], P1 = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});
function aI(e = {}) {
  return [P1.of(e), P0, tI, nI, fO];
}
const r9 = typeof String.prototype.normalize == "function" ? (e) => e.normalize("NFKD") : (e) => e;
class Ts {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(t, n, a = 0, i = t.length, l, r) {
    this.test = r, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = t.iterRange(a, i), this.bufferStart = a, this.normalize = l ? (s) => l(r9(s)) : r9, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return ca(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let t = this.peek();
      if (t < 0)
        return this.done = !0, this;
      let n = im(t), a = this.bufferStart + this.bufferPos;
      this.bufferPos += mi(t);
      let i = this.normalize(n);
      if (i.length)
        for (let l = 0, r = a; ; l++) {
          let s = i.charCodeAt(l), o = this.match(s, r, this.bufferPos + this.bufferStart);
          if (l == i.length - 1) {
            if (o)
              return this.value = o, this;
            break;
          }
          r == a && l < n.length && n.charCodeAt(l) == s && r++;
        }
    }
  }
  match(t, n, a) {
    let i = null;
    for (let l = 0; l < this.matches.length; l += 2) {
      let r = this.matches[l], s = !1;
      this.query.charCodeAt(r) == t && (r == this.query.length - 1 ? i = { from: this.matches[l + 1], to: a } : (this.matches[l]++, s = !0)), s || (this.matches.splice(l, 2), l -= 2);
    }
    return this.query.charCodeAt(0) == t && (this.query.length == 1 ? i = { from: n, to: a } : this.matches.push(1, n)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Ts.prototype[Symbol.iterator] = function() {
  return this;
});
const mO = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Dm = "gm" + (/x/.unicode == null ? "" : "u");
class vO {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(t, n, a, i = 0, l = t.length) {
    if (this.text = t, this.to = l, this.curLine = "", this.done = !1, this.value = mO, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new gO(t, n, a, i, l);
    this.re = new RegExp(n, Dm + (a != null && a.ignoreCase ? "i" : "")), this.test = a == null ? void 0 : a.test, this.iter = t.iter();
    let r = t.lineAt(i);
    this.curLineStart = r.from, this.matchPos = vd(t, i), this.getLine(this.curLineStart);
  }
  getLine(t) {
    this.iter.next(t), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let t = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = t;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let a = this.curLineStart + n.index, i = a + n[0].length;
        if (this.matchPos = vd(this.text, i + (a == i ? 1 : 0)), a == this.curLineStart + this.curLine.length && this.nextLine(), (a < i || a > this.value.to) && (!this.test || this.test(a, i, n)))
          return this.value = { from: a, to: i, match: n }, this;
        t = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), t = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Sf = /* @__PURE__ */ new WeakMap();
class hs {
  constructor(t, n) {
    this.from = t, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(t, n, a) {
    let i = Sf.get(t);
    if (!i || i.from >= a || i.to <= n) {
      let s = new hs(n, t.sliceString(n, a));
      return Sf.set(t, s), s;
    }
    if (i.from == n && i.to == a)
      return i;
    let { text: l, from: r } = i;
    return r > n && (l = t.sliceString(n, r) + l, r = n), i.to < a && (l += t.sliceString(i.to, a)), Sf.set(t, new hs(r, l)), new hs(n, l.slice(n - r, a - r));
  }
}
class gO {
  constructor(t, n, a, i, l) {
    this.text = t, this.to = l, this.done = !1, this.value = mO, this.matchPos = vd(t, i), this.re = new RegExp(n, Dm + (a != null && a.ignoreCase ? "i" : "")), this.test = a == null ? void 0 : a.test, this.flat = hs.get(t, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(t) {
    return t >= this.to ? this.to : this.text.lineAt(t).to;
  }
  next() {
    for (; ; ) {
      let t = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == t && (this.re.lastIndex = t + 1, n = this.re.exec(this.flat.text)), n) {
        let a = this.flat.from + n.index, i = a + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(a, i, n)))
          return this.value = { from: a, to: i, match: n }, this.matchPos = vd(this.text, i + (a == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = hs.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (vO.prototype[Symbol.iterator] = gO.prototype[Symbol.iterator] = function() {
  return this;
});
function iI(e) {
  try {
    return new RegExp(e, Dm), !0;
  } catch {
    return !1;
  }
}
function vd(e, t) {
  if (t >= e.length)
    return t;
  let n = e.lineAt(t), a;
  for (; t < n.to && (a = n.text.charCodeAt(t - n.from)) >= 56320 && a < 57344; )
    t++;
  return t;
}
function $0(e) {
  let t = String(e.state.doc.lineAt(e.state.selection.main.head).number), n = Qt("input", { class: "cm-textfield", name: "line", value: t }), a = Qt("form", {
    class: "cm-gotoLine",
    onkeydown: (l) => {
      l.keyCode == 27 ? (l.preventDefault(), e.dispatch({ effects: gd.of(!1) }), e.focus()) : l.keyCode == 13 && (l.preventDefault(), i());
    },
    onsubmit: (l) => {
      l.preventDefault(), i();
    }
  }, Qt("label", e.state.phrase("Go to line"), ": ", n), " ", Qt("button", { class: "cm-button", type: "submit" }, e.state.phrase("go")));
  function i() {
    let l = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!l)
      return;
    let { state: r } = e, s = r.doc.lineAt(r.selection.main.head), [, o, u, c, d] = l, f = c ? +c.slice(1) : 0, h = u ? +u : s.number;
    if (u && d) {
      let v = h / 100;
      o && (v = v * (o == "-" ? -1 : 1) + s.number / r.doc.lines), h = Math.round(r.doc.lines * v);
    } else u && o && (h = h * (o == "-" ? -1 : 1) + s.number);
    let m = r.doc.line(Math.max(1, Math.min(r.doc.lines, h))), g = we.cursor(m.from + Math.max(0, Math.min(f, m.length)));
    e.dispatch({
      effects: [gd.of(!1), Re.scrollIntoView(g.from, { y: "center" })],
      selection: g
    }), e.focus();
  }
  return { dom: a };
}
const gd = /* @__PURE__ */ at.define(), s9 = /* @__PURE__ */ $n.define({
  create() {
    return !0;
  },
  update(e, t) {
    for (let n of t.effects)
      n.is(gd) && (e = n.value);
    return e;
  },
  provide: (e) => eu.from(e, (t) => t ? $0 : null)
}), lI = (e) => {
  let t = Jo(e, $0);
  if (!t) {
    let n = [gd.of(!0)];
    e.state.field(s9, !1) == null && n.push(at.appendConfig.of([s9, rI])), e.dispatch({ effects: n }), t = Jo(e, $0);
  }
  return t && t.dom.querySelector("input").select(), !0;
}, rI = /* @__PURE__ */ Re.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), sI = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, oI = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, sI, {
      highlightWordAroundCursor: (t, n) => t || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function uI(e) {
  return [mI, hI];
}
const cI = /* @__PURE__ */ qe.mark({ class: "cm-selectionMatch" }), dI = /* @__PURE__ */ qe.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function o9(e, t, n, a) {
  return (n == 0 || e(t.sliceDoc(n - 1, n)) != Ft.Word) && (a == t.doc.length || e(t.sliceDoc(a, a + 1)) != Ft.Word);
}
function fI(e, t, n, a) {
  return e(t.sliceDoc(n, n + 1)) == Ft.Word && e(t.sliceDoc(a - 1, a)) == Ft.Word;
}
const hI = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.decorations = this.getDeco(e);
  }
  update(e) {
    (e.selectionSet || e.docChanged || e.viewportChanged) && (this.decorations = this.getDeco(e.view));
  }
  getDeco(e) {
    let t = e.state.facet(oI), { state: n } = e, a = n.selection;
    if (a.ranges.length > 1)
      return qe.none;
    let i = a.main, l, r = null;
    if (i.empty) {
      if (!t.highlightWordAroundCursor)
        return qe.none;
      let o = n.wordAt(i.head);
      if (!o)
        return qe.none;
      r = n.charCategorizer(i.head), l = n.sliceDoc(o.from, o.to);
    } else {
      let o = i.to - i.from;
      if (o < t.minSelectionLength || o > 200)
        return qe.none;
      if (t.wholeWords) {
        if (l = n.sliceDoc(i.from, i.to), r = n.charCategorizer(i.head), !(o9(r, n, i.from, i.to) && fI(r, n, i.from, i.to)))
          return qe.none;
      } else if (l = n.sliceDoc(i.from, i.to), !l)
        return qe.none;
    }
    let s = [];
    for (let o of e.visibleRanges) {
      let u = new Ts(n.doc, l, o.from, o.to);
      for (; !u.next().done; ) {
        let { from: c, to: d } = u.value;
        if ((!r || o9(r, n, c, d)) && (i.empty && c <= i.from && d >= i.to ? s.push(dI.range(c, d)) : (c >= i.to || d <= i.from) && s.push(cI.range(c, d)), s.length > t.maxMatches))
          return qe.none;
      }
    }
    return qe.set(s);
  }
}, {
  decorations: (e) => e.decorations
}), mI = /* @__PURE__ */ Re.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), vI = ({ state: e, dispatch: t }) => {
  let { selection: n } = e, a = we.create(n.ranges.map((i) => e.wordAt(i.head) || we.cursor(i.head)), n.mainIndex);
  return a.eq(n) ? !1 : (t(e.update({ selection: a })), !0);
};
function gI(e, t) {
  let { main: n, ranges: a } = e.selection, i = e.wordAt(n.head), l = i && i.from == n.from && i.to == n.to;
  for (let r = !1, s = new Ts(e.doc, t, a[a.length - 1].to); ; )
    if (s.next(), s.done) {
      if (r)
        return null;
      s = new Ts(e.doc, t, 0, Math.max(0, a[a.length - 1].from - 1)), r = !0;
    } else {
      if (r && a.some((o) => o.from == s.value.from))
        continue;
      if (l) {
        let o = e.wordAt(s.value.from);
        if (!o || o.from != s.value.from || o.to != s.value.to)
          continue;
      }
      return s.value;
    }
}
const pI = ({ state: e, dispatch: t }) => {
  let { ranges: n } = e.selection;
  if (n.some((l) => l.from === l.to))
    return vI({ state: e, dispatch: t });
  let a = e.sliceDoc(n[0].from, n[0].to);
  if (e.selection.ranges.some((l) => e.sliceDoc(l.from, l.to) != a))
    return !1;
  let i = gI(e, a);
  return i ? (t(e.update({
    selection: e.selection.addRange(we.range(i.from, i.to), !1),
    effects: Re.scrollIntoView(i.to)
  })), !0) : !1;
}, to = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (t) => new MI(t),
      scrollToMatch: (t) => Re.scrollIntoView(t)
    });
  }
});
class pO {
  /**
  Create a query object.
  */
  constructor(t) {
    this.search = t.search, this.caseSensitive = !!t.caseSensitive, this.literal = !!t.literal, this.regexp = !!t.regexp, this.replace = t.replace || "", this.valid = !!this.search && (!this.regexp || iI(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!t.wholeWord;
  }
  /**
  @internal
  */
  unquote(t) {
    return this.literal ? t : t.replace(/\\([nrt\\])/g, (n, a) => a == "n" ? `
` : a == "r" ? "\r" : a == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(t) {
    return this.search == t.search && this.replace == t.replace && this.caseSensitive == t.caseSensitive && this.regexp == t.regexp && this.wholeWord == t.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new CI(this) : new OI(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(t, n = 0, a) {
    let i = t.doc ? t : ot.create({ doc: t });
    return a == null && (a = i.doc.length), this.regexp ? ts(this, i, n, a) : es(this, i, n, a);
  }
}
class yO {
  constructor(t) {
    this.spec = t;
  }
}
function es(e, t, n, a) {
  return new Ts(t.doc, e.unquoted, n, a, e.caseSensitive ? void 0 : (i) => i.toLowerCase(), e.wholeWord ? yI(t.doc, t.charCategorizer(t.selection.main.head)) : void 0);
}
function yI(e, t) {
  return (n, a, i, l) => ((l > n || l + i.length < a) && (l = Math.max(0, n - 2), i = e.sliceString(l, Math.min(e.length, a + 2))), (t(pd(i, n - l)) != Ft.Word || t(yd(i, n - l)) != Ft.Word) && (t(yd(i, a - l)) != Ft.Word || t(pd(i, a - l)) != Ft.Word));
}
class OI extends yO {
  constructor(t) {
    super(t);
  }
  nextMatch(t, n, a) {
    let i = es(this.spec, t, a, t.doc.length).nextOverlapping();
    if (i.done) {
      let l = Math.min(t.doc.length, n + this.spec.unquoted.length);
      i = es(this.spec, t, 0, l).nextOverlapping();
    }
    return i.done || i.value.from == n && i.value.to == a ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(t, n, a) {
    for (let i = a; ; ) {
      let l = Math.max(n, i - 1e4 - this.spec.unquoted.length), r = es(this.spec, t, l, i), s = null;
      for (; !r.nextOverlapping().done; )
        s = r.value;
      if (s)
        return s;
      if (l == n)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(t, n, a) {
    let i = this.prevMatchInRange(t, 0, n);
    return i || (i = this.prevMatchInRange(t, Math.max(0, a - this.spec.unquoted.length), t.doc.length)), i && (i.from != n || i.to != a) ? i : null;
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(t, n) {
    let a = es(this.spec, t, 0, t.doc.length), i = [];
    for (; !a.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(a.value);
    }
    return i;
  }
  highlight(t, n, a, i) {
    let l = es(this.spec, t, Math.max(0, n - this.spec.unquoted.length), Math.min(a + this.spec.unquoted.length, t.doc.length));
    for (; !l.next().done; )
      i(l.value.from, l.value.to);
  }
}
function ts(e, t, n, a) {
  return new vO(t.doc, e.search, {
    ignoreCase: !e.caseSensitive,
    test: e.wholeWord ? bI(t.charCategorizer(t.selection.main.head)) : void 0
  }, n, a);
}
function pd(e, t) {
  return e.slice(jn(e, t, !1), t);
}
function yd(e, t) {
  return e.slice(t, jn(e, t));
}
function bI(e) {
  return (t, n, a) => !a[0].length || (e(pd(a.input, a.index)) != Ft.Word || e(yd(a.input, a.index)) != Ft.Word) && (e(yd(a.input, a.index + a[0].length)) != Ft.Word || e(pd(a.input, a.index + a[0].length)) != Ft.Word);
}
class CI extends yO {
  nextMatch(t, n, a) {
    let i = ts(this.spec, t, a, t.doc.length).next();
    return i.done && (i = ts(this.spec, t, 0, n).next()), i.done ? null : i.value;
  }
  prevMatchInRange(t, n, a) {
    for (let i = 1; ; i++) {
      let l = Math.max(
        n,
        a - i * 1e4
        /* FindPrev.ChunkSize */
      ), r = ts(this.spec, t, l, a), s = null;
      for (; !r.next().done; )
        s = r.value;
      if (s && (l == n || s.from > l + 10))
        return s;
      if (l == n)
        return null;
    }
  }
  prevMatch(t, n, a) {
    return this.prevMatchInRange(t, 0, n) || this.prevMatchInRange(t, a, t.doc.length);
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, a) => a == "$" ? "$" : a == "&" ? t.match[0] : a != "0" && +a < t.match.length ? t.match[a] : n);
  }
  matchAll(t, n) {
    let a = ts(this.spec, t, 0, t.doc.length), i = [];
    for (; !a.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(a.value);
    }
    return i;
  }
  highlight(t, n, a, i) {
    let l = ts(this.spec, t, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(a + 250, t.doc.length));
    for (; !l.next().done; )
      i(l.value.from, l.value.to);
  }
}
const lu = /* @__PURE__ */ at.define(), Rm = /* @__PURE__ */ at.define(), kl = /* @__PURE__ */ $n.define({
  create(e) {
    return new xf(_0(e).create(), null);
  },
  update(e, t) {
    for (let n of t.effects)
      n.is(lu) ? e = new xf(n.value.create(), e.panel) : n.is(Rm) && (e = new xf(e.query, n.value ? Im : null));
    return e;
  },
  provide: (e) => eu.from(e, (t) => t.panel)
});
class xf {
  constructor(t, n) {
    this.query = t, this.panel = n;
  }
}
const wI = /* @__PURE__ */ qe.mark({ class: "cm-searchMatch" }), kI = /* @__PURE__ */ qe.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), SI = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.view = e, this.decorations = this.highlight(e.state.field(kl));
  }
  update(e) {
    let t = e.state.field(kl);
    (t != e.startState.field(kl) || e.docChanged || e.selectionSet || e.viewportChanged) && (this.decorations = this.highlight(t));
  }
  highlight({ query: e, panel: t }) {
    if (!t || !e.spec.valid)
      return qe.none;
    let { view: n } = this, a = new Gi();
    for (let i = 0, l = n.visibleRanges, r = l.length; i < r; i++) {
      let { from: s, to: o } = l[i];
      for (; i < r - 1 && o > l[i + 1].from - 2 * 250; )
        o = l[++i].to;
      e.highlight(n.state, s, o, (u, c) => {
        let d = n.state.selection.ranges.some((f) => f.from == u && f.to == c);
        a.add(u, c, d ? kI : wI);
      });
    }
    return a.finish();
  }
}, {
  decorations: (e) => e.decorations
});
function Ru(e) {
  return (t) => {
    let n = t.state.field(kl, !1);
    return n && n.query.spec.valid ? e(t, n) : CO(t);
  };
}
const Od = /* @__PURE__ */ Ru((e, { query: t }) => {
  let { to: n } = e.state.selection.main, a = t.nextMatch(e.state, n, n);
  if (!a)
    return !1;
  let i = we.single(a.from, a.to), l = e.state.facet(to);
  return e.dispatch({
    selection: i,
    effects: [Bm(e, a), l.scrollToMatch(i.main, e)],
    userEvent: "select.search"
  }), bO(e), !0;
}), bd = /* @__PURE__ */ Ru((e, { query: t }) => {
  let { state: n } = e, { from: a } = n.selection.main, i = t.prevMatch(n, a, a);
  if (!i)
    return !1;
  let l = we.single(i.from, i.to), r = e.state.facet(to);
  return e.dispatch({
    selection: l,
    effects: [Bm(e, i), r.scrollToMatch(l.main, e)],
    userEvent: "select.search"
  }), bO(e), !0;
}), xI = /* @__PURE__ */ Ru((e, { query: t }) => {
  let n = t.matchAll(e.state, 1e3);
  return !n || !n.length ? !1 : (e.dispatch({
    selection: we.create(n.map((a) => we.range(a.from, a.to))),
    userEvent: "select.search.matches"
  }), !0);
}), PI = ({ state: e, dispatch: t }) => {
  let n = e.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: a, to: i } = n.main, l = [], r = 0;
  for (let s = new Ts(e.doc, e.sliceDoc(a, i)); !s.next().done; ) {
    if (l.length > 1e3)
      return !1;
    s.value.from == a && (r = l.length), l.push(we.range(s.value.from, s.value.to));
  }
  return t(e.update({
    selection: we.create(l, r),
    userEvent: "select.search.matches"
  })), !0;
}, u9 = /* @__PURE__ */ Ru((e, { query: t }) => {
  let { state: n } = e, { from: a, to: i } = n.selection.main;
  if (n.readOnly)
    return !1;
  let l = t.nextMatch(n, a, a);
  if (!l)
    return !1;
  let r = l, s = [], o, u, c = [];
  if (r.from == a && r.to == i && (u = n.toText(t.getReplacement(r)), s.push({ from: r.from, to: r.to, insert: u }), r = t.nextMatch(n, r.from, r.to), c.push(Re.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(a).number) + "."))), r) {
    let d = s.length == 0 || s[0].from >= l.to ? 0 : l.to - l.from - u.length;
    o = we.single(r.from - d, r.to - d), c.push(Bm(e, r)), c.push(n.facet(to).scrollToMatch(o.main, e));
  }
  return e.dispatch({
    changes: s,
    selection: o,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), $I = /* @__PURE__ */ Ru((e, { query: t }) => {
  if (e.state.readOnly)
    return !1;
  let n = t.matchAll(e.state, 1e9).map((i) => {
    let { from: l, to: r } = i;
    return { from: l, to: r, insert: t.getReplacement(i) };
  });
  if (!n.length)
    return !1;
  let a = e.state.phrase("replaced $ matches", n.length) + ".";
  return e.dispatch({
    changes: n,
    effects: Re.announce.of(a),
    userEvent: "input.replace.all"
  }), !0;
});
function Im(e) {
  return e.state.facet(to).createPanel(e);
}
function _0(e, t) {
  var n, a, i, l, r;
  let s = e.selection.main, o = s.empty || s.to > s.from + 100 ? "" : e.sliceDoc(s.from, s.to);
  if (t && !o)
    return t;
  let u = e.facet(to);
  return new pO({
    search: ((n = t == null ? void 0 : t.literal) !== null && n !== void 0 ? n : u.literal) ? o : o.replace(/\n/g, "\\n"),
    caseSensitive: (a = t == null ? void 0 : t.caseSensitive) !== null && a !== void 0 ? a : u.caseSensitive,
    literal: (i = t == null ? void 0 : t.literal) !== null && i !== void 0 ? i : u.literal,
    regexp: (l = t == null ? void 0 : t.regexp) !== null && l !== void 0 ? l : u.regexp,
    wholeWord: (r = t == null ? void 0 : t.wholeWord) !== null && r !== void 0 ? r : u.wholeWord
  });
}
function OO(e) {
  let t = Jo(e, Im);
  return t && t.dom.querySelector("[main-field]");
}
function bO(e) {
  let t = OO(e);
  t && t == e.root.activeElement && t.select();
}
const CO = (e) => {
  let t = e.state.field(kl, !1);
  if (t && t.panel) {
    let n = OO(e);
    if (n && n != e.root.activeElement) {
      let a = _0(e.state, t.query.spec);
      a.valid && e.dispatch({ effects: lu.of(a) }), n.focus(), n.select();
    }
  } else
    e.dispatch({ effects: [
      Rm.of(!0),
      t ? lu.of(_0(e.state, t.query.spec)) : at.appendConfig.of(TI)
    ] });
  return !0;
}, wO = (e) => {
  let t = e.state.field(kl, !1);
  if (!t || !t.panel)
    return !1;
  let n = Jo(e, Im);
  return n && n.dom.contains(e.root.activeElement) && e.focus(), e.dispatch({ effects: Rm.of(!1) }), !0;
}, _I = [
  { key: "Mod-f", run: CO, scope: "editor search-panel" },
  { key: "F3", run: Od, shift: bd, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Od, shift: bd, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: wO, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: PI },
  { key: "Mod-Alt-g", run: lI },
  { key: "Mod-d", run: pI, preventDefault: !0 }
];
class MI {
  constructor(t) {
    this.view = t;
    let n = this.query = t.state.field(kl).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Qt("input", {
      value: n.search,
      placeholder: Oa(t, "Find"),
      "aria-label": Oa(t, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Qt("input", {
      value: n.replace,
      placeholder: Oa(t, "Replace"),
      "aria-label": Oa(t, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Qt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = Qt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = Qt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function a(i, l, r) {
      return Qt("button", { class: "cm-button", name: i, onclick: l, type: "button" }, r);
    }
    this.dom = Qt("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      a("next", () => Od(t), [Oa(t, "next")]),
      a("prev", () => bd(t), [Oa(t, "previous")]),
      a("select", () => xI(t), [Oa(t, "all")]),
      Qt("label", null, [this.caseField, Oa(t, "match case")]),
      Qt("label", null, [this.reField, Oa(t, "regexp")]),
      Qt("label", null, [this.wordField, Oa(t, "by word")]),
      ...t.state.readOnly ? [] : [
        Qt("br"),
        this.replaceField,
        a("replace", () => u9(t), [Oa(t, "replace")]),
        a("replaceAll", () => $I(t), [Oa(t, "replace all")])
      ],
      Qt("button", {
        name: "close",
        onclick: () => wO(t),
        "aria-label": Oa(t, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let t = new pO({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    t.eq(this.query) || (this.query = t, this.view.dispatch({ effects: lu.of(t) }));
  }
  keydown(t) {
    MQ(this.view, t, "search-panel") ? t.preventDefault() : t.keyCode == 13 && t.target == this.searchField ? (t.preventDefault(), (t.shiftKey ? bd : Od)(this.view)) : t.keyCode == 13 && t.target == this.replaceField && (t.preventDefault(), u9(this.view));
  }
  update(t) {
    for (let n of t.transactions)
      for (let a of n.effects)
        a.is(lu) && !a.value.eq(this.query) && this.setQuery(a.value);
  }
  setQuery(t) {
    this.query = t, this.searchField.value = t.search, this.replaceField.value = t.replace, this.caseField.checked = t.caseSensitive, this.reField.checked = t.regexp, this.wordField.checked = t.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(to).top;
  }
}
function Oa(e, t) {
  return e.state.phrase(t);
}
const vc = 30, gc = /[\s\.,:;?!]/;
function Bm(e, { from: t, to: n }) {
  let a = e.state.doc.lineAt(t), i = e.state.doc.lineAt(n).to, l = Math.max(a.from, t - vc), r = Math.min(i, n + vc), s = e.state.sliceDoc(l, r);
  if (l != a.from) {
    for (let o = 0; o < vc; o++)
      if (!gc.test(s[o + 1]) && gc.test(s[o])) {
        s = s.slice(o);
        break;
      }
  }
  if (r != i) {
    for (let o = s.length - 1; o > s.length - vc; o--)
      if (!gc.test(s[o - 1]) && gc.test(s[o])) {
        s = s.slice(0, o);
        break;
      }
  }
  return Re.announce.of(`${e.state.phrase("current match")}. ${s} ${e.state.phrase("on line")} ${a.number}.`);
}
const VI = /* @__PURE__ */ Re.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), TI = [
  kl,
  /* @__PURE__ */ El.low(SI),
  VI
];
class kO {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(t, n, a, i) {
    this.state = t, this.pos = n, this.explicit = a, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let n = Tn(this.state).resolveInner(this.pos, -1);
    for (; n && t.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let n = this.state.doc.lineAt(this.pos), a = Math.max(n.from, this.pos - 250), i = n.text.slice(a - n.from, this.pos - n.from), l = i.search(xO(t, !1));
    return l < 0 ? null : { from: a + l, to: this.pos, text: i.slice(l) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(t, n, a) {
    t == "abort" && this.abortListeners && (this.abortListeners.push(n), a && a.onDocChange && (this.abortOnDocChange = !0));
  }
}
function c9(e) {
  let t = Object.keys(e).join(""), n = /\w/.test(t);
  return n && (t = t.replace(/\w/g, "")), `[${n ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
function LI(e) {
  let t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of e) {
    t[i[0]] = !0;
    for (let l = 1; l < i.length; l++)
      n[i[l]] = !0;
  }
  let a = c9(t) + c9(n) + "*$";
  return [new RegExp("^" + a), new RegExp(a)];
}
function SO(e) {
  let t = e.map((i) => typeof i == "string" ? { label: i } : i), [n, a] = t.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : LI(t);
  return (i) => {
    let l = i.matchBefore(a);
    return l || i.explicit ? { from: l ? l.from : i.pos, options: t, validFor: n } : null;
  };
}
function QI(e, t) {
  return (n) => {
    for (let a = Tn(n.state).resolveInner(n.pos, -1); a; a = a.parent) {
      if (e.indexOf(a.name) > -1)
        return null;
      if (a.type.isTop)
        break;
    }
    return t(n);
  };
}
class d9 {
  constructor(t, n, a, i) {
    this.completion = t, this.source = n, this.match = a, this.score = i;
  }
}
function fr(e) {
  return e.selection.main.from;
}
function xO(e, t) {
  var n;
  let { source: a } = e, i = t && a[0] != "^", l = a[a.length - 1] != "$";
  return !i && !l ? e : new RegExp(`${i ? "^" : ""}(?:${a})${l ? "$" : ""}`, (n = e.flags) !== null && n !== void 0 ? n : e.ignoreCase ? "i" : "");
}
const Zm = /* @__PURE__ */ rl.define();
function AI(e, t, n, a) {
  let { main: i } = e.selection, l = n - i.from, r = a - i.from;
  return Object.assign(Object.assign({}, e.changeByRange((s) => {
    if (s != i && n != a && e.sliceDoc(s.from + l, s.from + r) != e.sliceDoc(n, a))
      return { range: s };
    let o = e.toText(t);
    return {
      changes: { from: s.from + l, to: a == i.from ? s.to : s.from + r, insert: o },
      range: we.cursor(s.from + l + o.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const f9 = /* @__PURE__ */ new WeakMap();
function DI(e) {
  if (!Array.isArray(e))
    return e;
  let t = f9.get(e);
  return t || f9.set(e, t = SO(e)), t;
}
const Cd = /* @__PURE__ */ at.define(), ru = /* @__PURE__ */ at.define();
class RI {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < t.length; ) {
      let a = ca(t, n), i = mi(a);
      this.chars.push(a);
      let l = t.slice(n, n + i), r = l.toUpperCase();
      this.folded.push(ca(r == l ? l.toLowerCase() : r, 0)), n += i;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, n) {
    return this.score = t, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: n, folded: a, any: i, precise: l, byWord: r } = this;
    if (n.length == 1) {
      let b = ca(t, 0), C = mi(b), S = C == t.length ? 0 : -100;
      if (b != n[0]) if (b == a[0])
        S += -200;
      else
        return null;
      return this.ret(S, [0, C]);
    }
    let s = t.indexOf(this.pattern);
    if (s == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let o = n.length, u = 0;
    if (s < 0) {
      for (let b = 0, C = Math.min(t.length, 200); b < C && u < o; ) {
        let S = ca(t, b);
        (S == n[u] || S == a[u]) && (i[u++] = b), b += mi(S);
      }
      if (u < o)
        return null;
    }
    let c = 0, d = 0, f = !1, h = 0, m = -1, g = -1, v = /[a-z]/.test(t), y = !0;
    for (let b = 0, C = Math.min(t.length, 200), S = 0; b < C && d < o; ) {
      let x = ca(t, b);
      s < 0 && (c < o && x == n[c] && (l[c++] = b), h < o && (x == n[h] || x == a[h] ? (h == 0 && (m = b), g = b + 1, h++) : h = 0));
      let w, V = x < 255 ? x >= 48 && x <= 57 || x >= 97 && x <= 122 ? 2 : x >= 65 && x <= 90 ? 1 : 0 : (w = im(x)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;
      (!b || V == 1 && v || S == 0 && V != 0) && (n[d] == x || a[d] == x && (f = !0) ? r[d++] = b : r.length && (y = !1)), S = V, b += mi(x);
    }
    return d == o && r[0] == 0 && y ? this.result(-100 + (f ? -200 : 0), r, t) : h == o && m == 0 ? this.ret(-200 - t.length + (g == t.length ? 0 : -100), [0, g]) : s > -1 ? this.ret(-700 - t.length, [s, s + this.pattern.length]) : h == o ? this.ret(-900 - t.length, [m, g]) : d == o ? this.result(-100 + (f ? -200 : 0) + -700 + (y ? 0 : -1100), r, t) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, t);
  }
  result(t, n, a) {
    let i = [], l = 0;
    for (let r of n) {
      let s = r + (this.astral ? mi(ca(a, r)) : 1);
      l && i[l - 1] == r ? i[l - 1] = s : (i[l++] = r, i[l++] = s);
    }
    return this.ret(t - a.length, i);
  }
}
class II {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let n = t.slice(0, this.pattern.length), a = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return a == null ? null : (this.matched = [0, n.length], this.score = a + (t.length == this.pattern.length ? 0 : -100), this);
  }
}
const An = /* @__PURE__ */ He.define({
  combine(e) {
    return ii(e, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: BI,
      filterStrict: !1,
      compareCompletions: (t, n) => t.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (t, n) => t && n,
      closeOnBlur: (t, n) => t && n,
      icons: (t, n) => t && n,
      tooltipClass: (t, n) => (a) => h9(t(a), n(a)),
      optionClass: (t, n) => (a) => h9(t(a), n(a)),
      addToOptions: (t, n) => t.concat(n),
      filterStrict: (t, n) => t || n
    });
  }
});
function h9(e, t) {
  return e ? t ? e + " " + t : e : t;
}
function BI(e, t, n, a, i, l) {
  let r = e.textDirection == Nt.RTL, s = r, o = !1, u = "top", c, d, f = t.left - i.left, h = i.right - t.right, m = a.right - a.left, g = a.bottom - a.top;
  if (s && f < Math.min(m, h) ? s = !1 : !s && h < Math.min(m, f) && (s = !0), m <= (s ? f : h))
    c = Math.max(i.top, Math.min(n.top, i.bottom - g)) - t.top, d = Math.min(400, s ? f : h);
  else {
    o = !0, d = Math.min(
      400,
      (r ? t.right : i.right - t.left) - 30
      /* Info.Margin */
    );
    let b = i.bottom - t.bottom;
    b >= g || b > t.top ? c = n.bottom - t.top : (u = "bottom", c = t.bottom - n.top);
  }
  let v = (t.bottom - t.top) / l.offsetHeight, y = (t.right - t.left) / l.offsetWidth;
  return {
    style: `${u}: ${c / v}px; max-width: ${d / y}px`,
    class: "cm-completionInfo-" + (o ? r ? "left-narrow" : "right-narrow" : s ? "left" : "right")
  };
}
function ZI(e) {
  let t = e.addToOptions.slice();
  return e.icons && t.push({
    render(n) {
      let a = document.createElement("div");
      return a.classList.add("cm-completionIcon"), n.type && a.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), a.setAttribute("aria-hidden", "true"), a;
    },
    position: 20
  }), t.push({
    render(n, a, i, l) {
      let r = document.createElement("span");
      r.className = "cm-completionLabel";
      let s = n.displayLabel || n.label, o = 0;
      for (let u = 0; u < l.length; ) {
        let c = l[u++], d = l[u++];
        c > o && r.appendChild(document.createTextNode(s.slice(o, c)));
        let f = r.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(s.slice(c, d))), f.className = "cm-completionMatchedText", o = d;
      }
      return o < s.length && r.appendChild(document.createTextNode(s.slice(o))), r;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let a = document.createElement("span");
      return a.className = "cm-completionDetail", a.textContent = n.detail, a;
    },
    position: 80
  }), t.sort((n, a) => n.position - a.position).map((n) => n.render);
}
function Pf(e, t, n) {
  if (e <= n)
    return { from: 0, to: e };
  if (t < 0 && (t = 0), t <= e >> 1) {
    let i = Math.floor(t / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let a = Math.floor((e - t) / n);
  return { from: e - (a + 1) * n, to: e - a * n };
}
class EI {
  constructor(t, n, a) {
    this.view = t, this.stateField = n, this.applyCompletion = a, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (o) => this.placeInfo(o),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = t.state.field(n), { options: l, selected: r } = i.open, s = t.state.facet(An);
    this.optionContent = ZI(s), this.optionClass = s.optionClass, this.tooltipClass = s.tooltipClass, this.range = Pf(l.length, r, s.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (o) => {
      let { options: u } = t.state.field(n).open;
      for (let c = o.target, d; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (d = /-(\d+)$/.exec(c.id)) && +d[1] < u.length) {
          this.applyCompletion(t, u[+d[1]]), o.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (o) => {
      let u = t.state.field(this.stateField, !1);
      u && u.tooltip && t.state.facet(An).closeOnBlur && o.relatedTarget != t.contentDOM && t.dispatch({ effects: ru.of(null) });
    }), this.showOptions(l, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var n;
    let a = t.state.field(this.stateField), i = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), a != i) {
      let { options: l, selected: r, disabled: s } = a.open;
      (!i.open || i.open.options != l) && (this.range = Pf(l.length, r, t.state.facet(An).maxRenderedOptions), this.showOptions(l, a.id)), this.updateSel(), s != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!s);
    }
  }
  updateTooltipClass(t) {
    let n = this.tooltipClass(t);
    if (n != this.currentClass) {
      for (let a of this.currentClass.split(" "))
        a && this.dom.classList.remove(a);
      for (let a of n.split(" "))
        a && this.dom.classList.add(a);
      this.currentClass = n;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), n = t.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = Pf(n.options.length, n.selected, this.view.state.facet(An).maxRenderedOptions), this.showOptions(n.options, t.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: a } = n.options[n.selected], { info: i } = a;
      if (!i)
        return;
      let l = typeof i == "string" ? document.createTextNode(i) : i(a);
      if (!l)
        return;
      "then" in l ? l.then((r) => {
        r && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(r, a);
      }).catch((r) => aa(this.view.state, r, "completion info")) : this.addInfoPane(l, a);
    }
  }
  addInfoPane(t, n) {
    this.destroyInfo();
    let a = this.info = document.createElement("div");
    if (a.className = "cm-tooltip cm-completionInfo", t.nodeType != null)
      a.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: i, destroy: l } = t;
      a.appendChild(i), this.infoDestroy = l || null;
    }
    this.dom.appendChild(a), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let n = null;
    for (let a = this.list.firstChild, i = this.range.from; a; a = a.nextSibling, i++)
      a.nodeName != "LI" || !a.id ? i-- : i == t ? a.hasAttribute("aria-selected") || (a.setAttribute("aria-selected", "true"), n = a) : a.hasAttribute("aria-selected") && a.removeAttribute("aria-selected");
    return n && HI(this.list, n), n;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), a = this.info.getBoundingClientRect(), i = t.getBoundingClientRect(), l = this.space;
    if (!l) {
      let r = this.dom.ownerDocument.defaultView || window;
      l = { left: 0, top: 0, right: r.innerWidth, bottom: r.innerHeight };
    }
    return i.top > Math.min(l.bottom, n.bottom) - 10 || i.bottom < Math.max(l.top, n.top) + 10 ? null : this.view.state.facet(An).positionInfo(this.view, n, i, a, l, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, n, a) {
    const i = document.createElement("ul");
    i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let l = null;
    for (let r = a.from; r < a.to; r++) {
      let { completion: s, match: o } = t[r], { section: u } = s;
      if (u) {
        let f = typeof u == "string" ? u : u.name;
        if (f != l && (r > a.from || a.from == 0))
          if (l = f, typeof u != "string" && u.header)
            i.appendChild(u.header(u));
          else {
            let h = i.appendChild(document.createElement("completion-section"));
            h.textContent = f;
          }
      }
      const c = i.appendChild(document.createElement("li"));
      c.id = n + "-" + r, c.setAttribute("role", "option");
      let d = this.optionClass(s);
      d && (c.className = d);
      for (let f of this.optionContent) {
        let h = f(s, this.view.state, this.view, o);
        h && c.appendChild(h);
      }
    }
    return a.from && i.classList.add("cm-completionListIncompleteTop"), a.to < t.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function NI(e, t) {
  return (n) => new EI(n, e, t);
}
function HI(e, t) {
  let n = e.getBoundingClientRect(), a = t.getBoundingClientRect(), i = n.height / e.offsetHeight;
  a.top < n.top ? e.scrollTop -= (n.top - a.top) / i : a.bottom > n.bottom && (e.scrollTop += (a.bottom - n.bottom) / i);
}
function m9(e) {
  return (e.boost || 0) * 100 + (e.apply ? 10 : 0) + (e.info ? 5 : 0) + (e.type ? 1 : 0);
}
function jI(e, t) {
  let n = [], a = null, i = (u) => {
    n.push(u);
    let { section: c } = u.completion;
    if (c) {
      a || (a = []);
      let d = typeof c == "string" ? c : c.name;
      a.some((f) => f.name == d) || a.push(typeof c == "string" ? { name: d } : c);
    }
  }, l = t.facet(An);
  for (let u of e)
    if (u.hasResult()) {
      let c = u.result.getMatch;
      if (u.result.filter === !1)
        for (let d of u.result.options)
          i(new d9(d, u.source, c ? c(d) : [], 1e9 - n.length));
      else {
        let d = t.sliceDoc(u.from, u.to), f, h = l.filterStrict ? new II(d) : new RI(d);
        for (let m of u.result.options)
          if (f = h.match(m.label)) {
            let g = m.displayLabel ? c ? c(m, f.matched) : [] : f.matched;
            i(new d9(m, u.source, g, f.score + (m.boost || 0)));
          }
      }
    }
  if (a) {
    let u = /* @__PURE__ */ Object.create(null), c = 0, d = (f, h) => {
      var m, g;
      return ((m = f.rank) !== null && m !== void 0 ? m : 1e9) - ((g = h.rank) !== null && g !== void 0 ? g : 1e9) || (f.name < h.name ? -1 : 1);
    };
    for (let f of a.sort(d))
      c -= 1e5, u[f.name] = c;
    for (let f of n) {
      let { section: h } = f.completion;
      h && (f.score += u[typeof h == "string" ? h : h.name]);
    }
  }
  let r = [], s = null, o = l.compareCompletions;
  for (let u of n.sort((c, d) => d.score - c.score || o(c.completion, d.completion))) {
    let c = u.completion;
    !s || s.label != c.label || s.detail != c.detail || s.type != null && c.type != null && s.type != c.type || s.apply != c.apply || s.boost != c.boost ? r.push(u) : m9(u.completion) > m9(s) && (r[r.length - 1] = u), s = u.completion;
  }
  return r;
}
class os {
  constructor(t, n, a, i, l, r) {
    this.options = t, this.attrs = n, this.tooltip = a, this.timestamp = i, this.selected = l, this.disabled = r;
  }
  setSelected(t, n) {
    return t == this.selected || t >= this.options.length ? this : new os(this.options, v9(n, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, n, a, i, l, r) {
    if (i && !r && t.some((u) => u.isPending))
      return i.setDisabled();
    let s = jI(t, n);
    if (!s.length)
      return i && t.some((u) => u.isPending) ? i.setDisabled() : null;
    let o = n.facet(An).selectOnOpen ? 0 : -1;
    if (i && i.selected != o && i.selected != -1) {
      let u = i.options[i.selected].completion;
      for (let c = 0; c < s.length; c++)
        if (s[c].completion == u) {
          o = c;
          break;
        }
    }
    return new os(s, v9(a, o), {
      pos: t.reduce((u, c) => c.hasResult() ? Math.min(u, c.from) : u, 1e8),
      create: qI,
      above: l.aboveCursor
    }, i ? i.timestamp : Date.now(), o, !1);
  }
  map(t) {
    return new os(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new os(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class wd {
  constructor(t, n, a) {
    this.active = t, this.id = n, this.open = a;
  }
  static start() {
    return new wd(YI, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: n } = t, a = n.facet(An), l = (a.override || n.languageDataAt("autocomplete", fr(n)).map(DI)).map((o) => (this.active.find((c) => c.source == o) || new Qa(
      o,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, a));
    l.length == this.active.length && l.every((o, u) => o == this.active[u]) && (l = this.active);
    let r = this.open, s = t.effects.some((o) => o.is(Em));
    r && t.docChanged && (r = r.map(t.changes)), t.selection || l.some((o) => o.hasResult() && t.changes.touchesRange(o.from, o.to)) || !zI(l, this.active) || s ? r = os.build(l, n, this.id, r, a, s) : r && r.disabled && !l.some((o) => o.isPending) && (r = null), !r && l.every((o) => !o.isPending) && l.some((o) => o.hasResult()) && (l = l.map((o) => o.hasResult() ? new Qa(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of t.effects)
      o.is($O) && (r = r && r.setSelected(o.value, this.id));
    return l == this.active && r == this.open ? this : new wd(l, this.id, r);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? FI : XI;
  }
}
function zI(e, t) {
  if (e == t)
    return !0;
  for (let n = 0, a = 0; ; ) {
    for (; n < e.length && !e[n].hasResult(); )
      n++;
    for (; a < t.length && !t[a].hasResult(); )
      a++;
    let i = n == e.length, l = a == t.length;
    if (i || l)
      return i == l;
    if (e[n++].result != t[a++].result)
      return !1;
  }
}
const FI = {
  "aria-autocomplete": "list"
}, XI = {};
function v9(e, t) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": e
  };
  return t > -1 && (n["aria-activedescendant"] = e + "-" + t), n;
}
const YI = [];
function PO(e, t) {
  if (e.isUserEvent("input.complete")) {
    let a = e.annotation(Zm);
    if (a && t.activateOnCompletion(a))
      return 12;
  }
  let n = e.isUserEvent("input.type");
  return n && t.activateOnTyping ? 5 : n ? 1 : e.isUserEvent("delete.backward") ? 2 : e.selection ? 8 : e.docChanged ? 16 : 0;
}
class Qa {
  constructor(t, n, a = !1) {
    this.source = t, this.state = n, this.explicit = a;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(t, n) {
    let a = PO(t, n), i = this;
    (a & 8 || a & 16 && this.touches(t)) && (i = new Qa(
      i.source,
      0
      /* State.Inactive */
    )), a & 4 && i.state == 0 && (i = new Qa(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(t, a);
    for (let l of t.effects)
      if (l.is(Cd))
        i = new Qa(i.source, 1, l.value);
      else if (l.is(ru))
        i = new Qa(
          i.source,
          0
          /* State.Inactive */
        );
      else if (l.is(Em))
        for (let r of l.value)
          r.source == i.source && (i = r);
    return i;
  }
  updateFor(t, n) {
    return this.map(t.changes);
  }
  map(t) {
    return this;
  }
  touches(t) {
    return t.changes.touchesRange(fr(t.state));
  }
}
class ms extends Qa {
  constructor(t, n, a, i, l, r) {
    super(t, 3, n), this.limit = a, this.result = i, this.from = l, this.to = r;
  }
  hasResult() {
    return !0;
  }
  updateFor(t, n) {
    var a;
    if (!(n & 3))
      return this.map(t.changes);
    let i = this.result;
    i.map && !t.changes.empty && (i = i.map(i, t.changes));
    let l = t.changes.mapPos(this.from), r = t.changes.mapPos(this.to, 1), s = fr(t.state);
    if (s > r || !i || n & 2 && (fr(t.startState) == this.from || s < this.limit))
      return new Qa(
        this.source,
        n & 4 ? 1 : 0
        /* State.Inactive */
      );
    let o = t.changes.mapPos(this.limit);
    return WI(i.validFor, t.state, l, r) ? new ms(this.source, this.explicit, o, i, l, r) : i.update && (i = i.update(i, l, r, new kO(t.state, s, !1))) ? new ms(this.source, this.explicit, o, i, i.from, (a = i.to) !== null && a !== void 0 ? a : fr(t.state)) : new Qa(this.source, 1, this.explicit);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new ms(this.source, this.explicit, t.mapPos(this.limit), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new Qa(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(t) {
    return t.changes.touchesRange(this.from, this.to);
  }
}
function WI(e, t, n, a) {
  if (!e)
    return !1;
  let i = t.sliceDoc(n, a);
  return typeof e == "function" ? e(i, n, a, t) : xO(e, !0).test(i);
}
const Em = /* @__PURE__ */ at.define({
  map(e, t) {
    return e.map((n) => n.map(t));
  }
}), $O = /* @__PURE__ */ at.define(), fa = /* @__PURE__ */ $n.define({
  create() {
    return wd.start();
  },
  update(e, t) {
    return e.update(t);
  },
  provide: (e) => [
    p1.from(e, (t) => t.tooltip),
    Re.contentAttributes.from(e, (t) => t.attrs)
  ]
});
function Nm(e, t) {
  const n = t.completion.apply || t.completion.label;
  let a = e.state.field(fa).active.find((i) => i.source == t.source);
  return a instanceof ms ? (typeof n == "string" ? e.dispatch(Object.assign(Object.assign({}, AI(e.state, n, a.from, a.to)), { annotations: Zm.of(t.completion) })) : n(e, t.completion, a.from, a.to), !0) : !1;
}
const qI = /* @__PURE__ */ NI(fa, Nm);
function pc(e, t = "option") {
  return (n) => {
    let a = n.state.field(fa, !1);
    if (!a || !a.open || a.open.disabled || Date.now() - a.open.timestamp < n.state.facet(An).interactionDelay)
      return !1;
    let i = 1, l;
    t == "page" && (l = X6(n, a.open.tooltip)) && (i = Math.max(2, Math.floor(l.dom.offsetHeight / l.dom.querySelector("li").offsetHeight) - 1));
    let { length: r } = a.open.options, s = a.open.selected > -1 ? a.open.selected + i * (e ? 1 : -1) : e ? 0 : r - 1;
    return s < 0 ? s = t == "page" ? 0 : r - 1 : s >= r && (s = t == "page" ? r - 1 : 0), n.dispatch({ effects: $O.of(s) }), !0;
  };
}
const UI = (e) => {
  let t = e.state.field(fa, !1);
  return e.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < e.state.facet(An).interactionDelay ? !1 : Nm(e, t.open.options[t.open.selected]);
}, g9 = (e) => e.state.field(fa, !1) ? (e.dispatch({ effects: Cd.of(!0) }), !0) : !1, GI = (e) => {
  let t = e.state.field(fa, !1);
  return !t || !t.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (e.dispatch({ effects: ru.of(null) }), !0);
};
class KI {
  constructor(t, n) {
    this.active = t, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const JI = 50, eB = 1e3, tB = /* @__PURE__ */ rn.fromClass(class {
  constructor(e) {
    this.view = e, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of e.state.field(fa).active)
      t.isPending && this.startQuery(t);
  }
  update(e) {
    let t = e.state.field(fa), n = e.state.facet(An);
    if (!e.selectionSet && !e.docChanged && e.startState.field(fa) == t)
      return;
    let a = e.transactions.some((l) => {
      let r = PO(l, n);
      return r & 8 || (l.selection || l.docChanged) && !(r & 3);
    });
    for (let l = 0; l < this.running.length; l++) {
      let r = this.running[l];
      if (a || r.context.abortOnDocChange && e.docChanged || r.updates.length + e.transactions.length > JI && Date.now() - r.time > eB) {
        for (let s of r.context.abortListeners)
          try {
            s();
          } catch (o) {
            aa(this.view.state, o);
          }
        r.context.abortListeners = null, this.running.splice(l--, 1);
      } else
        r.updates.push(...e.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), e.transactions.some((l) => l.effects.some((r) => r.is(Cd))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((l) => l.isPending && !this.running.some((r) => r.active.source == l.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let l of e.transactions)
        l.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && l.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: e } = this.view, t = e.field(fa);
    for (let n of t.active)
      n.isPending && !this.running.some((a) => a.active.source == n.source) && this.startQuery(n);
    this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(An).updateSyncTime));
  }
  startQuery(e) {
    let { state: t } = this.view, n = fr(t), a = new kO(t, n, e.explicit, this.view), i = new KI(e, a);
    this.running.push(i), Promise.resolve(e.source(a)).then((l) => {
      i.context.aborted || (i.done = l || null, this.scheduleAccept());
    }, (l) => {
      this.view.dispatch({ effects: ru.of(null) }), aa(this.view.state, l);
    });
  }
  scheduleAccept() {
    this.running.every((e) => e.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(An).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var e;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], n = this.view.state.facet(An), a = this.view.state.field(fa);
    for (let i = 0; i < this.running.length; i++) {
      let l = this.running[i];
      if (l.done === void 0)
        continue;
      if (this.running.splice(i--, 1), l.done) {
        let s = fr(l.updates.length ? l.updates[0].startState : this.view.state), o = Math.min(s, l.done.from + (l.active.explicit ? 0 : 1)), u = new ms(l.active.source, l.active.explicit, o, l.done, l.done.from, (e = l.done.to) !== null && e !== void 0 ? e : s);
        for (let c of l.updates)
          u = u.update(c, n);
        if (u.hasResult()) {
          t.push(u);
          continue;
        }
      }
      let r = a.active.find((s) => s.source == l.active.source);
      if (r && r.isPending)
        if (l.done == null) {
          let s = new Qa(
            l.active.source,
            0
            /* State.Inactive */
          );
          for (let o of l.updates)
            s = s.update(o, n);
          s.isPending || t.push(s);
        } else
          this.startQuery(r);
    }
    (t.length || a.open && a.open.disabled) && this.view.dispatch({ effects: Em.of(t) });
  }
}, {
  eventHandlers: {
    blur(e) {
      let t = this.view.state.field(fa, !1);
      if (t && t.tooltip && this.view.state.facet(An).closeOnBlur) {
        let n = t.open && X6(this.view, t.open.tooltip);
        (!n || !n.dom.contains(e.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: ru.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Cd.of(!1) }), 20), this.composing = 0;
    }
  }
}), nB = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), aB = /* @__PURE__ */ El.highest(/* @__PURE__ */ Re.domEventHandlers({
  keydown(e, t) {
    let n = t.state.field(fa, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || e.key.length > 1 || e.ctrlKey && !(nB && e.altKey) || e.metaKey)
      return !1;
    let a = n.open.options[n.open.selected], i = n.active.find((r) => r.source == a.source), l = a.completion.commitCharacters || i.result.commitCharacters;
    return l && l.indexOf(e.key) > -1 && Nm(t, a), !1;
  }
})), _O = /* @__PURE__ */ Re.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class iB {
  constructor(t, n, a, i) {
    this.field = t, this.line = n, this.from = a, this.to = i;
  }
}
class Hm {
  constructor(t, n, a) {
    this.field = t, this.from = n, this.to = a;
  }
  map(t) {
    let n = t.mapPos(this.from, -1, Hn.TrackDel), a = t.mapPos(this.to, 1, Hn.TrackDel);
    return n == null || a == null ? null : new Hm(this.field, n, a);
  }
}
class jm {
  constructor(t, n) {
    this.lines = t, this.fieldPositions = n;
  }
  instantiate(t, n) {
    let a = [], i = [n], l = t.doc.lineAt(n), r = /^\s*/.exec(l.text)[0];
    for (let o of this.lines) {
      if (a.length) {
        let u = r, c = /^\t*/.exec(o)[0].length;
        for (let d = 0; d < c; d++)
          u += t.facet(Lu);
        i.push(n + u.length - c), o = u + o.slice(c);
      }
      a.push(o), n += o.length + 1;
    }
    let s = this.fieldPositions.map((o) => new Hm(o.field, i[o.line] + o.from, i[o.line] + o.to));
    return { text: a, ranges: s };
  }
  static parse(t) {
    let n = [], a = [], i = [], l;
    for (let r of t.split(/\r\n?|\n/)) {
      for (; l = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(r); ) {
        let s = l[1] ? +l[1] : null, o = l[2] || l[3] || "", u = -1, c = o.replace(/\\[{}]/g, (d) => d[1]);
        for (let d = 0; d < n.length; d++)
          (s != null ? n[d].seq == s : c && n[d].name == c) && (u = d);
        if (u < 0) {
          let d = 0;
          for (; d < n.length && (s == null || n[d].seq != null && n[d].seq < s); )
            d++;
          n.splice(d, 0, { seq: s, name: c }), u = d;
          for (let f of i)
            f.field >= u && f.field++;
        }
        i.push(new iB(u, a.length, l.index, l.index + c.length)), r = r.slice(0, l.index) + o + r.slice(l.index + l[0].length);
      }
      r = r.replace(/\\([{}])/g, (s, o, u) => {
        for (let c of i)
          c.line == a.length && c.from > u && (c.from--, c.to--);
        return o;
      }), a.push(r);
    }
    return new jm(a, i);
  }
}
let lB = /* @__PURE__ */ qe.widget({ widget: /* @__PURE__ */ new class extends Ii {
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-snippetFieldPosition", e;
  }
  ignoreEvent() {
    return !1;
  }
}() }), rB = /* @__PURE__ */ qe.mark({ class: "cm-snippetField" });
class no {
  constructor(t, n) {
    this.ranges = t, this.active = n, this.deco = qe.set(t.map((a) => (a.from == a.to ? lB : rB).range(a.from, a.to)));
  }
  map(t) {
    let n = [];
    for (let a of this.ranges) {
      let i = a.map(t);
      if (!i)
        return null;
      n.push(i);
    }
    return new no(n, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((n) => this.ranges.some((a) => a.field == this.active && a.from <= n.from && a.to >= n.to));
  }
}
const Iu = /* @__PURE__ */ at.define({
  map(e, t) {
    return e && e.map(t);
  }
}), sB = /* @__PURE__ */ at.define(), su = /* @__PURE__ */ $n.define({
  create() {
    return null;
  },
  update(e, t) {
    for (let n of t.effects) {
      if (n.is(Iu))
        return n.value;
      if (n.is(sB) && e)
        return new no(e.ranges, n.value);
    }
    return e && t.docChanged && (e = e.map(t.changes)), e && t.selection && !e.selectionInsideField(t.selection) && (e = null), e;
  },
  provide: (e) => Re.decorations.from(e, (t) => t ? t.deco : qe.none)
});
function zm(e, t) {
  return we.create(e.filter((n) => n.field == t).map((n) => we.range(n.from, n.to)));
}
function oB(e) {
  let t = jm.parse(e);
  return (n, a, i, l) => {
    let { text: r, ranges: s } = t.instantiate(n.state, i), { main: o } = n.state.selection, u = {
      changes: { from: i, to: l == o.from ? o.to : l, insert: gt.of(r) },
      scrollIntoView: !0,
      annotations: a ? [Zm.of(a), wn.userEvent.of("input.complete")] : void 0
    };
    if (s.length && (u.selection = zm(s, 0)), s.some((c) => c.field > 0)) {
      let c = new no(s, 0), d = u.effects = [Iu.of(c)];
      n.state.field(su, !1) === void 0 && d.push(at.appendConfig.of([su, hB, mB, _O]));
    }
    n.dispatch(n.state.update(u));
  };
}
function MO(e) {
  return ({ state: t, dispatch: n }) => {
    let a = t.field(su, !1);
    if (!a || e < 0 && a.active == 0)
      return !1;
    let i = a.active + e, l = e > 0 && !a.ranges.some((r) => r.field == i + e);
    return n(t.update({
      selection: zm(a.ranges, i),
      effects: Iu.of(l ? null : new no(a.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const uB = ({ state: e, dispatch: t }) => e.field(su, !1) ? (t(e.update({ effects: Iu.of(null) })), !0) : !1, cB = /* @__PURE__ */ MO(1), dB = /* @__PURE__ */ MO(-1), fB = [
  { key: "Tab", run: cB, shift: dB },
  { key: "Escape", run: uB }
], p9 = /* @__PURE__ */ He.define({
  combine(e) {
    return e.length ? e[0] : fB;
  }
}), hB = /* @__PURE__ */ El.highest(/* @__PURE__ */ Tl.compute([p9], (e) => e.facet(p9)));
function oa(e, t) {
  return Object.assign(Object.assign({}, t), { apply: oB(e) });
}
const mB = /* @__PURE__ */ Re.domEventHandlers({
  mousedown(e, t) {
    let n = t.state.field(su, !1), a;
    if (!n || (a = t.posAtCoords({ x: e.clientX, y: e.clientY })) == null)
      return !1;
    let i = n.ranges.find((l) => l.from <= a && l.to >= a);
    return !i || i.field == n.active ? !1 : (t.dispatch({
      selection: zm(n.ranges, i.field),
      effects: Iu.of(n.ranges.some((l) => l.field > i.field) ? new no(n.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), ou = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, ar = /* @__PURE__ */ at.define({
  map(e, t) {
    let n = t.mapPos(e, -1, Hn.TrackAfter);
    return n ?? void 0;
  }
}), Fm = /* @__PURE__ */ new class extends Sr {
}();
Fm.startSide = 1;
Fm.endSide = -1;
const VO = /* @__PURE__ */ $n.define({
  create() {
    return mt.empty;
  },
  update(e, t) {
    if (e = e.map(t.changes), t.selection) {
      let n = t.state.doc.lineAt(t.selection.main.head);
      e = e.update({ filter: (a) => a >= n.from && a <= n.to });
    }
    for (let n of t.effects)
      n.is(ar) && (e = e.update({ add: [Fm.range(n.value, n.value + 1)] }));
    return e;
  }
});
function vB() {
  return [pB, VO];
}
const $f = "()[]{}<>";
function TO(e) {
  for (let t = 0; t < $f.length; t += 2)
    if ($f.charCodeAt(t) == e)
      return $f.charAt(t + 1);
  return im(e < 128 ? e : e + 1);
}
function LO(e, t) {
  return e.languageDataAt("closeBrackets", t)[0] || ou;
}
const gB = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), pB = /* @__PURE__ */ Re.inputHandler.of((e, t, n, a) => {
  if ((gB ? e.composing : e.compositionStarted) || e.state.readOnly)
    return !1;
  let i = e.state.selection.main;
  if (a.length > 2 || a.length == 2 && mi(ca(a, 0)) == 1 || t != i.from || n != i.to)
    return !1;
  let l = bB(e.state, a);
  return l ? (e.dispatch(l), !0) : !1;
}), yB = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let a = LO(e, e.selection.main.head).brackets || ou.brackets, i = null, l = e.changeByRange((r) => {
    if (r.empty) {
      let s = CB(e.doc, r.head);
      for (let o of a)
        if (o == s && $1(e.doc, r.head) == TO(ca(o, 0)))
          return {
            changes: { from: r.head - o.length, to: r.head + o.length },
            range: we.cursor(r.head - o.length)
          };
    }
    return { range: i = r };
  });
  return i || t(e.update(l, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, OB = [
  { key: "Backspace", run: yB }
];
function bB(e, t) {
  let n = LO(e, e.selection.main.head), a = n.brackets || ou.brackets;
  for (let i of a) {
    let l = TO(ca(i, 0));
    if (t == i)
      return l == i ? SB(e, i, a.indexOf(i + i + i) > -1, n) : wB(e, i, l, n.before || ou.before);
    if (t == l && QO(e, e.selection.main.from))
      return kB(e, i, l);
  }
  return null;
}
function QO(e, t) {
  let n = !1;
  return e.field(VO).between(0, e.doc.length, (a) => {
    a == t && (n = !0);
  }), n;
}
function $1(e, t) {
  let n = e.sliceString(t, t + 2);
  return n.slice(0, mi(ca(n, 0)));
}
function CB(e, t) {
  let n = e.sliceString(t - 2, t);
  return mi(ca(n, 0)) == n.length ? n : n.slice(1);
}
function wB(e, t, n, a) {
  let i = null, l = e.changeByRange((r) => {
    if (!r.empty)
      return {
        changes: [{ insert: t, from: r.from }, { insert: n, from: r.to }],
        effects: ar.of(r.to + t.length),
        range: we.range(r.anchor + t.length, r.head + t.length)
      };
    let s = $1(e.doc, r.head);
    return !s || /\s/.test(s) || a.indexOf(s) > -1 ? {
      changes: { insert: t + n, from: r.head },
      effects: ar.of(r.head + t.length),
      range: we.cursor(r.head + t.length)
    } : { range: i = r };
  });
  return i ? null : e.update(l, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function kB(e, t, n) {
  let a = null, i = e.changeByRange((l) => l.empty && $1(e.doc, l.head) == n ? {
    changes: { from: l.head, to: l.head + n.length, insert: n },
    range: we.cursor(l.head + n.length)
  } : a = { range: l });
  return a ? null : e.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function SB(e, t, n, a) {
  let i = a.stringPrefixes || ou.stringPrefixes, l = null, r = e.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: t, from: s.from }, { insert: t, from: s.to }],
        effects: ar.of(s.to + t.length),
        range: we.range(s.anchor + t.length, s.head + t.length)
      };
    let o = s.head, u = $1(e.doc, o), c;
    if (u == t) {
      if (y9(e, o))
        return {
          changes: { insert: t + t, from: o },
          effects: ar.of(o + t.length),
          range: we.cursor(o + t.length)
        };
      if (QO(e, o)) {
        let f = n && e.sliceDoc(o, o + t.length * 3) == t + t + t ? t + t + t : t;
        return {
          changes: { from: o, to: o + f.length, insert: f },
          range: we.cursor(o + f.length)
        };
      }
    } else {
      if (n && e.sliceDoc(o - 2 * t.length, o) == t + t && (c = O9(e, o - 2 * t.length, i)) > -1 && y9(e, c))
        return {
          changes: { insert: t + t + t + t, from: o },
          effects: ar.of(o + t.length),
          range: we.cursor(o + t.length)
        };
      if (e.charCategorizer(o)(u) != Ft.Word && O9(e, o, i) > -1 && !xB(e, o, t, i))
        return {
          changes: { insert: t + t, from: o },
          effects: ar.of(o + t.length),
          range: we.cursor(o + t.length)
        };
    }
    return { range: l = s };
  });
  return l ? null : e.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function y9(e, t) {
  let n = Tn(e).resolveInner(t + 1);
  return n.parent && n.from == t;
}
function xB(e, t, n, a) {
  let i = Tn(e).resolveInner(t, -1), l = a.reduce((r, s) => Math.max(r, s.length), 0);
  for (let r = 0; r < 5; r++) {
    let s = e.sliceDoc(i.from, Math.min(i.to, i.from + n.length + l)), o = s.indexOf(n);
    if (!o || o > -1 && a.indexOf(s.slice(0, o)) > -1) {
      let c = i.firstChild;
      for (; c && c.from == i.from && c.to - c.from > n.length + o; ) {
        if (e.sliceDoc(c.to - n.length, c.to) == n)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = i.to == t && i.parent;
    if (!u)
      break;
    i = u;
  }
  return !1;
}
function O9(e, t, n) {
  let a = e.charCategorizer(t);
  if (a(e.sliceDoc(t - 1, t)) != Ft.Word)
    return t;
  for (let i of n) {
    let l = t - i.length;
    if (e.sliceDoc(l, t) == i && a(e.sliceDoc(l - 1, l)) != Ft.Word)
      return l;
  }
  return -1;
}
function PB(e = {}) {
  return [
    aB,
    fa,
    An.of(e),
    tB,
    $B,
    _O
  ];
}
const AO = [
  { key: "Ctrl-Space", run: g9 },
  { mac: "Alt-`", run: g9 },
  { key: "Escape", run: GI },
  { key: "ArrowDown", run: /* @__PURE__ */ pc(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ pc(!1) },
  { key: "PageDown", run: /* @__PURE__ */ pc(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ pc(!1, "page") },
  { key: "Enter", run: UI }
], $B = /* @__PURE__ */ El.highest(/* @__PURE__ */ Tl.computeN([An], (e) => e.facet(An).defaultKeymap ? [AO] : [])), M0 = [
  xA(),
  _A(),
  z6(),
  xy(),
  vD(),
  N6(),
  ZQ(),
  ot.allowMultipleSelections.of(!0),
  nD(),
  Mm(yy, { fallback: !0 }),
  xD(),
  vB(),
  PB(),
  iA(),
  sA(),
  UQ(),
  uI(),
  Tl.of([
    ...OB,
    ...md,
    ..._I,
    ...My,
    ...dD,
    ...AO,
    ...XR
  ])
], _B = [
  z6(),
  xy(),
  N6(),
  Mm(yy, { fallback: !0 }),
  Tl.of([
    ...md,
    ...My
  ])
];
/**
 * vue-codemirror6
 *
 * @description CodeMirror6 Component for vue2 and vue3.
 * @author Logue <logue@hotmail.co.jp>
 * @copyright 2022-2025 By Masashi Yoshikawa All rights reserved.
 * @license MIT
 * @version 1.3.10
 * @see {@link https://github.com/logue/vue-codemirror6}
 */
const MB = (e) => e ? Object.entries(e).reduce((t, [n, a]) => (n = n.charAt(0).toUpperCase() + n.slice(1), n = `on${n}`, { ...t, [n]: a }), {}) : {};
function b9(e, t = {}, n) {
  const { props: a, domProps: i, on: l, ...r } = t, s = l ? MB(l) : {};
  return G(
    e,
    { ...r, ...a, ...i, ...s },
    n
  );
}
const VB = (e) => typeof e == "function" ? e() : e;
var TB = Sn({
  /** Component Name */
  name: "CodeMirror",
  /** Model Definition */
  model: {
    prop: "modelValue",
    event: "update:modelValue"
  },
  /** Props Definition */
  props: {
    /** Model value */
    modelValue: {
      type: String,
      default: ""
    },
    /**
     * Theme
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView^theme}
     */
    theme: {
      type: Object,
      default: () => ({})
    },
    /** Dark Mode */
    dark: {
      type: Boolean,
      default: !1
    },
    /**
     * Use Basic Setup
     *
     * @see {@link https://codemirror.net/docs/ref/#codemirror.basicSetup}
     */
    basic: {
      type: Boolean,
      default: !1
    },
    /**
     * Use Minimal Setup (The basic setting has priority.)
     *
     * @see {@link https://codemirror.net/docs/ref/#codemirror.minimalSetup}
     */
    minimal: {
      type: Boolean,
      default: !1
    },
    /**
     * Placeholder
     *
     * @see {@link https://codemirror.net/docs/ref/#view.placeholder}
     */
    placeholder: {
      type: String,
      default: void 0
    },
    /**
     * Line wrapping
     *
     * An extension that enables line wrapping in the editor (by setting CSS white-space to pre-wrap in the content).
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView%5ElineWrapping}
     */
    wrap: {
      type: Boolean,
      default: !1
    },
    /**
     * Allow tab key indent.
     *
     * @see {@link https://codemirror.net/examples/tab/}
     */
    tab: {
      type: Boolean,
      default: !1
    },
    /**
     * Tab character
     */
    indentUnit: {
      type: String,
      default: void 0
    },
    /**
     * Allow Multiple Selection.
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^allowMultipleSelections}
     */
    allowMultipleSelections: {
      type: Boolean,
      default: !1
    },
    /**
     * Tab size
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^tabSize}
     */
    tabSize: {
      type: Number,
      default: void 0
    },
    /**
     * Set line break (separetor) char.
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^lineSeparator}
     */
    lineSeparator: {
      type: String,
      default: void 0
    },
    /**
     * Readonly
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^readOnly}
     */
    readonly: {
      type: Boolean,
      default: !1
    },
    /**
     * Disable input.
     *
     * This is the reversed value of the CodeMirror editable.
     * Similar to `readonly`, but setting this value to true disables dragging.
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView^editable}
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Additional Extension
     *
     * @see {@link https://codemirror.net/docs/ref/#state.Extension}
     */
    extensions: {
      type: Array,
      default: () => []
    },
    /**
     * Language Phreses
     *
     * @see {@link https://codemirror.net/examples/translate/}
     */
    phrases: {
      type: Object,
      default: () => {
      }
    },
    /**
     * CodeMirror Language
     *
     * @see {@link https://codemirror.net/docs/ref/#language}
     */
    lang: {
      type: Object,
      default: () => {
      }
    },
    /**
     * CodeMirror Linter
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.linter}
     */
    linter: {
      type: Function,
      default: void 0
    },
    /**
     * Linter Config
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.linter^config}
     */
    linterConfig: {
      type: Object,
      default: () => ({})
    },
    /**
     * Forces any linters configured to run when the editor is idle to run right away.
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.forceLinting}
     */
    forceLinting: {
      type: Boolean,
      default: !1
    },
    /**
     * Show Linter Gutter
     *
     * An area to 🔴 the lines with errors will be displayed.
     * This feature is not enabled if `linter` is not specified.
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.lintGutter}
     */
    gutter: {
      type: Boolean,
      default: !1
    },
    /**
     * Gutter Config
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.lintGutter^config}
     */
    gutterConfig: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Using tag
     */
    tag: {
      type: String,
      default: "div"
    }
  },
  /** Emits */
  emits: {
    /** Model Update */
    "update:modelValue": (e = "") => !0,
    /** CodeMirror ViewUpdate */
    update: (e) => !0,
    /** CodeMirror onReady */
    ready: (e) => !0,
    /** CodeMirror onFocus */
    focus: (e) => !0,
    /** State Changed */
    change: (e) => !0,
    /** CodeMirror onDestroy */
    destroy: () => !0
  },
  /**
   * Setup
   *
   * @param props  - Props
   * @param context - Context
   */
  setup(e, t) {
    const n = Y(), a = Y(e.modelValue), i = Ve(new Re()), l = k({
      get: () => i.value.hasFocus,
      set: (T) => {
        T && i.value.focus();
      }
    }), r = k({
      get: () => i.value.state.selection,
      set: (T) => i.value.dispatch({ selection: T })
    }), s = k({
      get: () => i.value.state.selection.main.head,
      set: (T) => i.value.dispatch({ selection: { anchor: T } })
    }), o = k(
      {
        get: () => i.value.state.toJSON(),
        set: (T) => i.value.setState(ot.fromJSON(T))
      }
    ), u = Y(0), c = Y(0), d = k(() => {
      const T = new Ss(), L = new Ss();
      if (e.basic && e.minimal)
        throw "[Vue CodeMirror] Both basic and minimal cannot be specified.";
      return [
        // Toggle basic setup
        e.basic && !e.minimal ? M0 : void 0,
        // Toggle minimal setup
        e.minimal && !e.basic ? _B : void 0,
        // ViewUpdate event listener
        Re.updateListener.of((A) => {
          var D;
          t.emit("focus", i.value.hasFocus), u.value = (D = i.value.state.doc) == null ? void 0 : D.length, !(A.changes.empty || !A.docChanged) && (e.linter && (e.forceLinting && i9(i.value), c.value = e.linter(i.value).length), t.emit("update", A));
        }),
        // Toggle light/dark mode.
        Re.theme(e.theme, { dark: e.dark }),
        // Toggle line wrapping
        e.wrap ? Re.lineWrapping : void 0,
        // Indent with tab
        e.tab ? Tl.of([ZR]) : void 0,
        // Tab character
        e.indentUnit ? Lu.of(e.indentUnit) : void 0,
        // Allow Multiple Selections
        ot.allowMultipleSelections.of(e.allowMultipleSelections),
        // Indent tab size
        e.tabSize ? L.of(ot.tabSize.of(e.tabSize)) : void 0,
        // locale settings
        e.phrases ? ot.phrases.of(e.phrases) : void 0,
        // Readonly option
        ot.readOnly.of(e.readonly),
        // Editable option
        Re.editable.of(!e.disabled),
        // Set Line break char
        e.lineSeparator ? ot.lineSeparator.of(e.lineSeparator) : void 0,
        // Lang
        e.lang ? T.of(e.lang) : void 0,
        // Append Linter settings
        e.linter ? WR(e.linter, e.linterConfig) : void 0,
        // Show 🔴 to error line when linter enabled.
        e.linter && e.gutter ? aI(e.gutterConfig) : void 0,
        // Placeholder
        e.placeholder ? eA(e.placeholder) : void 0,
        // Append Extensions
        ...e.extensions
      ].filter((A) => !!A);
    });
    pe(
      d,
      (T) => {
        var L;
        (L = i.value) == null || L.dispatch({
          effects: at.reconfigure.of(T)
        });
      },
      { immediate: !0 }
    ), pe(
      () => e.modelValue,
      async (T) => {
        if (i.value.composing || // IME fix
        i.value.state.doc.toJSON().join(e.lineSeparator ?? `
`) === T)
          return;
        const L = !i.value.state.selection.ranges.every(
          (A) => A.anchor < T.length && A.head < T.length
        );
        i.value.dispatch({
          changes: { from: 0, to: i.value.state.doc.length, insert: T },
          selection: L ? { anchor: 0, head: 0 } : i.value.state.selection,
          scrollIntoView: !0
        });
      },
      { immediate: !0 }
    ), rt(async () => {
      let T = a.value;
      n.value && (n.value.childNodes[0] && (a.value !== "" && console.warn(
        "[CodeMirror.vue] The <code-mirror> tag contains child elements that overwrite the `v-model` values."
      ), T = n.value.childNodes[0].innerText.trim()), i.value = new Re({
        parent: n.value,
        state: ot.create({ doc: T, extensions: d.value }),
        dispatch: (L) => {
          i.value.update([L]), !(L.changes.empty || !L.docChanged) && (t.emit("update:modelValue", L.state.doc.toString() ?? ""), t.emit("change", L.state));
        }
      }), await et(), t.emit("ready", {
        view: i.value,
        state: i.value.state,
        container: n.value
      }));
    }), ni(() => {
      i.value.destroy(), t.emit("destroy");
    });
    const f = () => {
      !e.linter || !i.value || (e.forceLinting && i9(i.value), c.value = NR(i.value.state));
    }, h = () => {
      var T, L;
      (T = i.value) == null || T.dispatch({
        effects: at.reconfigure.of([])
      }), (L = i.value) == null || L.dispatch({
        effects: at.appendConfig.of(d.value)
      });
    }, m = (T, L) => i.value.state.sliceDoc(T, L), g = (T) => i.value.state.doc.line(T + 1).text, v = () => i.value.state.doc.lines, y = () => i.value.state.selection.main.head, b = () => {
      let T;
      return (T = i.value.state.selection.ranges) !== null && T !== void 0 ? T : [];
    }, C = () => {
      let T;
      return (T = i.value.state.sliceDoc(
        i.value.state.selection.main.from,
        i.value.state.selection.main.to
      )) !== null && T !== void 0 ? T : "";
    }, S = () => {
      const T = i.value.state;
      return T ? T.selection.ranges.map(
        (L) => T.sliceDoc(L.from, L.to)
      ) : [];
    }, x = () => i.value.state.selection.ranges.some(
      (T) => !T.empty
    ), w = (T, L, A) => i.value.dispatch({
      changes: { from: L, to: A, insert: T }
    }), V = (T) => i.value.dispatch(i.value.state.replaceSelection(T)), _ = (T) => i.value.dispatch({ selection: { anchor: T } }), O = (T, L) => i.value.dispatch({ selection: { anchor: T, head: L } }), $ = (T, L) => i.value.dispatch({
      selection: we.create(T, L)
    }), P = (T) => i.value.dispatch({
      selection: we.create(
        r.value.ranges.map((L) => L.extend(T(L)))
      )
    }), M = {
      editor: n,
      view: i,
      cursor: s,
      selection: r,
      focus: l,
      length: u,
      json: o,
      diagnosticCount: c,
      dom: i.value.contentDOM,
      lint: f,
      forceReconfigure: h,
      // Bellow is CodeMirror5's function
      getRange: m,
      getLine: g,
      lineCount: v,
      getCursor: y,
      listSelections: b,
      getSelection: C,
      getSelections: S,
      somethingSelected: x,
      replaceRange: w,
      replaceSelection: V,
      setCursor: _,
      setSelection: O,
      setSelections: $,
      extendSelectionsBy: P
    };
    return t.expose(M), M;
  },
  render() {
    return b9(
      this.$props.tag,
      {
        ref: "editor",
        class: "vue-codemirror"
      },
      this.$slots.default ? (
        // Hide original content
        b9(
          "aside",
          { style: "display: none;", "aria-hidden": "true" },
          VB(this.$slots.default)
        )
      ) : void 0
    );
  }
});
let LB = class V0 {
  /**
  @internal
  */
  constructor(t, n, a, i, l, r, s, o, u, c = 0, d) {
    this.p = t, this.stack = n, this.state = a, this.reducePos = i, this.pos = l, this.score = r, this.buffer = s, this.bufferBase = o, this.curContext = u, this.lookAhead = c, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, n, a = 0) {
    let i = t.parser.context;
    return new V0(t, [], n, a, a, 0, [], 0, i ? new C9(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var n;
    let a = t >> 19, i = t & 65535, { parser: l } = this.p, r = this.reducePos < this.pos - 25;
    r && this.setLookAhead(this.pos);
    let s = l.dynamicPrecedence(i);
    if (s && (this.score += s), a == 0) {
      this.pushState(l.getGoto(this.state, i, !0), this.reducePos), i < l.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, r ? 8 : 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let o = this.stack.length - (a - 1) * 3 - (t & 262144 ? 6 : 0), u = o ? this.stack[o - 2] : this.p.ranges[0].from, c = this.reducePos - u;
    c >= 2e3 && !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = c));
    let d = o ? this.stack[o - 1] : 0, f = this.bufferBase + this.buffer.length - d;
    if (i < l.minRepeatTerm || t & 131072) {
      let h = l.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, u, h, f + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[o];
    else {
      let h = this.stack[o - 3];
      this.state = l.getGoto(h, i, !0);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(i, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, n, a, i = 4, l = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let r = this, s = this.buffer.length;
      if (s == 0 && r.parent && (s = r.bufferBase - r.parent.bufferBase, r = r.parent), s > 0 && r.buffer[s - 4] == 0 && r.buffer[s - 1] > -1) {
        if (n == a)
          return;
        if (r.buffer[s - 2] >= n) {
          r.buffer[s - 2] = a;
          return;
        }
      }
    }
    if (!l || this.pos == a)
      this.buffer.push(t, n, a, i);
    else {
      let r = this.buffer.length;
      if (r > 0 && this.buffer[r - 4] != 0) {
        let s = !1;
        for (let o = r; o > 0 && this.buffer[o - 2] > a; o -= 4)
          if (this.buffer[o - 1] >= 0) {
            s = !0;
            break;
          }
        if (s)
          for (; r > 0 && this.buffer[r - 2] > a; )
            this.buffer[r] = this.buffer[r - 4], this.buffer[r + 1] = this.buffer[r - 3], this.buffer[r + 2] = this.buffer[r - 2], this.buffer[r + 3] = this.buffer[r - 1], r -= 4, i > 4 && (i -= 4);
      }
      this.buffer[r] = t, this.buffer[r + 1] = n, this.buffer[r + 2] = a, this.buffer[r + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, n, a, i) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if (t & 262144)
      this.pos = i, this.shiftContext(n, a), n <= this.p.parser.maxNode && this.buffer.push(n, a, i, 4);
    else {
      let l = t, { parser: r } = this.p;
      (i > this.pos || n <= r.maxNode) && (this.pos = i, r.stateFlag(
        l,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(l, a), this.shiftContext(n, a), n <= r.maxNode && this.buffer.push(n, a, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, n, a, i) {
    t & 65536 ? this.reduce(t) : this.shift(t, n, a, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, n) {
    let a = this.p.reused.length - 1;
    (a < 0 || this.p.reused[a] != t) && (this.p.reused.push(t), a++);
    let i = this.pos;
    this.reducePos = this.pos = i + t.length, this.pushState(n, i), this.buffer.push(
      a,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, n = t.buffer.length;
    for (; n > 0 && t.buffer[n - 2] > t.reducePos; )
      n -= 4;
    let a = t.buffer.slice(n), i = t.bufferBase + n;
    for (; t && i == t.bufferBase; )
      t = t.parent;
    return new V0(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, a, i, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, n) {
    let a = t <= this.p.parser.maxNode;
    a && this.storeNode(t, this.pos, n, 4), this.storeNode(0, this.pos, n, a ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let n = new QB(this); ; ) {
      let a = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, t);
      if (a == 0)
        return !1;
      if (!(a & 65536))
        return !0;
      n.reduce(a);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let l = 0, r; l < n.length; l += 2)
        (r = n[l + 1]) != this.state && this.p.parser.hasAction(r, t) && i.push(n[l], r);
      if (this.stack.length < 120)
        for (let l = 0; i.length < 8 && l < n.length; l += 2) {
          let r = n[l + 1];
          i.some((s, o) => o & 1 && s == r) || i.push(n[l], r);
        }
      n = i;
    }
    let a = [];
    for (let i = 0; i < n.length && a.length < 4; i += 2) {
      let l = n[i + 1];
      if (l == this.state)
        continue;
      let r = this.split();
      r.pushState(l, this.pos), r.storeNode(0, r.pos, r.pos, 4, !0), r.shiftContext(n[i], this.pos), r.reducePos = this.pos, r.score -= 200, a.push(r);
    }
    return a;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, n = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(n & 65536))
      return !1;
    if (!t.validAction(this.state, n)) {
      let a = n >> 19, i = n & 65535, l = this.stack.length - a * 3;
      if (l < 0 || t.getGoto(this.stack[l], i, !1) < 0) {
        let r = this.findForcedReduction();
        if (r == null)
          return !1;
        n = r;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, n = [], a = (i, l) => {
      if (!n.includes(i))
        return n.push(i), t.allActions(i, (r) => {
          if (!(r & 393216)) if (r & 65536) {
            let s = (r >> 19) - l;
            if (s > 1) {
              let o = r & 65535, u = this.stack.length - s * 3;
              if (u >= 0 && t.getGoto(this.stack[u], o, !1) >= 0)
                return s << 19 | 65536 | o;
            }
          } else {
            let s = a(r, l + 1);
            if (s != null)
              return s;
          }
        });
    };
    return a(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != t.stack[n])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(n)));
  }
  reduceContext(t, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let n = new C9(this.curContext.tracker, t);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
class C9 {
  constructor(t, n) {
    this.tracker = t, this.context = n, this.hash = t.strict ? t.hash(n) : 0;
  }
}
class QB {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let n = t & 65535, a = t >> 19;
    a == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (a - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = i;
  }
}
class kd {
  constructor(t, n, a) {
    this.stack = t, this.pos = n, this.index = a, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, n = t.bufferBase + t.buffer.length) {
    return new kd(t, n, n - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new kd(this.stack, this.pos, this.index);
  }
}
function wo(e, t = Uint16Array) {
  if (typeof e != "string")
    return e;
  let n = null;
  for (let a = 0, i = 0; a < e.length; ) {
    let l = 0;
    for (; ; ) {
      let r = e.charCodeAt(a++), s = !1;
      if (r == 126) {
        l = 65535;
        break;
      }
      r >= 92 && r--, r >= 34 && r--;
      let o = r - 32;
      if (o >= 46 && (o -= 46, s = !0), l += o, s)
        break;
      l *= 46;
    }
    n ? n[i++] = l : n = new t(l);
  }
  return n;
}
class Rc {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const w9 = new Rc();
class AB {
  /**
  @internal
  */
  constructor(t, n) {
    this.input = t, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = w9, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, n) {
    let a = this.range, i = this.rangeIndex, l = this.pos + t;
    for (; l < a.from; ) {
      if (!i)
        return null;
      let r = this.ranges[--i];
      l -= a.from - r.to, a = r;
    }
    for (; n < 0 ? l > a.to : l >= a.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let r = this.ranges[++i];
      l += r.from - a.to, a = r;
    }
    return l;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let n of this.ranges)
      if (n.to > t)
        return Math.max(t, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let n = this.chunkOff + t, a, i;
    if (n >= 0 && n < this.chunk.length)
      a = this.pos + t, i = this.chunk.charCodeAt(n);
    else {
      let l = this.resolveOffset(t, 1);
      if (l == null)
        return -1;
      if (a = l, a >= this.chunk2Pos && a < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(a - this.chunk2Pos);
      else {
        let r = this.rangeIndex, s = this.range;
        for (; s.to <= a; )
          s = this.ranges[++r];
        this.chunk2 = this.input.chunk(this.chunk2Pos = a), a + this.chunk2.length > s.to && (this.chunk2 = this.chunk2.slice(0, s.to - a)), i = this.chunk2.charCodeAt(0);
      }
    }
    return a >= this.token.lookAhead && (this.token.lookAhead = a + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, n = 0) {
    let a = n ? this.resolveOffset(n, -1) : this.pos;
    if (a == null || a < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = a;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, n) {
    this.token.value = t, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), n = this.pos + t.length;
      this.chunk = n > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, n) {
    if (n ? (this.token = n, n.start = t, n.lookAhead = t + 1, n.value = n.extended = -1) : this.token = w9, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, n) {
    if (t >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, n - this.chunkPos);
    if (t >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, n - this.chunk2Pos);
    if (t >= this.range.from && n <= this.range.to)
      return this.input.read(t, n);
    let a = "";
    for (let i of this.ranges) {
      if (i.from >= n)
        break;
      i.to > t && (a += this.input.read(Math.max(i.from, t), Math.min(i.to, n)));
    }
    return a;
  }
}
class vs {
  constructor(t, n) {
    this.data = t, this.id = n;
  }
  token(t, n) {
    let { parser: a } = n.p;
    DO(this.data, t, n, this.id, a.data, a.tokenPrecTable);
  }
}
vs.prototype.contextual = vs.prototype.fallback = vs.prototype.extend = !1;
class T0 {
  constructor(t, n, a) {
    this.precTable = n, this.elseToken = a, this.data = typeof t == "string" ? wo(t) : t;
  }
  token(t, n) {
    let a = t.pos, i = 0;
    for (; ; ) {
      let l = t.next < 0, r = t.resolveOffset(1, 1);
      if (DO(this.data, t, n, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (l || i++, r == null)
        break;
      t.reset(r, t.token);
    }
    i && (t.reset(a, t.token), t.acceptToken(this.elseToken, i));
  }
}
T0.prototype.contextual = vs.prototype.fallback = vs.prototype.extend = !1;
class sl {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, n = {}) {
    this.token = t, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
}
function DO(e, t, n, a, i, l) {
  let r = 0, s = 1 << a, { dialect: o } = n.p.parser;
  e: for (; s & e[r]; ) {
    let u = e[r + 1];
    for (let h = r + 3; h < u; h += 2)
      if ((e[h + 1] & s) > 0) {
        let m = e[h];
        if (o.allows(m) && (t.token.value == -1 || t.token.value == m || DB(m, t.token.value, i, l))) {
          t.acceptToken(m);
          break;
        }
      }
    let c = t.next, d = 0, f = e[r + 2];
    if (t.next < 0 && f > d && e[u + f * 3 - 3] == 65535) {
      r = e[u + f * 3 - 1];
      continue e;
    }
    for (; d < f; ) {
      let h = d + f >> 1, m = u + h + (h << 1), g = e[m], v = e[m + 1] || 65536;
      if (c < g)
        f = h;
      else if (c >= v)
        d = h + 1;
      else {
        r = e[m + 2], t.advance();
        continue e;
      }
    }
    break;
  }
}
function k9(e, t, n) {
  for (let a = t, i; (i = e[a]) != 65535; a++)
    if (i == n)
      return a - t;
  return -1;
}
function DB(e, t, n, a) {
  let i = k9(n, a, t);
  return i < 0 || k9(n, a, e) < i;
}
const ba = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let _f = null;
function S9(e, t, n) {
  let a = e.cursor(Vn.IncludeAnonymous);
  for (a.moveTo(t); ; )
    if (!(n < 0 ? a.childBefore(t) : a.childAfter(t)))
      for (; ; ) {
        if ((n < 0 ? a.to < t : a.from > t) && !a.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            a.to - 1,
            t - 25
            /* Lookahead.Margin */
          )) : Math.min(e.length, Math.max(
            a.from + 1,
            t + 25
            /* Lookahead.Margin */
          ));
        if (n < 0 ? a.prevSibling() : a.nextSibling())
          break;
        if (!a.parent())
          return n < 0 ? 0 : e.length;
      }
}
class RB {
  constructor(t, n) {
    this.fragments = t, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? S9(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? S9(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let a = this.trees[n], i = this.index[n];
      if (i == a.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let l = a.children[i], r = this.start[n] + a.positions[i];
      if (r > t)
        return this.nextStart = r, null;
      if (l instanceof kn) {
        if (r == t) {
          if (r < this.safeFrom)
            return null;
          let s = r + l.length;
          if (s <= this.safeTo) {
            let o = l.prop(ut.lookAhead);
            if (!o || s + o < this.fragment.to)
              return l;
          }
        }
        this.index[n]++, r + l.length >= Math.max(this.safeFrom, t) && (this.trees.push(l), this.start.push(r), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = r + l.length;
    }
  }
}
class IB {
  constructor(t, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((a) => new Rc());
  }
  getActions(t) {
    let n = 0, a = null, { parser: i } = t.p, { tokenizers: l } = i, r = i.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), s = t.curContext ? t.curContext.hash : 0, o = 0;
    for (let u = 0; u < l.length; u++) {
      if (!(1 << u & r))
        continue;
      let c = l[u], d = this.tokens[u];
      if (!(a && !c.fallback) && ((c.contextual || d.start != t.pos || d.mask != r || d.context != s) && (this.updateCachedToken(d, c, t), d.mask = r, d.context = s), d.lookAhead > d.end + 25 && (o = Math.max(d.lookAhead, o)), d.value != 0)) {
        let f = n;
        if (d.extended > -1 && (n = this.addActions(t, d.extended, d.end, n)), n = this.addActions(t, d.value, d.end, n), !c.extend && (a = d, n > f))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return o && t.setLookAhead(o), !a && t.pos == this.stream.end && (a = new Rc(), a.value = t.p.parser.eofTerm, a.start = a.end = t.pos, n = this.addActions(t, a.value, a.end, n)), this.mainToken = a, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let n = new Rc(), { pos: a, p: i } = t;
    return n.start = a, n.end = Math.min(a + 1, i.stream.end), n.value = a == i.stream.end ? i.parser.eofTerm : 0, n;
  }
  updateCachedToken(t, n, a) {
    let i = this.stream.clipPos(a.pos);
    if (n.token(this.stream.reset(i, t), a), t.value > -1) {
      let { parser: l } = a.p;
      for (let r = 0; r < l.specialized.length; r++)
        if (l.specialized[r] == t.value) {
          let s = l.specializers[r](this.stream.read(t.start, t.end), a);
          if (s >= 0 && a.p.parser.dialect.allows(s >> 1)) {
            s & 1 ? t.extended = s >> 1 : t.value = s >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(i + 1);
  }
  putAction(t, n, a, i) {
    for (let l = 0; l < i; l += 3)
      if (this.actions[l] == t)
        return i;
    return this.actions[i++] = t, this.actions[i++] = n, this.actions[i++] = a, i;
  }
  addActions(t, n, a, i) {
    let { state: l } = t, { parser: r } = t.p, { data: s } = r;
    for (let o = 0; o < 2; o++)
      for (let u = r.stateSlot(
        l,
        o ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (s[u] == 65535)
          if (s[u + 1] == 1)
            u = Ni(s, u + 2);
          else {
            i == 0 && s[u + 1] == 2 && (i = this.putAction(Ni(s, u + 2), n, a, i));
            break;
          }
        s[u] == n && (i = this.putAction(Ni(s, u + 1), n, a, i));
      }
    return i;
  }
}
class BB {
  constructor(t, n, a, i) {
    this.parser = t, this.input = n, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new AB(n, i), this.tokens = new IB(t, this.stream), this.topTerm = t.top[1];
    let { from: l } = i[0];
    this.stacks = [LB.start(this, t.top[0], l)], this.fragments = a.length && this.stream.end - l > t.bufferLength * 4 ? new RB(a, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, n = this.minStackPos, a = this.stacks = [], i, l;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [r] = t;
      for (; r.forceReduce() && r.stack.length && r.stack[r.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let r = 0; r < t.length; r++) {
      let s = t[r];
      for (; ; ) {
        if (this.tokens.mainToken = null, s.pos > n)
          a.push(s);
        else {
          if (this.advanceStack(s, a, t))
            continue;
          {
            i || (i = [], l = []), i.push(s);
            let o = this.tokens.getMainToken(s);
            l.push(o.value, o.end);
          }
        }
        break;
      }
    }
    if (!a.length) {
      let r = i && EB(i);
      if (r)
        return ba && console.log("Finish with " + this.stackID(r)), this.stackToTree(r);
      if (this.parser.strict)
        throw ba && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let r = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, l, a);
      if (r)
        return ba && console.log("Force-finish " + this.stackID(r)), this.stackToTree(r.forceAll());
    }
    if (this.recovering) {
      let r = this.recovering == 1 ? 1 : this.recovering * 3;
      if (a.length > r)
        for (a.sort((s, o) => o.score - s.score); a.length > r; )
          a.pop();
      a.some((s) => s.reducePos > n) && this.recovering--;
    } else if (a.length > 1) {
      e: for (let r = 0; r < a.length - 1; r++) {
        let s = a[r];
        for (let o = r + 1; o < a.length; o++) {
          let u = a[o];
          if (s.sameState(u) || s.buffer.length > 500 && u.buffer.length > 500)
            if ((s.score - u.score || s.buffer.length - u.buffer.length) > 0)
              a.splice(o--, 1);
            else {
              a.splice(r--, 1);
              continue e;
            }
        }
      }
      a.length > 12 && a.splice(
        12,
        a.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = a[0].pos;
    for (let r = 1; r < a.length; r++)
      a[r].pos < this.minStackPos && (this.minStackPos = a[r].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, n, a) {
    let i = t.pos, { parser: l } = this, r = ba ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let u = t.curContext && t.curContext.tracker.strict, c = u ? t.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(i); d; ) {
        let f = this.parser.nodeSet.types[d.type.id] == d.type ? l.getGoto(t.state, d.type.id) : -1;
        if (f > -1 && d.length && (!u || (d.prop(ut.contextHash) || 0) == c))
          return t.useNode(d, f), ba && console.log(r + this.stackID(t) + ` (via reuse of ${l.getName(d.type.id)})`), !0;
        if (!(d instanceof kn) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let h = d.children[0];
        if (h instanceof kn && d.positions[0] == 0)
          d = h;
        else
          break;
      }
    }
    let s = l.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (s > 0)
      return t.reduce(s), ba && console.log(r + this.stackID(t) + ` (via always-reduce ${l.getName(
        s & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let o = this.tokens.getActions(t);
    for (let u = 0; u < o.length; ) {
      let c = o[u++], d = o[u++], f = o[u++], h = u == o.length || !a, m = h ? t : t.split(), g = this.tokens.mainToken;
      if (m.apply(c, d, g ? g.start : m.pos, f), ba && console.log(r + this.stackID(m) + ` (via ${c & 65536 ? `reduce of ${l.getName(
        c & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${l.getName(d)} @ ${i}${m == t ? "" : ", split"})`), h)
        return !0;
      m.pos > i ? n.push(m) : a.push(m);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, n) {
    let a = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > a)
        return x9(t, n), !0;
    }
  }
  runRecovery(t, n, a) {
    let i = null, l = !1;
    for (let r = 0; r < t.length; r++) {
      let s = t[r], o = n[r << 1], u = n[(r << 1) + 1], c = ba ? this.stackID(s) + " -> " : "";
      if (s.deadEnd && (l || (l = !0, s.restart(), ba && console.log(c + this.stackID(s) + " (restarted)"), this.advanceFully(s, a))))
        continue;
      let d = s.split(), f = c;
      for (let h = 0; d.forceReduce() && h < 10 && (ba && console.log(f + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, a)); h++)
        ba && (f = this.stackID(d) + " -> ");
      for (let h of s.recoverByInsert(o))
        ba && console.log(c + this.stackID(h) + " (via recover-insert)"), this.advanceFully(h, a);
      this.stream.end > s.pos ? (u == s.pos && (u++, o = 0), s.recoverByDelete(o, u), ba && console.log(c + this.stackID(s) + ` (via recover-delete ${this.parser.getName(o)})`), x9(s, a)) : (!i || i.score < s.score) && (i = s);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), kn.build({
      buffer: kd.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let n = (_f || (_f = /* @__PURE__ */ new WeakMap())).get(t);
    return n || _f.set(t, n = String.fromCodePoint(this.nextStackID++)), n + t;
  }
}
function x9(e, t) {
  for (let n = 0; n < t.length; n++) {
    let a = t[n];
    if (a.pos == e.pos && a.sameState(e)) {
      t[n].score < e.score && (t[n] = e);
      return;
    }
  }
  t.push(e);
}
class ZB {
  constructor(t, n, a) {
    this.source = t, this.flags = n, this.disabled = a;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}
const Mf = (e) => e;
class RO {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || Mf, this.reduce = t.reduce || Mf, this.reuse = t.reuse || Mf, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}
class uu extends ty {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let n = t.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let s = 0; s < t.repeatNodeCount; s++)
      n.push("");
    let a = Object.keys(t.topRules).map((s) => t.topRules[s][1]), i = [];
    for (let s = 0; s < n.length; s++)
      i.push([]);
    function l(s, o, u) {
      i[s].push([o, o.deserialize(String(u))]);
    }
    if (t.nodeProps)
      for (let s of t.nodeProps) {
        let o = s[0];
        typeof o == "string" && (o = ut[o]);
        for (let u = 1; u < s.length; ) {
          let c = s[u++];
          if (c >= 0)
            l(c, o, s[u++]);
          else {
            let d = s[u + -c];
            for (let f = -c; f > 0; f--)
              l(s[u++], o, d);
            u++;
          }
        }
      }
    this.nodeSet = new Om(n.map((s, o) => pa.define({
      name: o >= this.minRepeatTerm ? void 0 : s,
      id: o,
      props: i[o],
      top: a.indexOf(o) > -1,
      error: o == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(o) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = G6;
    let r = wo(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let s = 0; s < this.specializerSpecs.length; s++)
      this.specialized[s] = this.specializerSpecs[s].term;
    this.specializers = this.specializerSpecs.map(P9), this.states = wo(t.states, Uint32Array), this.data = wo(t.stateData), this.goto = wo(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((s) => typeof s == "number" ? new vs(r, s) : s), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, n, a) {
    let i = new BB(this, t, n, a);
    for (let l of this.wrappers)
      i = l(i, t, n, a);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, n, a = !1) {
    let i = this.goto;
    if (n >= i[0])
      return -1;
    for (let l = i[n + 1]; ; ) {
      let r = i[l++], s = r & 1, o = i[l++];
      if (s && a)
        return o;
      for (let u = l + (r >> 1); l < u; l++)
        if (i[l] == t)
          return o;
      if (s)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, n) {
    let a = this.data;
    for (let i = 0; i < 2; i++)
      for (let l = this.stateSlot(
        t,
        i ? 2 : 1
        /* ParseState.Actions */
      ), r; ; l += 3) {
        if ((r = a[l]) == 65535)
          if (a[l + 1] == 1)
            r = a[l = Ni(a, l + 2)];
          else {
            if (a[l + 1] == 2)
              return Ni(a, l + 2);
            break;
          }
        if (r == n || r == 0)
          return Ni(a, l + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, n) {
    return this.states[t * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(t, n) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(t, n) {
    return !!this.allActions(t, (a) => a == n ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, n) {
    let a = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), i = a ? n(a) : void 0;
    for (let l = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); i == null; l += 3) {
      if (this.data[l] == 65535)
        if (this.data[l + 1] == 1)
          l = Ni(this.data, l + 2);
        else
          break;
      i = n(Ni(this.data, l + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let n = [];
    for (let a = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; a += 3) {
      if (this.data[a] == 65535)
        if (this.data[a + 1] == 1)
          a = Ni(this.data, a + 2);
        else
          break;
      if (!(this.data[a + 2] & 1)) {
        let i = this.data[a + 1];
        n.some((l, r) => r & 1 && l == i) || n.push(this.data[a], i);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let n = Object.assign(Object.create(uu.prototype), this);
    if (t.props && (n.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let a = this.topRules[t.top];
      if (!a)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      n.top = a;
    }
    return t.tokenizers && (n.tokenizers = this.tokenizers.map((a) => {
      let i = t.tokenizers.find((l) => l.from == a);
      return i ? i.to : a;
    })), t.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((a, i) => {
      let l = t.specializers.find((s) => s.from == a.external);
      if (!l)
        return a;
      let r = Object.assign(Object.assign({}, a), { external: l.to });
      return n.specializers[i] = P9(r), r;
    })), t.contextTracker && (n.context = t.contextTracker), t.dialect && (n.dialect = this.parseDialect(t.dialect)), t.strict != null && (n.strict = t.strict), t.wrap && (n.wrappers = n.wrappers.concat(t.wrap)), t.bufferLength != null && (n.bufferLength = t.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let n = Object.keys(this.dialects), a = n.map(() => !1);
    if (t)
      for (let l of t.split(" ")) {
        let r = n.indexOf(l);
        r >= 0 && (a[r] = !0);
      }
    let i = null;
    for (let l = 0; l < n.length; l++)
      if (!a[l])
        for (let r = this.dialects[n[l]], s; (s = this.data[r++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[s] = 1;
    return new ZB(t, a, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new uu(t);
  }
}
function Ni(e, t) {
  return e[t] | e[t + 1] << 16;
}
function EB(e) {
  let t = null;
  for (let n of e) {
    let a = n.p.stoppedAt;
    (n.pos == n.p.stream.end || a != null && n.pos > a) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < n.score) && (t = n);
  }
  return t;
}
function P9(e) {
  if (e.external) {
    let t = e.extend ? 1 : 0;
    return (n, a) => e.external(n, a) << 1 | t;
  }
  return e.get;
}
const NB = 314, HB = 315, $9 = 1, jB = 2, zB = 3, FB = 4, XB = 316, YB = 318, WB = 319, qB = 5, UB = 6, GB = 0, L0 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], IO = 125, KB = 59, Q0 = 47, JB = 42, eZ = 43, tZ = 45, nZ = 60, aZ = 44, iZ = 63, lZ = 46, rZ = 91, sZ = new RO({
  start: !1,
  shift(e, t) {
    return t == qB || t == UB || t == YB ? e : t == WB;
  },
  strict: !1
}), oZ = new sl((e, t) => {
  let { next: n } = e;
  (n == IO || n == -1 || t.context) && e.acceptToken(XB);
}, { contextual: !0, fallback: !0 }), uZ = new sl((e, t) => {
  let { next: n } = e, a;
  L0.indexOf(n) > -1 || n == Q0 && ((a = e.peek(1)) == Q0 || a == JB) || n != IO && n != KB && n != -1 && !t.context && e.acceptToken(NB);
}, { contextual: !0 }), cZ = new sl((e, t) => {
  e.next == rZ && !t.context && e.acceptToken(HB);
}, { contextual: !0 }), dZ = new sl((e, t) => {
  let { next: n } = e;
  if (n == eZ || n == tZ) {
    if (e.advance(), n == e.next) {
      e.advance();
      let a = !t.context && t.canShift($9);
      e.acceptToken(a ? $9 : jB);
    }
  } else n == iZ && e.peek(1) == lZ && (e.advance(), e.advance(), (e.next < 48 || e.next > 57) && e.acceptToken(zB));
}, { contextual: !0 });
function Vf(e, t) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e == 95 || e >= 192 || !t && e >= 48 && e <= 57;
}
const fZ = new sl((e, t) => {
  if (e.next != nZ || !t.dialectEnabled(GB) || (e.advance(), e.next == Q0)) return;
  let n = 0;
  for (; L0.indexOf(e.next) > -1; )
    e.advance(), n++;
  if (Vf(e.next, !0)) {
    for (e.advance(), n++; Vf(e.next, !1); )
      e.advance(), n++;
    for (; L0.indexOf(e.next) > -1; )
      e.advance(), n++;
    if (e.next == aZ) return;
    for (let a = 0; ; a++) {
      if (a == 7) {
        if (!Vf(e.next, !0)) return;
        break;
      }
      if (e.next != "extends".charCodeAt(a)) break;
      e.advance(), n++;
    }
  }
  e.acceptToken(FB, -n);
}), hZ = km({
  "get set async static": ae.modifier,
  "for while do if else switch try catch finally return throw break continue default case": ae.controlKeyword,
  "in of await yield void typeof delete instanceof": ae.operatorKeyword,
  "let var const using function class extends": ae.definitionKeyword,
  "import export from": ae.moduleKeyword,
  "with debugger as new": ae.keyword,
  TemplateString: ae.special(ae.string),
  super: ae.atom,
  BooleanLiteral: ae.bool,
  this: ae.self,
  null: ae.null,
  Star: ae.modifier,
  VariableName: ae.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": ae.function(ae.variableName),
  VariableDefinition: ae.definition(ae.variableName),
  Label: ae.labelName,
  PropertyName: ae.propertyName,
  PrivatePropertyName: ae.special(ae.propertyName),
  "CallExpression/MemberExpression/PropertyName": ae.function(ae.propertyName),
  "FunctionDeclaration/VariableDefinition": ae.function(ae.definition(ae.variableName)),
  "ClassDeclaration/VariableDefinition": ae.definition(ae.className),
  "NewExpression/VariableName": ae.className,
  PropertyDefinition: ae.definition(ae.propertyName),
  PrivatePropertyDefinition: ae.definition(ae.special(ae.propertyName)),
  UpdateOp: ae.updateOperator,
  "LineComment Hashbang": ae.lineComment,
  BlockComment: ae.blockComment,
  Number: ae.number,
  String: ae.string,
  Escape: ae.escape,
  ArithOp: ae.arithmeticOperator,
  LogicOp: ae.logicOperator,
  BitOp: ae.bitwiseOperator,
  CompareOp: ae.compareOperator,
  RegExp: ae.regexp,
  Equals: ae.definitionOperator,
  Arrow: ae.function(ae.punctuation),
  ": Spread": ae.punctuation,
  "( )": ae.paren,
  "[ ]": ae.squareBracket,
  "{ }": ae.brace,
  "InterpolationStart InterpolationEnd": ae.special(ae.brace),
  ".": ae.derefOperator,
  ", ;": ae.separator,
  "@": ae.meta,
  TypeName: ae.typeName,
  TypeDefinition: ae.definition(ae.typeName),
  "type enum interface implements namespace module declare": ae.definitionKeyword,
  "abstract global Privacy readonly override": ae.modifier,
  "is keyof unique infer asserts": ae.operatorKeyword,
  JSXAttributeValue: ae.attributeValue,
  JSXText: ae.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": ae.angleBracket,
  "JSXIdentifier JSXNameSpacedName": ae.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": ae.attributeName,
  "JSXBuiltin/JSXIdentifier": ae.standard(ae.tagName)
}), mZ = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, const: 52, extends: 56, this: 60, true: 68, false: 68, null: 80, void: 84, typeof: 88, super: 104, new: 138, delete: 150, yield: 159, await: 163, class: 168, public: 231, private: 231, protected: 231, readonly: 233, instanceof: 252, satisfies: 255, in: 256, import: 290, keyof: 347, unique: 351, infer: 357, asserts: 393, is: 395, abstract: 415, implements: 417, type: 419, let: 422, var: 424, using: 427, interface: 433, enum: 437, namespace: 443, module: 445, declare: 449, global: 453, for: 472, of: 481, while: 484, with: 488, do: 492, if: 496, else: 498, switch: 502, case: 508, try: 514, catch: 518, finally: 522, return: 526, throw: 530, break: 534, continue: 538, debugger: 542 }, vZ = { __proto__: null, async: 125, get: 127, set: 129, declare: 191, public: 193, private: 193, protected: 193, static: 195, abstract: 197, override: 199, readonly: 205, accessor: 207, new: 399 }, gZ = { __proto__: null, "<": 189 }, pZ = uu.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D_O.QQlO'#DeO.bQlO'#DpO%[QlO'#DxO0fQlO'#EQOOQ!0Lf'#EY'#EYO1PQ`O'#EVOOQO'#En'#EnOOQO'#Ij'#IjO1XQ`O'#GrO1dQ`O'#EmO1iQ`O'#EmO3hQ!0MxO'#JpO6[Q!0MxO'#JqO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#F{O9UQ`O'#FzOOQ!0Lf'#Jq'#JqOOQ!0Lb'#Jp'#JpO9ZQ`O'#GvOOQ['#K]'#K]O9fQ`O'#IWO9kQ!0LrO'#IXOOQ['#J^'#J^OOQ['#I]'#I]Q`QlOOQ`QlOOO9sQ!L^O'#DtO9zQlO'#D|O:RQlO'#EOO9aQ`O'#GrO:YQMhO'#CoO:hQ`O'#ElO:sQ`O'#EwO:xQMhO'#FdO;gQ`O'#GrOOQO'#K^'#K^O;lQ`O'#K^O;zQ`O'#GzO;zQ`O'#G{O;zQ`O'#G}O9aQ`O'#HQO<qQ`O'#HTO>YQ`O'#CeO>jQ`O'#HaO>rQ`O'#HgO>rQ`O'#HiO`QlO'#HkO>rQ`O'#HmO>rQ`O'#HpO>wQ`O'#HvO>|Q!0LsO'#H|O%[QlO'#IOO?XQ!0LsO'#IQO?dQ!0LsO'#ISO9kQ!0LrO'#IUO?oQ!0MxO'#CiO@qQpO'#DjQOQ`OOO%[QlO'#EOOAXQ`O'#ERO:YQMhO'#ElOAdQ`O'#ElOAoQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Do'#DoOOQ!0Lb'#Jt'#JtO%[QlO'#JtOOQO'#Jw'#JwOOQO'#If'#IfOBoQpO'#EeOOQ!0Lb'#Ed'#EdOOQ!0Lb'#J{'#J{OCkQ!0MSO'#EeOCuQpO'#EUOOQO'#Jv'#JvODZQpO'#JwOEhQpO'#EUOCuQpO'#EePEuO&2DjO'#CbPOOO)CD{)CD{OOOO'#I^'#I^OFQO#tO,59UOOQ!0Lh,59U,59UOOOO'#I_'#I_OF`O&jO,59UOFnQ!L^O'#DaOOOO'#Ia'#IaOFuO#@ItO,59yOOQ!0Lf,59y,59yOGTQlO'#IbOGhQ`O'#JrOIgQ!fO'#JrO+}QlO'#JrOInQ`O,5:POJUQ`O'#EnOJcQ`O'#KROJnQ`O'#KQOJnQ`O'#KQOJvQ`O,5;[OJ{Q`O'#KPOOQ!0Ln,5:[,5:[OKSQlO,5:[OMQQ!0MxO,5:dOMqQ`O,5:lON[Q!0LrO'#KOONcQ`O'#J}O9ZQ`O'#J}ONwQ`O'#J}O! PQ`O,5;ZO! UQ`O'#J}O!#ZQ!fO'#JqOOQ!0Lh'#Ci'#CiO%[QlO'#EQO!#yQ!fO,5:qOOQS'#Jx'#JxOOQO-E<h-E<hO9aQ`O,5=^O!$aQ`O,5=^O!$fQlO,5;XO!&iQMhO'#EiO!(SQ`O,5;XO!(XQlO'#DwO!(cQpO,5;bO!(kQpO,5;bO%[QlO,5;bOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cOOQ['#FY'#FYO!(yQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#InO!*|Q!0LrO,5<hO%[QlO,5;cO!&iQMhO,5;cO!+kQMhO,5;cO!-]QMhO'#E[O%[QlO,5;vOOQ!0Lf,5;z,5;zO!-dQ,UO'#FiO!.aQ,UO'#KVO!-{Q,UO'#KVO!.hQ,UO'#KVOOQO'#KV'#KVO!.|Q,UO,5<ROOOW,5<_,5<_O!/_QlO'#FuOOOW'#Im'#ImO7VO7dO,5<PO!/fQ,UO'#FwOOQ!0Lf,5<P,5<PO!0VQ$IUO'#CwOOQ!0Lh'#C{'#C{O!0jO#@ItO'#DPO!1WQMjO,5<dO!1_Q`O,5<gO!2zQ(CWO'#GWO!3XQ`O'#GXO!3^Q`O'#GXO!4|Q(CWO'#G]O!6RQpO'#GaOOQO'#Gm'#GmO!+rQMhO'#GlOOQO'#Go'#GoO!+rQMhO'#GnO!6tQ$IUO'#JjOOQ!0Lh'#Jj'#JjO!7OQ`O'#JiO!7^Q`O'#JhO!7fQ`O'#CuOOQ!0Lh'#Cy'#CyO!7qQ`O'#C{OOQ!0Lh'#DT'#DTOOQ!0Lh'#DV'#DVO1SQ`O'#DXO!+rQMhO'#GOO!+rQMhO'#GQO!7vQ`O'#GSO!7{Q`O'#GTO!3^Q`O'#GZO!+rQMhO'#G`O;zQ`O'#JiO!8QQ`O'#EoO!8oQ`O,5<fOOQ!0Lb'#Cr'#CrO!8wQ`O'#EpO!9qQpO'#EqOOQ!0Lb'#KP'#KPO!9xQ!0LrO'#K_O9kQ!0LrO,5=bO`QlO,5>rOOQ['#Jf'#JfOOQ[,5>s,5>sOOQ[-E<Z-E<ZO!;wQ!0MxO,5:`O!9lQpO,5:^O!>bQ!0MxO,5:hO%[QlO,5:hO!@xQ!0MxO,5:jOOQO,5@x,5@xO!AiQMhO,5=^O!AwQ!0LrO'#JgO9UQ`O'#JgO!BYQ!0LrO,59ZO!BeQpO,59ZO!BmQMhO,59ZO:YQMhO,59ZO!BxQ`O,5;XO!CQQ`O'#H`O!CfQ`O'#KbO%[QlO,5;|O!9lQpO,5<OO!CnQ`O,5=yO!CsQ`O,5=yO!CxQ`O,5=yO9kQ!0LrO,5=yO;zQ`O,5=iOOQO'#Cw'#CwO!DWQpO,5=fO!D`QMhO,5=gO!DkQ`O,5=iO!DpQ!bO,5=lO!DxQ`O'#K^O>wQ`O'#HVO9aQ`O'#HXO!D}Q`O'#HXO:YQMhO'#HZO!ESQ`O'#HZOOQ[,5=o,5=oO!EXQ`O'#H[O!EjQ`O'#CoO!EoQ`O,59PO!EyQ`O,59PO!HOQlO,59POOQ[,59P,59PO!H`Q!0LrO,59PO%[QlO,59PO!JkQlO'#HcOOQ['#Hd'#HdOOQ['#He'#HeO`QlO,5={O!KRQ`O,5={O`QlO,5>RO`QlO,5>TO!KWQ`O,5>VO`QlO,5>XO!K]Q`O,5>[O!KbQlO,5>bOOQ[,5>h,5>hO%[QlO,5>hO9kQ!0LrO,5>jOOQ[,5>l,5>lO# lQ`O,5>lOOQ[,5>n,5>nO# lQ`O,5>nOOQ[,5>p,5>pO#!YQpO'#D]O%[QlO'#JtO#!{QpO'#JtO##VQpO'#DkO##hQpO'#DkO#%yQlO'#DkO#&QQ`O'#JsO#&YQ`O,5:UO#&_Q`O'#ErO#&mQ`O'#KSO#&uQ`O,5;]O#&zQpO'#DkO#'XQpO'#ETOOQ!0Lf,5:m,5:mO%[QlO,5:mO#'`Q`O,5:mO>wQ`O,5;WO!BeQpO,5;WO!BmQMhO,5;WO:YQMhO,5;WO#'hQ`O,5@`O#'mQ07dO,5:qOOQO-E<d-E<dO#(sQ!0MSO,5;POCuQpO,5:pO#(}QpO,5:pOCuQpO,5;PO!BYQ!0LrO,5:pOOQ!0Lb'#Eh'#EhOOQO,5;P,5;PO%[QlO,5;PO#)[Q!0LrO,5;PO#)gQ!0LrO,5;PO!BeQpO,5:pOOQO,5;V,5;VO#)uQ!0LrO,5;PPOOO'#I['#I[P#*ZO&2DjO,58|POOO,58|,58|OOOO-E<[-E<[OOQ!0Lh1G.p1G.pOOOO-E<]-E<]OOOO,59{,59{O#*fQ!bO,59{OOOO-E<_-E<_OOQ!0Lf1G/e1G/eO#*kQ!fO,5>|O+}QlO,5>|OOQO,5?S,5?SO#*uQlO'#IbOOQO-E<`-E<`O#+SQ`O,5@^O#+[Q!fO,5@^O#+cQ`O,5@lOOQ!0Lf1G/k1G/kO%[QlO,5@mO#+kQ`O'#IhOOQO-E<f-E<fO#+cQ`O,5@lOOQ!0Lb1G0v1G0vOOQ!0Ln1G/v1G/vOOQ!0Ln1G0W1G0WO%[QlO,5@jO#,PQ!0LrO,5@jO#,bQ!0LrO,5@jO#,iQ`O,5@iO9ZQ`O,5@iO#,qQ`O,5@iO#-PQ`O'#IkO#,iQ`O,5@iOOQ!0Lb1G0u1G0uO!(cQpO,5:sO!(nQpO,5:sOOQS,5:u,5:uO#-qQdO,5:uO#-yQMhO1G2xO9aQ`O1G2xOOQ!0Lf1G0s1G0sO#.XQ!0MxO1G0sO#/^Q!0MvO,5;TOOQ!0Lh'#GV'#GVO#/zQ!0MzO'#JjO!$fQlO1G0sO#2VQ!fO'#JuO%[QlO'#JuO#2aQ`O,5:cOOQ!0Lh'#D]'#D]OOQ!0Lf1G0|1G0|O%[QlO1G0|OOQ!0Lf1G1e1G1eO#2fQ`O1G0|O#4zQ!0MxO1G0}O#5RQ!0MxO1G0}O#7iQ!0MxO1G0}O#7pQ!0MxO1G0}O#:WQ!0MxO1G0}O#<nQ!0MxO1G0}O#<uQ!0MxO1G0}O#<|Q!0MxO1G0}O#?dQ!0MxO1G0}O#?kQ!0MxO1G0}O#AxQ?MtO'#CiO#CsQ?MtO1G1_O#CzQ?MtO'#JqO#D_Q!0MxO,5?YOOQ!0Lb-E<l-E<lO#FlQ!0MxO1G0}O#GiQ!0MzO1G0}OOQ!0Lf1G0}1G0}O#HlQMjO'#JzO#HvQ`O,5:vO#H{Q!0MxO1G1bO#IoQ,UO,5<VO#IwQ,UO,5<WO#JPQ,UO'#FnO#JhQ`O'#FmOOQO'#KW'#KWOOQO'#Il'#IlO#JmQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#KOQ?MtO'#JpO#KYQ`O,5<aO!(yQlO,5<aOOOW-E<k-E<kOOQ!0Lf1G1k1G1kO#K_QpO'#KVOOQ!0Lf,5<c,5<cO#KgQpO,5<cO#KlQMhO'#DROOOO'#I`'#I`O#KsO#@ItO,59kOOQ!0Lh,59k,59kO%[QlO1G2OO!7{Q`O'#IpO#LOQ`O,5<yOOQ!0Lh,5<v,5<vO!+rQMhO'#IsO#LlQMjO,5=WO!+rQMhO'#IuO#M_QMjO,5=YO!&iQMhO,5=[OOQO1G2R1G2RO#MiQ!dO'#CrO#M|Q(CWO'#EpO$ RQpO'#GaO$ iQ!dO,5<rO$ pQ`O'#KYO9ZQ`O'#KYO$!OQ`O,5<tO!+rQMhO,5<sO$!TQ`O'#GYO$!fQ`O,5<sO$!kQ!dO'#GVO$!xQ!dO'#KZO$#SQ`O'#KZO!&iQMhO'#KZO$#XQ`O,5<wO$#^QlO'#JtO$#hQpO'#GbO##hQpO'#GbO$#yQ`O'#GfO!3^Q`O'#GjO$$OQ!0LrO'#IrO$$ZQpO,5<{OOQ!0Lp,5<{,5<{O$$bQpO'#GbO$$oQpO'#GcO$%QQpO'#GcO$%VQMjO,5=WO$%gQMjO,5=YOOQ!0Lh,5=],5=]O!+rQMhO,5@TO!+rQMhO,5@TO$%wQ`O'#IwO$&VQ`O,5@SO$&_Q`O,59aOOQ!0Lh,59g,59gO$'UQ$IYO,59sOOQ!0Lh'#Jn'#JnO$'wQMjO,5<jO$(jQMjO,5<lO@iQ`O,5<nOOQ!0Lh,5<o,5<oO$(tQ`O,5<uO$(yQMjO,5<zO$)ZQ`O,5@TO$)iQ`O'#J}O!$fQlO1G2QO$)nQ`O1G2QO9ZQ`O'#KQO9ZQ`O'#ErO%[QlO'#ErO9ZQ`O'#IyO$)sQ!0LrO,5@yOOQ[1G2|1G2|OOQ[1G4^1G4^OOQ!0Lf1G/z1G/zOOQ!0Lf1G/x1G/xO$+uQ!0MxO1G0SOOQ[1G2x1G2xO!&iQMhO1G2xO%[QlO1G2xO#-|Q`O1G2xO$-yQMhO'#EiOOQ!0Lb,5@R,5@RO$.WQ!0LrO,5@ROOQ[1G.u1G.uO!BYQ!0LrO1G.uO!BeQpO1G.uO!BmQMhO1G.uO$.iQ`O1G0sO$.nQ`O'#CiO$.yQ`O'#KcO$/RQ`O,5=zO$/WQ`O'#KcO$/]Q`O'#KcO$/kQ`O'#JPO$/yQ`O,5@|O$0RQ!fO1G1hOOQ!0Lf1G1j1G1jO9aQ`O1G3eO@iQ`O1G3eO$0YQ`O1G3eO$0_Q`O1G3eOOQ[1G3e1G3eO!DkQ`O1G3TO!&iQMhO1G3QO$0dQ`O1G3QOOQ[1G3R1G3RO!&iQMhO1G3RO$0iQ`O1G3RO$0qQpO'#HPOOQ[1G3T1G3TO!5|QpO'#I{O!DpQ!bO1G3WOOQ[1G3W1G3WOOQ[,5=q,5=qO$0yQMhO,5=sO9aQ`O,5=sO$#yQ`O,5=uO9UQ`O,5=uO!BeQpO,5=uO!BmQMhO,5=uO:YQMhO,5=uO$1XQ`O'#KaO$1dQ`O,5=vOOQ[1G.k1G.kO$1iQ!0LrO1G.kO@iQ`O1G.kO$1tQ`O1G.kO9kQ!0LrO1G.kO$3|Q!fO,5AOO$4ZQ`O,5AOO9ZQ`O,5AOO$4fQlO,5=}O$4mQ`O,5=}OOQ[1G3g1G3gO`QlO1G3gOOQ[1G3m1G3mOOQ[1G3o1G3oO>rQ`O1G3qO$4rQlO1G3sO$8vQlO'#HrOOQ[1G3v1G3vO$9TQ`O'#HxO>wQ`O'#HzOOQ[1G3|1G3|O$9]QlO1G3|O9kQ!0LrO1G4SOOQ[1G4U1G4UOOQ!0Lb'#G^'#G^O9kQ!0LrO1G4WO9kQ!0LrO1G4YO$=dQ`O,5@`O!(yQlO,5;^O9ZQ`O,5;^O>wQ`O,5:VO!(yQlO,5:VO!BeQpO,5:VO$=iQ?MtO,5:VOOQO,5;^,5;^O$=sQpO'#IcO$>ZQ`O,5@_OOQ!0Lf1G/p1G/pO$>cQpO'#IiO$>mQ`O,5@nOOQ!0Lb1G0w1G0wO##hQpO,5:VOOQO'#Ie'#IeO$>uQpO,5:oOOQ!0Ln,5:o,5:oO#'cQ`O1G0XOOQ!0Lf1G0X1G0XO%[QlO1G0XOOQ!0Lf1G0r1G0rO>wQ`O1G0rO!BeQpO1G0rO!BmQMhO1G0rOOQ!0Lb1G5z1G5zO!BYQ!0LrO1G0[OOQO1G0k1G0kO%[QlO1G0kO$>|Q!0LrO1G0kO$?XQ!0LrO1G0kO!BeQpO1G0[OCuQpO1G0[O$?gQ!0LrO1G0kOOQO1G0[1G0[O$?{Q!0MxO1G0kPOOO-E<Y-E<YPOOO1G.h1G.hOOOO1G/g1G/gO$@VQ!bO,5<hO$@_Q!fO1G4hOOQO1G4n1G4nO%[QlO,5>|O$@iQ`O1G5xO$@qQ`O1G6WO$@yQ!fO1G6XO9ZQ`O,5?SO$ATQ!0MxO1G6UO%[QlO1G6UO$AeQ!0LrO1G6UO$AvQ`O1G6TO$AvQ`O1G6TO9ZQ`O1G6TO$BOQ`O,5?VO9ZQ`O,5?VOOQO,5?V,5?VO$BdQ`O,5?VO$)iQ`O,5?VOOQO-E<i-E<iOOQS1G0_1G0_OOQS1G0a1G0aO#-tQ`O1G0aOOQ[7+(d7+(dO!&iQMhO7+(dO%[QlO7+(dO$BrQ`O7+(dO$B}QMhO7+(dO$C]Q!0MzO,5=WO$EhQ!0MzO,5=YO$GsQ!0MzO,5=WO$JUQ!0MzO,5=YO$LgQ!0MzO,59sO$NlQ!0MzO,5<jO%!wQ!0MzO,5<lO%%SQ!0MzO,5<zOOQ!0Lf7+&_7+&_O%'eQ!0MxO7+&_O%(XQlO'#IdO%(fQ`O,5@aO%(nQ!fO,5@aOOQ!0Lf1G/}1G/}O%(xQ`O7+&hOOQ!0Lf7+&h7+&hO%(}Q?MtO,5:dO%[QlO7+&yO%)XQ?MtO,5:`O%)fQ?MtO,5:hO%)pQ?MtO,5:jO%)zQMhO'#IgO%*UQ`O,5@fOOQ!0Lh1G0b1G0bOOQO1G1q1G1qOOQO1G1r1G1rO%*^Q!jO,5<YO!(yQlO,5<XOOQO-E<j-E<jOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%*iQ`O1G1{OOQ!0Lf1G1}1G1}OOOO,59m,59mO%*nQ!dO,59mOOOO-E<^-E<^OOQ!0Lh1G/V1G/VO%*uQ!0MxO7+'jOOQ!0Lh,5?[,5?[O%+iQMhO1G2eP%+pQ`O'#IpPOQ!0Lh-E<n-E<nO%,^QMjO,5?_OOQ!0Lh-E<q-E<qO%-PQMjO,5?aOOQ!0Lh-E<s-E<sO%-ZQ!dO1G2vO%-bQ!dO'#CrO%-xQMhO'#KQO$#^QlO'#JtOOQ!0Lh1G2^1G2^O%.PQ`O'#IoO%.eQ`O,5@tO%.eQ`O,5@tO%.mQ`O,5@tO%.xQ`O,5@tOOQO1G2`1G2`O%/WQMjO1G2_O!+rQMhO1G2_O%/hQ(CWO'#IqO%/uQ`O,5@uO!&iQMhO,5@uO%/}Q!dO,5@uOOQ!0Lh1G2c1G2cO%2_Q!fO'#CiO%2iQ`O,5=OOOQ!0Lb,5<|,5<|O%2qQpO,5<|OOQ!0Lb,5<},5<}OCfQ`O,5<|O%2|QpO,5<|OOQ!0Lb,5=Q,5=QO$)iQ`O,5=UOOQO,5?^,5?^OOQO-E<p-E<pOOQ!0Lp1G2g1G2gO##hQpO,5<|O$#^QlO,5=OO%3[Q`O,5<}O%3gQpO,5<}O!+rQMhO'#IsO%4aQMjO1G2rO!+rQMhO'#IuO%5SQMjO1G2tO%5^QMjO1G5oO%5hQMjO1G5oOOQO,5?c,5?cOOQO-E<u-E<uOOQO1G.{1G.{O!9lQpO,59uO%[QlO,59uOOQ!0Lh,5<i,5<iO%5uQ`O1G2YO!+rQMhO1G2aO!+rQMhO1G5oO!+rQMhO1G5oO%5zQ!0MxO7+'lOOQ!0Lf7+'l7+'lO!$fQlO7+'lO%6nQ`O,5;^OOQ!0Lb,5?e,5?eOOQ!0Lb-E<w-E<wO%6sQ!dO'#K[O#'cQ`O7+(dO4UQ!fO7+(dO$BuQ`O7+(dO%6}Q!0MvO'#CiO%7nQ!0LrO,5=RO%8PQ!0MvO,5=RO%8dQ`O,5=ROOQ!0Lb1G5m1G5mOOQ[7+$a7+$aO!BYQ!0LrO7+$aO!BeQpO7+$aO!$fQlO7+&_O%8lQ`O'#JOO%9TQ`O,5@}OOQO1G3f1G3fO9aQ`O,5@}O%9TQ`O,5@}O%9]Q`O,5@}OOQO,5?k,5?kOOQO-E<}-E<}OOQ!0Lf7+'S7+'SO%9bQ`O7+)PO9kQ!0LrO7+)PO9aQ`O7+)PO@iQ`O7+)POOQ[7+(o7+(oO%9gQ!0MvO7+(lO!&iQMhO7+(lO!DfQ`O7+(mOOQ[7+(m7+(mO!&iQMhO7+(mO%9qQ`O'#K`O%9|Q`O,5=kOOQO,5?g,5?gOOQO-E<y-E<yOOQ[7+(r7+(rO%;`QpO'#HYOOQ[1G3_1G3_O!&iQMhO1G3_O%[QlO1G3_O%;gQ`O1G3_O%;rQMhO1G3_O9kQ!0LrO1G3aO$#yQ`O1G3aO9UQ`O1G3aO!BeQpO1G3aO!BmQMhO1G3aO%<QQ`O'#I}O%<fQ`O,5@{O%<nQpO,5@{OOQ!0Lb1G3b1G3bOOQ[7+$V7+$VO@iQ`O7+$VO9kQ!0LrO7+$VO%<yQ`O7+$VO%[QlO1G6jO%[QlO1G6kO%=OQ!0LrO1G6jO%=YQlO1G3iO%=aQ`O1G3iO%=fQlO1G3iOOQ[7+)R7+)RO9kQ!0LrO7+)]O`QlO7+)_OOQ['#Kf'#KfOOQ['#JQ'#JQO%=mQlO,5>^OOQ[,5>^,5>^O%[QlO'#HsO%=zQ`O'#HuOOQ[,5>d,5>dO9ZQ`O,5>dOOQ[,5>f,5>fOOQ[7+)h7+)hOOQ[7+)n7+)nOOQ[7+)r7+)rOOQ[7+)t7+)tO%>PQpO1G5zO%>kQ?MtO1G0xO%>uQ`O1G0xOOQO1G/q1G/qO%?QQ?MtO1G/qO>wQ`O1G/qO!(yQlO'#DkOOQO,5>},5>}OOQO-E<a-E<aOOQO,5?T,5?TOOQO-E<g-E<gO!BeQpO1G/qOOQO-E<c-E<cOOQ!0Ln1G0Z1G0ZOOQ!0Lf7+%s7+%sO#'cQ`O7+%sOOQ!0Lf7+&^7+&^O>wQ`O7+&^O!BeQpO7+&^OOQO7+%v7+%vO$?{Q!0MxO7+&VOOQO7+&V7+&VO%[QlO7+&VO%?[Q!0LrO7+&VO!BYQ!0LrO7+%vO!BeQpO7+%vO%?gQ!0LrO7+&VO%?uQ!0MxO7++pO%[QlO7++pO%@VQ`O7++oO%@VQ`O7++oOOQO1G4q1G4qO9ZQ`O1G4qO%@_Q`O1G4qOOQS7+%{7+%{O#'cQ`O<<LOO4UQ!fO<<LOO%@mQ`O<<LOOOQ[<<LO<<LOO!&iQMhO<<LOO%[QlO<<LOO%@uQ`O<<LOO%AQQ!0MzO,5?_O%C]Q!0MzO,5?aO%EhQ!0MzO1G2_O%GyQ!0MzO1G2rO%JUQ!0MzO1G2tO%LaQ!fO,5?OO%[QlO,5?OOOQO-E<b-E<bO%LkQ`O1G5{OOQ!0Lf<<JS<<JSO%LsQ?MtO1G0sO%NzQ?MtO1G0}O& RQ?MtO1G0}O&#SQ?MtO1G0}O&#ZQ?MtO1G0}O&%[Q?MtO1G0}O&']Q?MtO1G0}O&'dQ?MtO1G0}O&'kQ?MtO1G0}O&)lQ?MtO1G0}O&)sQ?MtO1G0}O&)zQ!0MxO<<JeO&+rQ?MtO1G0}O&,oQ?MvO1G0}O&-rQ?MvO'#JjO&/xQ?MtO1G1bO&0VQ?MtO1G0SO&0aQMjO,5?ROOQO-E<e-E<eO!(yQlO'#FpOOQO'#KX'#KXOOQO1G1t1G1tO&0kQ`O1G1sO&0pQ?MtO,5?YOOOW7+'g7+'gOOOO1G/X1G/XO&0zQ!dO1G4vOOQ!0Lh7+(P7+(PP!&iQMhO,5?[O!+rQMhO7+(bO&1RQ`O,5?ZO9ZQ`O,5?ZOOQO-E<m-E<mO&1aQ`O1G6`O&1aQ`O1G6`O&1iQ`O1G6`O&1tQMjO7+'yO&2UQ!dO,5?]O&2`Q`O,5?]O!&iQMhO,5?]OOQO-E<o-E<oO&2eQ!dO1G6aO&2oQ`O1G6aO&2wQ`O1G2jO!&iQMhO1G2jOOQ!0Lb1G2h1G2hOOQ!0Lb1G2i1G2iO%2qQpO1G2hO!BeQpO1G2hOCfQ`O1G2hOOQ!0Lb1G2p1G2pO&2|QpO1G2hO&3[Q`O1G2jO$)iQ`O1G2iOCfQ`O1G2iO$#^QlO1G2jO&3dQ`O1G2iO&4WQMjO,5?_OOQ!0Lh-E<r-E<rO&4yQMjO,5?aOOQ!0Lh-E<t-E<tO!+rQMhO7++ZOOQ!0Lh1G/a1G/aO&5TQ`O1G/aOOQ!0Lh7+'t7+'tO&5YQMjO7+'{O&5jQMjO7++ZO&5tQMjO7++ZO&6RQ!0MxO<<KWOOQ!0Lf<<KW<<KWO&6uQ`O1G0xO!&iQMhO'#IxO&6zQ`O,5@vO&8|Q!fO<<LOO!&iQMhO1G2mO&9TQ!0LrO1G2mOOQ[<<G{<<G{O!BYQ!0LrO<<G{O&9fQ!0MxO<<IyOOQ!0Lf<<Iy<<IyOOQO,5?j,5?jO&:YQ`O,5?jO&:_Q`O,5?jOOQO-E<|-E<|O&:mQ`O1G6iO&:mQ`O1G6iO9aQ`O1G6iO@iQ`O<<LkOOQ[<<Lk<<LkO&:uQ`O<<LkO9kQ!0LrO<<LkOOQ[<<LW<<LWO%9gQ!0MvO<<LWOOQ[<<LX<<LXO!DfQ`O<<LXO&:zQpO'#IzO&;VQ`O,5@zO!(yQlO,5@zOOQ[1G3V1G3VOOQO'#I|'#I|O9kQ!0LrO'#I|O&;_QpO,5=tOOQ[,5=t,5=tO&;fQpO'#EeO&;mQpO'#GdO&;rQ`O7+(yO&;wQ`O7+(yOOQ[7+(y7+(yO!&iQMhO7+(yO%[QlO7+(yO&<PQ`O7+(yOOQ[7+({7+({O9kQ!0LrO7+({O$#yQ`O7+({O9UQ`O7+({O!BeQpO7+({O&<[Q`O,5?iOOQO-E<{-E<{OOQO'#H]'#H]O&<gQ`O1G6gO9kQ!0LrO<<GqOOQ[<<Gq<<GqO@iQ`O<<GqO&<oQ`O7+,UO&<tQ`O7+,VO%[QlO7+,UO%[QlO7+,VOOQ[7+)T7+)TO&<yQ`O7+)TO&=OQlO7+)TO&=VQ`O7+)TOOQ[<<Lw<<LwOOQ[<<Ly<<LyOOQ[-E=O-E=OOOQ[1G3x1G3xO&=[Q`O,5>_OOQ[,5>a,5>aO&=aQ`O1G4OO9ZQ`O7+&dO!(yQlO7+&dOOQO7+%]7+%]O&=fQ?MtO1G6XO>wQ`O7+%]OOQ!0Lf<<I_<<I_OOQ!0Lf<<Ix<<IxO>wQ`O<<IxOOQO<<Iq<<IqO$?{Q!0MxO<<IqO%[QlO<<IqOOQO<<Ib<<IbO!BYQ!0LrO<<IbO&=pQ!0LrO<<IqO&={Q!0MxO<= [O&>]Q`O<= ZOOQO7+*]7+*]O9ZQ`O7+*]OOQ[ANAjANAjO&>eQ!fOANAjO!&iQMhOANAjO#'cQ`OANAjO4UQ!fOANAjO&>lQ`OANAjO%[QlOANAjO&>tQ!0MzO7+'yO&AVQ!0MzO,5?_O&CbQ!0MzO,5?aO&EmQ!0MzO7+'{O&HOQ!fO1G4jO&HYQ?MtO7+&_O&J^Q?MvO,5=WO&LeQ?MvO,5=YO&LuQ?MvO,5=WO&MVQ?MvO,5=YO&MgQ?MvO,59sO' mQ?MvO,5<jO'#pQ?MvO,5<lO'&UQ?MvO,5<zO''zQ?MtO7+'jO'(XQ?MtO7+'lO'(fQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*b7+*bO'(kQMjO<<K|OOQO1G4u1G4uO'(rQ`O1G4uO'(}Q`O1G4uO')]Q`O7++zO')]Q`O7++zO!&iQMhO1G4wO')eQ!dO1G4wO')oQ`O7++{O')wQ`O7+(UO'*SQ!dO7+(UOOQ!0Lb7+(S7+(SOOQ!0Lb7+(T7+(TO!BeQpO7+(SOCfQ`O7+(SO'*^Q`O7+(UO!&iQMhO7+(UO$)iQ`O7+(TO'*cQ`O7+(UOCfQ`O7+(TO'*kQMjO<<NuOOQ!0Lh7+${7+${O!+rQMhO<<NuO'*uQ!dO,5?dOOQO-E<v-E<vO'+PQ!0MvO7+(XO!&iQMhO7+(XOOQ[AN=gAN=gO9aQ`O1G5UOOQO1G5U1G5UO'+aQ`O1G5UO'+fQ`O7+,TO'+fQ`O7+,TO9kQ!0LrOANBVO@iQ`OANBVOOQ[ANBVANBVOOQ[ANArANArOOQ[ANAsANAsO'+nQ`O,5?fOOQO-E<x-E<xO'+yQ?MtO1G6fOOQO,5?h,5?hOOQO-E<z-E<zOOQ[1G3`1G3`O',TQ`O,5=OOOQ[<<Le<<LeO!&iQMhO<<LeO&;rQ`O<<LeO',YQ`O<<LeO%[QlO<<LeOOQ[<<Lg<<LgO9kQ!0LrO<<LgO$#yQ`O<<LgO9UQ`O<<LgO',bQpO1G5TO',mQ`O7+,ROOQ[AN=]AN=]O9kQ!0LrOAN=]OOQ[<= p<= pOOQ[<= q<= qO',uQ`O<= pO',zQ`O<= qOOQ[<<Lo<<LoO'-PQ`O<<LoO'-UQlO<<LoOOQ[1G3y1G3yO>wQ`O7+)jO'-]Q`O<<JOO'-hQ?MtO<<JOOOQO<<Hw<<HwOOQ!0LfAN?dAN?dOOQOAN?]AN?]O$?{Q!0MxOAN?]OOQOAN>|AN>|O%[QlOAN?]OOQO<<Mw<<MwOOQ[G27UG27UO!&iQMhOG27UO#'cQ`OG27UO'-rQ!fOG27UO4UQ!fOG27UO'-yQ`OG27UO'.RQ?MtO<<JeO'.`Q?MvO1G2_O'0UQ?MvO,5?_O'2XQ?MvO,5?aO'4[Q?MvO1G2rO'6_Q?MvO1G2tO'8bQ?MtO<<KWO'8oQ?MtO<<IyOOQO1G1v1G1vO!+rQMhOANAhOOQO7+*a7+*aO'8|Q`O7+*aO'9XQ`O<= fO'9aQ!dO7+*cOOQ!0Lb<<Kp<<KpO$)iQ`O<<KpOCfQ`O<<KpO'9kQ`O<<KpO!&iQMhO<<KpOOQ!0Lb<<Kn<<KnO!BeQpO<<KnO'9vQ!dO<<KpOOQ!0Lb<<Ko<<KoO':QQ`O<<KpO!&iQMhO<<KpO$)iQ`O<<KoO':VQMjOANDaO':aQ!0MvO<<KsOOQO7+*p7+*pO9aQ`O7+*pO':qQ`O<= oOOQ[G27qG27qO9kQ!0LrOG27qO!(yQlO1G5QO':yQ`O7+,QO';RQ`O1G2jO&;rQ`OANBPOOQ[ANBPANBPO!&iQMhOANBPO';WQ`OANBPOOQ[ANBRANBRO9kQ!0LrOANBRO$#yQ`OANBROOQO'#H^'#H^OOQO7+*o7+*oOOQ[G22wG22wOOQ[ANE[ANE[OOQ[ANE]ANE]OOQ[ANBZANBZO';`Q`OANBZOOQ[<<MU<<MUO!(yQlOAN?jOOQOG24wG24wO$?{Q!0MxOG24wO#'cQ`OLD,pOOQ[LD,pLD,pO!&iQMhOLD,pO';eQ!fOLD,pO';lQ?MvO7+'yO'=bQ?MvO,5?_O'?eQ?MvO,5?aO'AhQ?MvO7+'{O'C^QMjOG27SOOQO<<M{<<M{OOQ!0LbANA[ANA[O$)iQ`OANA[OCfQ`OANA[O'CnQ!dOANA[OOQ!0LbANAYANAYO'CuQ`OANA[O!&iQMhOANA[O'DQQ!dOANA[OOQ!0LbANAZANAZOOQO<<N[<<N[OOQ[LD-]LD-]O'D[Q?MtO7+*lOOQO'#Ge'#GeOOQ[G27kG27kO&;rQ`OG27kO!&iQMhOG27kOOQ[G27mG27mO9kQ!0LrOG27mOOQ[G27uG27uO'DfQ?MtOG25UOOQOLD*cLD*cOOQ[!$(![!$(![O#'cQ`O!$(![O!&iQMhO!$(![O'DpQ!0MzOG27SOOQ!0LbG26vG26vO$)iQ`OG26vO'GRQ`OG26vOCfQ`OG26vO'G^Q!dOG26vO!&iQMhOG26vOOQ[LD-VLD-VO&;rQ`OLD-VOOQ[LD-XLD-XOOQ[!)9Ev!)9EvO#'cQ`O!)9EvOOQ!0LbLD,bLD,bO$)iQ`OLD,bOCfQ`OLD,bO'GeQ`OLD,bO'GpQ!dOLD,bOOQ[!$(!q!$(!qOOQ[!.K;b!.K;bO'GwQ?MvOG27SOOQ!0Lb!$( |!$( |O$)iQ`O!$( |OCfQ`O!$( |O'ImQ`O!$( |OOQ!0Lb!)9Eh!)9EhO$)iQ`O!)9EhOCfQ`O!)9EhOOQ!0Lb!.K;S!.K;SO$)iQ`O!.K;SOOQ!0Lb!4/0n!4/0nO!(yQlO'#DxO1PQ`O'#EVO'IxQ!fO'#JpO'JPQ!L^O'#DtO'JWQlO'#D|O'J_Q!fO'#CiO'LuQ!fO'#CiO!(yQlO'#EOO'MVQlO,5;XO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO'#InO( YQ`O,5<hO!(yQlO,5;cO( bQMhO,5;cO(!{QMhO,5;cO!(yQlO,5;vO!&iQMhO'#GlO( bQMhO'#GlO!&iQMhO'#GnO( bQMhO'#GnO1SQ`O'#DXO1SQ`O'#DXO!&iQMhO'#GOO( bQMhO'#GOO!&iQMhO'#GQO( bQMhO'#GQO!&iQMhO'#G`O( bQMhO'#G`O!(yQlO,5:hO(#SQpO'#D]O(#^QpO'#JtO!(yQlO,5@mO'MVQlO1G0sO(#hQ?MtO'#CiO!(yQlO1G2OO!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO(#rQ!dO'#CrO!&iQMhO,5<sO( bQMhO,5<sO'MVQlO1G2QO!(yQlO7+&yO!&iQMhO1G2_O( bQMhO1G2_O!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO!&iQMhO1G2aO( bQMhO1G2aO'MVQlO7+'lO'MVQlO7+&_O!&iQMhOANAhO( bQMhOANAhO($VQ`O'#EmO($[Q`O'#EmO($dQ`O'#F[O($iQ`O'#EwO($nQ`O'#KRO($yQ`O'#KPO(%UQ`O,5;XO(%ZQMjO,5<dO(%bQ`O'#GXO(%gQ`O'#GXO(%lQ`O,5<fO(%tQ`O,5;XO(%|Q?MtO1G1_O(&TQ`O,5<sO(&YQ`O,5<sO(&_Q`O,5<uO(&dQ`O,5<uO(&iQ`O1G2QO(&nQ`O1G0sO(&sQMjO<<K|O(&zQMjO<<K|O7eQMhO'#F{O9UQ`O'#FzOAdQ`O'#ElO!(yQlO,5;sO!3^Q`O'#GXO!3^Q`O'#GXO!3^Q`O'#GZO!3^Q`O'#GZO!+rQMhO7+(bO!+rQMhO7+(bO%-ZQ!dO1G2vO%-ZQ!dO1G2vO!&iQMhO,5=[O!&iQMhO,5=[",
  stateData: "((P~O'zOS'{OSTOS'|RQ~OPYOQYOSfOY!VOaqOdzOeyOj!POnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!swO!vxO!z]O$V|O$miO%g}O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO&U!WO&[!XO&^!YO&`!ZO&b![O&e!]O&k!^O&q!_O&s!`O&u!aO&w!bO&y!cO(RSO(TTO(WUO(_VO(m[O~OWtO~P`OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa!wOq!nO!Q!oO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!xO#U!pO#V!pO#Y!zO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O'|!{O~OP]XR]X[]Xa]Xp]X!O]X!Q]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X'x]X(_]X(p]X(w]X(x]X~O!e%QX~P(qO_!}O(T#PO(U!}O(V#PO~O_#QO(V#PO(W#PO(X#QO~Ov#SO!S#TO(`#TO(a#VO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R;{O(TTO(WUO(_VO(m[O~O!Y#ZO!Z#WO!W(fP!W(tP~P+}O![#cO~P`OPYOQYOSfOd!jOe!iOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(TTO(WUO(_VO(m[O~On#mO!Y#iO!z]O#g#lO#h#iO(R;|O!i(qP~P.iO!j#oO(R#nO~O!v#sO!z]O%g#tO~O#i#uO~O!e#vO#i#uO~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z$_O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa(dX'x(dX'u(dX!i(dX!W(dX!](dX%h(dX!e(dX~P1qO#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX!](eX%h(eX~Oa(eX'x(eX'u(eX!W(eX!i(eXt(eX!e(eX~P4UO#^$eO~O$[$hO$^$gO$e$mO~OSfO!]$nO$h$oO$j$qO~Oh%VOj%cOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R$sO(TTO(WUO(_$uO(w$}O(x%POg([P~O!j%dO~O!Q%gO!]%hO(R%fO~O!e%lO~Oa%mO'x%mO~O!O%qO~P%[O(S!lO~P%[O%m%uO~P%[Oh%VO!j%dO(R%fO(S!lO~Oe%|O!j%dO(R%fO~O#t$RO~O!O&RO!]&OO!j&QO%i&UO(R%fO(S!lO(TTO(WUO`)UP~O!v#sO~O%r&WO!Q)QX!])QX(R)QX~O(R&XO~Oj!PO!s&^O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO~Od&cOe&bO!v&`O%g&aO%z&_O~P<POd&fOeyOj!PO!]&eO!s&^O!vxO!z]O%g}O%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO~Ob&iO#^&lO%i&gO(S!lO~P=UO!j&mO!s&qO~O!j#oO~O!]XO~Oa%mO'v&yO'x%mO~Oa%mO'v&|O'x%mO~Oa%mO'v'OO'x%mO~O'u]X!W]Xt]X!i]X&Y]X!]]X%h]X!e]X~P(qO!`']O!a'UO!b'UO(S!lO(TTO(WUO~Oq'SO!Q'RO!Y'VO(c'QO![(gP![(vP~P@]Ol'`O!]'^O(R%fO~Oe'eO!j%dO(R%fO~O!O&RO!j&QO~Oq!nO!Q!oO!z;wO#R!pO#S!pO#U!pO#V!pO(S!lO(TTO(WUO(c!mO(m!sO~O!`'kO!a'jO!b'jO#T!pO#Y'lO#Z'lO~PAwOa%mOh%VO!e#vO!j%dO'x%mO(p'nO~O!n'rO#^'pO~PCVOq!nO!Q!oO(TTO(WUO(c!mO(m!sO~O!]XOq(kX!Q(kX!`(kX!a(kX!b(kX!z(kX#R(kX#S(kX#T(kX#U(kX#V(kX#Y(kX#Z(kX(S(kX(T(kX(W(kX(c(kX(m(kX~O!a'jO!b'jO(S!lO~PCuO'}'vO(O'vO(P'xO~O_!}O(T'zO(U!}O(V'zO~O_#QO(V'zO(W'zO(X#QO~Ot'|O~P%[Ov#SO!S#TO(`#TO(a(PO~O!Y(RO!W'UX!W'[X!Z'UX!Z'[X~P+}O!Z(TO!W(fX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z(TO!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~O!W(fX~PGpO!W(YO~O!W(sX!Z(sX!e(sX!i(sX(p(sX~O#^(sX#i#bX![(sX~PIsO#^(ZO!W(uX!Z(uX~O!Z([O!W(tX~O!W(_O~O#^$eO~PIsO![(`O~P`OR#zO!O#yO!Q#{O!j#xO(_VOP!la[!lap!la!Z!la!n!la#P!la#l!la#m!la#n!la#o!la#p!la#q!la#r!la#s!la#t!la#u!la#w!la#y!la#z!la(p!la(w!la(x!la~Oa!la'x!la'u!la!W!la!i!lat!la!]!la%h!la!e!la~PKZO!i(aO~O!e#vO#^(bO(p'nO!Z(rXa(rX'x(rX~O!i(rX~PMvO!Q%gO!]%hO!z]O#g(gO#h(fO(R%fO~O!Z(hO!i(qX~O!i(jO~O!Q%gO!]%hO#h(fO(R%fO~OP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O!e#vO!i(eX~P! dOR(lO!O(kO!j#xO#Q$dO!z!ya!Q!ya~O!v!ya%g!ya!]!ya#g!ya#h!ya(R!ya~P!#eO!v(pO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~O#i(vO~O!Y(xO!i(iP~P%[O(c(zO(m[O~O!Q(|O!j#xO(c(zO(m[O~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z$_Oa$pa'x$pa'u$pa!i$pa!W$pa!]$pa%h$pa!e$pa~Oj)bO~P!&iOh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Og(nP~P!+rO!O)gO!e)fO!]$]X$Y$]X$[$]X$^$]X$e$]X~O!e)fO!](yX$Y(yX$[(yX$^(yX$e(yX~O!O)gO~P!-{O!O)gO!](yX$Y(yX$[(yX$^(yX$e(yX~O!])iO$Y)mO$[)hO$^)hO$e)nO~O!Y)qO~P!(yO$[$hO$^$gO$e)uO~Ol$yX!O$yX#Q$yX'w$yX(w$yX(x$yX~OgkXg$yXlkX!ZkX#^kX~P!/qOv)wO(`)xO(a)zO~Ol*TO!O)|O'w)}O(w$}O(x%PO~Og){O~P!0uOg*UO~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q*WO!]*XO!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~O!Y*[O(R*VO!i(|P~P!1dO#i*^O~O!j*_O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R*aO(TTO(WUO(_$uO(w$}O(x%PO~O!Y*dO!W(}P~P!3cOp*pOq!nO!Q*fO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO(c!mO~O![*mO~P!5WO#Q$dOl(^X!O(^X'w(^X(w(^X(x(^X!Z(^X#^(^X~Og(^X#}(^X~P!6YOl*uO#^*tOg(]X!Z(]X~O!Z*vOg([X~Oj%cO(R&XOg([P~Oq*yO~O!j+OO~O(R(tO~On+TO!Q%gO!Y#iO!]%hO!z]O#g#lO#h#iO(R%fO!i(qP~O!e#vO#i+UO~O!Q%gO!Y+WO!Z([O!]%hO(R%fO!W(tP~Oq'YO!Q+YO!Y+XO(TTO(WUO(c(zO~O![(vP~P!9]O!Z+ZOa)RX'x)RX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa!ha!Z!ha'x!ha'u!ha!W!ha!i!hat!ha!]!ha%h!ha!e!ha~P!:TOR#zO!O#yO!Q#{O!j#xO(_VOP!pa[!pap!pa!Z!pa!n!pa#P!pa#l!pa#m!pa#n!pa#o!pa#p!pa#q!pa#r!pa#s!pa#t!pa#u!pa#w!pa#y!pa#z!pa(p!pa(w!pa(x!pa~Oa!pa'x!pa'u!pa!W!pa!i!pat!pa!]!pa%h!pa!e!pa~P!<kOR#zO!O#yO!Q#{O!j#xO(_VOP!ra[!rap!ra!Z!ra!n!ra#P!ra#l!ra#m!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#w!ra#y!ra#z!ra(p!ra(w!ra(x!ra~Oa!ra'x!ra'u!ra!W!ra!i!rat!ra!]!ra%h!ra!e!ra~P!?ROh%VOl+dO!]'^O%h+cO~O!e+fOa(ZX!](ZX'x(ZX!Z(ZX~Oa%mO!]XO'x%mO~Oh%VO!j%dO~Oh%VO!j%dO(R%fO~O!e#vO#i(vO~Ob+qO%i+rO(R+nO(TTO(WUO![)VP~O!Z+sO`)UX~O[+wO~O`+xO~O!]&OO(R%fO(S!lO`)UP~Oh%VO#^+}O~Oh%VOl,QO!]$|O~O!],SO~O!O,UO!]XO~O%m%uO~O!v,ZO~Oe,`O~Ob,aO(R#nO(TTO(WUO![)TP~Oe%|O~O%i!QO(R&XO~P=UO[,fO`,eO~OPYOQYOSfOdzOeyOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!guO!jZO!mYO!nYO!oYO!qvO!vxO!z]O$miO%g}O(TTO(WUO(_VO(m[O~O!]!eO!s!gO$V!kO(R!dO~P!FRO`,eOa%mO'x%mO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa,kOj!OO!swO%k!OO%l!OO%m!OO~P!HkO!j&mO~O&[,qO~O!],sO~O&m,uO&o,vOP&jaQ&jaS&jaY&jaa&jad&jae&jaj&jan&jap&jaq&jar&jax&jaz&ja|&ja!Q&ja!U&ja!V&ja!]&ja!g&ja!j&ja!m&ja!n&ja!o&ja!q&ja!s&ja!v&ja!z&ja$V&ja$m&ja%g&ja%i&ja%k&ja%l&ja%m&ja%p&ja%r&ja%u&ja%v&ja%x&ja&U&ja&[&ja&^&ja&`&ja&b&ja&e&ja&k&ja&q&ja&s&ja&u&ja&w&ja&y&ja'u&ja(R&ja(T&ja(W&ja(_&ja(m&ja![&ja&c&jab&ja&h&ja~O(R,{O~Oh!cX!Z!PX![!PX!e!PX!e!cX!j!cX#^!PX~O!Z!cX![!cX~P# qO!e-QO#^-POh(hX!Z#fX![#fX!e(hX!j(hX~O!Z(hX![(hX~P#!dOh%VO!e-SO!j%dO!Z!_X![!_X~Oq!nO!Q!oO(TTO(WUO(c!mO~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(TTO(WUO(_VO(m[O~O(R<rO~P##yO!Z-WO![(gX~O![-YO~O!e-QO#^-PO!Z#fX![#fX~O!Z-ZO![(vX~O![-]O~O!a-^O!b-^O(S!lO~P##hO![-aO~P'_Ol-dO!]'^O~O!W-iO~Oq!ya!`!ya!a!ya!b!ya#R!ya#S!ya#T!ya#U!ya#V!ya#Y!ya#Z!ya(S!ya(T!ya(W!ya(c!ya(m!ya~P!#eO!n-nO#^-lO~PCVO!a-pO!b-pO(S!lO~PCuOa%mO#^-lO'x%mO~Oa%mO!e#vO#^-lO'x%mO~Oa%mO!e#vO!n-nO#^-lO'x%mO(p'nO~O'}'vO(O'vO(P-uO~Ot-vO~O!W'Ua!Z'Ua~P!:TO!Y-zO!W'UX!Z'UX~P%[O!Z(TO!W(fa~O!W(fa~PGpO!Z([O!W(ta~O!Q%gO!Y.OO!]%hO(R%fO!W'[X!Z'[X~O#^.QO!Z(ra!i(raa(ra'x(ra~O!e#vO~P#,PO!Z(hO!i(qa~O!Q%gO!]%hO#h.UO(R%fO~On.ZO!Q%gO!Y.WO!]%hO!z]O#g.YO#h.WO(R%fO!Z'_X!i'_X~OR._O!j#xO~Oh%VOl.bO!]'^O%h.aO~Oa#ai!Z#ai'x#ai'u#ai!W#ai!i#ait#ai!]#ai%h#ai!e#ai~P!:TOl=|O!O)|O'w)}O(w$}O(x%PO~O#i#]aa#]a#^#]a'x#]a!Z#]a!i#]a!]#]a!W#]a~P#.{O#i(^XP(^XR(^X[(^Xa(^Xp(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X'x(^X(_(^X(p(^X!i(^X!W(^X'u(^Xt(^X!](^X%h(^X!e(^X~P!6YO!Z.oO!i(iX~P!:TO!i.rO~O!W.tO~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kia#kip#ki!Z#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#l#ki~P#2kO#l$OO~P#2kOP$[OR#zOp$aO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO[#kia#ki!Z#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#p#ki~P#5YO#p$QO~P#5YOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO(_VOa#ki!Z#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#u#ki~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO(_VO(x#}Oa#ki!Z#ki#y#ki#z#ki'x#ki(p#ki(w#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#w$UO~P#:_O#w#ki~P#:_O#u$SO~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO(_VO(w#|O(x#}Oa#ki!Z#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#y#ki~P#=TO#y$WO~P#=TOP]XR]X[]Xp]X!O]X!Q]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X!Z]X![]X~O#}]X~P#?rOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO#y<XO#z<YO(_VO(p$YO(w#|O(x#}O~O#}.vO~P#BPO#Q$dO#^<`O$P<`O#}(eX![(eX~P! dOa'ba!Z'ba'x'ba'u'ba!i'ba!W'bat'ba!]'ba%h'ba!e'ba~P!:TO[#kia#kip#ki!Z#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO(w#ki(x#ki~P#EROl=|O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P#ERO!Z.zOg(nX~P!0uOg.|O~Oa$Oi!Z$Oi'x$Oi'u$Oi!W$Oi!i$Oit$Oi!]$Oi%h$Oi!e$Oi~P!:TO$[.}O$^.}O~O$[/OO$^/OO~O!e)fO#^/PO!]$bX$Y$bX$[$bX$^$bX$e$bX~O!Y/QO~O!])iO$Y/SO$[)hO$^)hO$e/TO~O!Z<ZO![(dX~P#BPO![/UO~O!e)fO$e(yX~O$e/WO~Ot/XO~P!&iOv)wO(`)xO(a/[O~O!Q/_O~O(w$}Ol%`a!O%`a'w%`a(x%`a!Z%`a#^%`a~Og%`a#}%`a~P#LTO(x%POl%ba!O%ba'w%ba(w%ba!Z%ba#^%ba~Og%ba#}%ba~P#LvO!ZfX!efX!ifX!i$yX(pfX~P!/qO!Y/hO!Z([O(R/gO!W(tP!W(}P~P!1dOp*pO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO~Oq<oO!Q/iO!Y+XO![*mO(c<nO![(vP~P#NaO!i/jO~P#.{O!Z/kO!e#vO(p'nO!i(|X~O!i/pO~O!Q%gO!Y*[O!]%hO(R%fO!i(|P~O#i/rO~O!W$yX!Z$yX!e%QX~P!/qO!Z/sO!W(}X~P#.{O!e/uO~O!W/wO~OnkO(R/xO~P.iOh%VOp/}O!e#vO!j%dO(p'nO~O!e+fO~Oa%mO!Z0RO'x%mO~O![0TO~P!5WO!a0UO!b0UO(S!lO~P##hOq!nO!Q0VO(TTO(WUO(c!mO~O#Y0XO~Og%`a!Z%`a#^%`a#}%`a~P!0uOg%ba!Z%ba#^%ba#}%ba~P!0uOj%cO(R&XOg'kX!Z'kX~O!Z*vOg([a~Og0bO~OR0cO!O0cO!Q0dO#Q$dOl{a'w{a(w{a(x{a!Z{a#^{a~Og{a#}{a~P$&dO!O)|O'w)}Ol$ra(w$ra(x$ra!Z$ra#^$ra~Og$ra#}$ra~P$'`O!O)|O'w)}Ol$ta(w$ta(x$ta!Z$ta#^$ta~Og$ta#}$ta~P$(RO#i0gO~Og%Sa!Z%Sa#^%Sa#}%Sa~P!0uOl0iO#^0hOg(]a!Z(]a~O!e#vO~O#i0lO~O!Z+ZOa)Ra'x)Ra~OR#zO!O#yO!Q#{O!j#xO(_VOP!pi[!pip!pi!Z!pi!n!pi#P!pi#l!pi#m!pi#n!pi#o!pi#p!pi#q!pi#r!pi#s!pi#t!pi#u!pi#w!pi#y!pi#z!pi(p!pi(w!pi(x!pi~Oa!pi'x!pi'u!pi!W!pi!i!pit!pi!]!pi%h!pi!e!pi~P$*OOh%VOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~On0vO%[0wO(R0tO~P$,fO!e+fOa(Za!](Za'x(Za!Z(Za~O#i0|O~O[]X!ZfX![fX~O!Z0}O![)VX~O![1PO~O[1QO~Ob1SO(R+nO(TTO(WUO~O!]&OO(R%fO`'sX!Z'sX~O!Z+sO`)Ua~O!i1VO~P!:TO[1YO~O`1ZO~O#^1^O~Ol1aO!]$|O~O(c(zO![)SP~Oh%VOl1jO!]1gO%h1iO~O[1tO!Z1rO![)TX~O![1uO~O`1wOa%mO'x%mO~O(R#nO(TTO(WUO~O#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O#t1zO&Y1{Oa(eX~P$2PO#^$eO#t1zO&Y1{O~Oa1}O~P%[Oa2PO~O&c2SOP&aiQ&aiS&aiY&aia&aid&aie&aij&ain&aip&aiq&air&aix&aiz&ai|&ai!Q&ai!U&ai!V&ai!]&ai!g&ai!j&ai!m&ai!n&ai!o&ai!q&ai!s&ai!v&ai!z&ai$V&ai$m&ai%g&ai%i&ai%k&ai%l&ai%m&ai%p&ai%r&ai%u&ai%v&ai%x&ai&U&ai&[&ai&^&ai&`&ai&b&ai&e&ai&k&ai&q&ai&s&ai&u&ai&w&ai&y&ai'u&ai(R&ai(T&ai(W&ai(_&ai(m&ai![&aib&ai&h&ai~Ob2YO![2WO&h2XO~P`O!]XO!j2[O~O&o,vOP&jiQ&jiS&jiY&jia&jid&jie&jij&jin&jip&jiq&jir&jix&jiz&ji|&ji!Q&ji!U&ji!V&ji!]&ji!g&ji!j&ji!m&ji!n&ji!o&ji!q&ji!s&ji!v&ji!z&ji$V&ji$m&ji%g&ji%i&ji%k&ji%l&ji%m&ji%p&ji%r&ji%u&ji%v&ji%x&ji&U&ji&[&ji&^&ji&`&ji&b&ji&e&ji&k&ji&q&ji&s&ji&u&ji&w&ji&y&ji'u&ji(R&ji(T&ji(W&ji(_&ji(m&ji![&ji&c&jib&ji&h&ji~O!W2bO~O!Z!_a![!_a~P#BPOq!nO!Q!oO!Y2hO(c!mO!Z'VX!['VX~P@]O!Z-WO![(ga~O!Z']X![']X~P!9]O!Z-ZO![(va~O![2oO~P'_Oa%mO#^2xO'x%mO~Oa%mO!e#vO#^2xO'x%mO~Oa%mO!e#vO!n2|O#^2xO'x%mO(p'nO~Oa%mO'x%mO~P!:TO!Z$_Ot$pa~O!W'Ui!Z'Ui~P!:TO!Z(TO!W(fi~O!Z([O!W(ti~O!W(ui!Z(ui~P!:TO!Z(ri!i(ria(ri'x(ri~P!:TO#^3OO!Z(ri!i(ria(ri'x(ri~O!Z(hO!i(qi~O!Q%gO!]%hO!z]O#g3TO#h3SO(R%fO~O!Q%gO!]%hO#h3SO(R%fO~Ol3[O!]'^O%h3ZO~Oh%VOl3[O!]'^O%h3ZO~O#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`at%`a!]%`a%h%`a!e%`a~P#LTO#i%baP%baR%ba[%baa%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%bat%ba!]%ba%h%ba!e%ba~P#LvO#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!Z%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`a#^%`at%`a!]%`a%h%`a!e%`a~P#.{O#i%baP%baR%ba[%baa%bap%ba!Q%ba!Z%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%ba#^%bat%ba!]%ba%h%ba!e%ba~P#.{O#i{aP{a[{aa{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a'x{a(_{a(p{a!i{a!W{a'u{at{a!]{a%h{a!e{a~P$&dO#i$raP$raR$ra[$raa$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra'x$ra(_$ra(p$ra!i$ra!W$ra'u$rat$ra!]$ra%h$ra!e$ra~P$'`O#i$taP$taR$ta[$taa$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta'x$ta(_$ta(p$ta!i$ta!W$ta'u$tat$ta!]$ta%h$ta!e$ta~P$(RO#i%SaP%SaR%Sa[%Saa%Sap%Sa!Q%Sa!Z%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa'x%Sa(_%Sa(p%Sa!i%Sa!W%Sa'u%Sa#^%Sat%Sa!]%Sa%h%Sa!e%Sa~P#.{Oa#aq!Z#aq'x#aq'u#aq!W#aq!i#aqt#aq!]#aq%h#aq!e#aq~P!:TO!Y3dO!Z'WX!i'WX~P%[O!Z.oO!i(ia~O!Z.oO!i(ia~P!:TO!W3gO~O#}!la![!la~PKZO#}!ha!Z!ha![!ha~P#BPO#}!pa![!pa~P!<kO#}!ra![!ra~P!?ROg'ZX!Z'ZX~P!+rO!Z.zOg(na~OSfO!]3{O$c3|O~O![4QO~Ot4RO~P#.{Oa$lq!Z$lq'x$lq'u$lq!W$lq!i$lqt$lq!]$lq%h$lq!e$lq~P!:TO!W4TO~P!&iO!Q4UO~O!O)|O'w)}O(x%POl'ga(w'ga!Z'ga#^'ga~Og'ga#}'ga~P%+uO!O)|O'w)}Ol'ia(w'ia(x'ia!Z'ia#^'ia~Og'ia#}'ia~P%,hO(p$YO~P#.{O!WfX!W$yX!ZfX!Z$yX!e%QX#^fX~P!/qO(R<xO~P!1dO!Q%gO!Y4XO!]%hO(R%fO!Z'cX!i'cX~O!Z/kO!i(|a~O!Z/kO!e#vO!i(|a~O!Z/kO!e#vO(p'nO!i(|a~Og${i!Z${i#^${i#}${i~P!0uO!Y4aO!W'eX!Z'eX~P!3cO!Z/sO!W(}a~O!Z/sO!W(}a~P#.{OP]XR]X[]Xp]X!O]X!Q]X!W]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!e%XX#t%XX~P%0XO!e#vO#t4fO~Oh%VO!e#vO!j%dO~Oh%VOp4kO!j%dO(p'nO~Op4pO!e#vO(p'nO~Oq!nO!Q4qO(TTO(WUO(c!mO~O(w$}Ol%`i!O%`i'w%`i(x%`i!Z%`i#^%`i~Og%`i#}%`i~P%3xO(x%POl%bi!O%bi'w%bi(w%bi!Z%bi#^%bi~Og%bi#}%bi~P%4kOg(]i!Z(]i~P!0uO#^4wOg(]i!Z(]i~P!0uO!i4zO~Oa$nq!Z$nq'x$nq'u$nq!W$nq!i$nqt$nq!]$nq%h$nq!e$nq~P!:TO!W5QO~O!Z5RO!])OX~P#.{Oa]Xa$yX!]]X!]$yX%]]X'x]X'x$yX!Z]X!Z$yX~P!/qO%]5UOa%Za!]%Za'x%Za!Z%Za~OlmX!OmX'wmX(wmX(xmX~P%7nOn5VO(R#nO~Ob5]O%i5^O(R+nO(TTO(WUO!Z'rX!['rX~O!Z0}O![)Va~O[5bO~O`5cO~Oa%mO'x%mO~P#.{O!Z5kO#^5mO![)SX~O![5nO~Op5tOq!nO!Q*fO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!pO#U!pO#V!pO#Y5sO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O![5rO~P%:ROl5yO!]1gO%h5xO~Oh%VOl5yO!]1gO%h5xO~Ob6QO(R#nO(TTO(WUO!Z'qX!['qX~O!Z1rO![)Ta~O(TTO(WUO(c6SO~O`6WO~O#t6ZO&Y6[O~PMvO!i6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO![6dO&h2XO~P`O!e6fO~O!e6hOh(hi!Z(hi![(hi!e(hi!j(hip(hi(p(hi~O!Z#fi![#fi~P#BPO#^6iO!Z#fi![#fi~O!Z!_i![!_i~P#BPOa%mO#^6rO'x%mO~Oa%mO!e#vO#^6rO'x%mO~O!Z(rq!i(rqa(rq'x(rq~P!:TO!Z(hO!i(qq~O!Q%gO!]%hO#h6yO(R%fO~O!]'^O%h6|O~Ol7QO!]'^O%h6|O~O#i'gaP'gaR'ga['gaa'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga'x'ga(_'ga(p'ga!i'ga!W'ga'u'gat'ga!]'ga%h'ga!e'ga~P%+uO#i'iaP'iaR'ia['iaa'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia'x'ia(_'ia(p'ia!i'ia!W'ia'u'iat'ia!]'ia%h'ia!e'ia~P%,hO#i${iP${iR${i[${ia${ip${i!Q${i!Z${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i'x${i(_${i(p${i!i${i!W${i'u${i#^${it${i!]${i%h${i!e${i~P#.{O#i%`iP%`iR%`i[%`ia%`ip%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i'x%`i(_%`i(p%`i!i%`i!W%`i'u%`it%`i!]%`i%h%`i!e%`i~P%3xO#i%biP%biR%bi[%bia%bip%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi'x%bi(_%bi(p%bi!i%bi!W%bi'u%bit%bi!]%bi%h%bi!e%bi~P%4kO!Z'Wa!i'Wa~P!:TO!Z.oO!i(ii~O#}#ai!Z#ai![#ai~P#BPOP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kip#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#l#ki~P%MQO#l<PO~P%MQOP$[OR#zOp<]O!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO[#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#p#ki~P& YO#p<RO~P& YOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO(_VO#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#u#ki~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO(_VO(x#}O#y#ki#z#ki#}#ki(p#ki(w#ki!Z#ki![#ki~O#w<VO~P&%cO#w#ki~P&%cO#u<TO~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO(_VO(w#|O(x#}O#z#ki#}#ki(p#ki!Z#ki![#ki~O#y#ki~P&'rO#y<XO~P&'rOa#{y!Z#{y'x#{y'u#{y!W#{y!i#{yt#{y!]#{y%h#{y!e#{y~P!:TO[#kip#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki!Z#ki![#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO(w#ki(x#ki~P&*nOl=}O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P&*nO#Q$dOP(^XR(^X[(^Xl(^Xp(^X!O(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X#}(^X'w(^X(_(^X(p(^X(w(^X(x(^X!Z(^X![(^X~O#}$Oi!Z$Oi![$Oi~P#BPO#}!pi![!pi~P$*OOg'Za!Z'Za~P!0uO![7dO~O!Z'ba!['ba~P#BPO!W7eO~P#.{O!e#vO(p'nO!Z'ca!i'ca~O!Z/kO!i(|i~O!Z/kO!e#vO!i(|i~Og${q!Z${q#^${q#}${q~P!0uO!W'ea!Z'ea~P#.{O!e7lO~O!Z/sO!W(}i~P#.{O!Z/sO!W(}i~O!W7oO~Oh%VOp7tO!j%dO(p'nO~O!e#vO#t7vO~Op7yO!e#vO(p'nO~O!O)|O'w)}O(x%POl'ha(w'ha!Z'ha#^'ha~Og'ha#}'ha~P&3oO!O)|O'w)}Ol'ja(w'ja(x'ja!Z'ja#^'ja~Og'ja#}'ja~P&4bO!W7{O~Og$}q!Z$}q#^$}q#}$}q~P!0uOg(]q!Z(]q~P!0uO#^7|Og(]q!Z(]q~P!0uOa$ny!Z$ny'x$ny'u$ny!W$ny!i$nyt$ny!]$ny%h$ny!e$ny~P!:TO!e6hO~O!Z5RO!])Oa~O!]'^OP$SaR$Sa[$Sap$Sa!O$Sa!Q$Sa!Z$Sa!j$Sa!n$Sa#P$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#t$Sa#u$Sa#w$Sa#y$Sa#z$Sa(_$Sa(p$Sa(w$Sa(x$Sa~O%h6|O~P&7SO%]8QOa%Zi!]%Zi'x%Zi!Z%Zi~Oa#ay!Z#ay'x#ay'u#ay!W#ay!i#ayt#ay!]#ay%h#ay!e#ay~P!:TO[8SO~Ob8UO(R+nO(TTO(WUO~O!Z0}O![)Vi~O`8YO~O(c(zO!Z'nX!['nX~O!Z5kO![)Sa~O![8cO~P%:RO(m!sO~P$$oO#Y8dO~O!]1gO~O!]1gO%h8fO~Ol8iO!]1gO%h8fO~O[8nO!Z'qa!['qa~O!Z1rO![)Ti~O!i8rO~O!i8sO~O!i8vO~O!i8vO~P%[Oa8xO~O!e8yO~O!i8zO~O!Z(ui![(ui~P#BPOa%mO#^9SO'x%mO~O!Z(ry!i(rya(ry'x(ry~P!:TO!Z(hO!i(qy~O%h9VO~P&7SO!]'^O%h9VO~O#i${qP${qR${q[${qa${qp${q!Q${q!Z${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q'x${q(_${q(p${q!i${q!W${q'u${q#^${qt${q!]${q%h${q!e${q~P#.{O#i'haP'haR'ha['haa'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha'x'ha(_'ha(p'ha!i'ha!W'ha'u'hat'ha!]'ha%h'ha!e'ha~P&3oO#i'jaP'jaR'ja['jaa'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja'x'ja(_'ja(p'ja!i'ja!W'ja'u'jat'ja!]'ja%h'ja!e'ja~P&4bO#i$}qP$}qR$}q[$}qa$}qp$}q!Q$}q!Z$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q'x$}q(_$}q(p$}q!i$}q!W$}q'u$}q#^$}qt$}q!]$}q%h$}q!e$}q~P#.{O!Z'Wi!i'Wi~P!:TO#}#aq!Z#aq![#aq~P#BPO(w$}OP%`aR%`a[%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a#}%`a(_%`a(p%`a!Z%`a![%`a~Ol%`a!O%`a'w%`a(x%`a~P&HgO(x%POP%baR%ba[%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba#}%ba(_%ba(p%ba!Z%ba![%ba~Ol%ba!O%ba'w%ba(w%ba~P&JnOl=}O!O)|O'w)}O(x%PO~P&HgOl=}O!O)|O'w)}O(w$}O~P&JnOR0cO!O0cO!Q0dO#Q$dOP{a[{al{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a#}{a'w{a(_{a(p{a(w{a(x{a!Z{a![{a~O!O)|O'w)}OP$raR$ra[$ral$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra#}$ra(_$ra(p$ra(w$ra(x$ra!Z$ra![$ra~O!O)|O'w)}OP$taR$ta[$tal$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta#}$ta(_$ta(p$ta(w$ta(x$ta!Z$ta![$ta~Ol=}O!O)|O'w)}O(w$}O(x%PO~OP%SaR%Sa[%Sap%Sa!Q%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa#}%Sa(_%Sa(p%Sa!Z%Sa![%Sa~P'%sO#}$lq!Z$lq![$lq~P#BPO#}$nq!Z$nq![$nq~P#BPO![9dO~O#}9eO~P!0uO!e#vO!Z'ci!i'ci~O!e#vO(p'nO!Z'ci!i'ci~O!Z/kO!i(|q~O!W'ei!Z'ei~P#.{O!Z/sO!W(}q~Op9lO!e#vO(p'nO~O[9nO!W9mO~P#.{O!W9mO~O!e#vO#t9tO~Og(]y!Z(]y~P!0uO!Z'la!]'la~P#.{Oa%Zq!]%Zq'x%Zq!Z%Zq~P#.{O[9yO~O!Z0}O![)Vq~O#^9}O!Z'na!['na~O!Z5kO![)Si~P#BPO!Q:PO~O!]1gO%h:SO~O(TTO(WUO(c:XO~O!Z1rO![)Tq~O!i:[O~O!i:]O~O!i:^O~O!i:^O~P%[O#^:aO!Z#fy![#fy~O!Z#fy![#fy~P#BPO%h:fO~P&7SO!]'^O%h:fO~O#}#{y!Z#{y![#{y~P#BPOP${iR${i[${ip${i!Q${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i#}${i(_${i(p${i!Z${i![${i~P'%sO!O)|O'w)}O(x%POP'gaR'ga['gal'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga#}'ga(_'ga(p'ga(w'ga!Z'ga!['ga~O!O)|O'w)}OP'iaR'ia['ial'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia#}'ia(_'ia(p'ia(w'ia(x'ia!Z'ia!['ia~O(w$}OP%`iR%`i[%`il%`ip%`i!O%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i#}%`i'w%`i(_%`i(p%`i(x%`i!Z%`i![%`i~O(x%POP%biR%bi[%bil%bip%bi!O%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi#}%bi'w%bi(_%bi(p%bi(w%bi!Z%bi![%bi~O#}$ny!Z$ny![$ny~P#BPO#}#ay!Z#ay![#ay~P#BPO!e#vO!Z'cq!i'cq~O!Z/kO!i(|y~O!W'eq!Z'eq~P#.{Op:pO!e#vO(p'nO~O[:tO!W:sO~P#.{O!W:sO~Og(]!R!Z(]!R~P!0uOa%Zy!]%Zy'x%Zy!Z%Zy~P#.{O!Z0}O![)Vy~O!Z5kO![)Sq~O(R:zO~O!]1gO%h:}O~O!i;QO~O%h;VO~P&7SOP${qR${q[${qp${q!Q${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q#}${q(_${q(p${q!Z${q![${q~P'%sO!O)|O'w)}O(x%POP'haR'ha['hal'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha#}'ha(_'ha(p'ha(w'ha!Z'ha!['ha~O!O)|O'w)}OP'jaR'ja['jal'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja#}'ja(_'ja(p'ja(w'ja(x'ja!Z'ja!['ja~OP$}qR$}q[$}qp$}q!Q$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q#}$}q(_$}q(p$}q!Z$}q![$}q~P'%sOg%d!Z!Z%d!Z#^%d!Z#}%d!Z~P!0uO!W;ZO~P#.{Op;[O!e#vO(p'nO~O[;^O!W;ZO~P#.{O!Z'nq!['nq~P#BPO!Z#f!Z![#f!Z~P#BPO#i%d!ZP%d!ZR%d!Z[%d!Za%d!Zp%d!Z!Q%d!Z!Z%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z'x%d!Z(_%d!Z(p%d!Z!i%d!Z!W%d!Z'u%d!Z#^%d!Zt%d!Z!]%d!Z%h%d!Z!e%d!Z~P#.{Op;fO!e#vO(p'nO~O!W;gO~P#.{Op;nO!e#vO(p'nO~O!W;oO~P#.{OP%d!ZR%d!Z[%d!Zp%d!Z!Q%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z#}%d!Z(_%d!Z(p%d!Z!Z%d!Z![%d!Z~P'%sOp;rO!e#vO(p'nO~Ot(dX~P1qO!O%qO~P!(yO(S!lO~P!(yO!WfX!ZfX#^fX~P%0XOP]XR]X[]Xp]X!O]X!Q]X!Z]X!ZfX!j]X!n]X#P]X#Q]X#^]X#^fX#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!efX!i]X!ifX(pfX~P'JlOP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]XO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z<ZO![$pa~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<fO!Q${O!]$|O!g=wO!j$xO#h<lO$V%_O$s<hO$u<jO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Oj)bO~P( bOp!cX(p!cX~P# qOp(hX(p(hX~P#!dO![]X![fX~P'JlO!WfX!W$yX!ZfX!Z$yX#^fX~P!/qO#i<OO~O!e#vO#i<OO~O#^<`O~O#t<SO~O#^<pO!Z(uX![(uX~O#^<`O!Z(sX![(sX~O#i<qO~Og<sO~P!0uO#i<yO~O#i<zO~O!e#vO#i<{O~O!e#vO#i<qO~O#}<|O~P#BPO#i<}O~O#i=OO~O#i=TO~O#i=UO~O#i=VO~O#i=WO~O#}=XO~P!0uO#}=YO~P!0uO#Q#R#S#U#V#Y#g#h#s$m$s$u$x%[%]%g%h%i%p%r%u%v%x%z~'|T#m!V'z(S#nq#l#op!O'{$['{(R$^(c~",
  goto: "$8f)ZPPPPPP)[PP)_P)pP+Q/VPPPP6aPP6wPP<oP@cP@yP@yPPP@yPCRP@yP@yP@yPCVPC[PCyPHsPPPHwPPPPHwKzPPPLQLrPHwPHwPP! QHwPPPHwPHwP!#XHwP!&o!'t!'}P!(q!(u!(q!,SPPPPPPP!,s!'tPP!-T!.uP!2RHwHw!2W!5d!:Q!:Q!>PPPP!>XHwPPPPPPPPPP!AhP!BuPPHw!DWPHwPHwHwHwHwHwPHw!EjP!HtP!KzP!LO!LY!L^!L^P!HqP!Lb!LbP# hP# lHwPHw# r#$wCV@yP@yP@y@yP#&U@y@y#(h@y#+`@y#-l@y@y#.[#0p#0p#0u#1O#0p#1ZPP#0pP@y#1s@y#5r@y@y6aPPP#9wPPP#:b#:bP#:bP#:x#:bPP#;OP#:uP#:u#;c#:u#;}#<T#<W)_#<Z)_P#<b#<b#<bP)_P)_P)_P)_PP)_P#<h#<kP#<k)_P#<oP#<rP)_P)_P)_P)_P)_P)_)_PP#<x#=O#=Z#=a#=g#=m#=s#>R#>X#>c#>i#>s#>y#?Z#?a#@R#@e#@k#@q#AP#Af#CZ#Ci#Cp#E[#Ej#G[#Gj#Gp#Gv#G|#HW#H^#Hd#Hn#IQ#IWPPPPPPPPPPP#I^PPPPPPP#JR#MY#Nr#Ny$ RPPP$&mP$&v$)o$0Y$0]$0`$1_$1b$1i$1qP$1w$1zP$2h$2l$3d$4r$4w$5_PP$5d$5j$5n$5q$5u$5y$6u$7^$7u$7y$7|$8P$8V$8Y$8^$8bR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0u+fQ1S+rQ1y,fQ3W.bQ5V0wQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 378,
  context: sZ,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 35, 37, 49, 51, 53, ""],
    ["group", -26, 9, 17, 19, 66, 206, 210, 214, 215, 217, 220, 223, 233, 235, 241, 243, 245, 247, 250, 256, 262, 264, 266, 268, 270, 272, 273, "Statement", -34, 13, 14, 30, 33, 34, 40, 49, 52, 53, 55, 60, 68, 70, 74, 78, 80, 82, 83, 108, 109, 118, 119, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 168, 170, "Expression", -23, 29, 31, 35, 39, 41, 43, 172, 174, 176, 177, 179, 180, 181, 183, 184, 185, 187, 188, 189, 200, 202, 204, 205, "Type", -3, 86, 101, 107, "ClassItem"],
    ["openedBy", 23, "<", 36, "InterpolationStart", 54, "[", 58, "{", 71, "(", 159, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 167, ">", 38, "InterpolationEnd", 48, "]", 59, "}", 72, ")", 164, "JSXEndTag"]
  ],
  propSources: [hZ],
  skippedNodes: [0, 5, 6, 276],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Up(X!b'z0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(V#S$h&j'{0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Up(X!b'{0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!n),Q(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(T':f$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(X!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Up(X!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Up(X!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(X!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(X!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(UpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(UpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Up(X!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(m%1l(Up(X!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Up(X!b$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Up(X!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Up(X!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(x+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(W';W$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(UpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!j/.^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!i!Lf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Up(X!b(S%&f#o(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Up(X!b#l(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Up(X!bp+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Z+Jf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Up(X!b!O.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!Y!L^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Up(X!b#m(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(X!b!V7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!V7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!V7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!V7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!V7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(X!b!V7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(X!b!V7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(X!b!V7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(X!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(X!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Up!V7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Up!V7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Up!V7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Up!V7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(UpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(UpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Up(X!b!V7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Up(X!b!V7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Up(X!b!V7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Up(X!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Up(X!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Up(X!b'|0/l!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Up(X!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(X!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(X!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(UpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(UpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Up(X!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!e$b$h&j#})Lv(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#P-<U(Up(X!b$m7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#p(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#q(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#^*!Y$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#i(Cl$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#q(Ch$e#|$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#q(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(p(Ct$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!z$Ip$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!Q0,v$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!W#)l$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Up(X!b(_+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Up(X!b(R,2j$^#t(c$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Up(X!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!]#Hb(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(w+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_![(CdtBr$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!o7`$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Up(X!b'z0/l$[#t(R,2j(c$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Up(X!b'{0/l$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [uZ, cZ, dZ, fZ, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, oZ, new T0("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOv~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!S~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(a~~", 141, 338), new T0("j~RQYZXz{^~^O(O~~aP!P!Qd~iO(P~~", 25, 321)],
  topRules: { Script: [0, 7], SingleExpression: [1, 274], SingleClassItem: [2, 275] },
  dialects: { jsx: 0, ts: 15091 },
  dynamicPrecedences: { 78: 1, 80: 1, 92: 1, 168: 1, 198: 1 },
  specialized: [{ term: 325, get: (e) => mZ[e] || -1 }, { term: 341, get: (e) => vZ[e] || -1 }, { term: 93, get: (e) => gZ[e] || -1 }],
  tokenPrec: 15116
}), BO = [
  /* @__PURE__ */ oa("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ oa("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ oa("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ oa("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ oa("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ oa(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ oa("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ oa(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ oa(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ oa('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ oa('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], yZ = /* @__PURE__ */ BO.concat([
  /* @__PURE__ */ oa("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ oa("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ oa("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), _9 = /* @__PURE__ */ new DA(), ZO = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function ho(e) {
  return (t, n) => {
    let a = t.node.getChild("VariableDefinition");
    return a && n(a, e), !0;
  };
}
const OZ = ["FunctionDeclaration"], bZ = {
  FunctionDeclaration: /* @__PURE__ */ ho("function"),
  ClassDeclaration: /* @__PURE__ */ ho("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ ho("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ ho("type"),
  NamespaceDeclaration: /* @__PURE__ */ ho("namespace"),
  VariableDefinition(e, t) {
    e.matchContext(OZ) || t(e, "variable");
  },
  TypeDefinition(e, t) {
    t(e, "type");
  },
  __proto__: null
};
function EO(e, t) {
  let n = _9.get(t);
  if (n)
    return n;
  let a = [], i = !0;
  function l(r, s) {
    let o = e.sliceString(r.from, r.to);
    a.push({ label: o, type: s });
  }
  return t.cursor(Vn.IncludeAnonymous).iterate((r) => {
    if (i)
      i = !1;
    else if (r.name) {
      let s = bZ[r.name];
      if (s && s(r, l) || ZO.has(r.name))
        return !1;
    } else if (r.to - r.from > 8192) {
      for (let s of EO(e, r.node))
        a.push(s);
      return !1;
    }
  }), _9.set(t, a), a;
}
const M9 = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, NO = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function CZ(e) {
  let t = Tn(e.state).resolveInner(e.pos, -1);
  if (NO.indexOf(t.name) > -1)
    return null;
  let n = t.name == "VariableName" || t.to - t.from < 20 && M9.test(e.state.sliceDoc(t.from, t.to));
  if (!n && !e.explicit)
    return null;
  let a = [];
  for (let i = t; i; i = i.parent)
    ZO.has(i.name) && (a = a.concat(EO(e.state.doc, i)));
  return {
    options: a,
    from: n ? t.from : e.pos,
    validFor: M9
  };
}
const hr = /* @__PURE__ */ nu.define({
  name: "javascript",
  parser: /* @__PURE__ */ pZ.configure({
    props: [
      /* @__PURE__ */ Pm.add({
        IfStatement: /* @__PURE__ */ Of({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Of({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: eD,
        SwitchBody: (e) => {
          let t = e.textAfter, n = /^\s*\}/.test(t), a = /^\s*(case|default)\b/.test(t);
          return e.baseIndent + (n ? 0 : a ? 1 : 2) * e.unit;
        },
        Block: /* @__PURE__ */ y0({ closing: "}" }),
        ArrowFunction: (e) => e.baseIndent + e.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Of({ except: /^{/ }),
        JSXElement(e) {
          let t = /^\s*<\//.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        JSXEscape(e) {
          let t = /\s*\}/.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(e) {
          return e.column(e.node.from) + e.unit;
        }
      }),
      /* @__PURE__ */ _m.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": uy,
        BlockComment(e) {
          return { from: e.from + 2, to: e.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), HO = {
  test: (e) => /^JSX/.test(e.name),
  facet: /* @__PURE__ */ iy({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, wZ = /* @__PURE__ */ hr.configure({ dialect: "ts" }, "typescript"), kZ = /* @__PURE__ */ hr.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Sm.add((e) => e.isTop ? [HO] : void 0)]
}), SZ = /* @__PURE__ */ hr.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Sm.add((e) => e.isTop ? [HO] : void 0)]
}, "typescript");
let jO = (e) => ({ label: e, type: "keyword" });
const zO = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(jO), xZ = /* @__PURE__ */ zO.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(jO));
function V9(e = {}) {
  let t = e.jsx ? e.typescript ? SZ : kZ : e.typescript ? wZ : hr, n = e.typescript ? yZ.concat(xZ) : BO.concat(zO);
  return new ry(t, [
    hr.data.of({
      autocomplete: QI(NO, SO(n))
    }),
    hr.data.of({
      autocomplete: CZ
    }),
    e.jsx ? _Z : []
  ]);
}
function PZ(e) {
  for (; ; ) {
    if (e.name == "JSXOpenTag" || e.name == "JSXSelfClosingTag" || e.name == "JSXFragmentTag")
      return e;
    if (e.name == "JSXEscape" || !e.parent)
      return null;
    e = e.parent;
  }
}
function T9(e, t, n = e.length) {
  for (let a = t == null ? void 0 : t.firstChild; a; a = a.nextSibling)
    if (a.name == "JSXIdentifier" || a.name == "JSXBuiltin" || a.name == "JSXNamespacedName" || a.name == "JSXMemberExpression")
      return e.sliceString(a.from, Math.min(a.to, n));
  return "";
}
const $Z = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), _Z = /* @__PURE__ */ Re.inputHandler.of((e, t, n, a, i) => {
  if (($Z ? e.composing : e.compositionStarted) || e.state.readOnly || t != n || a != ">" && a != "/" || !hr.isActiveAt(e.state, t, -1))
    return !1;
  let l = i(), { state: r } = l, s = r.changeByRange((o) => {
    var u;
    let { head: c } = o, d = Tn(r).resolveInner(c - 1, -1), f;
    if (d.name == "JSXStartTag" && (d = d.parent), !(r.doc.sliceString(c - 1, c) != a || d.name == "JSXAttributeValue" && d.to > c)) {
      if (a == ">" && d.name == "JSXFragmentTag")
        return { range: o, changes: { from: c, insert: "</>" } };
      if (a == "/" && d.name == "JSXStartCloseTag") {
        let h = d.parent, m = h.parent;
        if (m && h.from == c - 2 && ((f = T9(r.doc, m.firstChild, c)) || ((u = m.firstChild) === null || u === void 0 ? void 0 : u.name) == "JSXFragmentTag")) {
          let g = `${f}>`;
          return { range: we.cursor(c + g.length, -1), changes: { from: c, insert: g } };
        }
      } else if (a == ">") {
        let h = PZ(d);
        if (h && h.name == "JSXOpenTag" && !/^\/?>|^<\//.test(r.doc.sliceString(c, c + 2)) && (f = T9(r.doc, h, c)))
          return { range: o, changes: { from: c, insert: `</${f}>` } };
      }
    }
    return { range: o };
  });
  return s.changes.empty ? !1 : (e.dispatch([
    l,
    r.update(s, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), MZ = "#e5c07b", L9 = "#e06c75", VZ = "#56b6c2", TZ = "#ffffff", Ic = "#abb2bf", A0 = "#7d8799", LZ = "#61afef", QZ = "#98c379", Q9 = "#d19a66", AZ = "#c678dd", DZ = "#21252b", A9 = "#2c313a", D9 = "#282c34", Tf = "#353a42", RZ = "#3E4451", R9 = "#528bff", IZ = /* @__PURE__ */ Re.theme({
  "&": {
    color: Ic,
    backgroundColor: D9
  },
  ".cm-content": {
    caretColor: R9
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: R9 },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: RZ },
  ".cm-panels": { backgroundColor: DZ, color: Ic },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: D9,
    color: A0,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: A9
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Tf
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Tf,
    borderBottomColor: Tf
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: A9,
      color: Ic
    }
  }
}, { dark: !0 }), BZ = /* @__PURE__ */ Au.define([
  {
    tag: ae.keyword,
    color: AZ
  },
  {
    tag: [ae.name, ae.deleted, ae.character, ae.propertyName, ae.macroName],
    color: L9
  },
  {
    tag: [/* @__PURE__ */ ae.function(ae.variableName), ae.labelName],
    color: LZ
  },
  {
    tag: [ae.color, /* @__PURE__ */ ae.constant(ae.name), /* @__PURE__ */ ae.standard(ae.name)],
    color: Q9
  },
  {
    tag: [/* @__PURE__ */ ae.definition(ae.name), ae.separator],
    color: Ic
  },
  {
    tag: [ae.typeName, ae.className, ae.number, ae.changed, ae.annotation, ae.modifier, ae.self, ae.namespace],
    color: MZ
  },
  {
    tag: [ae.operator, ae.operatorKeyword, ae.url, ae.escape, ae.regexp, ae.link, /* @__PURE__ */ ae.special(ae.string)],
    color: VZ
  },
  {
    tag: [ae.meta, ae.comment],
    color: A0
  },
  {
    tag: ae.strong,
    fontWeight: "bold"
  },
  {
    tag: ae.emphasis,
    fontStyle: "italic"
  },
  {
    tag: ae.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: ae.link,
    color: A0,
    textDecoration: "underline"
  },
  {
    tag: ae.heading,
    fontWeight: "bold",
    color: L9
  },
  {
    tag: [ae.atom, ae.bool, /* @__PURE__ */ ae.special(ae.variableName)],
    color: Q9
  },
  {
    tag: [ae.processingInstruction, ae.string, ae.inserted],
    color: QZ
  },
  {
    tag: ae.invalid,
    color: TZ
  }
]), ZZ = [IZ, /* @__PURE__ */ Mm(BZ)], ns = 63, I9 = 64, EZ = 1, NZ = 2, FO = 3, HZ = 4, XO = 5, jZ = 6, zZ = 7, YO = 65, FZ = 66, XZ = 8, YZ = 9, WZ = 10, qZ = 11, UZ = 12, WO = 13, GZ = 19, KZ = 20, JZ = 29, eE = 33, tE = 34, nE = 47, aE = 0, Xm = 1, D0 = 2, cu = 3, R0 = 4;
class Jl {
  constructor(t, n, a) {
    this.parent = t, this.depth = n, this.type = a, this.hash = (t ? t.hash + t.hash << 8 : 0) + n + (n << 4) + a;
  }
}
Jl.top = new Jl(null, -1, aE);
function _o(e, t) {
  for (let n = 0, a = t - e.pos - 1; ; a--, n++) {
    let i = e.peek(a);
    if (Ji(i) || i == -1) return n;
  }
}
function I0(e) {
  return e == 32 || e == 9;
}
function Ji(e) {
  return e == 10 || e == 13;
}
function qO(e) {
  return I0(e) || Ji(e);
}
function ir(e) {
  return e < 0 || qO(e);
}
const iE = new RO({
  start: Jl.top,
  reduce(e, t) {
    return e.type == cu && (t == KZ || t == tE) ? e.parent : e;
  },
  shift(e, t, n, a) {
    if (t == FO)
      return new Jl(e, _o(a, a.pos), Xm);
    if (t == YO || t == XO)
      return new Jl(e, _o(a, a.pos), D0);
    if (t == ns)
      return e.parent;
    if (t == GZ || t == eE)
      return new Jl(e, 0, cu);
    if (t == WO && e.type == R0)
      return e.parent;
    if (t == nE) {
      let i = /[1-9]/.exec(a.read(a.pos, n.pos));
      if (i) return new Jl(e, e.depth + +i[0], R0);
    }
    return e;
  },
  hash(e) {
    return e.hash;
  }
});
function Ls(e, t, n = 0) {
  return e.peek(n) == t && e.peek(n + 1) == t && e.peek(n + 2) == t && ir(e.peek(n + 3));
}
const lE = new sl((e, t) => {
  if (e.next == -1 && t.canShift(I9))
    return e.acceptToken(I9);
  let n = e.peek(-1);
  if ((Ji(n) || n < 0) && t.context.type != cu) {
    if (Ls(
      e,
      45
      /* '-' */
    ))
      if (t.canShift(ns)) e.acceptToken(ns);
      else return e.acceptToken(EZ, 3);
    if (Ls(
      e,
      46
      /* '.' */
    ))
      if (t.canShift(ns)) e.acceptToken(ns);
      else return e.acceptToken(NZ, 3);
    let a = 0;
    for (; e.next == 32; )
      a++, e.advance();
    (a < t.context.depth || a == t.context.depth && t.context.type == Xm && (e.next != 45 || !ir(e.peek(1)))) && // Not blank
    e.next != -1 && !Ji(e.next) && e.next != 35 && e.acceptToken(ns, -a);
  }
}, { contextual: !0 }), rE = new sl((e, t) => {
  if (t.context.type == cu) {
    e.next == 63 && (e.advance(), ir(e.next) && e.acceptToken(zZ));
    return;
  }
  if (e.next == 45)
    e.advance(), ir(e.next) && e.acceptToken(t.context.type == Xm && t.context.depth == _o(e, e.pos - 1) ? HZ : FO);
  else if (e.next == 63)
    e.advance(), ir(e.next) && e.acceptToken(t.context.type == D0 && t.context.depth == _o(e, e.pos - 1) ? jZ : XO);
  else {
    let n = e.pos;
    for (; ; )
      if (I0(e.next)) {
        if (e.pos == n) return;
        e.advance();
      } else if (e.next == 33)
        UO(e);
      else if (e.next == 38)
        B0(e);
      else if (e.next == 42) {
        B0(e);
        break;
      } else if (e.next == 39 || e.next == 34) {
        if (Ym(e, !0)) break;
        return;
      } else if (e.next == 91 || e.next == 123) {
        if (!oE(e)) return;
        break;
      } else {
        GO(e, !0, !1, 0);
        break;
      }
    for (; I0(e.next); ) e.advance();
    if (e.next == 58) {
      if (e.pos == n && t.canShift(JZ)) return;
      let a = e.peek(1);
      ir(a) && e.acceptTokenTo(t.context.type == D0 && t.context.depth == _o(e, n) ? FZ : YO, n);
    }
  }
}, { contextual: !0 });
function sE(e) {
  return e > 32 && e < 127 && e != 34 && e != 37 && e != 44 && e != 60 && e != 62 && e != 92 && e != 94 && e != 96 && e != 123 && e != 124 && e != 125;
}
function B9(e) {
  return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70;
}
function Z9(e, t) {
  return e.next == 37 ? (e.advance(), B9(e.next) && e.advance(), B9(e.next) && e.advance(), !0) : sE(e.next) || t && e.next == 44 ? (e.advance(), !0) : !1;
}
function UO(e) {
  if (e.advance(), e.next == 60) {
    for (e.advance(); ; )
      if (!Z9(e, !0)) {
        e.next == 62 && e.advance();
        break;
      }
  } else
    for (; Z9(e, !1); )
      ;
}
function B0(e) {
  for (e.advance(); !ir(e.next) && Sd(e.tag) != "f"; ) e.advance();
}
function Ym(e, t) {
  let n = e.next, a = !1, i = e.pos;
  for (e.advance(); ; ) {
    let l = e.next;
    if (l < 0) break;
    if (e.advance(), l == n)
      if (l == 39)
        if (e.next == 39) e.advance();
        else break;
      else
        break;
    else if (l == 92 && n == 34)
      e.next >= 0 && e.advance();
    else if (Ji(l)) {
      if (t) return !1;
      a = !0;
    } else if (t && e.pos >= i + 1024)
      return !1;
  }
  return !a;
}
function oE(e) {
  for (let t = [], n = e.pos + 1024; ; )
    if (e.next == 91 || e.next == 123)
      t.push(e.next), e.advance();
    else if (e.next == 39 || e.next == 34) {
      if (!Ym(e, !0)) return !1;
    } else if (e.next == 93 || e.next == 125) {
      if (t[t.length - 1] != e.next - 2) return !1;
      if (t.pop(), e.advance(), !t.length) return !0;
    } else {
      if (e.next < 0 || e.pos > n || Ji(e.next))
        return !1;
      e.advance();
    }
}
const uE = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
function Sd(e) {
  return e < 33 ? "u" : e > 125 ? "s" : uE[e - 33];
}
function Lf(e, t) {
  let n = Sd(e);
  return n != "u" && !(t && n == "f");
}
function GO(e, t, n, a) {
  if (Sd(e.next) == "s" || (e.next == 63 || e.next == 58 || e.next == 45) && Lf(e.peek(1), n))
    e.advance();
  else
    return !1;
  let i = e.pos;
  for (; ; ) {
    let l = e.next, r = 0, s = a + 1;
    for (; qO(l); ) {
      if (Ji(l)) {
        if (t) return !1;
        s = 0;
      } else
        s++;
      l = e.peek(++r);
    }
    if (!(l >= 0 && (l == 58 ? Lf(e.peek(r + 1), n) : l == 35 ? e.peek(r - 1) != 32 : Lf(l, n))) || !n && s <= a || s == 0 && !n && (Ls(e, 45, r) || Ls(e, 46, r)))
      break;
    if (t && Sd(l) == "f") return !1;
    for (let u = r; u >= 0; u--) e.advance();
    if (t && e.pos > i + 1024) return !1;
  }
  return !0;
}
const cE = new sl((e, t) => {
  if (e.next == 33)
    UO(e), e.acceptToken(UZ);
  else if (e.next == 38 || e.next == 42) {
    let n = e.next == 38 ? WZ : qZ;
    B0(e), e.acceptToken(n);
  } else e.next == 39 || e.next == 34 ? (Ym(e, !1), e.acceptToken(YZ)) : GO(e, !1, t.context.type == cu, t.context.depth) && e.acceptToken(XZ);
}), dE = new sl((e, t) => {
  let n = t.context.type == R0 ? t.context.depth : -1, a = e.pos;
  e: for (; ; ) {
    let i = 0, l = e.next;
    for (; l == 32; ) l = e.peek(++i);
    if (!i && (Ls(e, 45, i) || Ls(e, 46, i)) || !Ji(l) && (n < 0 && (n = Math.max(t.context.depth + 1, i)), i < n))
      break;
    for (; ; ) {
      if (e.next < 0) break e;
      let r = Ji(e.next);
      if (e.advance(), r) continue e;
      a = e.pos;
    }
  }
  e.acceptTokenTo(WO, a);
}), fE = km({
  DirectiveName: ae.keyword,
  DirectiveContent: ae.attributeValue,
  "DirectiveEnd DocEnd": ae.meta,
  QuotedLiteral: ae.string,
  BlockLiteralHeader: ae.special(ae.string),
  BlockLiteralContent: ae.content,
  Literal: ae.content,
  "Key/Literal Key/QuotedLiteral": ae.definition(ae.propertyName),
  "Anchor Alias": ae.labelName,
  Tag: ae.typeName,
  Comment: ae.lineComment,
  ": , -": ae.separator,
  "?": ae.punctuation,
  "[ ]": ae.squareBracket,
  "{ }": ae.brace
}), hE = uu.deserialize({
  version: 14,
  states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
  stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
  goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
  nodeNames: "⚠ DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 74,
  context: iE,
  nodeProps: [
    ["isolate", -3, 8, 9, 14, ""],
    ["openedBy", 18, "[", 32, "{"],
    ["closedBy", 19, "]", 33, "}"]
  ],
  propSources: [fE],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [lE, rE, cE, dE, 0, 1],
  topRules: { Stream: [0, 15] },
  tokenPrec: 0
}), mE = /* @__PURE__ */ nu.define({
  name: "yaml",
  parser: /* @__PURE__ */ hE.configure({
    props: [
      /* @__PURE__ */ Pm.add({
        Stream: (e) => {
          for (let t = e.node.resolve(e.pos, -1); t && t.to >= e.pos; t = t.parent) {
            if (t.name == "BlockLiteralContent" && t.from < t.to)
              return e.baseIndentFor(t);
            if (t.name == "BlockLiteral")
              return e.baseIndentFor(t) + e.unit;
            if (t.name == "BlockSequence" || t.name == "BlockMapping")
              return e.column(t.from, 1);
            if (t.name == "QuotedLiteral")
              return null;
            if (t.name == "Literal") {
              let n = e.column(t.from, 1);
              if (n == e.lineIndent(t.from, 1))
                return n;
              if (t.to > e.pos)
                return null;
            }
          }
          return null;
        },
        FlowMapping: /* @__PURE__ */ y0({ closing: "}" }),
        FlowSequence: /* @__PURE__ */ y0({ closing: "]" })
      }),
      /* @__PURE__ */ _m.add({
        "FlowMapping FlowSequence": uy,
        "Item Pair BlockLiteral": (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to })
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*[\]\}]$/
  }
});
function vE() {
  return new ry(mE);
}
const gE = { class: "editor-wrapper" }, pE = {
  __name: "SScriptEditor",
  props: /* @__PURE__ */ Nc({
    height: {
      type: [String, Number],
      default: 0
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    lang: {
      type: String,
      default: null
    }
  }, {
    modelValue: {
      type: String,
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = l2(e, "modelValue"), n = e, a = k(() => {
      const r = n.readonly ? [M0, V9(), Tl.of(md)] : [M0, V9(), ZZ, Tl.of(md)];
      return n.lang === "yaml" && r.push(vE()), r;
    }), i = Y(null), l = k(() => {
      const r = n.height ? { height: `${n.height}px` } : {}, s = n.readonly ? { backgroundColor: "transparent" } : { backgroundColor: "#282c34" };
      return { ...r, ...s };
    });
    return (r, s) => (N(), ee("div", gE, [
      p(X(TB), {
        ref_key: "editor",
        ref: i,
        modelValue: t.value,
        "onUpdate:modelValue": s[0] || (s[0] = (o) => t.value = o),
        class: "script-editor",
        autofocus: !0,
        "indent-with-tab": !0,
        "tab-size": 2,
        extensions: a.value,
        readonly: e.readonly,
        style: Ot(l.value)
      }, null, 8, ["modelValue", "extensions", "readonly", "style"])
    ]));
  }
}, yE = {}, OE = { class: "s-table__form" };
function bE(e, t) {
  return N(), ee("div", OE, [
    ke(e.$slots, "default")
  ]);
}
const CE = /* @__PURE__ */ Ut(yE, [["render", bE]]), wE = {
  key: 0,
  class: "s-form__item-label"
}, kE = {
  key: 0,
  class: "required"
}, SE = {
  key: 0,
  class: "s-form__item-append"
}, xE = {
  __name: "SFormItem",
  props: {
    className: {
      type: String,
      default: "",
      description: "페이지타이틀"
    },
    contentClass: {
      type: String,
      default: "",
      description: "콘텐트 영역 클래스"
    },
    contentItemClass: {
      type: String,
      default: "",
      description: "콘텐트 아이템 영역 클래스"
    },
    singleLine: {
      type: Boolean,
      default: !0,
      description: "tooltip과 아이콘을 한 줄로 표시 (flex-wrap: nowrap)"
    },
    label: { type: String, required: !1, default: "", description: "폼라벨" },
    showLabel: { type: Boolean, required: !1, default: !0, description: "폼라벨 노출 여부" },
    name: { type: String, default: "", description: "validation 체크 시 필수 값" },
    required: { type: Boolean, default: !1, description: "필수값" }
  },
  setup(e) {
    const t = e, n = Y(null), a = Y(0), i = Y(null), l = k(() => {
      const u = t.singleLine ? 50 : 30;
      return Math.max(100, a.value - u);
    }), r = async () => {
      if (await et(), await new Promise((u) => setTimeout(u, 50)), n.value) {
        const u = n.value.offsetWidth;
        a.value = u;
      } else
        console.log("contentItemRef가 없음");
    }, s = (u) => G(lv, {
      title: u,
      text: u,
      titleWidth: l.value
    }), o = () => {
      r();
    };
    return rt(() => {
      r(), setTimeout(() => {
        r();
      }, 100), setTimeout(() => {
        r();
      }, 300), n.value && window.ResizeObserver && (i.value = new ResizeObserver((u) => {
        for (const c of u) {
          const d = c.contentRect.width;
          d > 0 && (a.value = d);
        }
      }), i.value.observe(n.value)), window.addEventListener("resize", o);
    }), mn(() => {
      window.removeEventListener("resize", o), i.value && (i.value.disconnect(), i.value = null);
    }), (u, c) => (N(), ee("div", {
      class: Ie(["s-form__item", e.className])
    }, [
      e.showLabel ? (N(), ee("div", wE, [
        ie("span", null, xe(e.label), 1),
        e.required ? (N(), ee("span", kE, "*")) : de("", !0)
      ])) : de("", !0),
      ie("div", {
        class: Ie(["s-form__item-content", [e.contentClass]])
      }, [
        ie("div", {
          ref_key: "contentItemRef",
          ref: n,
          class: Ie(["s-form__item-content-item", [e.contentItemClass, { "single-line": e.singleLine }]])
        }, [
          ke(u.$slots, "default", { tooltip: s }, void 0, !0)
        ], 2),
        u.$slots["outer-append"] ? (N(), ee("div", SE, [
          ke(u.$slots, "outer-append", {}, void 0, !0)
        ])) : de("", !0)
      ], 2)
    ], 2));
  }
}, Z0 = /* @__PURE__ */ Ut(xE, [["__scopeId", "data-v-7a7565f0"]]);
/**
  * vee-validate v4.15.0
  * (c) 2024 Abdelrahman Awad
  * @license MIT
  */
function qa(e) {
  return typeof e == "function";
}
function PE(e) {
  return e == null;
}
const Qs = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function KO(e) {
  return Number(e) >= 0;
}
function $E(e) {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function _E(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let a = 1; a < t.length; a++) {
    if (KO(t[a])) {
      n += `[${t[a]}]`;
      continue;
    }
    n += `.${t[a]}`;
  }
  return n;
}
const ME = {};
function VE(e) {
  return ME[e];
}
function E9(e, t, n) {
  typeof n.value == "object" && (n.value = lr(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function lr(e) {
  if (typeof e != "object") return e;
  var t = 0, n, a, i, l = Object.prototype.toString.call(e);
  if (l === "[object Object]" ? i = Object.create(e.__proto__ || null) : l === "[object Array]" ? i = Array(e.length) : l === "[object Set]" ? (i = /* @__PURE__ */ new Set(), e.forEach(function(r) {
    i.add(lr(r));
  })) : l === "[object Map]" ? (i = /* @__PURE__ */ new Map(), e.forEach(function(r, s) {
    i.set(lr(s), lr(r));
  })) : l === "[object Date]" ? i = /* @__PURE__ */ new Date(+e) : l === "[object RegExp]" ? i = new RegExp(e.source, e.flags) : l === "[object DataView]" ? i = new e.constructor(lr(e.buffer)) : l === "[object ArrayBuffer]" ? i = e.slice(0) : l.slice(-6) === "Array]" && (i = new e.constructor(e)), i) {
    for (a = Object.getOwnPropertySymbols(e); t < a.length; t++)
      E9(i, a[t], Object.getOwnPropertyDescriptor(e, a[t]));
    for (t = 0, a = Object.getOwnPropertyNames(e); t < a.length; t++)
      Object.hasOwnProperty.call(i, n = a[t]) && i[n] === e[n] || E9(i, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return i || e;
}
const JO = Symbol("vee-validate-form"), TE = Symbol("vee-validate-field-instance"), xd = Symbol("Default empty value"), eb = typeof window < "u";
function E0(e) {
  return qa(e) && !!e.__locatorRef;
}
function Mo(e) {
  return !!e && qa(e.parse) && e.__type === "VVTypedSchema";
}
function N0(e) {
  return !!e && qa(e.validate);
}
function Bu(e) {
  return e === "checkbox" || e === "radio";
}
function LE(e) {
  return Qs(e) || Array.isArray(e);
}
function Wm(e) {
  return /^\[.+\]$/i.test(e);
}
function QE(e) {
  return tb(e) && e.multiple;
}
function tb(e) {
  return e.tagName === "SELECT";
}
function AE(e, t) {
  const n = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
  return e === "select" && "multiple" in t && n;
}
function DE(e, t) {
  return !AE(e, t) && t.type !== "file" && !Bu(t.type);
}
function RE(e) {
  return e ? !!(typeof Event < "u" && qa(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function N9(e, t) {
  return t in e && e[t] !== xd;
}
function Sa(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, a, i;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (!Sa(e[a], t[a]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      for (a of e.entries())
        if (!Sa(a[1], t.get(a[0])))
          return !1;
      return !0;
    }
    if (j9(e) && j9(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (e[a] !== t[a])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (i = Object.keys(e), n = i.length - H9(e, i), n !== Object.keys(t).length - H9(t, Object.keys(t)))
      return !1;
    for (a = n; a-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, i[a]))
        return !1;
    for (a = n; a-- !== 0; ) {
      var l = i[a];
      if (!Sa(e[l], t[l]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function H9(e, t) {
  let n = 0;
  for (let i = t.length; i-- !== 0; ) {
    var a = t[i];
    e[a] === void 0 && n++;
  }
  return n;
}
function j9(e) {
  return eb ? e instanceof File : !1;
}
function nb(e) {
  return Wm(e) ? e.replace(/\[|\]/gi, "") : e;
}
function As(e, t, n) {
  return e ? Wm(t) ? e[nb(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((i, l) => LE(i) && l in i ? i[l] : n, e) : n;
}
function IE(e, t, n) {
  if (Wm(t)) {
    e[nb(t)] = n;
    return;
  }
  const a = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let i = e;
  for (let l = 0; l < a.length; l++) {
    if (l === a.length - 1) {
      i[a[l]] = n;
      return;
    }
    (!(a[l] in i) || PE(i[a[l]])) && (i[a[l]] = KO(a[l + 1]) ? [] : {}), i = i[a[l]];
  }
}
function ab(e) {
  return Object.keys(e);
}
function ib(e, t = void 0) {
  const n = Pl();
  return (n == null ? void 0 : n.provides[e]) || ct(e, t);
}
function z9(e, t, n) {
  if (Array.isArray(e)) {
    const a = [...e], i = a.findIndex((l) => Sa(l, t));
    return i >= 0 ? a.splice(i, 1) : a.push(t), a;
  }
  return Sa(e, t) ? n : t;
}
function BE(e, t) {
  let n, a;
  return function(...i) {
    const l = this;
    return n || (n = !0, setTimeout(() => n = !1, t), a = e.apply(l, i)), a;
  };
}
function ZE(e, t) {
  return Qs(t) && t.number ? $E(e) : e;
}
function F9(e, t) {
  let n;
  return async function(...i) {
    const l = e(...i);
    n = l;
    const r = await l;
    return l !== n ? r : (n = void 0, t(r, i));
  };
}
function EE(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function NE(e, t, n) {
  return t.slots.default ? typeof e == "string" || !e ? t.slots.default(n()) : {
    default: () => {
      var a, i;
      return (i = (a = t.slots).default) === null || i === void 0 ? void 0 : i.call(a, n());
    }
  } : t.slots.default;
}
function Qf(e) {
  if (lb(e))
    return e._value;
}
function lb(e) {
  return "_value" in e;
}
function HE(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function rb(e) {
  if (!RE(e))
    return e;
  const t = e.target;
  if (Bu(t.type) && lb(t))
    return Qf(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (QE(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(Qf);
  if (tb(t)) {
    const n = Array.from(t.options).find((a) => a.selected);
    return n ? Qf(n) : t.value;
  }
  return HE(t);
}
function sb(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? Qs(e) && e._$$isNormalized ? e : Qs(e) ? Object.keys(e).reduce((n, a) => {
    const i = jE(e[a]);
    return e[a] !== !1 && (n[a] = X9(i)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, a) => {
    const i = zE(a);
    return i.name && (n[i.name] = X9(i.params)), n;
  }, t) : t;
}
function jE(e) {
  return e === !0 ? [] : Array.isArray(e) || Qs(e) ? e : [e];
}
function X9(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? FE(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, a) => (n[a] = t(e[a]), n), {});
}
const zE = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function FE(e) {
  const t = (n) => {
    var a;
    return (a = As(n, e)) !== null && a !== void 0 ? a : n[e];
  };
  return t.__locatorRef = e, t;
}
function XE(e) {
  return Array.isArray(e) ? e.filter(E0) : ab(e).filter((t) => E0(e[t])).map((t) => e[t]);
}
const YE = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let WE = Object.assign({}, YE);
const qm = () => WE;
async function qE(e, t, n = {}) {
  const a = n == null ? void 0 : n.bails, i = {
    name: (n == null ? void 0 : n.name) || "{field}",
    rules: t,
    label: n == null ? void 0 : n.label,
    bails: a ?? !0,
    formData: (n == null ? void 0 : n.values) || {}
  }, l = await UE(i, e);
  return Object.assign(Object.assign({}, l), { valid: !l.errors.length });
}
async function UE(e, t) {
  const n = e.rules;
  if (Mo(n) || N0(n))
    return JE(t, Object.assign(Object.assign({}, e), { rules: n }));
  if (qa(n) || Array.isArray(n)) {
    const s = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, o = Array.isArray(n) ? n : [n], u = o.length, c = [];
    for (let d = 0; d < u; d++) {
      const f = o[d], h = await f(t, s);
      if (!(typeof h != "string" && !Array.isArray(h) && h)) {
        if (Array.isArray(h))
          c.push(...h);
        else {
          const g = typeof h == "string" ? h : ob(s);
          c.push(g);
        }
        if (e.bails)
          return {
            errors: c
          };
      }
    }
    return {
      errors: c
    };
  }
  const a = Object.assign(Object.assign({}, e), { rules: sb(n) }), i = [], l = Object.keys(a.rules), r = l.length;
  for (let s = 0; s < r; s++) {
    const o = l[s], u = await eN(a, t, {
      name: o,
      params: a.rules[o]
    });
    if (u.error && (i.push(u.error), e.bails))
      return {
        errors: i
      };
  }
  return {
    errors: i
  };
}
function GE(e) {
  return !!e && e.name === "ValidationError";
}
function KE(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n, a) {
      var i;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1, context: (a == null ? void 0 : a.formData) || {} }),
          errors: []
        };
      } catch (l) {
        if (!GE(l))
          throw l;
        if (!(!((i = l.inner) === null || i === void 0) && i.length) && l.errors.length)
          return { errors: [{ path: l.path, errors: l.errors }] };
        const r = l.inner.reduce((s, o) => {
          const u = o.path || "";
          return s[u] || (s[u] = { errors: [], path: u }), s[u].errors.push(...o.errors), s;
        }, {});
        return { errors: Object.values(r) };
      }
    }
  };
}
async function JE(e, t) {
  const a = await (Mo(t.rules) ? t.rules : KE(t.rules)).parse(e, { formData: t.formData }), i = [];
  for (const l of a.errors)
    l.errors.length && i.push(...l.errors);
  return {
    value: a.value,
    errors: i
  };
}
async function eN(e, t, n) {
  const a = VE(n.name);
  if (!a)
    throw new Error(`No such validator '${n.name}' exists.`);
  const i = tN(n.params, e.formData), l = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: i })
  }, r = await a(t, i, l);
  return typeof r == "string" ? {
    error: r
  } : {
    error: r ? void 0 : ob(l)
  };
}
function ob(e) {
  const t = qm().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function tN(e, t) {
  const n = (a) => E0(a) ? a(t) : a;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((a, i) => (a[i] = n(e[i]), a), {});
}
let Y9 = 0;
function nN(e, t) {
  const { value: n, initialValue: a, setInitialValue: i } = aN(e, t.modelValue, t.form);
  if (!t.form) {
    let f = function(h) {
      var m;
      "value" in h && (n.value = h.value), "errors" in h && u(h.errors), "touched" in h && (d.touched = (m = h.touched) !== null && m !== void 0 ? m : d.touched), "initialValue" in h && i(h.initialValue);
    };
    const { errors: o, setErrors: u } = rN(), c = Y9 >= Number.MAX_SAFE_INTEGER ? 0 : ++Y9, d = lN(n, a, o, t.schema);
    return {
      id: c,
      path: e,
      value: n,
      initialValue: a,
      meta: d,
      flags: { pendingUnmount: { [c]: !1 }, pendingReset: !1 },
      errors: o,
      setState: f
    };
  }
  const l = t.form.createPathState(e, {
    bails: t.bails,
    label: t.label,
    type: t.type,
    validate: t.validate,
    schema: t.schema
  }), r = k(() => l.errors);
  function s(o) {
    var u, c, d;
    "value" in o && (n.value = o.value), "errors" in o && ((u = t.form) === null || u === void 0 || u.setFieldError(X(e), o.errors)), "touched" in o && ((c = t.form) === null || c === void 0 || c.setFieldTouched(X(e), (d = o.touched) !== null && d !== void 0 ? d : !1)), "initialValue" in o && i(o.initialValue);
  }
  return {
    id: Array.isArray(l.id) ? l.id[l.id.length - 1] : l.id,
    path: e,
    value: n,
    errors: r,
    meta: l,
    initialValue: a,
    flags: l.__flags,
    setState: s
  };
}
function aN(e, t, n) {
  const a = Y(X(t));
  function i() {
    return n ? As(n.initialValues.value, X(e), X(a)) : X(a);
  }
  function l(u) {
    if (!n) {
      a.value = u;
      return;
    }
    n.setFieldInitialValue(X(e), u, !0);
  }
  const r = k(i);
  if (!n)
    return {
      value: Y(i()),
      initialValue: r,
      setInitialValue: l
    };
  const s = iN(t, n, r, e);
  return n.stageInitialValue(X(e), s, !0), {
    value: k({
      get() {
        return As(n.values, X(e));
      },
      set(u) {
        n.setFieldValue(X(e), u, !1);
      }
    }),
    initialValue: r,
    setInitialValue: l
  };
}
function iN(e, t, n, a) {
  return Mi(e) ? X(e) : e !== void 0 ? e : As(t.values, X(a), X(n));
}
function lN(e, t, n, a) {
  const i = k(() => {
    var r, s, o;
    return (o = (s = (r = nn(a)) === null || r === void 0 ? void 0 : r.describe) === null || s === void 0 ? void 0 : s.call(r).required) !== null && o !== void 0 ? o : !1;
  }), l = zt({
    touched: !1,
    pending: !1,
    valid: !0,
    required: i,
    validated: !!X(n).length,
    initialValue: k(() => X(t)),
    dirty: k(() => !Sa(X(e), X(t)))
  });
  return pe(n, (r) => {
    l.valid = !r.length;
  }, {
    immediate: !0,
    flush: "sync"
  }), l;
}
function rN() {
  const e = Y([]);
  return {
    errors: e,
    setErrors: (t) => {
      e.value = EE(t);
    }
  };
}
const ub = {}, Vo = {}, To = "vee-validate-inspector", ua = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let yn = null, gl;
async function sN(e) {
  if (process.env.NODE_ENV !== "production") {
    if (!eb)
      return;
    (await import("./index-CKSg2LAL.js")).setupDevtoolsPlugin({
      id: "vee-validate-devtools-plugin",
      label: "VeeValidate Plugin",
      packageName: "vee-validate",
      homepage: "https://vee-validate.logaretm.com/v4",
      app: e,
      logo: "https://vee-validate.logaretm.com/v4/logo.png"
    }, (n) => {
      gl = n, n.addInspector({
        id: To,
        icon: "rule",
        label: "vee-validate",
        noSelectionText: "Select a vee-validate node to inspect",
        actions: [
          {
            icon: "done_outline",
            tooltip: "Validate selected item",
            action: async () => {
              if (!yn) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (yn.type === "field") {
                await yn.field.validate();
                return;
              }
              if (yn.type === "form") {
                await yn.form.validate();
                return;
              }
              yn.type === "pathState" && await yn.form.validateField(yn.state.path);
            }
          },
          {
            icon: "delete_sweep",
            tooltip: "Clear validation state of the selected item",
            action: () => {
              if (!yn) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (yn.type === "field") {
                yn.field.resetField();
                return;
              }
              yn.type === "form" && yn.form.resetForm(), yn.type === "pathState" && yn.form.resetField(yn.state.path);
            }
          }
        ]
      }), n.on.getInspectorTree((a) => {
        if (a.inspectorId !== To)
          return;
        const i = Object.values(ub), l = Object.values(Vo);
        a.rootNodes = [
          ...i.map(uN),
          ...l.map((r) => dN(r))
        ];
      }), n.on.getInspectorState((a) => {
        if (a.inspectorId !== To)
          return;
        const { form: i, field: l, state: r, type: s } = fN(a.nodeId);
        if (n.unhighlightElement(), i && s === "form") {
          a.state = hN(i), yn = { type: "form", form: i }, n.highlightElement(i._vm);
          return;
        }
        if (r && s === "pathState" && i) {
          a.state = W9(r), yn = { type: "pathState", state: r, form: i };
          return;
        }
        if (l && s === "field") {
          a.state = W9({
            errors: l.errors.value,
            dirty: l.meta.dirty,
            valid: l.meta.valid,
            touched: l.meta.touched,
            value: l.value.value,
            initialValue: l.meta.initialValue
          }), yn = { field: l, type: "field" }, n.highlightElement(l._vm);
          return;
        }
        yn = null, n.unhighlightElement();
      });
    });
  }
}
const H0 = BE(() => {
  setTimeout(async () => {
    await et(), gl == null || gl.sendInspectorState(To), gl == null || gl.sendInspectorTree(To);
  }, 100);
}, 100);
function oN(e) {
  const t = Pl();
  if (!gl) {
    const n = t == null ? void 0 : t.appContext.app;
    if (!n)
      return;
    sN(n);
  }
  Vo[e.id] = Object.assign({}, e), Vo[e.id]._vm = t, ni(() => {
    delete Vo[e.id], H0();
  }), H0();
}
function uN(e) {
  const { textColor: t, bgColor: n } = db(e.meta.value.valid), a = {};
  Object.values(e.getAllPathStates()).forEach((r) => {
    IE(a, nn(r.path), cN(r, e));
  });
  function i(r, s = []) {
    const o = [...s].pop();
    return "id" in r ? Object.assign(Object.assign({}, r), { label: o || r.label }) : Qs(r) ? {
      id: `${s.join(".")}`,
      label: o || "",
      children: Object.keys(r).map((u) => i(r[u], [...s, u]))
    } : Array.isArray(r) ? {
      id: `${s.join(".")}`,
      label: `${o}[]`,
      children: r.map((u, c) => i(u, [...s, String(c)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: l } = i(a);
  return {
    id: Um(e),
    label: e.name,
    children: l,
    tags: [
      {
        label: "Form",
        textColor: t,
        backgroundColor: n
      },
      {
        label: `${e.getAllPathStates().length} fields`,
        textColor: ua.white,
        backgroundColor: ua.unknown
      }
    ]
  };
}
function cN(e, t) {
  return {
    id: Um(t, e),
    label: nn(e.path),
    tags: cb(e.multiple, e.fieldsCount, e.type, e.valid, t)
  };
}
function dN(e, t) {
  return {
    id: Um(t, e),
    label: X(e.name),
    tags: cb(!1, 1, e.type, e.meta.valid, t)
  };
}
function cb(e, t, n, a, i) {
  const { textColor: l, bgColor: r } = db(a);
  return [
    e ? void 0 : {
      label: "Field",
      textColor: l,
      backgroundColor: r
    },
    i ? void 0 : {
      label: "Standalone",
      textColor: ua.black,
      backgroundColor: ua.gray
    },
    n === "checkbox" ? {
      label: "Checkbox",
      textColor: ua.white,
      backgroundColor: ua.blue
    } : void 0,
    n === "radio" ? {
      label: "Radio",
      textColor: ua.white,
      backgroundColor: ua.purple
    } : void 0,
    e ? {
      label: "Multiple",
      textColor: ua.black,
      backgroundColor: ua.orange
    } : void 0
  ].filter(Boolean);
}
function Um(e, t) {
  const n = t ? "path" in t ? "pathState" : "field" : "form", a = t ? "path" in t ? t == null ? void 0 : t.path : nn(t == null ? void 0 : t.name) : "", i = { f: e == null ? void 0 : e.formId, ff: (t == null ? void 0 : t.id) || a, type: n };
  return btoa(encodeURIComponent(JSON.stringify(i)));
}
function fN(e) {
  try {
    const t = JSON.parse(decodeURIComponent(atob(e))), n = ub[t.f];
    if (!n && t.ff) {
      const i = Vo[t.ff];
      return i ? {
        type: t.type,
        field: i
      } : {};
    }
    if (!n)
      return {};
    const a = n.getPathState(t.ff);
    return {
      type: t.type,
      form: n,
      state: a
    };
  } catch {
  }
  return {};
}
function W9(e) {
  return {
    "Field state": [
      { key: "errors", value: e.errors },
      {
        key: "initialValue",
        value: e.initialValue
      },
      {
        key: "currentValue",
        value: e.value
      },
      {
        key: "touched",
        value: e.touched
      },
      {
        key: "dirty",
        value: e.dirty
      },
      {
        key: "valid",
        value: e.valid
      }
    ]
  };
}
function hN(e) {
  const { errorBag: t, meta: n, values: a, isSubmitting: i, isValidating: l, submitCount: r } = e;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: r.value
      },
      {
        key: "isSubmitting",
        value: i.value
      },
      {
        key: "isValidating",
        value: l.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: a
      },
      {
        key: "errors",
        value: ab(t.value).reduce((s, o) => {
          var u;
          const c = (u = t.value[o]) === null || u === void 0 ? void 0 : u[0];
          return c && (s[o] = c), s;
        }, {})
      }
    ]
  };
}
function db(e) {
  return {
    bgColor: e ? ua.success : ua.error,
    textColor: e ? ua.black : ua.white
  };
}
function mN(e, t, n) {
  return Bu(n == null ? void 0 : n.type) ? gN(e, t, n) : fb(e, t, n);
}
function fb(e, t, n) {
  const { initialValue: a, validateOnMount: i, bails: l, type: r, checkedValue: s, label: o, validateOnValueUpdate: u, uncheckedValue: c, controlled: d, keepValueOnUnmount: f, syncVModel: h, form: m } = vN(n), g = d ? ib(JO) : void 0, v = m || g, y = k(() => _E(nn(e))), b = k(() => {
    if (nn(v == null ? void 0 : v.schema))
      return;
    const Q = X(t);
    return N0(Q) || Mo(Q) || qa(Q) || Array.isArray(Q) ? Q : sb(Q);
  }), C = !qa(b.value) && Mo(nn(t)), { id: S, value: x, initialValue: w, meta: V, setState: _, errors: O, flags: $ } = nN(y, {
    modelValue: a,
    form: v,
    bails: l,
    label: o,
    type: r,
    validate: b.value ? D : void 0,
    schema: C ? t : void 0
  }), P = k(() => O.value[0]);
  h && pN({
    value: x,
    prop: h,
    handleChange: B,
    shouldValidate: () => u && !$.pendingReset
  });
  const M = (E, Q = !1) => {
    V.touched = !0, Q && L();
  };
  async function T(E) {
    var Q, W;
    if (v != null && v.validateSchema) {
      const { results: se } = await v.validateSchema(E);
      return (Q = se[nn(y)]) !== null && Q !== void 0 ? Q : { valid: !0, errors: [] };
    }
    return b.value ? qE(x.value, b.value, {
      name: nn(y),
      label: nn(o),
      values: (W = v == null ? void 0 : v.values) !== null && W !== void 0 ? W : {},
      bails: l
    }) : { valid: !0, errors: [] };
  }
  const L = F9(async () => (V.pending = !0, V.validated = !0, T("validated-only")), (E) => ($.pendingUnmount[q.id] || (_({ errors: E.errors }), V.pending = !1, V.valid = E.valid), E)), A = F9(async () => T("silent"), (E) => (V.valid = E.valid, E));
  function D(E) {
    return (E == null ? void 0 : E.mode) === "silent" ? A() : L();
  }
  function B(E, Q = !0) {
    const W = rb(E);
    R(W, Q);
  }
  rt(() => {
    if (i)
      return L();
    (!v || !v.validateSchema) && A();
  });
  function j(E) {
    V.touched = E;
  }
  function I(E) {
    var Q;
    const W = E && "value" in E ? E.value : w.value;
    _({
      value: lr(W),
      initialValue: lr(W),
      touched: (Q = E == null ? void 0 : E.touched) !== null && Q !== void 0 ? Q : !1,
      errors: (E == null ? void 0 : E.errors) || []
    }), V.pending = !1, V.validated = !1, A();
  }
  const Z = Pl();
  function R(E, Q = !0) {
    x.value = Z && h ? ZE(E, Z.props.modelModifiers) : E, (Q ? L : A)();
  }
  function J(E) {
    _({ errors: Array.isArray(E) ? E : [E] });
  }
  const F = k({
    get() {
      return x.value;
    },
    set(E) {
      R(E, u);
    }
  }), q = {
    id: S,
    name: y,
    label: o,
    value: F,
    meta: V,
    errors: O,
    errorMessage: P,
    type: r,
    checkedValue: s,
    uncheckedValue: c,
    bails: l,
    keepValueOnUnmount: f,
    resetField: I,
    handleReset: () => I(),
    validate: D,
    handleChange: B,
    handleBlur: M,
    setState: _,
    setTouched: j,
    setErrors: J,
    setValue: R
  };
  if (Tt(TE, q), Mi(t) && typeof X(t) != "function" && pe(t, (E, Q) => {
    Sa(E, Q) || (V.validated ? L() : A());
  }, {
    deep: !0
  }), process.env.NODE_ENV !== "production" && (q._vm = Pl(), pe(() => Object.assign(Object.assign({ errors: O.value }, V), { value: x.value }), H0, {
    deep: !0
  }), v || oN(q)), !v)
    return q;
  const z = k(() => {
    const E = b.value;
    return !E || qa(E) || N0(E) || Mo(E) || Array.isArray(E) ? {} : Object.keys(E).reduce((Q, W) => {
      const se = XE(E[W]).map((Se) => Se.__locatorRef).reduce((Se, U) => {
        const ne = As(v.values, U) || v.values[U];
        return ne !== void 0 && (Se[U] = ne), Se;
      }, {});
      return Object.assign(Q, se), Q;
    }, {});
  });
  return pe(z, (E, Q) => {
    if (!Object.keys(E).length)
      return;
    !Sa(E, Q) && (V.validated ? L() : A());
  }), mn(() => {
    var E;
    const Q = (E = nn(q.keepValueOnUnmount)) !== null && E !== void 0 ? E : nn(v.keepValuesOnUnmount), W = nn(y);
    if (Q || !v || $.pendingUnmount[q.id]) {
      v == null || v.removePathState(W, S);
      return;
    }
    $.pendingUnmount[q.id] = !0;
    const se = v.getPathState(W);
    if (Array.isArray(se == null ? void 0 : se.id) && (se != null && se.multiple) ? se != null && se.id.includes(q.id) : (se == null ? void 0 : se.id) === q.id) {
      if (se != null && se.multiple && Array.isArray(se.value)) {
        const U = se.value.findIndex((ne) => Sa(ne, nn(q.checkedValue)));
        if (U > -1) {
          const ne = [...se.value];
          ne.splice(U, 1), v.setFieldValue(W, ne);
        }
        Array.isArray(se.id) && se.id.splice(se.id.indexOf(q.id), 1);
      } else
        v.unsetPathValue(nn(y));
      v.removePathState(W, S);
    }
  }), q;
}
function vN(e) {
  const t = () => ({
    initialValue: void 0,
    validateOnMount: !1,
    bails: !0,
    label: void 0,
    validateOnValueUpdate: !0,
    keepValueOnUnmount: void 0,
    syncVModel: !1,
    controlled: !0
  }), n = !!(e != null && e.syncVModel), a = typeof (e == null ? void 0 : e.syncVModel) == "string" ? e.syncVModel : (e == null ? void 0 : e.modelPropName) || "modelValue", i = n && !("initialValue" in (e || {})) ? j0(Pl(), a) : e == null ? void 0 : e.initialValue;
  if (!e)
    return Object.assign(Object.assign({}, t()), { initialValue: i });
  const l = "valueProp" in e ? e.valueProp : e.checkedValue, r = "standalone" in e ? !e.standalone : e.controlled, s = (e == null ? void 0 : e.modelPropName) || (e == null ? void 0 : e.syncVModel) || !1;
  return Object.assign(Object.assign(Object.assign({}, t()), e || {}), {
    initialValue: i,
    controlled: r ?? !0,
    checkedValue: l,
    syncVModel: s
  });
}
function gN(e, t, n) {
  const a = n != null && n.standalone ? void 0 : ib(JO), i = n == null ? void 0 : n.checkedValue, l = n == null ? void 0 : n.uncheckedValue;
  function r(s) {
    const o = s.handleChange, u = k(() => {
      const d = nn(s.value), f = nn(i);
      return Array.isArray(d) ? d.findIndex((h) => Sa(h, f)) >= 0 : Sa(f, d);
    });
    function c(d, f = !0) {
      var h, m;
      if (u.value === ((h = d == null ? void 0 : d.target) === null || h === void 0 ? void 0 : h.checked)) {
        f && s.validate();
        return;
      }
      const g = nn(e), v = a == null ? void 0 : a.getPathState(g), y = rb(d);
      let b = (m = nn(i)) !== null && m !== void 0 ? m : y;
      a && (v != null && v.multiple) && v.type === "checkbox" ? b = z9(As(a.values, g) || [], b, void 0) : (n == null ? void 0 : n.type) === "checkbox" && (b = z9(nn(s.value), b, nn(l))), o(b, f);
    }
    return Object.assign(Object.assign({}, s), {
      checked: u,
      checkedValue: i,
      uncheckedValue: l,
      handleChange: c
    });
  }
  return r(fb(e, t, n));
}
function pN({ prop: e, value: t, handleChange: n, shouldValidate: a }) {
  const i = Pl();
  if (!i || !e) {
    process.env.NODE_ENV !== "production" && console.warn("Failed to setup model events because `useField` was not called in setup.");
    return;
  }
  const l = typeof e == "string" ? e : "modelValue", r = `update:${l}`;
  l in i.props && (pe(t, (s) => {
    Sa(s, j0(i, l)) || i.emit(r, s);
  }), pe(() => j0(i, l), (s) => {
    if (s === xd && t.value === void 0)
      return;
    const o = s === xd ? void 0 : s;
    Sa(o, t.value) || n(o, a());
  }));
}
function j0(e, t) {
  if (e)
    return e.props[t];
}
const yN = /* @__PURE__ */ Sn({
  name: "Field",
  inheritAttrs: !1,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: !0
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => qm().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: xd
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: !1
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    const n = ue(e, "rules"), a = ue(e, "name"), i = ue(e, "label"), l = ue(e, "uncheckedValue"), r = ue(e, "keepValue"), { errors: s, value: o, errorMessage: u, validate: c, handleChange: d, handleBlur: f, setTouched: h, resetField: m, handleReset: g, meta: v, checked: y, setErrors: b, setValue: C } = mN(a, n, {
      validateOnMount: e.validateOnMount,
      bails: e.bails,
      standalone: e.standalone,
      type: t.attrs.type,
      initialValue: bN(e, t),
      // Only for checkboxes and radio buttons
      checkedValue: t.attrs.value,
      uncheckedValue: l,
      label: i,
      validateOnValueUpdate: e.validateOnModelUpdate,
      keepValueOnUnmount: r,
      syncVModel: !0
    }), S = function($, P = !0) {
      d($, P);
    }, x = k(() => {
      const { validateOnInput: O, validateOnChange: $, validateOnBlur: P, validateOnModelUpdate: M } = ON(e);
      function T(B) {
        f(B, P), qa(t.attrs.onBlur) && t.attrs.onBlur(B);
      }
      function L(B) {
        S(B, O), qa(t.attrs.onInput) && t.attrs.onInput(B);
      }
      function A(B) {
        S(B, $), qa(t.attrs.onChange) && t.attrs.onChange(B);
      }
      const D = {
        name: e.name,
        onBlur: T,
        onInput: L,
        onChange: A
      };
      return D["onUpdate:modelValue"] = (B) => S(B, M), D;
    }), w = k(() => {
      const O = Object.assign({}, x.value);
      Bu(t.attrs.type) && y && (O.checked = y.value);
      const $ = q9(e, t);
      return DE($, t.attrs) && (O.value = o.value), O;
    }), V = k(() => Object.assign(Object.assign({}, x.value), { modelValue: o.value }));
    function _() {
      return {
        field: w.value,
        componentField: V.value,
        value: o.value,
        meta: v,
        errors: s.value,
        errorMessage: u.value,
        validate: c,
        resetField: m,
        handleChange: S,
        handleInput: (O) => S(O, !1),
        handleReset: g,
        handleBlur: x.value.onBlur,
        setTouched: h,
        setErrors: b,
        setValue: C
      };
    }
    return t.expose({
      value: o,
      meta: v,
      errors: s,
      errorMessage: u,
      setErrors: b,
      setTouched: h,
      setValue: C,
      reset: m,
      validate: c,
      handleChange: d
    }), () => {
      const O = Lr(q9(e, t)), $ = NE(O, t, _);
      return O ? G(O, Object.assign(Object.assign({}, t.attrs), w.value), $) : $;
    };
  }
});
function q9(e, t) {
  let n = e.as || "";
  return !e.as && !t.slots.default && (n = "input"), n;
}
function ON(e) {
  var t, n, a, i;
  const { validateOnInput: l, validateOnChange: r, validateOnBlur: s, validateOnModelUpdate: o } = qm();
  return {
    validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : l,
    validateOnChange: (n = e.validateOnChange) !== null && n !== void 0 ? n : r,
    validateOnBlur: (a = e.validateOnBlur) !== null && a !== void 0 ? a : s,
    validateOnModelUpdate: (i = e.validateOnModelUpdate) !== null && i !== void 0 ? i : o
  };
}
function bN(e, t) {
  return Bu(t.attrs.type) ? N9(e, "modelValue") ? e.modelValue : void 0 : N9(e, "modelValue") ? e.modelValue : t.attrs.value;
}
const U9 = yN;
function CN(e = [], t = {}) {
  const { valuePrefix: n = "", nameMapper: a } = t;
  return e.map((i) => {
    const l = n ? `${n}.${i.name}` : i.name;
    if (a && typeof a == "function") {
      const s = a(i.name, i);
      if (s)
        return {
          ...s,
          value: s.value || l,
          order: s.order !== void 0 ? s.order : i.order || 0
        };
    }
    const r = {
      type: i.type,
      // 'duration', 'integer'
      label: i.label,
      required: !1,
      // 필요시 param에서 가져오기
      value: l,
      placeholder: i.description,
      defaultValue: i.defaultValue,
      order: i.order || 0
    };
    return i.type === "duration" && i.units && i.units.length > 0 && (r.units = i.units.map((s) => ({
      label: s.label,
      value: s.value,
      description: s.description
    })), r.unitItemTitle = "label", r.unitItemValue = "value", r.defaultUnitValue = i.defaultUnitValue), i.type === "integer" && (r.type = "number"), i.type === "string" && (r.type = "input"), i.name === "latency" && (r.type = "number", r.step = "0.1"), r;
  }).sort((i, l) => (i.order || 0) - (l.order || 0));
}
const wN = {
  key: 2,
  class: "error-text-color"
}, kN = { key: 0 }, SN = {
  key: 2,
  class: "form-item--half"
}, xN = {
  key: 3,
  class: "form-item--half"
}, PN = {
  key: 7,
  class: "error-text-color"
}, $N = { key: 0 }, _N = {
  __name: "SFormGenerator",
  props: {
    /**
     * 폼 필드 설정 배열 (fieldGroups 미사용 시 사용)
     */
    fields: {
      type: Array,
      required: !1,
      default: () => []
    },
    /**
     * 필드 그룹 객체
     * 예: { basic: [...], billing: [...] }
     */
    fieldGroups: {
      type: Object,
      required: !1,
      default: () => null
    },
    /**
     * 그룹 선택 필드 설정 (fieldGroups 사용 시)
     * 예: { type: 'select', value: 'accountType', options: [...] }
     */
    groupSelector: {
      type: Object,
      required: !1,
      default: () => null
    },
    /**
     * 백엔드 템플릿 배열 (자동 변환)
     * 예: [{ id: 1, name: "템플릿1", ruleParams: [...] }]
     */
    templates: {
      type: Array,
      required: !1,
      default: () => null
    },
    /**
     * 템플릿 선택 필드 레이블
     */
    templateLabel: {
      type: String,
      default: "템플릿 선택"
    },
    /**
     * 템플릿 선택 필드명 (선택된 템플릿 ID가 저장될 필드)
     */
    templateField: {
      type: String,
      default: "templateId"
    },
    /**
     * 폼 데이터 객체 (v-model)
     */
    modelValue: {
      type: Object,
      default: () => ({})
    },
    /**
     * 값이 저장될 상위 경로
     * 예: "accountData" → accountData.serviceAccount.projectId
     */
    valuePath: {
      type: String,
      default: ""
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, i = (b) => {
      if (b === null || typeof b != "object") return b;
      if (b instanceof Date) return new Date(b.getTime());
      if (Array.isArray(b)) return b.map((S) => i(S));
      const C = {};
      for (const S in b)
        Object.prototype.hasOwnProperty.call(b, S) && (C[S] = i(b[S]));
      return C;
    }, l = (b) => n.valuePath ? `${n.valuePath}.${b}` : b, r = (b, C) => {
      if (!C) return b;
      const S = C.split(".");
      let x = b;
      for (const w of S)
        if (x && typeof x == "object" && w in x)
          x = x[w];
        else
          return;
      return x;
    }, s = (b, C, S) => {
      const x = C.split("."), w = i(b);
      let V = w;
      for (let _ = 0; _ < x.length - 1; _++) {
        const O = x[_];
        (!V[O] || typeof V[O] != "object" || Array.isArray(V[O])) && (V[O] = {}), V = V[O];
      }
      return V[x[x.length - 1]] = S, w;
    }, o = (b) => {
      const C = l(b);
      return r(n.modelValue, C);
    }, u = k(() => {
      if (!n.templates || n.templates.length === 0)
        return null;
      const b = {};
      return n.templates.forEach((C) => {
        C.ruleParams && C.ruleParams.length > 0 && (b[C.id] = CN(
          C.ruleParams,
          { valuePrefix: n.valuePath || "ruleParams" }
        ));
      }), b;
    }), c = k(() => !n.templates || n.templates.length === 0 ? null : {
      type: "select",
      label: n.templateLabel,
      required: !0,
      value: n.templateField,
      options: n.templates.map((b) => ({
        title: b.name,
        value: b.id
      }))
    }), d = k(() => u.value || n.fieldGroups), f = k(() => c.value || n.groupSelector), h = k(() => {
      if (d.value && f.value) {
        const b = o(f.value.value);
        return b && d.value[b] ? d.value[b] : [];
      }
      return n.fields;
    });
    pe(
      () => d.value && f.value ? o(f.value.value) : null,
      (b, C) => {
        if (b === C || !d.value || !f.value)
          return;
        const S = d.value[b] || [], x = C !== void 0 ? d.value[C] || [] : [], w = i(n.modelValue);
        C !== void 0 && x.forEach((_) => {
          const $ = l(_.value).split(".");
          let P = w;
          for (let M = 0; M < $.length - 1; M++) {
            const T = $[M];
            if (P[T] && typeof P[T] == "object")
              P = P[T];
            else
              return;
          }
          delete P[$[$.length - 1]];
        });
        let V = w;
        S.forEach((_) => {
          var O, $;
          if (_.defaultValue !== void 0) {
            const P = l(_.value);
            if (_.type === "duration") {
              const M = _.defaultUnitValue || _.units && ((O = _.units[0]) == null ? void 0 : O.value), T = {
                value: _.defaultValue ? Number(_.defaultValue) : void 0,
                unit: M
              };
              V = s(V, P, T);
            } else if (_.type === "composite" && _.composite) {
              const M = _.composite.valueField || "value", T = _.composite.optionField || "unit", L = _.composite.defaultOptionValue || _.composite.options && (($ = _.composite.options[0]) == null ? void 0 : $.value), A = {
                [M]: _.defaultValue ? Number(_.defaultValue) : void 0,
                [T]: L
              };
              V = s(V, P, A);
            } else
              V = s(V, P, _.defaultValue);
          }
        }), a("update:modelValue", V);
      }
    );
    const m = (b, C) => {
      const S = l(b), x = r(n.modelValue, S);
      if (x && typeof x == "object")
        return x[C];
      if (typeof x == "string" && C === "value") {
        const w = x.match(/^(\d+)/);
        return w ? w[1] : void 0;
      }
      if (typeof x == "string" && C === "unit") {
        const w = x.match(/([a-z]+)$/i);
        return w ? w[1] : void 0;
      }
    }, g = (b, C, S, x, w, V, _) => {
      const O = l(b), $ = r(n.modelValue, O) || {}, P = $[S] || (x.length > 0 ? x[0][w] : void 0), M = {
        ...$,
        [C]: V !== "" && V !== null && V !== void 0 ? typeof V == "string" && !isNaN(V) ? Number(V) : V : void 0,
        [S]: P
      }, T = s(n.modelValue, O, M);
      a("update:modelValue", T), _(M);
    }, v = (b, C, S, x, w) => {
      const V = l(b), _ = r(n.modelValue, V) || {}, O = _[C] ?? m(b, C), $ = {
        ..._,
        [C]: O,
        [S]: x
      }, P = s(n.modelValue, V, $);
      a("update:modelValue", P), w($);
    }, y = (b, C, S) => {
      const x = l(b), w = s(n.modelValue, x, C);
      a("update:modelValue", w), S(C);
    };
    return (b, C) => {
      const S = Pe("v-select"), x = Pe("v-radio"), w = Pe("v-radio-group"), V = Pe("v-text-field"), _ = Pe("v-checkbox");
      return N(), ee(ge, null, [
        f.value ? (N(), Ce(X(Z0), {
          key: 0,
          label: f.value.label,
          required: f.value.required
        }, {
          "outer-append": re(() => [
            f.value.appendText ? (N(), ee("span", kN, xe(f.value.appendText), 1)) : de("", !0)
          ]),
          default: re(() => [
            p(X(U9), {
              name: f.value.value
            }, {
              default: re(({ errors: O, handleChange: $ }) => [
                f.value.type === "select" ? (N(), Ce(S, {
                  key: 0,
                  "model-value": o(f.value.value),
                  variant: "outlined",
                  density: "compact",
                  "hide-details": "auto",
                  items: f.value.options || [],
                  "item-title": f.value.itemTitle || "title",
                  "item-value": f.value.itemValue || "value",
                  placeholder: f.value.placeholder,
                  "error-messages": O,
                  "onUpdate:modelValue": (P) => y(f.value.value, P, $)
                }, null, 8, ["model-value", "items", "item-title", "item-value", "placeholder", "error-messages", "onUpdate:modelValue"])) : f.value.type === "radio" ? (N(), Ce(w, {
                  key: 1,
                  "model-value": o(f.value.value),
                  density: "compact",
                  "hide-details": "auto",
                  "error-messages": O,
                  inline: "",
                  "onUpdate:modelValue": (P) => y(f.value.value, P, $)
                }, {
                  default: re(() => [
                    (N(!0), ee(ge, null, Ge(f.value.options || [], (P) => (N(), Ce(x, {
                      key: P[f.value.itemValue || "value"],
                      label: P[f.value.itemTitle || "title"],
                      value: P[f.value.itemValue || "value"],
                      density: "compact"
                    }, null, 8, ["label", "value"]))), 128))
                  ]),
                  _: 2
                }, 1032, ["model-value", "error-messages", "onUpdate:modelValue"])) : (N(), ee("span", wN, " Unsupported groupSelector type: " + xe(f.value.type), 1))
              ]),
              _: 1
            }, 8, ["name"])
          ]),
          _: 1
        }, 8, ["label", "required"])) : de("", !0),
        (N(!0), ee(ge, null, Ge(h.value, (O, $) => (N(), Ce(X(Z0), {
          key: O.value || $,
          label: O.label,
          required: O.required
        }, {
          "outer-append": re(() => [
            O.appendText ? (N(), ee("span", $N, xe(O.appendText), 1)) : de("", !0)
          ]),
          default: re(() => [
            p(X(U9), {
              name: O.value
            }, {
              default: re(({ errors: P, handleChange: M }) => [
                O.type === "input" ? (N(), Ce(V, {
                  key: 0,
                  "model-value": o(O.value),
                  variant: "outlined",
                  density: "compact",
                  "hide-details": "auto",
                  type: O.encrypt ? "password" : "text",
                  placeholder: O.placeholder,
                  "error-messages": P,
                  "onUpdate:modelValue": (T) => y(O.value, T, M)
                }, null, 8, ["model-value", "type", "placeholder", "error-messages", "onUpdate:modelValue"])) : O.type === "number" || O.type === "integer" ? (N(), Ce(V, {
                  key: 1,
                  "model-value": o(O.value),
                  variant: "outlined",
                  density: "compact",
                  "hide-details": "auto",
                  type: "number",
                  step: O.step,
                  min: O.min,
                  max: O.max,
                  placeholder: O.placeholder,
                  "error-messages": P,
                  "onUpdate:modelValue": (T) => y(O.value, T, M)
                }, null, 8, ["model-value", "step", "min", "max", "placeholder", "error-messages", "onUpdate:modelValue"])) : O.type === "duration" ? (N(), ee("div", SN, [
                  p(V, {
                    "model-value": m(O.value, "value"),
                    variant: "outlined",
                    density: "compact",
                    "hide-details": "auto",
                    type: "number",
                    placeholder: O.placeholder,
                    "error-messages": P,
                    "onUpdate:modelValue": (T) => g(O.value, "value", "unit", O.units || [], O.unitItemValue || "value", T, M)
                  }, null, 8, ["model-value", "placeholder", "error-messages", "onUpdate:modelValue"]),
                  p(S, {
                    "model-value": m(O.value, "unit"),
                    variant: "outlined",
                    density: "compact",
                    "hide-details": "auto",
                    items: O.units || [],
                    "item-title": O.unitItemTitle || "label",
                    "item-value": O.unitItemValue || "value",
                    "error-messages": P,
                    "onUpdate:modelValue": (T) => v(O.value, "value", "unit", T, M)
                  }, null, 8, ["model-value", "items", "item-title", "item-value", "error-messages", "onUpdate:modelValue"])
                ])) : O.type === "composite" && O.composite ? (N(), ee("div", xN, [
                  p(V, {
                    "model-value": m(O.value, O.composite.valueField || "value"),
                    variant: "outlined",
                    density: "compact",
                    "hide-details": "auto",
                    type: O.composite.valueType || "number",
                    step: O.composite.step,
                    min: O.composite.min,
                    max: O.composite.max,
                    placeholder: O.placeholder,
                    "error-messages": P,
                    "onUpdate:modelValue": (T) => g(O.value, O.composite.valueField || "value", O.composite.optionField || "unit", O.composite.options || [], O.composite.optionItemValue || "value", T, M)
                  }, null, 8, ["model-value", "type", "step", "min", "max", "placeholder", "error-messages", "onUpdate:modelValue"]),
                  p(S, {
                    "model-value": m(O.value, O.composite.optionField || "unit"),
                    variant: "outlined",
                    density: "compact",
                    "hide-details": "auto",
                    items: O.composite.options || [],
                    "item-title": O.composite.optionItemTitle || "label",
                    "item-value": O.composite.optionItemValue || "value",
                    "error-messages": P,
                    "onUpdate:modelValue": (T) => v(O.value, O.composite.valueField || "value", O.composite.optionField || "unit", T, M)
                  }, null, 8, ["model-value", "items", "item-title", "item-value", "error-messages", "onUpdate:modelValue"])
                ])) : O.type === "checkbox" ? (N(), Ce(_, {
                  key: 4,
                  "model-value": o(O.value),
                  "error-messages": P,
                  density: "compact",
                  "hide-details": "auto",
                  "true-value": O.trueValue || "Y",
                  "false-value": O.falseValue || "N",
                  "onUpdate:modelValue": (T) => y(O.value, T, M)
                }, null, 8, ["model-value", "error-messages", "true-value", "false-value", "onUpdate:modelValue"])) : O.type === "select" ? (N(), Ce(S, {
                  key: 5,
                  "model-value": o(O.value),
                  variant: "outlined",
                  density: "compact",
                  "hide-details": "auto",
                  items: O.options || [],
                  "item-title": O.itemTitle || "title",
                  "item-value": O.itemValue || "value",
                  placeholder: O.placeholder,
                  "error-messages": P,
                  "onUpdate:modelValue": (T) => y(O.value, T, M)
                }, null, 8, ["model-value", "items", "item-title", "item-value", "placeholder", "error-messages", "onUpdate:modelValue"])) : O.type === "radio" ? (N(), Ce(w, {
                  key: 6,
                  "model-value": o(O.value),
                  density: "compact",
                  "hide-details": "auto",
                  "error-messages": P,
                  inline: "",
                  "onUpdate:modelValue": (T) => y(O.value, T, M)
                }, {
                  default: re(() => [
                    (N(!0), ee(ge, null, Ge(O.options || [], (T) => (N(), Ce(x, {
                      key: T[O.itemValue || "value"],
                      label: T[O.itemTitle || "title"],
                      value: T[O.itemValue || "value"],
                      density: "compact"
                    }, null, 8, ["label", "value"]))), 128))
                  ]),
                  _: 2
                }, 1032, ["model-value", "error-messages", "onUpdate:modelValue"])) : (N(), ee("span", PN, " Unsupported field type: " + xe(O.type), 1))
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 2
        }, 1032, ["label", "required"]))), 128))
      ], 64);
    };
  }
}, MN = /* @__PURE__ */ Ut(_N, [["__scopeId", "data-v-aae56dff"]]), VN = { class: "s-avatar" }, TN = {
  __name: "SAvatar",
  props: {
    user: {
      type: Object,
      default: () => {
      },
      description: "회원정보"
    },
    menuItems: {
      type: Array,
      default: () => [],
      description: "회원정보 메뉴들"
    },
    className: {
      type: Object,
      default: () => {
      },
      description: "custom class"
    }
  },
  emits: ["click:menu-item"],
  setup(e) {
    const t = e, n = k(() => {
      var a;
      return (a = t.className) == null ? void 0 : a.fontWhite;
    });
    return (a, i) => {
      const l = Pe("v-list-item-title"), r = Pe("v-list-item"), s = Pe("v-list"), o = Pe("v-menu");
      return N(), ee("div", VN, [
        p(o, { offset: [5, 0] }, {
          activator: re(({ props: u }) => [
            ie("div", fe({ class: "s-user-name" }, u), [
              ie("div", {
                class: Ie(["s-user-name__text", { fontWhite: n.value }])
              }, xe(e.user.name), 3)
            ], 16)
          ]),
          default: re(() => [
            p(s, { class: "s-avatar-menu__list" }, {
              default: re(() => [
                (N(!0), ee(ge, null, Ge(e.menuItems, (u, c) => (N(), ee(ge, { key: c }, [
                  u.visable ? de("", !0) : (N(), Ce(r, {
                    key: 0,
                    value: u.value,
                    onClick: (d) => a.$emit("click:menu-item", u.value)
                  }, {
                    default: re(() => [
                      p(l, null, {
                        default: re(() => [
                          Ee(xe(u.title), 1)
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["value", "onClick"]))
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        ke(a.$slots, "badge", {}, void 0, !0)
      ]);
    };
  }
}, hb = /* @__PURE__ */ Ut(TN, [["__scopeId", "data-v-28ffadb1"]]), LN = "[Image]", mb = {
  __name: "SImg",
  props: {
    /*
      @brief 클래스 이름 값 할당
      @date 2021/11/04
      @example
      {
          클래스 이름 : {
          타입: '',
          필수유무: Boolean
          디폴트: 값
          }
      }
      */
    bind: {
      type: Object,
      default: void 0,
      description: "v-bind 옵션값"
    },
    onProps: {
      type: Object,
      default: void 0,
      description: "v-on 옵션값"
    },
    className: {
      type: Object,
      description: "클래스 이름 값 할당",
      isActive: {
        type: Boolean,
        description: "액티브 유무"
      },
      default: void 0
    },
    alt: {
      type: String,
      default: void 0,
      description: "스크린 리더용 대체 텍스트"
    },
    aspectRatio: {
      type: [String, Number],
      default: void 0,
      description: "너비/높이로 계산되므로 1920x1080px 이미지의 경우 1.7778이 됨. 생략하면 자동으로 계산"
    },
    // contain: {
    //   type: Boolean,
    //   default: false,
    //   description: '크롭되는 이미지 사이즈를 예방함.',
    // },
    // contentClass: {
    //   type: String,
    //   default: undefined,
    //   description: '반응형 콘텐츠 div에 사용자 지정 클래스 적용',
    // },
    cover: {
      type: Boolean,
      default: !1,
      description: "전체 컨테이너를 덮도록 배경 이미지의 크기를 조정합니다."
    },
    // dark: {
    //   type: Boolean,
    //   default: false,
    //   description: '구성 요소에 어두운 테마 변형을 적용',
    // },
    eager: {
      type: Boolean,
      default: !1,
      description: "마운트 시 구성 요소 콘텐츠를 강제로 렌더링"
    },
    gradient: {
      type: String,
      default: void 0,
      description: "이미지에 그라디언트를 만든다. linear-gradient 만 서포트"
    },
    lazySrc: {
      type: String,
      default: void 0,
      description: "기본 이미지가 로드되기를 기다리는 동안 표시할 항목으로 일반적으로 base64로 인코딩된 작은 축소판"
    },
    lazySrcUrl: {
      type: String,
      default: void 0,
      description: "기본 경로가 아닌 경로에서 가져올 lazyload 이미지 경로"
    },
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      }),
      description: "Intersection ovserver 생성자에 전달되는 옵션"
    },
    sizes: {
      type: String,
      default: void 0,
      description: "srcset과 함께 사용."
    },
    src: {
      type: [String, Object],
      default: "",
      // { src: String, srcset: String, lazySrc: String, aspect: Number }
      description: "이미지 url"
    },
    srcUrl: {
      type: String,
      default: void 0,
      description: "기본 경로가 아닌 경로에서 가져올 이미지 경로"
    },
    srcset: {
      type: String,
      default: void 0,
      description: "장치 크기에 따라 사용할 대체 이미지"
    },
    transition: {
      type: String,
      default: "fade-transition",
      description: "lazy-src에서 src로 전환할 때 사용할 전환"
    },
    width: {
      type: [String, Number],
      default: void 0,
      description: "구성 요소의 너비를 설정"
    },
    publicPath: {
      type: String,
      default: "",
      description: "/public 이후의 경로"
    }
  },
  emits: ["error", "load", "loadstart"],
  setup(e, { emit: t }) {
    const n = t, a = e, i = k(() => a.srcUrl ? a.srcUrl : a.src ? a.publicPath ? `${a.publicPath}/${a.src}` : `/assets/images/${a.src}` : ""), l = k(() => {
      if (a.lazySrcUrl)
        return a.lazySrcUrl;
      if (a.lazySrc)
        return a.publicPath ? `${a.publicPath}/${a.lazySrc}` : `/assets/images/${a.lazySrc}`;
    }), r = (u) => {
      console.log(LN, "onError", u), n("error", u);
    }, s = (u) => {
      n("load", u);
    }, o = (u) => {
      n("loadstart", u);
    };
    return (u, c) => {
      const d = Pe("v-img");
      return N(), Ce(d, fe({
        class: ["s-img", { ...e.className }],
        alt: e.alt,
        "aspect-ratio": e.aspectRatio,
        cover: e.cover,
        eager: e.eager,
        gradient: e.gradient,
        "lazy-src": l.value,
        options: e.options,
        sizes: e.sizes,
        src: i.value,
        srcset: e.srcset,
        transition: e.transition,
        width: e.width
      }, e.bind, {
        onError: r,
        onLoad: s,
        onLoadstart: o
      }), {
        default: re(() => [
          ke(u.$slots, "default")
        ]),
        placeholder: re(() => [
          ke(u.$slots, "placeholder")
        ]),
        _: 3
      }, 16, ["class", "alt", "aspect-ratio", "cover", "eager", "gradient", "lazy-src", "options", "sizes", "src", "srcset", "transition", "width"]);
    };
  }
}, Af = {
  save: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M7.17739 2H5.16881C3.55139 2 2.24023 3.31115 2.24023 4.92857V19.0714C2.24023 20.6888 3.55139 22 5.16881 22H19.3117C20.9291 22 22.2402 20.6888 22.2402 19.0714V8.29883C22.2402 7.52212 21.9317 6.77723 21.3825 6.22802L18.0122 2.85777C17.463 2.30855 16.7181 2 15.9414 2L7.17773 2C7.17762 2 7.1775 2 7.17739 2ZM6.17773 4L6.17773 6.375C6.17773 7.5486 7.12913 8.5 8.30273 8.5L16.1777 8.5C17.3513 8.5 18.3027 7.5486 18.3027 6.375V5.97671L19.9683 7.64224L20.6754 6.93513L19.9683 7.64224C20.1424 7.81638 20.2402 8.05256 20.2402 8.29884V19.0714C20.2402 19.5843 19.8245 20 19.3117 20H18.3027V14.8125C18.3027 13.6389 17.3513 12.6875 16.1777 12.6875H8.30273C7.12913 12.6875 6.17773 13.6389 6.17773 14.8125V19.875C6.17773 19.9173 6.18036 19.9591 6.18547 20H5.16881C4.65596 20 4.24023 19.5843 4.24023 19.0714V4.92857C4.24023 4.41572 4.65596 4 5.16881 4H6.17773ZM8.17 20H16.3027V14.8125C16.3027 14.7435 16.2468 14.6875 16.1777 14.6875H8.30273C8.2337 14.6875 8.17773 14.7435 8.17773 14.8125V19.875C8.17773 19.9173 8.1751 19.9591 8.17 20ZM16.304 4.07374C16.3032 4.09071 16.3027 4.10781 16.3027 4.125V6.375C16.3027 6.44404 16.2468 6.5 16.1777 6.5L8.30273 6.5C8.2337 6.5 8.17773 6.44403 8.17773 6.375L8.17773 4H15.9414C16.0672 4 16.1904 4.02554 16.304 4.07374Z",
      fill: "currentColor"
    })
  ]),
  delete: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.24023 4.05882C8.24023 2.97639 9.08258 2 10.2402 2H14.2402C15.3979 2 16.2402 2.97639 16.2402 4.05882V5.11765C16.2402 5.13729 16.24 5.1569 16.2394 5.17647H20.2402C20.7925 5.17647 21.2402 5.62419 21.2402 6.17647C21.2402 6.72876 20.7925 7.17647 20.2402 7.17647H19.2394C19.24 7.19604 19.2402 7.21565 19.2402 7.23529V18.8824C19.2402 20.5496 17.9502 22 16.2402 22H8.24023C6.5303 22 5.24023 20.5496 5.24023 18.8824V7.23529C5.24023 7.21565 5.24051 7.19604 5.24106 7.17647H4.24023C3.68795 7.17647 3.24023 6.72876 3.24023 6.17647C3.24023 5.62419 3.68795 5.17647 4.24023 5.17647H8.24106C8.24051 5.1569 8.24023 5.13729 8.24023 5.11765V4.05882ZM7.25735 7.17647C7.25006 7.18579 7.24023 7.2047 7.24023 7.23529V18.8824C7.24023 19.5542 7.74103 20 8.24023 20H16.2402C16.7394 20 17.2402 19.5542 17.2402 18.8824V7.23529C17.2402 7.2047 17.2304 7.18579 17.2231 7.17647H7.25735ZM10.2574 4C10.2501 4.00932 10.2402 4.02823 10.2402 4.05882V5.11765C10.2402 5.14824 10.2501 5.16715 10.2574 5.17647H14.2231C14.2304 5.16715 14.2402 5.14824 14.2402 5.11765V4.05882C14.2402 4.02823 14.2304 4.00932 14.2231 4H10.2574ZM10.2402 9.41177C10.7925 9.41177 11.2402 9.85948 11.2402 10.4118V16.7647C11.2402 17.317 10.7925 17.7647 10.2402 17.7647C9.68795 17.7647 9.24023 17.317 9.24023 16.7647V10.4118C9.24023 9.85948 9.68795 9.41177 10.2402 9.41177ZM14.2402 9.41177C14.7925 9.41177 15.2402 9.85948 15.2402 10.4118V16.7647C15.2402 17.317 14.7925 17.7647 14.2402 17.7647C13.6879 17.7647 13.2402 17.317 13.2402 16.7647V10.4118C13.2402 9.85948 13.6879 9.41177 14.2402 9.41177Z",
      fill: "currentColor"
    })
  ]),
  excel: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M23.4921 19.1996C23.4921 21.0774 21.9699 22.5996 20.0921 22.5996L9.29183 22.5996C7.41406 22.5996 5.89182 21.0774 5.89182 19.1996L5.89182 18.529C5.89182 17.9767 6.33954 17.529 6.89182 17.529C7.44411 17.529 7.89182 17.9767 7.89182 18.529L7.89182 19.1996C7.89182 19.9728 8.51863 20.5996 9.29183 20.5996L20.0921 20.5996C20.8653 20.5996 21.4921 19.9728 21.4921 19.1996L21.4922 4.79967C21.4922 4.02647 20.8654 3.39967 20.0922 3.39967L9.29184 3.39967C8.51863 3.39967 7.89182 4.02647 7.89182 4.79968L7.89182 5.60181C7.89182 6.1541 7.44411 6.60181 6.89182 6.60181C6.33954 6.60181 5.89182 6.1541 5.89182 5.60181L5.89182 4.79968C5.89182 2.9219 7.41406 1.39967 9.29184 1.39967L20.0922 1.39967C21.97 1.39967 23.4922 2.92191 23.4922 4.79968L23.4921 19.1996Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M11.8008 15.8601L11.8008 8.22372C11.8008 7.62372 11.3099 7.13281 10.7099 7.13281L3.07351 7.13281C2.47351 7.13281 1.9826 7.62372 1.9826 8.22372L1.9826 15.8601C1.9826 16.4601 2.47351 16.951 3.07351 16.951L10.7099 16.951C11.3099 16.951 11.8008 16.4601 11.8008 15.8601ZM3.07351 15.8601L3.07351 8.22372L10.7099 8.22372L10.7099 15.8601L3.07351 15.8601Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.1016 8.22392L12.1016 15.8603C12.1016 16.626 11.4763 17.2512 10.7107 17.2512L3.07429 17.2512C2.3086 17.2512 1.68338 16.626 1.68338 15.8603L1.68338 8.22392C1.68338 7.45823 2.3086 6.83301 3.07429 6.83301L10.7107 6.83301C11.4763 6.83301 12.1016 7.45823 12.1016 8.22392ZM3.37429 8.52392L3.37429 15.5603L10.4107 15.5603L10.4107 8.52392L3.37429 8.52392ZM11.8016 8.22392L11.8016 15.8603C11.8016 16.4603 11.3107 16.9512 10.7107 16.9512L3.07429 16.9512C2.47429 16.9512 1.98338 16.4603 1.98338 15.8603L1.98338 8.22392C1.98338 7.62392 2.47429 7.13301 3.07429 7.13301L10.7107 7.13301C11.3107 7.13301 11.8016 7.62392 11.8016 8.22392ZM3.07429 15.8603L10.7107 15.8603L10.7107 8.22392L3.07429 8.22392L3.07429 15.8603Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M9.18174 9.75452C9.03994 9.61272 8.81087 9.61272 8.66907 9.75452L6.89111 11.5288L5.11315 9.75088C4.97135 9.60908 4.74229 9.60908 4.60049 9.75088C4.45869 9.89268 4.45869 10.1217 4.60049 10.2635L6.37845 12.0415L4.60049 13.8195C4.45869 13.9613 4.45869 14.1903 4.60049 14.3321C4.74229 14.4739 4.97135 14.4739 5.11315 14.3321L6.89111 12.5542L8.66907 14.3321C8.81087 14.4739 9.03994 14.4739 9.18174 14.3321C9.32354 14.1903 9.32354 13.9613 9.18174 13.8195L7.40378 12.0415L9.18174 10.2635C9.3199 10.1254 9.3199 9.89268 9.18174 9.75452Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.31588 9.4006C8.65297 9.0639 9.19835 9.06402 9.53529 9.40096C9.86872 9.73439 9.86872 10.2837 9.53529 10.6171L8.11088 12.0415L9.53529 13.4659C9.87235 13.803 9.87235 14.3486 9.53529 14.6857C9.19823 15.0227 8.65258 15.0227 8.31552 14.6857L6.89111 13.2613L5.46671 14.6857C5.12964 15.0227 4.584 15.0227 4.24694 14.6857C3.90987 14.3486 3.90987 13.803 4.24694 13.4659L5.67134 12.0415L4.24694 10.6171C3.90987 10.28 3.90987 9.73439 4.24694 9.39733C4.584 9.06027 5.12964 9.06027 5.46671 9.39733L6.89147 10.8221L8.31588 9.4006ZM8.66907 9.75452C8.81087 9.61272 9.03994 9.61272 9.18174 9.75452C9.3199 9.89268 9.3199 10.1254 9.18174 10.2635L7.40378 12.0415L9.18174 13.8195C9.32354 13.9613 9.32354 14.1903 9.18174 14.3321C9.03994 14.4739 8.81087 14.4739 8.66907 14.3321L6.89111 12.5542L5.11315 14.3321C4.97135 14.4739 4.74229 14.4739 4.60049 14.3321C4.45869 14.1903 4.45869 13.9613 4.60049 13.8195L6.37845 12.0415L4.60049 10.2635C4.45869 10.1217 4.45869 9.89268 4.60049 9.75088C4.74229 9.60908 4.97135 9.60908 5.11315 9.75088L6.89108 11.5288L8.66907 9.75452Z",
      fill: "currentColor"
    })
  ]),
  register: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.33994 4.79988C2.33995 2.92212 3.86218 1.3999 5.73994 1.3999H16.5402C18.418 1.3999 19.9402 2.92213 19.9402 4.7999V11.3999C19.9402 11.9522 19.4925 12.3999 18.9402 12.3999C18.3879 12.3999 17.9402 11.9522 17.9402 11.3999V4.7999C17.9402 4.0267 17.3134 3.3999 16.5402 3.3999H5.73994C4.96674 3.3999 4.33994 4.0267 4.33994 4.7999L4.33984 19.1998C4.33984 19.973 4.96664 20.5998 5.73984 20.5998H10.5398C11.0921 20.5998 11.5398 21.0476 11.5398 21.5998C11.5398 22.1521 11.0921 22.5998 10.5398 22.5998H5.73983C3.86206 22.5998 2.33983 21.0776 2.33984 19.1998L2.33994 4.79988ZM6.54022 7.1999C6.54022 6.64762 6.98793 6.1999 7.54022 6.1999H14.7402C15.2925 6.1999 15.7402 6.64762 15.7402 7.1999C15.7402 7.75219 15.2925 8.1999 14.7402 8.1999H7.54022C6.98793 8.1999 6.54022 7.75219 6.54022 7.1999ZM6.54022 10.7999C6.54022 10.2476 6.98793 9.7999 7.54022 9.7999H14.7402C15.2925 9.7999 15.7402 10.2476 15.7402 10.7999C15.7402 11.3522 15.2925 11.7999 14.7402 11.7999H7.54022C6.98793 11.7999 6.54022 11.3522 6.54022 10.7999ZM6.54022 14.3999C6.54022 13.8476 6.98793 13.3999 7.54022 13.3999H11.1402C11.6925 13.3999 12.1402 13.8476 12.1402 14.3999C12.1402 14.9522 11.6925 15.3999 11.1402 15.3999H7.54022C6.98793 15.3999 6.54022 14.9522 6.54022 14.3999ZM21.8473 14.8926C22.2378 15.2831 22.2379 15.9163 21.8473 16.3068L17.0473 21.107C16.8598 21.2945 16.6054 21.3999 16.3402 21.3999C16.075 21.3999 15.8207 21.2945 15.6331 21.107L13.4331 18.907C13.0426 18.5165 13.0426 17.8833 13.4331 17.4928C13.8236 17.1023 14.4568 17.1023 14.8473 17.4928L16.3402 18.9857L20.4331 14.8926C20.8236 14.5021 21.4568 14.5021 21.8473 14.8926Z",
      fill: "currentColor"
    })
  ]),
  edit: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.59775 4.7574C1.59776 2.87964 3.11999 1.35742 4.99775 1.35742H15.798C17.6758 1.35742 19.198 2.87965 19.198 4.75742V9.55742C19.198 10.1097 18.7503 10.5574 18.198 10.5574C17.6457 10.5574 17.198 10.1097 17.198 9.55742V4.75742C17.198 3.98422 16.5712 3.35742 15.798 3.35742H4.99775C4.22456 3.35742 3.59775 3.98422 3.59775 4.75741L3.59766 19.1574C3.59765 19.9306 4.22445 20.5574 4.99765 20.5574H9.79766C10.3499 20.5574 10.7977 21.0051 10.7977 21.5574C10.7977 22.1096 10.3499 22.5574 9.79766 22.5574H4.99764C3.11987 22.5574 1.59764 21.0351 1.59766 19.1573L1.59775 4.7574ZM5.79803 7.15742C5.79803 6.60514 6.24575 6.15742 6.79803 6.15742H13.998C14.5503 6.15742 14.998 6.60514 14.998 7.15742C14.998 7.70971 14.5503 8.15742 13.998 8.15742H6.79803C6.24575 8.15742 5.79803 7.70971 5.79803 7.15742ZM5.79803 10.7574C5.79803 10.2051 6.24575 9.75742 6.79803 9.75742H13.998C14.5503 9.75742 14.998 10.2051 14.998 10.7574C14.998 11.3097 14.5503 11.7574 13.998 11.7574H6.79803C6.24575 11.7574 5.79803 11.3097 5.79803 10.7574ZM17.7819 12.4502C18.1724 12.0597 18.8056 12.0597 19.1961 12.4502L22.5902 15.8443C22.7778 16.0318 22.8831 16.2862 22.8831 16.5514C22.8831 16.8166 22.7778 17.071 22.5902 17.2585L17.4991 22.3497C17.3115 22.5372 17.0572 22.6426 16.792 22.6426H13.3979C12.8456 22.6426 12.3979 22.1948 12.3979 21.6426V18.2484C12.3979 17.9832 12.5032 17.7289 12.6907 17.5413L17.7819 12.4502ZM18.489 14.5715L14.3979 18.6627V20.6426H16.3778L20.4689 16.5514L18.489 14.5715ZM5.79803 14.3574C5.79803 13.8051 6.24575 13.3574 6.79803 13.3574H10.398C10.9503 13.3574 11.398 13.8051 11.398 14.3574C11.398 14.9097 10.9503 15.3574 10.398 15.3574H6.79803C6.24575 15.3574 5.79803 14.9097 5.79803 14.3574Z",
      fill: "currentColor"
    })
  ]),
  settings: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M19.673 12.98C19.713 12.66 19.743 12.34 19.743 12C19.743 11.66 19.713 11.34 19.673 11.02L21.783 9.37C21.973 9.22 22.023 8.95 21.903 8.73L19.903 5.27C19.813 5.11 19.643 5.02 19.463 5.02C19.403 5.02 19.343 5.03 19.293 5.05L16.803 6.05C16.283 5.65 15.723 5.32 15.113 5.07L14.733 2.42C14.703 2.18 14.493 2 14.243 2H10.243C9.993 2 9.783 2.18 9.753 2.42L9.373 5.07C8.763 5.32 8.203 5.66 7.683 6.05L5.193 5.05C5.133 5.03 5.073 5.02 5.013 5.02C4.843 5.02 4.673 5.11 4.583 5.27L2.583 8.73C2.453 8.95 2.513 9.22 2.703 9.37L4.813 11.02C4.773 11.34 4.743 11.67 4.743 12C4.743 12.33 4.773 12.66 4.813 12.98L2.703 14.63C2.513 14.78 2.463 15.05 2.583 15.27L4.583 18.73C4.673 18.89 4.843 18.98 5.023 18.98C5.083 18.98 5.143 18.97 5.193 18.95L7.683 17.95C8.203 18.35 8.763 18.68 9.373 18.93L9.753 21.58C9.783 21.82 9.993 22 10.243 22H14.243C14.493 22 14.703 21.82 14.733 21.58L15.113 18.93C15.723 18.68 16.283 18.34 16.803 17.95L19.293 18.95C19.353 18.97 19.413 18.98 19.473 18.98C19.643 18.98 19.813 18.89 19.903 18.73L21.903 15.27C22.023 15.05 21.973 14.78 21.783 14.63L19.673 12.98ZM17.693 11.27C17.733 11.58 17.743 11.79 17.743 12C17.743 12.21 17.723 12.43 17.693 12.73L17.553 13.86L18.443 14.56L19.523 15.4L18.823 16.61L17.553 16.1L16.513 15.68L15.613 16.36C15.183 16.68 14.773 16.92 14.363 17.09L13.303 17.52L13.143 18.65L12.943 20H11.543L11.193 17.52L10.133 17.09C9.703 16.91 9.303 16.68 8.903 16.38L7.993 15.68L6.933 16.11L5.663 16.62L4.963 15.41L6.043 14.57L6.933 13.87L6.793 12.74C6.763 12.43 6.743 12.2 6.743 12C6.743 11.8 6.763 11.57 6.793 11.27L6.933 10.14L6.043 9.44L4.963 8.6L5.663 7.39L6.933 7.9L7.973 8.32L8.873 7.64C9.303 7.32 9.713 7.08 10.123 6.91L11.183 6.48L11.343 5.35L11.543 4H12.933L13.283 6.48L14.343 6.91C14.773 7.09 15.173 7.32 15.573 7.62L16.483 8.32L17.543 7.89L18.813 7.38L19.513 8.59L18.443 9.44L17.553 10.14L17.693 11.27ZM12.243 8C10.033 8 8.243 9.79 8.243 12C8.243 14.21 10.033 16 12.243 16C14.453 16 16.243 14.21 16.243 12C16.243 9.79 14.453 8 12.243 8ZM12.243 14C11.143 14 10.243 13.1 10.243 12C10.243 10.9 11.143 10 12.243 10C13.343 10 14.243 10.9 14.243 12C14.243 13.1 13.343 14 12.243 14Z",
      fill: "currentColor"
    })
  ]),
  branch: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.94882 5.45605C5.1972 5.45605 4.58789 6.06536 4.58789 6.81698C4.58789 7.56853 5.19721 8.17786 5.9489 8.17786C6.70051 8.17786 7.30975 7.56862 7.30975 6.81698C7.30975 6.06536 6.70044 5.45605 5.94882 5.45605ZM2.58789 6.81698C2.58789 4.96079 4.09263 3.45605 5.94882 3.45605C7.46185 3.45605 8.74137 4.45585 9.16275 5.83083C9.21699 5.82173 9.27272 5.81698 9.32955 5.81698H15.819C15.827 5.81698 15.8349 5.81708 15.8428 5.81727C16.2707 4.45309 17.5449 3.46344 19.0502 3.46344C20.9064 3.46344 22.4111 4.96817 22.4111 6.82437C22.4111 8.68056 20.9064 10.1853 19.0502 10.1853C17.5395 10.1853 16.2616 9.18855 15.8382 7.8168C15.8318 7.81693 15.8254 7.81699 15.819 7.81699H11.1624C11.337 8.26098 11.44 8.78987 11.44 9.41393V14.5931C11.44 15.5551 11.8042 15.8705 12.0245 16.0044C12.1667 16.0908 12.3166 16.1379 12.4359 16.1621C12.4938 16.1738 12.5392 16.1791 12.5652 16.1813C12.5734 16.182 12.5794 16.1824 12.583 16.1826H15.4268C15.5194 16.1826 15.6091 16.1952 15.6942 16.2188C16.1085 14.8323 17.3937 13.8217 18.9149 13.8217C20.771 13.8217 22.2758 15.3264 22.2758 17.1826C22.2758 19.0388 20.771 20.5436 18.9149 20.5436C17.3937 20.5436 16.1085 19.5329 15.6942 18.1465C15.6091 18.17 15.5194 18.1826 15.4268 18.1826H12.5702V17.1826C12.5702 18.1826 12.5696 18.1826 12.569 18.1826L12.5677 18.1826L12.565 18.1826L12.559 18.1826L12.5445 18.1823C12.5337 18.1821 12.5208 18.1818 12.5058 18.1812C12.4759 18.18 12.4376 18.1778 12.3922 18.1738C12.3017 18.166 12.1806 18.151 12.0388 18.1222C11.7587 18.0655 11.376 17.9507 10.9857 17.7135C10.1409 17.2 9.43998 16.2205 9.43998 14.5931V9.41393C9.43998 8.69249 9.23507 8.33302 9.03889 8.14106C8.52497 9.33888 7.33495 10.1779 5.9489 10.1779C4.09279 10.1779 2.58789 8.67325 2.58789 6.81698ZM19.0502 5.46344C18.2986 5.46344 17.6893 6.07275 17.6893 6.82437C17.6893 7.57599 18.2986 8.1853 19.0502 8.1853C19.8018 8.1853 20.4111 7.57599 20.4111 6.82437C20.4111 6.07275 19.8018 5.46344 19.0502 5.46344ZM18.9149 15.8217C18.1632 15.8217 17.5539 16.431 17.5539 17.1826C17.5539 17.9342 18.1632 18.5436 18.9149 18.5436C19.6665 18.5436 20.2758 17.9342 20.2758 17.1826C20.2758 16.431 19.6665 15.8217 18.9149 15.8217Z",
      fill: "currentColor"
    })
  ]),
  commit: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.4603 10.2661C11.5028 10.2661 10.7266 11.0423 10.7266 11.9998C10.7266 12.9573 11.5028 13.7335 12.4603 13.7335C13.4178 13.7335 14.194 12.9573 14.194 11.9998C14.194 11.0423 13.4178 10.2661 12.4603 10.2661ZM8.86206 10.9998C9.29924 9.42333 10.7446 8.26611 12.4603 8.26611C14.1111 8.26611 15.5117 9.33745 16.0047 10.8228H22.1004C22.6527 10.8228 23.1004 11.2705 23.1004 11.8228C23.1004 12.3751 22.6527 12.8228 22.1004 12.8228H16.1031C15.7283 14.4889 14.2396 15.7335 12.4603 15.7335C10.7446 15.7335 9.29924 14.5763 8.86206 12.9998H2.90039C2.34811 12.9998 1.90039 12.5521 1.90039 11.9998C1.90039 11.4475 2.34811 10.9998 2.90039 10.9998H8.86206Z",
      fill: "currentColor"
    })
  ]),
  "prepaid-history": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.69922 4.8C3.69922 3.39274 4.71582 2 6.25922 2H18.7392C20.2826 2 21.2992 3.39274 21.2992 4.8V21C21.2992 21.3719 21.0928 21.7132 20.7633 21.8858C20.4339 22.0584 20.0358 22.0339 19.73 21.8222L17.6992 20.4163L15.6684 21.8222C15.326 22.0593 14.8725 22.0593 14.53 21.8222L12.4992 20.4163L10.4684 21.8222C10.126 22.0593 9.67245 22.0593 9.33001 21.8222L7.29922 20.4163L5.26843 21.8222C4.96262 22.0339 4.56457 22.0584 4.23511 21.8858C3.90565 21.7132 3.69922 21.3719 3.69922 21V4.8ZM6.25922 4C6.07949 4 5.69922 4.21904 5.69922 4.8V19.0914L6.73001 18.3778C7.07245 18.1407 7.52598 18.1407 7.86843 18.3778L9.89922 19.7837L11.93 18.3778C12.2725 18.1407 12.726 18.1407 13.0684 18.3778L15.0992 19.7837L17.13 18.3778C17.4725 18.1407 17.926 18.1407 18.2684 18.3778L19.2992 19.0914V4.8C19.2992 4.21904 18.9189 4 18.7392 4H6.25922Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.4998 4.54004C13.0521 4.54004 13.4998 4.98775 13.4998 5.54004V6.44655H13.7708C13.7852 6.44655 13.7996 6.44686 13.8139 6.44748C14.3935 6.47251 14.9524 6.67042 15.4186 7.01574C15.8848 7.36106 16.237 7.83799 16.4298 8.38516C16.6134 8.90604 16.3399 9.47712 15.8191 9.6607C15.2982 9.84428 14.7271 9.57084 14.5435 9.04996C14.4834 8.87931 14.3735 8.73056 14.2281 8.62286C14.0875 8.51865 13.9197 8.45748 13.7452 8.44655H11.2288C10.9884 8.44655 10.7578 8.54206 10.5878 8.71206C10.4178 8.88207 10.3223 9.11264 10.3223 9.35306C10.3223 9.59349 10.4178 9.82406 10.5878 9.99407C10.7578 10.1641 10.9884 10.2596 11.2288 10.2596H13.7708C14.5416 10.2596 15.2809 10.5658 15.826 11.1109C16.3711 11.656 16.6773 12.3952 16.6773 13.1661C16.6773 13.9369 16.3711 14.6762 15.826 15.2213C15.2809 15.7664 14.5416 16.0726 13.7708 16.0726H13.4998V16.9791C13.4998 17.5314 13.0521 17.9791 12.4998 17.9791C11.9475 17.9791 11.4998 17.5314 11.4998 16.9791V16.0726H11.2288C11.2144 16.0726 11.2 16.0723 11.1856 16.0717C10.606 16.0466 10.0472 15.8487 9.58098 15.5034C9.1148 15.1581 8.76262 14.6812 8.56978 14.134C8.3862 13.6131 8.65963 13.042 9.18051 12.8585C9.7014 12.6749 10.2725 12.9483 10.4561 13.4692C10.5162 13.6398 10.626 13.7886 10.7714 13.8963C10.9121 14.0005 11.0799 14.0617 11.2543 14.0726H13.7708C14.0112 14.0726 14.2418 13.9771 14.4118 13.8071C14.5818 13.6371 14.6773 13.4065 14.6773 13.1661C14.6773 12.9257 14.5818 12.6951 14.4118 12.5251C14.2418 12.3551 14.0112 12.2596 13.7708 12.2596H11.2288C10.4579 12.2596 9.71864 11.9534 9.17356 11.4083C8.62849 10.8632 8.32227 10.1239 8.32227 9.35306C8.32227 8.58221 8.62849 7.84293 9.17356 7.29785C9.71864 6.75277 10.4579 6.44655 11.2288 6.44655H11.4998V5.54004C11.4998 4.98775 11.9475 4.54004 12.4998 4.54004Z",
      fill: "currentColor"
    })
  ]),
  "cost-approval": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.19931 4.79988C2.19932 2.92212 3.72155 1.3999 5.59931 1.3999H16.3996C18.2773 1.3999 19.7996 2.92213 19.7996 4.7999V11.3999C19.7996 11.9522 19.3519 12.3999 18.7996 12.3999C18.2473 12.3999 17.7996 11.9522 17.7996 11.3999V4.7999C17.7996 4.0267 17.1728 3.3999 16.3996 3.3999H5.59931C4.82612 3.3999 4.19932 4.0267 4.19931 4.7999L4.19922 19.1998C4.19921 19.973 4.82601 20.5998 5.59921 20.5998H10.3992C10.9515 20.5998 11.3992 21.0476 11.3992 21.5998C11.3992 22.1521 10.9515 22.5998 10.3992 22.5998H5.5992C3.72143 22.5998 2.19921 21.0776 2.19922 19.1998L2.19931 4.79988ZM22.4819 13.6688C22.8857 14.0457 22.9075 14.6785 22.5306 15.0822L16.9306 21.0822C16.7456 21.2805 16.488 21.3951 16.2168 21.3998C15.9457 21.4044 15.6842 21.2988 15.4925 21.107L13.2925 18.907C12.902 18.5165 12.902 17.8833 13.2925 17.4928C13.683 17.1023 14.3162 17.1023 14.7067 17.4928L16.1748 18.9609L21.0685 13.7176C21.4454 13.3138 22.0782 13.292 22.4819 13.6688Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.1189 4.92773C11.6712 4.92773 12.1189 5.37545 12.1189 5.92773V6.83425H12.3899C12.4043 6.83425 12.4187 6.83456 12.4331 6.83518C13.0127 6.8602 13.5715 7.05811 14.0377 7.40344C14.5039 7.74876 14.8561 8.22569 15.0489 8.77285C15.2325 9.29373 14.9591 9.86481 14.4382 10.0484C13.9173 10.232 13.3462 9.95854 13.1627 9.43766C13.1025 9.267 12.9927 9.11825 12.8473 9.01055C12.7066 8.90635 12.5389 8.84518 12.3644 8.83425H9.84792C9.6075 8.83425 9.37692 8.92975 9.20692 9.09976C9.03691 9.26976 8.94141 9.50034 8.94141 9.74076C8.94141 9.98118 9.03691 10.2118 9.20692 10.3818C9.37692 10.5518 9.6075 10.6473 9.84792 10.6473H12.3899C13.1608 10.6473 13.9001 10.9535 14.4451 11.4986C14.9902 12.0436 15.2964 12.7829 15.2964 13.5538C15.2964 14.3246 14.9902 15.0639 14.4451 15.609C13.9001 16.1541 13.1608 16.4603 12.3899 16.4603H12.1189V17.3668C12.1189 17.9191 11.6712 18.3668 11.1189 18.3668C10.5666 18.3668 10.1189 17.9191 10.1189 17.3668V16.4603H9.84792C9.83353 16.4603 9.81915 16.46 9.80478 16.4594C9.22517 16.4343 8.66631 16.2364 8.20012 15.8911C7.73394 15.5458 7.38176 15.0689 7.18892 14.5217C7.00534 14.0008 7.27877 13.4297 7.79966 13.2462C8.32054 13.0626 8.89161 13.336 9.0752 13.8569C9.13534 14.0275 9.24518 14.1763 9.39058 14.284C9.53126 14.3882 9.69899 14.4494 9.87346 14.4603H12.3899C12.6304 14.4603 12.8609 14.3648 13.0309 14.1948C13.2009 14.0248 13.2964 13.7942 13.2964 13.5538C13.2964 13.3134 13.2009 13.0828 13.0309 12.9128C12.8609 12.7428 12.6304 12.6473 12.3899 12.6473H9.84792C9.07706 12.6473 8.33778 12.3411 7.7927 11.796C7.24763 11.2509 6.94141 10.5116 6.94141 9.74076C6.94141 8.9699 7.24763 8.23062 7.7927 7.68554C8.33778 7.14047 9.07706 6.83425 9.84792 6.83425H10.1189V5.92773C10.1189 5.37545 10.5666 4.92773 11.1189 4.92773Z",
      fill: "currentColor"
    })
  ]),
  router: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M15.5627 16.0074C15.9532 16.398 15.9532 17.0311 15.5627 17.4217L13.2057 19.7787C12.8152 20.1692 12.182 20.1692 11.7915 19.7787L9.43446 17.4217C9.04394 17.0311 9.04394 16.398 9.43446 16.0074C9.82498 15.6169 10.4581 15.6169 10.8487 16.0074L11.4986 16.6574L11.4986 13.7683C11.4986 13.216 11.9463 12.7683 12.4986 12.7683C13.0509 12.7683 13.4986 13.216 13.4986 13.7683L13.4986 16.6574L14.1485 16.0074C14.539 15.6169 15.1722 15.6169 15.5627 16.0074Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.43533 7.99353C9.0448 7.60301 9.0448 6.96984 9.43533 6.57932L11.7924 4.2223C12.1829 3.83177 12.816 3.83177 13.2066 4.2223L15.5636 6.57932C15.9541 6.96985 15.9541 7.60301 15.5636 7.99353C15.1731 8.38406 14.5399 8.38406 14.1494 7.99353L13.4995 7.34362L13.4995 10.2327C13.4995 10.785 13.0517 11.2327 12.4995 11.2327C11.9472 11.2327 11.4995 10.785 11.4995 10.2327L11.4995 7.34362L10.8495 7.99353C10.459 8.38406 9.82585 8.38406 9.43533 7.99353Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.5055 8.9363C16.896 8.54578 17.5292 8.54578 17.9197 8.93631L20.2767 11.2933C20.6672 11.6839 20.6672 12.317 20.2767 12.7075L17.9197 15.0646C17.5292 15.4551 16.896 15.4551 16.5055 15.0646C16.115 14.674 16.115 14.0409 16.5055 13.6503L17.1554 13.0004L14.2663 13.0004C13.714 13.0004 13.2663 12.5527 13.2663 12.0004C13.2663 11.4481 13.714 11.0004 14.2663 11.0004L17.1554 11.0004L16.5055 10.3505C16.115 9.95999 16.115 9.32683 16.5055 8.9363Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.49256 15.0637C8.10203 15.4542 7.46887 15.4542 7.07834 15.0637L4.72132 12.7067C4.3308 12.3161 4.3308 11.683 4.72132 11.2925L7.07834 8.93544C7.46887 8.54491 8.10203 8.54491 8.49256 8.93544C8.88308 9.32596 8.88308 9.95913 8.49256 10.3497L7.84264 10.9996L10.7317 10.9996C11.284 10.9996 11.7317 11.4473 11.7317 11.9996C11.7317 12.5519 11.284 12.9996 10.7317 12.9996L7.84264 12.9996L8.49256 13.6495C8.88308 14.04 8.88308 14.6732 8.49256 15.0637Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.864 5.63604C15.3492 2.12132 9.65076 2.12132 6.13604 5.63604C2.62132 9.15076 2.62132 14.8492 6.13604 18.364C9.65076 21.8787 15.3492 21.8787 18.864 18.364C22.3787 14.8492 22.3787 9.15076 18.864 5.63604ZM4.72183 4.22183C9.01759 -0.0739419 15.9824 -0.0739419 20.2782 4.22183C24.5739 8.51759 24.5739 15.4824 20.2782 19.7782C15.9824 24.0739 9.01759 24.0739 4.72183 19.7782C0.426058 15.4824 0.426058 8.51759 4.72183 4.22183Z",
      fill: "currentColor"
    })
  ]),
  deployRequest: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 23 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.95867 3.77529C6.61644 3.43306 6.61644 2.87819 6.95867 2.53596L8.87517 0.619457C9.03952 0.455113 9.26242 0.362784 9.49483 0.362785C9.72725 0.362785 9.95015 0.455113 10.1145 0.619457L12.031 2.53596C12.3732 2.87819 12.3732 3.43306 12.031 3.77529C11.6888 4.11752 11.1339 4.11752 10.7917 3.77529L10.3712 3.35478L10.3712 7.91811C10.3712 8.40209 9.97882 8.79444 9.49483 8.79444C9.01085 8.79444 8.6185 8.40209 8.6185 7.91811L8.6185 3.35478L8.19799 3.77529C7.85576 4.11752 7.3009 4.11752 6.95867 3.77529Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.83539 9.08374C2.36789 9.20901 1.88737 8.93158 1.7621 8.46408L1.06061 5.84609C1.00046 5.62159 1.03195 5.38239 1.14816 5.18111C1.26437 4.97983 1.45578 4.83295 1.68028 4.7728L4.29827 4.07131C4.76576 3.94605 5.24629 4.22348 5.37156 4.69097C5.49682 5.15847 5.21939 5.639 4.75189 5.76426L4.17747 5.91818L8.12943 8.19984C8.54857 8.44183 8.69218 8.97779 8.45019 9.39694C8.2082 9.81608 7.67224 9.95969 7.25309 9.7177L3.30114 7.43603L3.45505 8.01046C3.58032 8.47795 3.30288 8.95848 2.83539 9.08374Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.1529 9.08374C16.6204 9.20901 17.1009 8.93158 17.2262 8.46408L17.9277 5.84609C17.9878 5.62159 17.9563 5.38239 17.8401 5.18111C17.7239 4.97983 17.5325 4.83295 17.308 4.7728L14.69 4.07131C14.2225 3.94605 13.742 4.22348 13.6167 4.69097C13.4915 5.15847 13.7689 5.639 14.2364 5.76426L14.8108 5.91818L10.8589 8.19984C10.4397 8.44183 10.2961 8.97779 10.5381 9.39694C10.7801 9.81608 11.316 9.95969 11.7352 9.7177L15.6871 7.43603L15.5332 8.01046C15.408 8.47795 15.6854 8.95848 16.1529 9.08374Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.0296 16.2247C12.3718 16.5669 12.3718 17.1218 12.0296 17.464L10.1131 19.3805C9.94877 19.5449 9.72586 19.6372 9.49345 19.6372C9.26103 19.6372 9.03813 19.5449 8.87378 19.3805L6.95728 17.464C6.61505 17.1218 6.61505 16.5669 6.95728 16.2247C7.29951 15.8825 7.85438 15.8825 8.19661 16.2247L8.61711 16.6452L8.61711 12.0819C8.61711 11.5979 9.00946 11.2056 9.49345 11.2056C9.97743 11.2056 10.3698 11.5979 10.3698 12.0819L10.3698 16.6452L10.7903 16.2247C11.1325 15.8825 11.6874 15.8825 12.0296 16.2247Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.83539 10.9163C2.3679 10.791 1.88737 11.0684 1.7621 11.5359L1.06061 14.1539C1.00046 14.3784 1.03195 14.6176 1.14816 14.8189C1.26437 15.0202 1.45578 15.167 1.68028 15.2272L4.29827 15.9287C4.76576 16.054 5.24629 15.7765 5.37156 15.309C5.49682 14.8415 5.21939 14.361 4.75189 14.2357L4.17747 14.0818L8.12943 11.8002C8.54857 11.5582 8.69218 11.0222 8.45019 10.6031C8.2082 10.1839 7.67224 10.0403 7.25309 10.2823L3.30114 12.564L3.45505 11.9895C3.58032 11.522 3.30289 11.0415 2.83539 10.9163Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M13.4323 11.2623L11.7346 10.2821C11.3154 10.0401 10.7795 10.1837 10.5375 10.6029C10.2955 11.022 10.4391 11.558 10.8582 11.8L12.6558 12.8378C12.8235 12.2646 13.0887 11.733 13.4323 11.2623Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M21.8239 10.5068C22.2802 10.9631 22.2802 11.7029 21.8239 12.1592L17.6175 16.3656C17.1612 16.8219 16.4214 16.8219 15.9651 16.3656L14.5629 14.9635C14.1066 14.5072 14.1066 13.7674 14.5629 13.3111C15.0192 12.8547 15.7591 12.8547 16.2154 13.3111L16.7913 13.887L20.1715 10.5068C20.6278 10.0505 21.3676 10.0505 21.8239 10.5068Z",
      fill: "currentColor"
    })
  ]),
  deploy: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.96453 5.77577C9.6223 5.43354 9.6223 4.87868 9.96453 4.53645L11.881 2.61995C12.0454 2.4556 12.2683 2.36327 12.5007 2.36327C12.7331 2.36327 12.956 2.4556 13.1204 2.61995L15.0369 4.53645C15.3791 4.87868 15.3791 5.43354 15.0369 5.77577C14.6946 6.118 14.1398 6.118 13.7975 5.77577L13.377 5.35527L13.377 9.9186C13.377 10.4026 12.9847 10.7949 12.5007 10.7949C12.0167 10.7949 11.6244 10.4026 11.6244 9.91859L11.6244 5.35527L11.2039 5.77577C10.8616 6.118 10.3068 6.118 9.96453 5.77577Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.84125 11.0842C5.37375 11.2095 4.89323 10.9321 4.76796 10.4646L4.06647 7.84658C4.00632 7.62208 4.03781 7.38288 4.15402 7.1816C4.27023 6.98032 4.46164 6.83344 4.68614 6.77329L7.30413 6.0718C7.77162 5.94654 8.25215 6.22397 8.37742 6.69146C8.50268 7.15896 8.22525 7.63948 7.75775 7.76475L7.18333 7.91867L11.1353 10.2003C11.5544 10.4423 11.698 10.9783 11.456 11.3974C11.2141 11.8166 10.6781 11.9602 10.259 11.7182L6.307 9.43652L6.46091 10.0109C6.58618 10.4784 6.30874 10.959 5.84125 11.0842Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M19.1588 11.0842C19.6262 11.2095 20.1068 10.9321 20.232 10.4646L20.9335 7.84658C20.9937 7.62208 20.9622 7.38288 20.846 7.1816C20.7298 6.98032 20.5384 6.83344 20.3139 6.77329L17.6959 6.0718C17.2284 5.94654 16.7478 6.22397 16.6226 6.69146C16.4973 7.15896 16.7748 7.63948 17.2422 7.76475L17.8167 7.91867L13.8647 10.2003C13.4456 10.4423 13.302 10.9783 13.544 11.3974C13.7859 11.8166 14.3219 11.9602 14.741 11.7182L18.693 9.43652L18.5391 10.0109C18.4138 10.4784 18.6913 10.959 19.1588 11.0842Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M15.0355 18.2247C15.3777 18.5669 15.3777 19.1218 15.0355 19.464L13.119 21.3805C12.9546 21.5449 12.7317 21.6372 12.4993 21.6372C12.2669 21.6372 12.044 21.5449 11.8796 21.3805L9.96314 19.464C9.62091 19.1218 9.62091 18.5669 9.96314 18.2247C10.3054 17.8825 10.8602 17.8825 11.2025 18.2247L11.623 18.6452L11.623 14.0819C11.623 13.5979 12.0153 13.2056 12.4993 13.2056C12.9833 13.2056 13.3756 13.5979 13.3756 14.0819L13.3756 18.6452L13.7961 18.2247C14.1384 17.8825 14.6932 17.8825 15.0355 18.2247Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M19.1588 12.9158C19.6262 12.7905 20.1068 13.0679 20.232 13.5354L20.9335 16.1534C20.9937 16.3779 20.9622 16.6171 20.846 16.8184C20.7298 17.0197 20.5384 17.1666 20.3139 17.2267L17.6959 17.9282C17.2284 18.0535 16.7478 17.776 16.6226 17.3085C16.4973 16.841 16.7748 16.3605 17.2422 16.2353L17.8167 16.0813L13.8647 13.7997C13.4456 13.5577 13.302 13.0217 13.544 12.6026C13.7859 12.1834 14.3219 12.0398 14.741 12.2818L18.693 14.5635L18.5391 13.9891C18.4138 13.5216 18.6913 13.041 19.1588 12.9158Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.84125 12.9158C5.37375 12.7905 4.89323 13.0679 4.76796 13.5354L4.06647 16.1534C4.00632 16.3779 4.03781 16.6171 4.15402 16.8184C4.27023 17.0197 4.46164 17.1666 4.68614 17.2267L7.30413 17.9282C7.77162 18.0535 8.25215 17.776 8.37742 17.3085C8.50268 16.841 8.22525 16.3605 7.75775 16.2353L7.18333 16.0813L11.1353 13.7997C11.5544 13.5577 11.698 13.0217 11.456 12.6026C11.2141 12.1834 10.6781 12.0398 10.259 12.2818L6.307 14.5635L6.46091 13.9891C6.58618 13.5216 6.30874 13.041 5.84125 12.9158Z",
      fill: "currentColor"
    })
  ]),
  network: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.58198 7.36426L8.46571 7.36426C8.55563 5.83552 8.85006 4.42551 9.30428 3.28459C7.88723 4.17769 6.87002 5.64735 6.58198 7.36426ZM12.499 0.364258C8.08075 0.364258 4.49902 3.94598 4.49902 8.36426C4.49902 12.4365 7.54163 15.798 11.4775 16.2997V17.7245C10.5992 18.0374 9.90701 18.7425 9.61155 19.6289H3.48828C2.936 19.6289 2.48828 20.0766 2.48828 20.6289C2.48828 21.1812 2.936 21.6289 3.48828 21.6289H9.63736C10.0615 22.7989 11.1826 23.6348 12.499 23.6348C13.8154 23.6348 14.9366 22.7989 15.3607 21.6289H21.5101C22.0624 21.6289 22.5101 21.1812 22.5101 20.6289C22.5101 20.0766 22.0624 19.6289 21.5101 19.6289H15.3865C15.0862 18.7281 14.3762 18.0146 13.4775 17.7096V16.305C17.4342 15.8225 20.499 12.4513 20.499 8.36426C20.499 3.94598 16.9173 0.364258 12.499 0.364258ZM12.499 2.36426C12.407 2.36426 12.2406 2.40266 12.002 2.6333C11.7586 2.8686 11.4938 3.25735 11.2497 3.81533C10.8537 4.72035 10.564 5.95237 10.4696 7.36426L14.5284 7.36426C14.434 5.95237 14.1443 4.72035 13.7484 3.81533C13.5043 3.25735 13.2394 2.8686 12.996 2.6333C12.7575 2.40266 12.591 2.36426 12.499 2.36426ZM16.5323 7.36426C16.4424 5.83552 16.148 4.42551 15.6938 3.28459C17.1108 4.17769 18.128 5.64735 18.4161 7.36426L16.5323 7.36426ZM10.4696 9.36426C10.564 10.7762 10.8537 12.0082 11.2497 12.9132C11.4938 13.4712 11.7586 13.8599 12.002 14.0952C12.2406 14.3259 12.407 14.3643 12.499 14.3643C12.591 14.3643 12.7575 14.3259 12.996 14.0952C13.2394 13.8599 13.5043 13.4712 13.7484 12.9132C14.1443 12.0082 14.434 10.7762 14.5284 9.36426H10.4696ZM15.6938 13.4439C16.148 12.303 16.4424 10.893 16.5323 9.36426H18.4161C18.128 11.0812 17.1108 12.5508 15.6938 13.4439ZM9.30428 13.4439C8.85006 12.303 8.55563 10.893 8.46571 9.36426H6.58198C6.87002 11.0812 7.88723 12.5508 9.30428 13.4439ZM12.499 19.5488C11.923 19.5488 11.4561 20.0158 11.4561 20.5918C11.4561 21.1678 11.923 21.6348 12.499 21.6348C13.075 21.6348 13.542 21.1678 13.542 20.5918C13.542 20.0158 13.075 19.5488 12.499 19.5488Z",
      fill: "currentColor"
    })
  ]),
  ip: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M21.4604 9.73404C21.3278 8.26865 20.8171 6.86277 19.9782 5.65394C19.1393 4.44512 18.001 3.47476 16.6747 2.83778C15.3483 2.20081 13.8793 1.91905 12.4114 2.02006C10.9435 2.12107 9.52697 2.60139 8.30037 3.41404C7.24957 4.11668 6.36742 5.04334 5.71731 6.12743C5.0672 7.21152 4.66526 8.42614 4.54037 9.68404C4.41785 10.9337 4.57504 12.195 5.00054 13.3763C5.42604 14.5577 6.10917 15.6295 7.00037 16.514L12.3004 21.824C12.3933 21.9178 12.5039 21.9922 12.6258 22.0429C12.7477 22.0937 12.8784 22.1198 13.0104 22.1198C13.1424 22.1198 13.2731 22.0937 13.3949 22.0429C13.5168 21.9922 13.6274 21.9178 13.7204 21.824L19.0004 16.514C19.8916 15.6295 20.5747 14.5577 21.0002 13.3763C21.4257 12.195 21.5829 10.9337 21.4604 9.68404V9.73404ZM17.6004 15.104L13.0004 19.704L8.40037 15.104C7.72246 14.4261 7.20317 13.6064 6.87984 12.7038C6.5565 11.8012 6.43715 10.8382 6.53037 9.88404C6.62419 8.91514 6.93213 7.9792 7.43194 7.14388C7.93175 6.30856 8.61093 5.59474 9.42037 5.05404C10.4813 4.34927 11.7267 3.97333 13.0004 3.97333C14.2741 3.97333 15.5194 4.34927 16.5804 5.05404C17.3874 5.59265 18.065 6.30332 18.5647 7.13498C19.0644 7.96663 19.3737 8.89864 19.4704 9.86404C19.5666 10.8215 19.4488 11.7883 19.1254 12.6946C18.8019 13.6009 18.281 14.4239 17.6004 15.104Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M14.5063 10.4092C14.7863 10.4092 14.9997 10.3459 15.1463 10.2192C15.2997 10.0859 15.3763 9.88587 15.3763 9.6192C15.3763 9.36587 15.2963 9.17253 15.1363 9.0392C14.983 8.8992 14.7563 8.8292 14.4563 8.8292C14.3497 8.8292 14.2597 8.83253 14.1863 8.8392C14.1197 8.8392 14.0497 8.84587 13.9763 8.8592V10.4092H14.5063ZM13.9863 13.6192C13.913 13.6392 13.7963 13.6592 13.6363 13.6792C13.483 13.6992 13.3297 13.7092 13.1763 13.7092C13.023 13.7092 12.8863 13.6959 12.7663 13.6692C12.653 13.6492 12.5563 13.6092 12.4763 13.5492C12.3963 13.4892 12.3363 13.4059 12.2963 13.2992C12.2563 13.1925 12.2363 13.0525 12.2363 12.8792V8.1692C12.2363 8.0292 12.273 7.92253 12.3463 7.8492C12.4263 7.7692 12.533 7.70587 12.6663 7.6592C12.893 7.5792 13.1497 7.52253 13.4363 7.4892C13.7297 7.4492 14.023 7.4292 14.3163 7.4292C15.2363 7.4292 15.9397 7.62587 16.4263 8.0192C16.913 8.41253 17.1563 8.94587 17.1563 9.6192C17.1563 9.94587 17.103 10.2425 16.9963 10.5092C16.8963 10.7692 16.743 10.9959 16.5363 11.1892C16.3363 11.3759 16.0797 11.5225 15.7663 11.6292C15.4597 11.7292 15.103 11.7792 14.6963 11.7792H13.9863V13.6192Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M10.9395 13.6193C10.8661 13.6393 10.7495 13.6593 10.5895 13.6793C10.4361 13.6993 10.2828 13.7093 10.1295 13.7093C9.97612 13.7093 9.83945 13.6959 9.71945 13.6693C9.60612 13.6493 9.50945 13.6093 9.42945 13.5493C9.34945 13.4893 9.28945 13.4059 9.24945 13.2993C9.20945 13.1926 9.18945 13.0526 9.18945 12.8793V7.59928C9.26279 7.58594 9.37945 7.56928 9.53945 7.54928C9.69945 7.52261 9.85279 7.50928 9.99945 7.50928C10.1528 7.50928 10.2861 7.52261 10.3995 7.54928C10.5195 7.56928 10.6195 7.60928 10.6995 7.66928C10.7795 7.72928 10.8395 7.81261 10.8795 7.91928C10.9195 8.02594 10.9395 8.16594 10.9395 8.33928V13.6193Z",
      fill: "currentColor"
    })
  ]),
  instanceManagement: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.52002 3C9.52002 2.44772 9.0723 2 8.52002 2C7.96774 2 7.52002 2.44772 7.52002 3V5.16371C6.65165 5.46369 5.96401 6.15123 5.66388 7.01953L3.5 7.01953C2.94772 7.01953 2.5 7.46725 2.5 8.01953C2.5 8.57182 2.94772 9.01953 3.5 9.01953L5.5 9.01953V11H3.5C2.94772 11 2.5 11.4477 2.5 12C2.5 12.5523 2.94772 13 3.5 13H5.5V14.9805H3.5C2.94772 14.9805 2.5 15.4282 2.5 15.9805C2.5 16.5328 2.94772 16.9805 3.5 16.9805H5.66388C5.96401 17.8488 6.65165 18.5363 7.52002 18.8363V21C7.52002 21.5523 7.96773 22 8.52002 22C9.0723 22 9.52002 21.5523 9.52002 21V19H11.5V21C11.5 21.5523 11.9477 22 12.5 22C13.0523 22 13.5 21.5523 13.5 21V19H13.7709C14.3232 19 14.7709 18.5523 14.7709 18C14.7709 17.4477 14.3232 17 13.7709 17H8.5C7.94772 17 7.5 16.5523 7.5 16V8C7.5 7.44772 7.94772 7 8.5 7H16.5C17.0523 7 17.5 7.44772 17.5 8V13.1831C17.5 13.7354 17.9477 14.1831 18.5 14.1831C19.0523 14.1831 19.5 13.7354 19.5 13.1831V13H21.5C22.0523 13 22.5 12.5523 22.5 12C22.5 11.4477 22.0523 11 21.5 11H19.5V9.02051L21.5 9.02051C22.0523 9.02051 22.5 8.57279 22.5 8.02051C22.5 7.46822 22.0523 7.02051 21.5 7.02051L19.3365 7.02051C19.0365 6.15174 18.3487 5.46381 17.48 5.16371V3C17.48 2.44772 17.0323 2 16.48 2C15.9277 2 15.48 2.44772 15.48 3V5H13.5V3C13.5 2.44772 13.0523 2 12.5 2C11.9477 2 11.5 2.44772 11.5 3V5H9.52002V3ZM9.25 9.85C9.25 9.24249 9.74249 8.75 10.35 8.75H14.65C15.2575 8.75 15.75 9.24249 15.75 9.85V14.15C15.75 14.7575 15.2575 15.25 14.65 15.25H10.35C9.74249 15.25 9.25 14.7575 9.25 14.15V9.85ZM17.9598 14.8388C17.9854 14.6423 18.1554 14.5039 18.3467 14.5039H19.8985C20.0898 14.5039 20.2598 14.6423 20.2855 14.8388L20.4169 15.7554C20.5953 15.8369 20.7628 15.935 20.9207 16.048L21.7836 15.7015C21.8308 15.6826 21.8802 15.6755 21.9236 15.6755C22.0583 15.6755 22.1935 15.7433 22.2668 15.8726L23.0447 17.2183C23.1347 17.3834 23.101 17.5959 22.9467 17.7177L22.946 17.7182L22.215 18.2898C22.2245 18.3832 22.2309 18.48 22.2309 18.582C22.2309 18.684 22.2245 18.7808 22.215 18.8742L22.9467 19.4464C23.101 19.5682 23.1347 19.7806 23.0446 19.9457L23.0422 19.9501L22.2668 21.2914C22.1945 21.4189 22.0606 21.4886 21.9275 21.4886C21.8817 21.4886 21.8373 21.4809 21.7948 21.4667L21.7892 21.4648L20.9197 21.1156C20.7631 21.2261 20.596 21.326 20.417 21.4084L20.2855 22.3253C20.2598 22.5218 20.0898 22.6602 19.8985 22.6602H18.3467C18.1554 22.6602 17.9854 22.5218 17.9598 22.3253L17.8283 21.4086C17.65 21.3272 17.4825 21.229 17.3245 21.1161L16.4616 21.4626C16.4145 21.4815 16.3651 21.4886 16.3217 21.4886C16.1869 21.4886 16.0518 21.4208 15.9785 21.2915L15.2006 19.9458C15.1105 19.7806 15.1443 19.5682 15.2985 19.4464L15.2992 19.4458L16.0303 18.8742C16.0208 18.7796 16.0144 18.6814 16.0144 18.582C16.0144 18.4826 16.0208 18.3845 16.0303 18.2899L15.2992 17.7182L15.2985 17.7177C15.1501 17.6005 15.1013 17.3874 15.2035 17.2133L15.9785 15.8726C16.0508 15.7451 16.1847 15.6755 16.3178 15.6755C16.3635 15.6755 16.408 15.6832 16.4504 15.6973L16.4561 15.6992L17.3256 16.0484C17.4821 15.938 17.6492 15.838 17.8283 15.7557L17.9598 14.8388ZM19.0225 15.6771L18.9702 16.03L18.97 16.0313L18.8921 16.5817L18.3763 16.7909C18.2356 16.8493 18.0904 16.9335 17.9344 17.0495L17.4961 17.3807L16.9886 17.1758L16.6557 17.0421L16.5571 17.2126L16.8402 17.4327L17.2736 17.7736L17.2058 18.3209C17.1942 18.4369 17.1876 18.5162 17.1876 18.582C17.1876 18.648 17.1942 18.7271 17.2058 18.8473L17.2736 19.3943L16.8393 19.7359L16.5571 19.9554L16.6557 20.1258L16.988 19.9924L17.5047 19.7828L17.947 20.123C18.0892 20.2295 18.2296 20.31 18.3798 20.373L18.896 20.5824L19.0237 21.4869H19.2228L19.2751 21.134L19.2753 21.1328L19.3532 20.5824L19.869 20.3732C20.0097 20.3148 20.1548 20.2306 20.3109 20.1145L20.7492 19.7833L21.2567 19.9883L21.5896 20.122L21.6882 19.9515L21.4051 19.7313L20.9717 19.3904L21.0395 18.8431C21.0511 18.7269 21.0577 18.6516 21.0577 18.582C21.0577 18.509 21.0543 18.436 21.0399 18.3243L21.0398 18.3233L20.9717 17.7736L21.4043 17.4333L21.4051 17.4327L21.6852 17.2102L21.5857 17.0382L21.2534 17.1717L20.7367 17.3813L20.2944 17.041C20.1522 16.9346 20.0118 16.854 19.8616 16.791L19.3454 16.5816L19.2177 15.6771H19.0225ZM11.25 10.75V13.25H13.75V10.75H11.25ZM17.3722 18.582C17.3722 17.615 18.1556 16.8316 19.1226 16.8316C20.0897 16.8316 20.8731 17.615 20.8731 18.582C20.8731 19.5491 20.0897 20.3325 19.1226 20.3325C18.1556 20.3325 17.3722 19.5491 17.3722 18.582ZM19.1226 18.0048C18.8056 18.0048 18.5454 18.265 18.5454 18.582C18.5454 18.8991 18.8056 19.1593 19.1226 19.1593C19.4397 19.1593 19.6999 18.8991 19.6999 18.582C19.6999 18.265 19.4397 18.0048 19.1226 18.0048Z",
      fill: "currentColor"
    })
  ]),
  instanceImageManagement: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.52026 3C9.52026 2.44772 9.07255 2 8.52026 2C7.96798 2 7.52026 2.44772 7.52026 3V5.16371C6.65189 5.46369 5.96425 6.15123 5.66412 7.01953L3.54883 7.01953C2.99654 7.01953 2.54883 7.46725 2.54883 8.01953C2.54883 8.57182 2.99654 9.01953 3.54883 9.01953L5.50024 9.01953V11H3.54883C2.99654 11 2.54883 11.4477 2.54883 12C2.54883 12.5523 2.99654 13 3.54883 13H5.50024V14.9805H3.54883C2.99654 14.9805 2.54883 15.4282 2.54883 15.9805C2.54883 16.5328 2.99654 16.9805 3.54883 16.9805H5.66412C5.96425 17.8488 6.65189 18.5363 7.52026 18.8363V21C7.52026 21.5523 7.96798 22 8.52026 22C9.07255 22 9.52026 21.5523 9.52026 21V19H11.5002V21C11.5002 21.5523 11.948 22 12.5002 22C13.0525 22 13.5002 21.5523 13.5002 21V19H15.4802V21C15.4802 21.5523 15.9279 22 16.4802 22C17.0325 22 17.4802 21.5523 17.4802 21V18.8363C18.3486 18.5363 19.0362 17.8488 19.3364 16.9805H21.5488C22.1011 16.9805 22.5488 16.5328 22.5488 15.9805C22.5488 15.4282 22.1011 14.9805 21.5488 14.9805H19.5002V13H21.5488C22.1011 13 22.5488 12.5523 22.5488 12C22.5488 11.4477 22.1011 11 21.5488 11H19.5002V9.02051L21.5488 9.02051C22.1011 9.02051 22.5488 8.57279 22.5488 8.02051C22.5488 7.46822 22.1011 7.02051 21.5488 7.02051L19.3367 7.02051C19.0368 6.15174 18.3489 5.46381 17.4802 5.16371V3C17.4802 2.44772 17.0325 2 16.4802 2C15.9279 2 15.4802 2.44772 15.4802 3V5H13.5002V3C13.5002 2.44772 13.0525 2 12.5002 2C11.948 2 11.5002 2.44772 11.5002 3V5H9.52026V3ZM7.50024 8C7.50024 7.44772 7.94796 7 8.50024 7H16.5002C17.0525 7 17.5002 7.44772 17.5002 8V16C17.5002 16.5523 17.0525 17 16.5002 17H8.50024C7.94796 17 7.50024 16.5523 7.50024 16V8ZM13.7782 9.3792C13.9514 9.38517 14.1091 9.48038 14.1951 9.63084L16.6194 13.8734C16.7079 14.0281 16.7072 14.2183 16.6178 14.3724C16.5283 14.5266 16.3635 14.6215 16.1853 14.6215H8.91235C8.72796 14.6215 8.55853 14.52 8.47152 14.3574C8.38451 14.1948 8.39404 13.9975 8.49633 13.8441L10.3146 11.1168C10.3977 10.9921 10.5323 10.9113 10.6813 10.8965C10.8304 10.8818 10.9782 10.9346 11.0841 11.0406L11.865 11.8214L13.345 9.60156C13.4411 9.45737 13.605 9.37324 13.7782 9.3792Z",
      fill: "currentColor"
    })
  ]),
  instanceDisable: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.52002 2C9.0723 2 9.52002 2.44772 9.52002 3V5H11.5V3C11.5 2.44772 11.9477 2 12.5 2C13.0523 2 13.5 2.44772 13.5 3V5H15.48V3C15.48 2.44772 15.9277 2 16.48 2C17.0323 2 17.48 2.44772 17.48 3V5.16371C18.3487 5.46381 19.0365 6.15174 19.3365 7.02051L21.5 7.02051C22.0523 7.02051 22.5 7.46822 22.5 8.02051C22.5 8.57279 22.0523 9.02051 21.5 9.02051L19.5 9.02051V11H21.5C22.0523 11 22.5 11.4477 22.5 12C22.5 12.5523 22.0523 13 21.5 13H19.5V13.9728C19.5 14.5251 19.0523 14.9728 18.5 14.9728C17.9477 14.9728 17.5 14.5251 17.5 13.9728V8C17.5 7.44772 17.0523 7 16.5 7H8.5C7.94772 7 7.5 7.44772 7.5 8V16C7.5 16.5523 7.94772 17 8.5 17H14.4309C14.9832 17 15.4309 17.4477 15.4309 18C15.4309 18.5523 14.9832 19 14.4309 19H13.5V21C13.5 21.5523 13.0523 22 12.5 22C11.9477 22 11.5 21.5523 11.5 21V19H9.52002V21C9.52002 21.5523 9.0723 22 8.52002 22C7.96773 22 7.52002 21.5523 7.52002 21V18.8363C6.65165 18.5363 5.96401 17.8488 5.66388 16.9805H3.5C2.94772 16.9805 2.5 16.5328 2.5 15.9805C2.5 15.4282 2.94772 14.9805 3.5 14.9805H5.5V13H3.5C2.94772 13 2.5 12.5523 2.5 12C2.5 11.4477 2.94772 11 3.5 11H5.5V9.01953L3.5 9.01953C2.94772 9.01953 2.5 8.57182 2.5 8.01953C2.5 7.46725 2.94772 7.01953 3.5 7.01953L5.66388 7.01953C5.96401 6.15123 6.65165 5.46369 7.52002 5.16371V3C7.52002 2.44772 7.96773 2 8.52002 2ZM21.0541 15.5155C21.4447 15.9061 21.4447 16.5392 21.0541 16.9298L19.852 18.1319L21.054 19.334C21.4446 19.7245 21.4446 20.3577 21.054 20.7482C20.6635 21.1388 20.0304 21.1388 19.6398 20.7482L18.4378 19.5462L17.2358 20.7481C16.8452 21.1387 16.2121 21.1387 15.8216 20.7481C15.431 20.3576 15.431 19.7244 15.8216 19.3339L17.0235 18.1319L15.8215 16.9299C15.4309 16.5393 15.4309 15.9062 15.8215 15.5156C16.212 15.1251 16.8451 15.1251 17.2357 15.5156L18.4378 16.7177L19.6399 15.5155C20.0305 15.125 20.6636 15.125 21.0541 15.5155ZM10.35 8.75C9.74249 8.75 9.25 9.24249 9.25 9.85V14.15C9.25 14.7575 9.74249 15.25 10.35 15.25H14.65C15.2575 15.25 15.75 14.7575 15.75 14.15V9.85C15.75 9.24249 15.2575 8.75 14.65 8.75H10.35ZM11.25 13.25V10.75H13.75V13.25H11.25Z",
      fill: "currentColor"
    })
  ]),
  instance: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.47144 3C9.47144 2.44772 9.02372 2 8.47144 2C7.91915 2 7.47144 2.44772 7.47144 3V5.16371C6.60307 5.46369 5.91542 6.15123 5.61529 7.01953H3.5C2.94772 7.01953 2.5 7.46725 2.5 8.01953C2.5 8.57182 2.94772 9.01953 3.5 9.01953L5.45142 9.01953V11H3.5C2.94772 11 2.5 11.4477 2.5 12C2.5 12.5523 2.94772 13 3.5 13H5.45142V14.9805H3.5C2.94772 14.9805 2.5 15.4282 2.5 15.9805C2.5 16.5328 2.94772 16.9805 3.5 16.9805H5.61529C5.91542 17.8488 6.60307 18.5363 7.47144 18.8363V21C7.47144 21.5523 7.91915 22 8.47144 22C9.02372 22 9.47144 21.5523 9.47144 21V19H11.4514V21C11.4514 21.5523 11.8991 22 12.4514 22C13.0037 22 13.4514 21.5523 13.4514 21V19H15.4314V21C15.4314 21.5523 15.8791 22 16.4314 22C16.9837 22 17.4314 21.5523 17.4314 21V18.8363C18.2998 18.5363 18.9874 17.8488 19.2875 16.9805H21.5C22.0523 16.9805 22.5 16.5328 22.5 15.9805C22.5 15.4282 22.0523 14.9805 21.5 14.9805H19.4514V13H21.5C22.0523 13 22.5 12.5523 22.5 12C22.5 11.4477 22.0523 11 21.5 11H19.4514V9.02051L21.5 9.02051C22.0523 9.02051 22.5 8.57279 22.5 8.02051C22.5 7.46822 22.0523 7.02051 21.5 7.02051L19.2879 7.02051C18.9879 6.15174 18.3001 5.46381 17.4314 5.16371V3C17.4314 2.44772 16.9837 2 16.4314 2C15.8791 2 15.4314 2.44772 15.4314 3V5H13.4514V3C13.4514 2.44772 13.0037 2 12.4514 2C11.8991 2 11.4514 2.44772 11.4514 3V5H9.47144V3ZM9.20142 9.96133C9.20142 9.35382 9.6939 8.86133 10.3014 8.86133H14.6014C15.2089 8.86133 15.7014 9.35382 15.7014 9.96133V14.2613C15.7014 14.8688 15.2089 15.3613 14.6014 15.3613H10.3014C9.6939 15.3613 9.20142 14.8688 9.20142 14.2613V9.96133ZM11.2014 10.8613V13.3613H13.7014V10.8613H11.2014ZM7.45142 8C7.45142 7.44772 7.89913 7 8.45142 7H16.4514C17.0037 7 17.4514 7.44772 17.4514 8V16C17.4514 16.5523 17.0037 17 16.4514 17H8.45142C7.89913 17 7.45142 16.5523 7.45142 16V8Z",
      fill: "currentColor"
    })
  ]),
  mergeRequest: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24023 5C2.24023 3.34315 3.58338 2 5.24023 2H9.24023C9.79252 2 10.2402 2.44772 10.2402 3C10.2402 3.55228 9.79252 4 9.24023 4H5.24023C4.68795 4 4.24023 4.44772 4.24023 5V9C4.24023 9.55228 3.79252 10 3.24023 10C2.68795 10 2.24023 9.55228 2.24023 9V5ZM14.2402 3C14.2402 2.44772 14.6879 2 15.2402 2H19.2402C20.8971 2 22.2402 3.34315 22.2402 5V9C22.2402 9.55228 21.7925 10 21.2402 10C20.688 10 20.2402 9.55228 20.2402 9V5C20.2402 4.44772 19.7925 4 19.2402 4H15.2402C14.6879 4 14.2402 3.55228 14.2402 3ZM3.24023 14C3.79252 14 4.24023 14.4477 4.24023 15V19C4.24023 19.5523 4.68795 20 5.24023 20H9.24023C9.79252 20 10.2402 20.4477 10.2402 21C10.2402 21.5523 9.79252 22 9.24023 22H5.24023C3.58338 22 2.24023 20.6569 2.24023 19V15C2.24023 14.4477 2.68795 14 3.24023 14ZM21.2402 14C21.7925 14 22.2402 14.4477 22.2402 15V19C22.2402 20.6569 20.8971 22 19.2402 22H15.2402C14.6879 22 14.2402 21.5523 14.2402 21C14.2402 20.4477 14.6879 20 15.2402 20H19.2402C19.7925 20 20.2402 19.5523 20.2402 19V15C20.2402 14.4477 20.688 14 21.2402 14Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24023 11.886C2.24025 11.3337 2.68797 10.886 3.24025 10.886L7.7683 10.8861L6.31001 9.42782C5.91948 9.03729 5.91948 8.40413 6.31001 8.01361C6.70053 7.62308 7.3337 7.62308 7.72422 8.0136L10.8897 11.1791C11.0772 11.3666 11.1826 11.6209 11.1826 11.8862C11.1826 12.1514 11.0772 12.4057 10.8897 12.5933L7.49556 15.9874C7.10503 16.3779 6.47187 16.3779 6.08135 15.9874C5.69082 15.5969 5.69082 14.9637 6.08135 14.5732L7.7684 12.8861L3.24021 12.886C2.68793 12.886 2.24022 12.4383 2.24023 11.886Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M22.2402 12.115C22.2402 12.6673 21.7925 13.115 21.2402 13.115L16.7122 13.1149L18.1705 14.5732C18.561 14.9637 18.561 15.5968 18.1705 15.9874C17.7799 16.3779 17.1468 16.3779 16.7562 15.9874L13.5908 12.8219C13.4033 12.6344 13.2979 12.38 13.2979 12.1148C13.2979 11.8496 13.4033 11.5952 13.5908 11.4077L16.9849 8.0136C17.3754 7.62307 18.0086 7.62307 18.3991 8.0136C18.7896 8.40412 18.7896 9.03729 18.3991 9.42781L16.7121 11.1149L21.2403 11.115C21.7925 11.115 22.2402 11.5627 22.2402 12.115Z",
      fill: "currentColor"
    })
  ]),
  vpc: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("g", {
      "clip-path": "url(#clip0_284_11237)"
    }, [
      G("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M11.5259 3.43457C8.93381 3.43457 6.81166 5.56513 6.81166 8.21912C6.81166 8.42303 6.82418 8.62353 6.84837 8.81993C6.8834 9.1043 6.79477 9.39003 6.60496 9.60466C6.50435 9.71843 6.38043 9.80642 6.24352 9.864C6.07631 9.94405 5.88836 9.97688 5.70044 9.95584C5.62003 9.94685 5.53799 9.94219 5.45452 9.94219C4.24309 9.94219 3.24023 10.9397 3.24023 12.196C3.24023 13.357 4.14392 14.2186 5.45452 14.2186C6.0068 14.2186 6.45452 14.6663 6.45452 15.2186C6.45452 15.7709 6.0068 16.2186 5.45452 16.2186C3.21472 16.2186 1.24023 14.6291 1.24023 12.196C1.24023 10.0755 2.78311 8.30205 4.81541 7.99066C4.93454 4.36015 7.88239 1.43457 11.5259 1.43457C13.8073 1.43457 15.8173 2.58383 17.0285 4.33056C17.0988 4.32809 17.1694 4.32684 17.2402 4.32684C20.5654 4.32684 23.2402 7.05222 23.2402 10.3883C23.2402 13.4908 20.9555 15.7432 18.0978 16.157C17.5512 16.2362 17.044 15.8572 16.9648 15.3107C16.8857 14.7641 17.2646 14.2568 17.8112 14.1777C19.7997 13.8898 21.2402 12.3856 21.2402 10.3883C21.2402 8.13367 19.4379 6.32684 17.2402 6.32684C17.0404 6.32684 16.8446 6.34165 16.6536 6.37008C16.242 6.43137 15.8354 6.23132 15.6328 5.86779C14.8199 4.40909 13.2816 3.43457 11.5259 3.43457Z",
        fill: "currentColor"
      }),
      G("path", {
        d: "M17.2071 22.5656C16.7493 22.5656 16.336 22.4634 15.9671 22.2589C15.5982 22.05 15.3093 21.7611 15.1004 21.3923C14.8916 21.0234 14.7871 20.6078 14.7871 20.1456C14.7871 19.6834 14.8916 19.2678 15.1004 18.8989C15.3138 18.53 15.6049 18.2434 15.9738 18.0389C16.3427 17.83 16.756 17.7256 17.2138 17.7256C17.6093 17.7256 17.9671 17.8011 18.2871 17.9523C18.6116 18.0989 18.8782 18.31 19.0871 18.5856L18.3404 19.3056C18.0516 18.9411 17.696 18.7589 17.2738 18.7589C17.0204 18.7589 16.7938 18.8167 16.5938 18.9323C16.3982 19.0478 16.2449 19.2123 16.1338 19.4256C16.0227 19.6345 15.9671 19.8745 15.9671 20.1456C15.9671 20.4167 16.0227 20.6567 16.1338 20.8656C16.2449 21.0745 16.3982 21.2367 16.5938 21.3523C16.7938 21.4678 17.0204 21.5256 17.2738 21.5256C17.7004 21.5256 18.056 21.3434 18.3404 20.9789L19.0871 21.6989C18.8782 21.9789 18.6116 22.1945 18.2871 22.3456C17.9671 22.4923 17.6071 22.5656 17.2071 22.5656Z",
        fill: "currentColor"
      }),
      G("path", {
        d: "M12.5667 17.8125C12.9623 17.8125 13.3067 17.8836 13.6001 18.0258C13.8934 18.1636 14.1201 18.3614 14.2801 18.6192C14.4401 18.8769 14.5201 19.1814 14.5201 19.5325C14.5201 19.8792 14.4401 20.1814 14.2801 20.4392C14.1201 20.6969 13.8934 20.8947 13.6001 21.0325C13.3067 21.1703 12.9623 21.2392 12.5667 21.2392H11.7467V22.4792H10.5801V17.8125H12.5667ZM12.4934 20.2458C12.7734 20.2458 12.9845 20.1836 13.1267 20.0592C13.269 19.9347 13.3401 19.7592 13.3401 19.5325C13.3401 19.3014 13.269 19.1236 13.1267 18.9992C12.9845 18.8703 12.7734 18.8058 12.4934 18.8058H11.7467V20.2458H12.4934Z",
        fill: "currentColor"
      }),
      G("path", {
        d: "M8.44591 22.4792H7.29258L5.39258 17.8125H6.65258L7.91258 20.9725L9.19924 17.8125H10.3526L8.44591 22.4792Z",
        fill: "currentColor"
      })
    ]),
    G("defs", {}, [
      G("clipPath", {
        id: "clip0_284_11237"
      }, [
        G("rect", {
          width: "22",
          height: "21.131",
          fill: "white",
          transform: "translate(1.24023 1.43457)"
        })
      ])
    ])
  ]),
  dataStorage: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M12.2402 2C8.24023 2 4.24023 3.37 4.24023 6V18C4.24023 20.63 8.24023 22 12.2402 22C16.2402 22 20.2402 20.63 20.2402 18V6C20.2402 3.37 16.2402 2 12.2402 2ZM18.2402 18C18.2402 18.71 15.9602 20 12.2402 20C8.52023 20 6.24023 18.71 6.24023 18V14.73C8.1123 15.62 10.1681 16.0551 12.2402 16C14.3123 16.0551 16.3682 15.62 18.2402 14.73V18ZM18.2402 12C18.2402 12.71 15.9602 14 12.2402 14C8.52023 14 6.24023 12.71 6.24023 12V8.73C8.1123 9.61996 10.1681 10.0551 12.2402 10C14.3123 10.0551 16.3682 9.61996 18.2402 8.73V12ZM12.2402 8C8.52023 8 6.24023 6.71 6.24023 6C6.24023 5.29 8.52023 4 12.2402 4C15.9602 4 18.2402 5.29 18.2402 6C18.2402 6.71 15.9602 8 12.2402 8Z",
      fill: "currentColor"
    })
  ]),
  subnet: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M21.2402 17.5602H15.0602C14.9109 17.1408 14.6701 16.7599 14.3553 16.4451C14.0405 16.1303 13.6596 15.8895 13.2402 15.7402L13.2029 14.0321H16.3729C17.4318 14.0669 18.4666 13.7123 19.2816 13.0354C20.0966 12.3585 20.6352 11.4063 20.7953 10.359C20.9555 9.31178 20.7262 8.24215 20.1507 7.35261C19.5753 6.46307 18.6937 5.81535 17.6729 5.53207C17.1381 4.34715 16.233 3.36797 15.0936 2.74189C13.9543 2.11581 12.6425 1.8767 11.3555 2.06055C10.0686 2.2444 8.87617 2.84126 7.95773 3.7613C7.03928 4.68135 6.4445 5.87481 6.2629 7.16207C5.44909 7.39028 4.74535 7.90527 4.28166 8.61192C3.81797 9.31858 3.62566 10.1692 3.74023 11.0065C3.85481 11.8439 4.26855 12.6116 4.90502 13.1677C5.54149 13.7238 6.3577 14.0309 7.2029 14.0321H11.2029L11.2402 15.7402C10.8208 15.8895 10.4399 16.1303 10.1251 16.4451C9.81034 16.7599 9.56955 17.1408 9.42023 17.5602H3.24023C2.97502 17.5602 2.72066 17.6656 2.53313 17.8531C2.34559 18.0406 2.24023 18.295 2.24023 18.5602C2.24023 18.8254 2.34559 19.0798 2.53313 19.2673C2.72066 19.4548 2.97502 19.5602 3.24023 19.5602H9.42023C9.63044 20.1393 10.0139 20.6397 10.5184 20.9934C11.0229 21.347 11.6241 21.5367 12.2402 21.5367C12.8564 21.5367 13.4575 21.347 13.9621 20.9934C14.4666 20.6397 14.85 20.1393 15.0602 19.5602H21.2402C21.5055 19.5602 21.7598 19.4548 21.9473 19.2673C22.1349 19.0798 22.2402 18.8254 22.2402 18.5602C22.2402 18.295 22.1349 18.0406 21.9473 17.8531C21.7598 17.6656 21.5055 17.5602 21.2402 17.5602ZM7.2029 12.0321C6.80507 12.0321 6.42354 11.874 6.14224 11.5927C5.86093 11.3114 5.7029 10.9299 5.7029 10.5321C5.7029 10.1342 5.86093 9.75272 6.14224 9.47141C6.42354 9.19011 6.80507 9.03207 7.2029 9.03207C7.46811 9.03207 7.72247 8.92672 7.91 8.73918C8.09754 8.55164 8.2029 8.29729 8.2029 8.03207C8.20028 7.0826 8.53549 6.16316 9.14859 5.43817C9.76168 4.71318 10.6127 4.22991 11.5494 4.07479C12.4861 3.91967 13.4475 4.10282 14.2615 4.59148C15.0756 5.08014 15.6893 5.84244 15.9929 6.74207C16.0501 6.91391 16.1528 7.067 16.2902 7.18501C16.4276 7.30301 16.5944 7.38149 16.7729 7.41207C17.3142 7.50234 17.8056 7.78234 18.1593 8.20194C18.5129 8.62154 18.7056 9.15333 18.7029 9.70207C18.7003 10.3192 18.4539 10.9103 18.0175 11.3467C17.5812 11.7831 16.99 12.0294 16.3729 12.0321H7.2029ZM12.2402 19.5602C12.0425 19.5602 11.8491 19.5015 11.6847 19.3917C11.5202 19.2818 11.392 19.1256 11.3164 18.9429C11.2407 18.7602 11.2209 18.5591 11.2594 18.3651C11.298 18.1711 11.3933 17.9929 11.5331 17.8531C11.673 17.7132 11.8512 17.618 12.0451 17.5794C12.2391 17.5408 12.4402 17.5606 12.6229 17.6363C12.8056 17.712 12.9618 17.8402 13.0717 18.0046C13.1816 18.1691 13.2402 18.3624 13.2402 18.5602C13.2402 18.8254 13.1349 19.0798 12.9473 19.2673C12.7598 19.4548 12.5055 19.5602 12.2402 19.5602Z",
      fill: "currentColor"
    })
  ]),
  server: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M8.24023 17C8.04245 17 7.84911 17.0586 7.68466 17.1685C7.52022 17.2784 7.39204 17.4346 7.31635 17.6173C7.24067 17.8 7.22086 18.0011 7.25945 18.1951C7.29803 18.3891 7.39328 18.5673 7.53313 18.7071C7.67298 18.847 7.85116 18.9422 8.04514 18.9808C8.23913 19.0194 8.44019 18.9996 8.62292 18.9239C8.80564 18.8482 8.96182 18.72 9.0717 18.5556C9.18159 18.3911 9.24023 18.1978 9.24023 18C9.24023 17.7348 9.13488 17.4804 8.94734 17.2929C8.7598 17.1054 8.50545 17 8.24023 17ZM8.24023 11C8.04245 11 7.84911 11.0586 7.68466 11.1685C7.52022 11.2784 7.39204 11.4346 7.31635 11.6173C7.24067 11.8 7.22086 12.0011 7.25945 12.1951C7.29803 12.3891 7.39328 12.5673 7.53313 12.7071C7.67298 12.847 7.85116 12.9422 8.04514 12.9808C8.23913 13.0194 8.44019 12.9996 8.62292 12.9239C8.80564 12.8482 8.96182 12.72 9.0717 12.5556C9.18159 12.3911 9.24023 12.1978 9.24023 12C9.24023 11.7348 9.13488 11.4804 8.94734 11.2929C8.7598 11.1054 8.50545 11 8.24023 11ZM8.24023 5C8.04245 5 7.84911 5.05865 7.68466 5.16853C7.52022 5.27841 7.39204 5.43459 7.31635 5.61732C7.24067 5.80004 7.22086 6.00111 7.25945 6.19509C7.29803 6.38907 7.39328 6.56725 7.53313 6.70711C7.67298 6.84696 7.85116 6.9422 8.04514 6.98079C8.23913 7.01937 8.44019 6.99957 8.62292 6.92388C8.80564 6.84819 8.96182 6.72002 9.0717 6.55557C9.18159 6.39112 9.24023 6.19778 9.24023 6C9.24023 5.73478 9.13488 5.48043 8.94734 5.29289C8.7598 5.10536 8.50545 5 8.24023 5ZM20.2402 5C20.2402 4.20435 19.9242 3.44129 19.3616 2.87868C18.7989 2.31607 18.0359 2 17.2402 2H7.24023C6.44458 2 5.68152 2.31607 5.11891 2.87868C4.5563 3.44129 4.24023 4.20435 4.24023 5V7C4.24464 7.74005 4.52245 8.45236 5.02023 9C4.52245 9.54764 4.24464 10.2599 4.24023 11V13C4.24464 13.7401 4.52245 14.4524 5.02023 15C4.52245 15.5476 4.24464 16.2599 4.24023 17V19C4.24023 19.7956 4.5563 20.5587 5.11891 21.1213C5.68152 21.6839 6.44458 22 7.24023 22H17.2402C18.0359 22 18.7989 21.6839 19.3616 21.1213C19.9242 20.5587 20.2402 19.7956 20.2402 19V17C20.2358 16.2599 19.958 15.5476 19.4602 15C19.958 14.4524 20.2358 13.7401 20.2402 13V11C20.2358 10.2599 19.958 9.54764 19.4602 9C19.958 8.45236 20.2358 7.74005 20.2402 7V5ZM18.2402 19C18.2402 19.2652 18.1349 19.5196 17.9473 19.7071C17.7598 19.8946 17.5055 20 17.2402 20H7.24023C6.97502 20 6.72066 19.8946 6.53313 19.7071C6.34559 19.5196 6.24023 19.2652 6.24023 19V17C6.24023 16.7348 6.34559 16.4804 6.53313 16.2929C6.72066 16.1054 6.97502 16 7.24023 16H17.2402C17.5055 16 17.7598 16.1054 17.9473 16.2929C18.1349 16.4804 18.2402 16.7348 18.2402 17V19ZM18.2402 13C18.2402 13.2652 18.1349 13.5196 17.9473 13.7071C17.7598 13.8946 17.5055 14 17.2402 14H7.24023C6.97502 14 6.72066 13.8946 6.53313 13.7071C6.34559 13.5196 6.24023 13.2652 6.24023 13V11C6.24023 10.7348 6.34559 10.4804 6.53313 10.2929C6.72066 10.1054 6.97502 10 7.24023 10H17.2402C17.5055 10 17.7598 10.1054 17.9473 10.2929C18.1349 10.4804 18.2402 10.7348 18.2402 11V13ZM18.2402 7C18.2402 7.26522 18.1349 7.51957 17.9473 7.70711C17.7598 7.89464 17.5055 8 17.2402 8H7.24023C6.97502 8 6.72066 7.89464 6.53313 7.70711C6.34559 7.51957 6.24023 7.26522 6.24023 7V5C6.24023 4.73478 6.34559 4.48043 6.53313 4.29289C6.72066 4.10536 6.97502 4 7.24023 4H17.2402C17.5055 4 17.7598 4.10536 17.9473 4.29289C18.1349 4.48043 18.2402 4.73478 18.2402 5V7Z",
      fill: "currentColor"
    })
  ]),
  resourceConfiguration: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24023 14.3078C2.24023 13.3226 3.04344 12.5386 4.0161 12.5386H7.11959C7.88425 12.5386 8.54418 13.0231 8.79146 13.709L9.02011 13.5957L9.46425 14.4917L9.02011 13.5957C9.91254 13.1533 10.8961 12.9232 11.8931 12.9232H12.2113C12.7821 12.9232 13.3505 12.9986 13.9013 13.1476L15.5321 13.5886C16.4065 13.825 16.9662 14.5301 17.0996 15.3127L17.9442 14.4754C18.796 13.6308 20.1268 13.5012 21.1266 14.1621C22.2862 14.9285 22.6455 16.5488 21.7044 17.7008C20.8686 18.7239 19.4592 20.2854 18.0294 20.9772C16.6559 21.6417 15.9065 21.7021 14.7492 21.7954C14.5741 21.8095 14.3897 21.8244 14.1924 21.8422C13.1359 21.9376 11.9161 21.7465 10.9244 21.5911C10.8648 21.5817 10.806 21.5725 10.7481 21.5635C10.2086 21.4795 9.74028 21.4099 9.3403 21.3816C9.15372 21.3684 9.00558 21.3664 8.88999 21.3711C8.81808 22.2894 8.04564 23.0001 7.11959 23.0001H4.0161C3.04344 23.0001 2.24023 22.2161 2.24023 21.2309V14.3078ZM8.89546 19.3698C9.09648 19.3653 9.29458 19.3734 9.48136 19.3866C9.97847 19.4218 10.5285 19.5052 11.0558 19.5873C11.0783 19.5908 11.1008 19.5943 11.1233 19.5978C12.21 19.7672 13.2094 19.9229 14.0125 19.8503C14.2331 19.8304 14.4301 19.8142 14.6092 19.7995C15.709 19.709 16.13 19.6744 17.1583 19.1769C18.1458 18.6991 19.31 17.4705 20.1555 16.4355L20.8487 17.0018L20.1555 16.4355C20.285 16.277 20.2796 15.9996 20.0238 15.8306C19.8122 15.6907 19.5299 15.7195 19.3523 15.8956L17.8158 17.419C17.1911 18.0383 16.3457 18.3847 15.4659 18.3847H14.8788C14.8785 18.3847 14.8782 18.3847 14.8779 18.3847H12.9386C12.3863 18.3847 11.9386 17.937 11.9386 17.3847C11.9386 16.8324 12.3863 16.3847 12.9386 16.3847H14.4666L15.0838 15.7728L15.6744 16.3685L15.0838 15.7728C15.1623 15.695 15.1365 15.5534 15.0101 15.5192L13.3793 15.0783C12.9987 14.9754 12.6059 14.9232 12.2113 14.9232H11.8931C11.2038 14.9232 10.5242 15.0823 9.9084 15.3876L9.46597 14.4951L9.9084 15.3876L8.89546 15.8897V19.3698ZM4.24023 14.5386V21.0001H6.89546V14.5386H4.24023Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M15.5065 3.16553C14.2723 3.16553 13.2083 3.90828 12.7424 4.97577C12.6243 5.24645 12.3925 5.45106 12.1093 5.53475C11.336 5.76328 10.7734 6.47983 10.7734 7.32526C10.7734 8.35606 11.609 9.19177 12.64 9.19177H18.9463C19.6604 9.19177 20.2395 8.61269 20.2395 7.89856C20.2395 7.29112 19.8194 6.77895 19.252 6.64169C18.8483 6.54404 18.5471 6.2071 18.495 5.7951C18.3077 4.31269 17.0399 3.16553 15.5065 3.16553ZM11.1061 3.77497C11.9569 2.22142 13.6078 1.16553 15.5065 1.16553C17.8418 1.16553 19.8038 2.76233 20.3607 4.92435C21.4713 5.45341 22.2395 6.58528 22.2395 7.89856C22.2395 9.71726 20.765 11.1918 18.9463 11.1918H12.64C10.5043 11.1918 8.77344 9.4605 8.77344 7.32526C8.77344 5.73397 9.73397 4.36855 11.1061 3.77497Z",
      fill: "currentColor"
    })
  ]),
  outboundRule: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.81452 5.40952V18.8232C4.61975 18.1016 7.31566 17.6992 10.2754 18.8873V5.4603C10.2754 5.46006 10.2754 5.45982 10.2754 5.45957C7.04155 3.82559 4.16473 4.64531 2.81452 5.40952ZM12.2754 5.57995V20.4864C12.2754 20.8439 12.0846 21.1742 11.7749 21.3527C11.4652 21.5313 11.0837 21.5309 10.7744 21.3518C6.95842 19.1426 3.54786 20.4554 2.40588 21.2928C2.102 21.5157 1.69865 21.5487 1.3625 21.3784C1.02636 21.2081 0.81452 20.8632 0.81452 20.4864V4.90378C0.81452 4.89792 0.814571 4.89207 0.814671 4.88624C0.808107 4.57142 0.949947 4.25847 1.22316 4.05812C2.81711 2.88922 6.89241 1.39852 11.3811 3.77982C13.2542 2.64468 17.2253 1.51529 21.5156 3.9991C21.8846 4.21278 22.066 4.62628 22.002 5.02367C22.0103 5.07525 22.0145 5.12814 22.0145 5.18204V12.8342C22.0145 13.3865 21.5668 13.8342 21.0145 13.8342C20.4622 13.8342 20.0145 13.3865 20.0145 12.8342V5.45957C16.5374 3.70269 13.4731 4.7825 12.2754 5.57995Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.4389 15.0566C16.4389 14.5044 15.9912 14.0566 15.4389 14.0566C13.9075 14.0566 12.666 15.2981 12.666 16.8295C12.666 18.3609 13.9075 19.6024 15.4389 19.6024H20.2599L19.5146 20.3512C19.1251 20.7427 19.1266 21.3758 19.518 21.7654C19.9095 22.155 20.5426 22.1535 20.9322 21.7621L23.3748 19.3078C23.7629 18.9178 23.7631 18.2875 23.3752 17.8973L21.043 15.5516C20.6536 15.1599 20.0205 15.1581 19.6288 15.5475C19.2371 15.9369 19.2353 16.57 19.6247 16.9617L20.2617 17.6024H15.4389C15.012 17.6024 14.666 17.2563 14.666 16.8295C14.666 16.4027 15.012 16.0566 15.4389 16.0566C15.9912 16.0566 16.4389 15.6089 16.4389 15.0566Z",
      fill: "currentColor"
    })
  ]),
  inboundRule: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.81452 5.40952V18.8232C4.61975 18.1016 7.31566 17.6992 10.2754 18.8873V5.4603C10.2754 5.46006 10.2754 5.45982 10.2754 5.45957C7.04155 3.82559 4.16473 4.64531 2.81452 5.40952ZM12.2754 5.57995V20.4864C12.2754 20.8439 12.0846 21.1742 11.7749 21.3527C11.4652 21.5313 11.0837 21.5309 10.7744 21.3518C6.95842 19.1426 3.54786 20.4554 2.40588 21.2928C2.102 21.5157 1.69865 21.5487 1.3625 21.3784C1.02636 21.2081 0.81452 20.8632 0.81452 20.4864V4.90378C0.81452 4.89792 0.814571 4.89207 0.814671 4.88624C0.808107 4.57142 0.949947 4.25847 1.22316 4.05812C2.81711 2.88922 6.89241 1.39852 11.3811 3.77982C13.2542 2.64468 17.2253 1.51529 21.5156 3.9991C21.8846 4.21278 22.066 4.62628 22.002 5.02367C22.0103 5.07525 22.0145 5.12814 22.0145 5.18204V12.8342C22.0145 13.3865 21.5668 13.8342 21.0145 13.8342C20.4622 13.8342 20.0145 13.3865 20.0145 12.8342V5.45957C16.5374 3.70269 13.4731 4.7825 12.2754 5.57995Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M19.8931 15.0566C19.8931 14.5044 20.3409 14.0566 20.8931 14.0566C22.4246 14.0566 23.666 15.2981 23.666 16.8295C23.666 18.3609 22.4246 19.6024 20.8931 19.6024H16.0721L16.8174 20.3512C17.207 20.7427 17.2055 21.3758 16.814 21.7654C16.4226 22.155 15.7894 22.1535 15.3998 21.7621L12.9572 19.3078C12.5691 18.9178 12.5689 18.2875 12.9569 17.8973L15.289 15.5516C15.6784 15.1599 16.3116 15.1581 16.7032 15.5475C17.0949 15.9369 17.0967 16.57 16.7073 16.9617L16.0704 17.6024H20.8931C21.32 17.6024 21.666 17.2563 21.666 16.8295C21.666 16.4027 21.32 16.0566 20.8931 16.0566C20.3409 16.0566 19.8931 15.6089 19.8931 15.0566Z",
      fill: "currentColor"
    })
  ]),
  securityGroupDelete: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.7683 1.91112C17.0384 1.42936 17.6478 1.25773 18.1296 1.52777C19.8045 2.4666 21.0406 4.06418 21.0406 6.00008C21.0406 7.93598 19.8045 9.53356 18.1296 10.4724C17.6478 10.7424 17.0384 10.5708 16.7683 10.089C16.4983 9.60728 16.6699 8.99782 17.1517 8.72777C18.3893 8.03404 19.0406 7.01443 19.0406 6.00008C19.0406 4.98573 18.3893 3.96612 17.1517 3.27239C16.6699 3.00234 16.4983 2.39289 16.7683 1.91112ZM11.0406 3.40008C9.60468 3.40008 8.44062 4.56414 8.44062 6.00008C8.44062 7.43602 9.60468 8.60008 11.0406 8.60008C12.4766 8.60008 13.6406 7.43602 13.6406 6.00008C13.6406 4.56414 12.4766 3.40008 11.0406 3.40008ZM6.44062 6.00008C6.44062 3.45957 8.50011 1.40008 11.0406 1.40008C13.5811 1.40008 15.6406 3.45957 15.6406 6.00008C15.6406 8.54059 13.5811 10.6001 11.0406 10.6001C8.50011 10.6001 6.44062 8.54059 6.44062 6.00008ZM1.64103 17.9996C1.64132 15.4593 3.70072 13.4001 6.24103 13.4001H12.8406C13.3929 13.4001 13.8406 13.8478 13.8406 14.4001C13.8406 14.9524 13.3929 15.4001 12.8406 15.4001H6.24103C4.8052 15.4001 3.64119 16.564 3.64103 17.9998L3.64062 21.6002C3.64056 22.1525 3.1928 22.6001 2.64051 22.6001C2.08823 22.6 1.64056 22.1523 1.64063 21.6L1.64103 17.9996Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M20.7463 15.7382C21.1368 16.1287 21.1368 16.7619 20.7463 17.1524L19.5441 18.3546L20.7462 19.5567C21.1367 19.9472 21.1367 20.5804 20.7462 20.9709C20.3557 21.3614 19.7225 21.3614 19.332 20.9709L18.1299 19.7688L16.9279 20.9708C16.5374 21.3613 15.9042 21.3613 15.5137 20.9708C15.1232 20.5803 15.1232 19.9471 15.5137 19.5566L16.7157 18.3546L15.5136 17.1525C15.1231 16.762 15.1231 16.1288 15.5136 15.7383C15.9041 15.3478 16.5373 15.3478 16.9278 15.7383L18.1299 16.9404L19.3321 15.7382C19.7226 15.3477 20.3558 15.3477 20.7463 15.7382Z",
      fill: "currentColor"
    })
  ]),
  securityGroupCreate: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.7683 1.91112C17.0384 1.42936 17.6478 1.25773 18.1296 1.52777C19.8045 2.4666 21.0406 4.06418 21.0406 6.00008C21.0406 7.93598 19.8045 9.53356 18.1296 10.4724C17.6478 10.7424 17.0384 10.5708 16.7683 10.089C16.4983 9.60728 16.6699 8.99782 17.1517 8.72777C18.3893 8.03404 19.0406 7.01443 19.0406 6.00008C19.0406 4.98573 18.3893 3.96612 17.1517 3.27239C16.6699 3.00234 16.4983 2.39289 16.7683 1.91112ZM11.0406 3.40008C9.60468 3.40008 8.44062 4.56414 8.44062 6.00008C8.44062 7.43602 9.60468 8.60008 11.0406 8.60008C12.4766 8.60008 13.6406 7.43602 13.6406 6.00008C13.6406 4.56414 12.4766 3.40008 11.0406 3.40008ZM6.44062 6.00008C6.44062 3.45957 8.50011 1.40008 11.0406 1.40008C13.5811 1.40008 15.6406 3.45957 15.6406 6.00008C15.6406 8.54059 13.5811 10.6001 11.0406 10.6001C8.50011 10.6001 6.44062 8.54059 6.44062 6.00008ZM1.64103 17.9996C1.64132 15.4593 3.70072 13.4001 6.24103 13.4001H12.8406C13.3929 13.4001 13.8406 13.8478 13.8406 14.4001C13.8406 14.9524 13.3929 15.4001 12.8406 15.4001H6.24103C4.8052 15.4001 3.64119 16.564 3.64103 17.9998L3.64062 21.6002C3.64056 22.1525 3.1928 22.6001 2.64051 22.6001C2.08823 22.6 1.64056 22.1523 1.64063 21.6L1.64103 17.9996Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M19.9635 14.7379C19.2316 14.3719 18.37 14.3719 17.638 14.7379L16.8008 15.1565V17.8835C16.8008 17.9425 16.8452 18.1848 17.2932 18.6457C17.6358 18.9982 18.1362 19.3978 18.8058 19.8485C19.4962 19.4004 19.9904 19.0463 20.3301 18.7177C20.7251 18.3357 20.8008 18.0946 20.8008 17.8835V15.1565L19.9635 14.7379ZM22.8008 14.5385V17.8835C22.8008 18.8273 22.3426 19.5536 21.7207 20.1552C21.126 20.7304 20.287 21.2826 19.3347 21.884C19.0086 22.09 18.593 22.09 18.2668 21.884C17.2753 21.2578 16.4485 20.6461 15.8591 20.0397C15.2902 19.4544 14.8008 18.7294 14.8008 17.8835V14.5385C14.8008 14.1597 15.0148 13.8134 15.3536 13.644L16.7436 12.949C18.0386 12.3015 19.5629 12.3015 20.858 12.949L22.248 13.644C22.5868 13.8134 22.8008 14.1597 22.8008 14.5385Z",
      fill: "currentColor"
    })
  ]),
  roleDelete: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.44062 6.00039C8.44062 4.56445 9.60468 3.40039 11.0406 3.40039C12.4766 3.40039 13.6406 4.56445 13.6406 6.00039C13.6406 7.43633 12.4766 8.60039 11.0406 8.60039C9.60468 8.60039 8.44062 7.43633 8.44062 6.00039ZM11.0406 1.40039C8.50011 1.40039 6.44062 3.45988 6.44062 6.00039C6.44062 8.5409 8.50011 10.6004 11.0406 10.6004C13.5811 10.6004 15.6406 8.5409 15.6406 6.00039C15.6406 3.45988 13.5811 1.40039 11.0406 1.40039ZM6.24103 13.4004C3.70072 13.4004 1.64132 15.4596 1.64103 17.9999L1.64063 21.6003C1.64056 22.1526 2.08823 22.6003 2.64051 22.6004C3.1928 22.6005 3.64056 22.1528 3.64062 21.6005L3.64103 18.0001C3.64119 16.5643 4.8052 15.4004 6.24103 15.4004H13.4405C13.9928 15.4004 14.4405 14.9527 14.4405 14.4004C14.4405 13.8481 13.9928 13.4004 13.4405 13.4004H6.24103ZM20.7477 17.1573C21.1383 16.7668 21.1383 16.1336 20.7478 15.7431C20.3572 15.3526 19.7241 15.3526 19.3335 15.7431L18.1314 16.9453L16.9293 15.7432C16.5388 15.3527 15.9056 15.3527 15.5151 15.7432C15.1245 16.1337 15.1245 16.7669 15.5151 17.1574L16.7171 18.3595L15.5152 19.5615C15.1246 19.952 15.1246 20.5852 15.5152 20.9757C15.9057 21.3662 16.5388 21.3662 16.9294 20.9757L18.1314 19.7737L19.3334 20.9758C19.724 21.3663 20.3571 21.3663 20.7477 20.9758C21.1382 20.5853 21.1382 19.9521 20.7477 19.5616L19.5456 18.3595L20.7477 17.1573Z",
      fill: "currentColor"
    })
  ]),
  roleEdit: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.44062 6.00039C8.44062 4.56445 9.60468 3.40039 11.0406 3.40039C12.4766 3.40039 13.6406 4.56445 13.6406 6.00039C13.6406 7.43633 12.4766 8.60039 11.0406 8.60039C9.60468 8.60039 8.44062 7.43633 8.44062 6.00039ZM11.0406 1.40039C8.50011 1.40039 6.44062 3.45988 6.44062 6.00039C6.44062 8.5409 8.50011 10.6004 11.0406 10.6004C13.5811 10.6004 15.6406 8.5409 15.6406 6.00039C15.6406 3.45988 13.5811 1.40039 11.0406 1.40039ZM6.24103 13.4004C3.70072 13.4004 1.64132 15.4596 1.64103 17.9999L1.64063 21.6003C1.64056 22.1526 2.08823 22.6003 2.64051 22.6004C3.1928 22.6005 3.64056 22.1528 3.64062 21.6005L3.64103 18.0001C3.64119 16.5643 4.8052 15.4004 6.24103 15.4004H13.4405C13.9928 15.4004 14.4405 14.9527 14.4405 14.4004C14.4405 13.8481 13.9928 13.4004 13.4405 13.4004H6.24103ZM19.6869 12.4081C19.2964 12.0176 18.6633 12.0176 18.2727 12.4081L13.1816 17.4993C12.994 17.6868 12.8887 17.9412 12.8887 18.2064V21.6005C12.8887 22.1528 13.3364 22.6005 13.8887 22.6005H17.2828C17.548 22.6005 17.8024 22.4952 17.9899 22.3076L23.0811 17.2165C23.2686 17.0289 23.374 16.7746 23.374 16.5093C23.374 16.2441 23.2686 15.9898 23.0811 15.8022L19.6869 12.4081ZM14.8887 18.6206L18.9798 14.5294L20.9597 16.5093L16.8686 20.6005H14.8887V18.6206Z",
      fill: "currentColor"
    })
  ]),
  roleAssign: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.0406 3.3999C9.60468 3.3999 8.44062 4.56396 8.44062 5.9999C8.44062 7.43584 9.60468 8.5999 11.0406 8.5999C12.4766 8.5999 13.6406 7.43584 13.6406 5.9999C13.6406 4.56396 12.4766 3.3999 11.0406 3.3999ZM6.44062 5.9999C6.44062 3.45939 8.50011 1.3999 11.0406 1.3999C13.5811 1.3999 15.6406 3.45939 15.6406 5.9999C15.6406 8.54041 13.5811 10.5999 11.0406 10.5999C8.50011 10.5999 6.44062 8.54041 6.44062 5.9999ZM1.64103 17.9994C1.64132 15.4591 3.70072 13.3999 6.24103 13.3999H13.4405C13.9928 13.3999 14.4405 13.8476 14.4405 14.3999C14.4405 14.9522 13.9928 15.3999 13.4405 15.3999H6.24103C4.8052 15.3999 3.64119 16.5638 3.64103 17.9996L3.64062 21.6C3.64056 22.1523 3.1928 22.6 2.64051 22.5999C2.08823 22.5998 1.64056 22.1521 1.64063 21.5998L1.64103 17.9994ZM21.1335 13.6928C21.524 13.3023 22.1572 13.3023 22.5477 13.6928C22.9383 14.0833 22.9383 14.7165 22.5477 15.107L18.3477 19.307C17.9572 19.6975 17.324 19.6975 16.9335 19.307L15.7335 18.107C15.343 17.7165 15.343 17.0833 15.7335 16.6928C16.124 16.3023 16.7572 16.3023 17.1477 16.6928L17.6406 17.1857L21.1335 13.6928Z",
      fill: "currentColor"
    })
  ]),
  companyInvite: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M14.1063 20.6006C14.6667 20.6006 15.2832 20.0678 15.2832 19.2006L15.2832 4.80057C15.2832 3.93335 14.6667 3.40057 14.1063 3.40057L5.39852 3.40057C4.83807 3.40057 4.22158 3.93335 4.22158 4.80057L4.22158 19.2006C4.22158 20.0678 4.83807 20.6006 5.39852 20.6006L5.50699 20.6006C5.49388 20.5359 5.48699 20.4691 5.48699 20.4006L5.48699 15.5313C5.48699 15.2661 5.59234 15.0117 5.77988 14.8242C5.96742 14.6367 6.22177 14.5313 6.48699 14.5313L13.0178 14.5313C13.5701 14.5313 14.0178 14.979 14.0178 15.5313L14.0178 20.4006C14.0178 20.4691 14.0109 20.536 13.9978 20.6006L14.1063 20.6006ZM12.0378 20.6006C12.0247 20.536 12.0178 20.4691 12.0178 20.4006L12.0178 16.5313L7.48699 16.5313L7.48699 20.4006C7.48699 20.4691 7.4801 20.536 7.46698 20.6006L12.0378 20.6006ZM17.2832 19.2006C17.2832 20.9843 15.9504 22.6006 14.1063 22.6006L5.39852 22.6006C3.55439 22.6006 2.22158 20.9843 2.22158 19.2006L2.22158 4.80057C2.22159 3.01682 3.5544 1.40057 5.39852 1.40057L14.1063 1.40057C15.9504 1.40057 17.2832 3.01683 17.2832 4.80057L17.2832 19.2006Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M10.5684 15.1064L10.5684 21.2559L9.06836 21.2559L9.06836 15.1064L10.5684 15.1064Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.93555 6.45605C4.93555 5.90377 5.38326 5.45605 5.93555 5.45605H6.84036C7.39265 5.45605 7.84036 5.90377 7.84036 6.45605C7.84036 7.00834 7.39265 7.45605 6.84036 7.45605H5.93555C5.38326 7.45605 4.93555 7.00834 4.93555 6.45605Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.93555 10.418C4.93555 9.86568 5.38326 9.41797 5.93555 9.41797H6.84036C7.39265 9.41797 7.84036 9.86568 7.84036 10.418C7.84036 10.9703 7.39265 11.418 6.84036 11.418H5.93555C5.38326 11.418 4.93555 10.9703 4.93555 10.418Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.29883 6.45605C8.29883 5.90377 8.74654 5.45605 9.29883 5.45605H10.2036C10.7559 5.45605 11.2036 5.90377 11.2036 6.45605C11.2036 7.00834 10.7559 7.45605 10.2036 7.45605H9.29883C8.74654 7.45605 8.29883 7.00834 8.29883 6.45605Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.29883 10.418C8.29883 9.86568 8.74654 9.41797 9.29883 9.41797H10.2036C10.7559 9.41797 11.2036 9.86568 11.2036 10.418C11.2036 10.9703 10.7559 11.418 10.2036 11.418H9.29883C8.74654 11.418 8.29883 10.9703 8.29883 10.418Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.6621 6.45605C11.6621 5.90377 12.1098 5.45605 12.6621 5.45605H13.5669C14.1192 5.45605 14.5669 5.90377 14.5669 6.45605C14.5669 7.00834 14.1192 7.45605 13.5669 7.45605H12.6621C12.1098 7.45605 11.6621 7.00834 11.6621 6.45605Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.6621 10.418C11.6621 9.86568 12.1098 9.41797 12.6621 9.41797H13.5669C14.1192 9.41797 14.5669 9.86568 14.5669 10.418C14.5669 10.9703 14.1192 11.418 13.5669 11.418H12.6621C12.1098 11.418 11.6621 10.9703 11.6621 10.418Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M22.2597 19.8554C22.2597 21.2031 21.3088 22.6006 19.7907 22.6006L14.8009 22.6006C14.2486 22.6006 13.8009 22.1529 13.8009 21.6006C13.8009 21.0483 14.2486 20.6006 14.8009 20.6006L19.7907 20.6006C19.8585 20.6006 19.9592 20.5705 20.0644 20.4455C20.1714 20.3183 20.2597 20.1129 20.2597 19.8554L20.2598 9.38412C20.2598 9.12662 20.1715 8.92119 20.0645 8.79403C19.9592 8.669 19.8586 8.6389 19.7908 8.6389L17.3352 8.6389C16.7829 8.6389 16.3352 8.19119 16.3352 7.6389C16.3352 7.08662 16.7829 6.6389 17.3352 6.6389L19.7908 6.6389C21.3089 6.63891 22.2598 8.03638 22.2598 9.38413L22.2597 19.8554Z",
      fill: "currentColor"
    })
  ]),
  private: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.93327 3.79289C5.3238 3.40237 5.95696 3.40237 6.34749 3.79289L21.3475 18.7929C21.738 19.1834 21.738 19.8166 21.3475 20.2071C20.957 20.5976 20.3238 20.5976 19.9333 20.2071L18.0185 18.2923C16.5082 19.2173 14.5948 19.8514 12.224 19.8126C8.22252 19.7472 5.57345 17.8927 3.94702 16.0641C3.13931 15.156 2.58219 14.2542 2.2259 13.5781C2.04728 13.2391 1.91774 12.9543 1.8314 12.75C1.7882 12.6477 1.7557 12.5654 1.7332 12.5063C1.72194 12.4768 1.71317 12.453 1.70681 12.4354L1.69904 12.4137L1.69648 12.4064L1.69553 12.4036L1.69514 12.4025C1.69496 12.402 1.6948 12.4015 2.64038 12.0761C1.68608 11.7773 1.68618 11.777 1.68629 11.7766L1.68707 11.7741L1.68846 11.7698L1.69247 11.7573L1.70549 11.7181C1.71641 11.6857 1.73191 11.6409 1.75223 11.5851C1.79285 11.4734 1.85288 11.3169 1.93447 11.125C2.09739 10.7417 2.34775 10.2137 2.70335 9.61782C3.34841 8.53686 4.35672 7.20429 5.84356 6.1174L4.93327 5.20711C4.54275 4.81658 4.54275 4.18342 4.93327 3.79289ZM7.27882 7.55266C5.93202 8.46354 5.01142 9.65297 4.4208 10.6427C4.11917 11.1482 3.90868 11.5931 3.77507 11.9074C3.75161 11.9626 3.73057 12.0136 3.71187 12.0602C3.77831 12.2117 3.87184 12.4115 3.99525 12.6457C4.29473 13.214 4.76453 13.9739 5.44144 14.7349C6.78424 16.2447 8.93516 17.7585 12.2567 17.8129C14.0065 17.8415 15.4179 17.434 16.5537 16.8275L14.3378 14.6116C13.7583 15.0575 13.0284 15.3217 12.2404 15.3217C10.3885 15.3217 8.84038 13.8539 8.84038 11.9863C8.84038 11.1849 9.12947 10.4506 9.60496 9.87879L7.27882 7.55266ZM11.0341 11.308C10.9098 11.5082 10.8404 11.7398 10.8404 11.9863C10.8404 12.6982 11.4413 13.3217 12.2404 13.3217C12.4782 13.3217 12.7 13.2657 12.8939 13.1677L11.0341 11.308ZM3.58508 11.7482C3.58493 11.7478 3.58496 11.7478 3.58508 11.7482V11.7482ZM2.64038 12.0761L1.68629 11.7766L1.58789 12.0908L1.6948 12.4015L2.64038 12.0761ZM12.2404 6.1C11.8594 6.1 11.4954 6.12012 11.1479 6.1577C10.5988 6.21707 10.1055 5.82008 10.0462 5.27099C9.9868 4.72191 10.3838 4.22866 10.9329 4.16929C11.3531 4.12385 11.7888 4.1 12.2404 4.1C16.3096 4.1 18.97 6.03063 20.5851 7.9428C21.3867 8.89184 21.9337 9.83744 22.281 10.5459C22.4552 10.9011 22.5807 11.1998 22.664 11.4138C22.7056 11.5208 22.7368 11.6069 22.7583 11.6686C22.7691 11.6995 22.7774 11.7242 22.7834 11.7425L22.7908 11.7649L22.7931 11.7724L22.794 11.7752L22.7944 11.7763C22.7945 11.7768 22.7947 11.7773 21.8404 12.0761C22.7894 12.3913 22.7894 12.3915 22.7893 12.3917L22.7882 12.3948L22.7866 12.3998L22.7817 12.4141C22.7777 12.4256 22.7723 12.4409 22.7655 12.4599C22.7519 12.4978 22.7325 12.5502 22.7071 12.6157C22.6562 12.7465 22.5808 12.9297 22.4782 13.1528C22.2734 13.5981 21.9583 14.2071 21.5107 14.8771C21.2039 15.3364 20.583 15.46 20.1237 15.1532C19.6645 14.8464 19.5409 14.2254 19.8477 13.7662C20.2263 13.1994 20.4917 12.6856 20.661 12.3174C20.7042 12.2235 20.7409 12.1395 20.7716 12.0668C20.7062 11.9039 20.612 11.6847 20.4853 11.4264C20.1913 10.8268 19.7287 10.0283 19.0572 9.23333C17.7261 7.65743 15.5866 6.1 12.2404 6.1ZM21.8404 12.0761L22.7893 12.3917L22.8911 12.0851L22.7947 11.7773L21.8404 12.0761ZM20.8868 12.3772C20.8869 12.3776 20.8869 12.3777 20.8868 12.3772V12.3772Z",
      fill: "currentColor"
    })
  ]),
  public: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.71187 12.1027C3.77709 11.9405 3.8705 11.7238 3.99547 11.4689C4.28946 10.8693 4.75209 10.0709 5.42357 9.27591C6.75464 7.70001 8.8942 6.14258 12.2404 6.14258C15.5866 6.14258 17.7261 7.70001 19.0572 9.27591C19.7287 10.0709 20.1913 10.8693 20.4853 11.4689C20.612 11.7273 20.7062 11.9465 20.7716 12.1094C20.7044 12.2686 20.6082 12.4819 20.4799 12.7327C20.1796 13.3197 19.7095 14.1002 19.0335 14.8739C17.6935 16.4076 15.5568 17.9094 12.2567 17.8554C8.93516 17.8011 6.78424 16.2872 5.44144 14.7775C4.76453 14.0165 4.29473 13.2566 3.99525 12.6883C3.87184 12.4541 3.77831 12.2542 3.71187 12.1027ZM21.8404 12.1187C22.7947 11.8199 22.7944 11.8189 22.7944 11.8189L22.794 11.8177L22.7931 11.815L22.7908 11.8075L22.7834 11.7851C22.7774 11.7668 22.7691 11.742 22.7583 11.7112C22.7368 11.6495 22.7056 11.5634 22.664 11.4563C22.5807 11.2424 22.4552 10.9437 22.281 10.5884C21.9337 9.88002 21.3867 8.93442 20.5851 7.98537C18.97 6.07321 16.3096 4.14258 12.2404 4.14258C8.17118 4.14258 5.51074 6.07321 3.89566 7.98537C3.09405 8.93442 2.54707 9.88002 2.19971 10.5884C2.02552 10.9437 1.90003 11.2424 1.81679 11.4563C1.77514 11.5634 1.74395 11.6495 1.72245 11.7112C1.7117 11.742 1.70336 11.7668 1.69733 11.7851L1.69001 11.8075L1.68763 11.815L1.68675 11.8177L1.68639 11.8189C1.68639 11.8189 1.68608 11.8199 2.64038 12.1187L1.68608 11.8199L1.58789 12.1334L1.6948 12.4441L2.64038 12.1187C1.6948 12.4441 1.69514 12.4451 1.69514 12.4451L1.69553 12.4462L1.69648 12.449L1.69904 12.4562L1.70681 12.478C1.71317 12.4956 1.72194 12.5193 1.7332 12.5489C1.7557 12.608 1.7882 12.6903 1.8314 12.7925C1.91774 12.9968 2.04728 13.2817 2.2259 13.6207C2.58219 14.2968 3.13931 15.1986 3.94702 16.1067C5.57345 17.9353 8.22252 19.7897 12.224 19.8552C16.2471 19.921 18.9104 18.0545 20.5396 16.1899C21.3482 15.2645 21.905 14.3384 22.2605 13.6436C22.4387 13.2951 22.5679 13.0018 22.6539 12.7916C22.6969 12.6863 22.7292 12.6017 22.7515 12.541C22.7627 12.5106 22.7714 12.4862 22.7777 12.4682L22.7853 12.4461L22.7878 12.4387L22.7887 12.436L22.7891 12.4348C22.7891 12.4348 22.7894 12.4339 21.8404 12.1187ZM21.8404 12.1187L22.7894 12.4339L22.8911 12.1277L22.7947 11.8199L21.8404 12.1187ZM12.2404 10.6935C11.4413 10.6935 10.8404 11.317 10.8404 12.0289C10.8404 12.7408 11.4413 13.3642 12.2404 13.3642C13.0395 13.3642 13.6404 12.7408 13.6404 12.0289C13.6404 11.317 13.0395 10.6935 12.2404 10.6935ZM8.84038 12.0289C8.84038 10.1613 10.3885 8.69353 12.2404 8.69353C14.0922 8.69353 15.6404 10.1613 15.6404 12.0289C15.6404 13.8965 14.0922 15.3642 12.2404 15.3642C10.3885 15.3642 8.84038 13.8965 8.84038 12.0289Z",
      fill: "currentColor"
    })
  ]),
  tagManagement: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M13.8861 3.40217C13.6629 3.385 13.4434 3.46622 13.2851 3.6245L3.86521 13.0444C3.56576 13.3438 3.56576 13.8293 3.86521 14.1288L10.1118 20.3753C10.4112 20.6748 10.8967 20.6748 11.1962 20.3753L20.616 10.9554C20.7743 10.7972 20.8555 10.5776 20.8384 10.3544L20.3922 4.55407C20.3632 4.17698 20.0635 3.87736 19.6865 3.84835L13.8861 3.40217ZM11.8709 2.21029C12.442 1.63916 13.2342 1.34611 14.0395 1.40806L19.8398 1.85424C21.2005 1.95891 22.2816 3.04003 22.3863 4.40068L22.8325 10.201C22.8944 11.0064 22.6014 11.7985 22.0302 12.3697L12.6104 21.7895C11.5299 22.87 9.77804 22.87 8.69754 21.7895L2.451 15.543C1.3705 14.4625 1.3705 12.7107 2.451 11.6302L11.8709 2.21029ZM15.5882 7.64726C15.591 7.09498 16.041 6.64955 16.5933 6.65237L16.5997 6.6524C17.1519 6.65521 17.5974 7.1052 17.5946 7.65748C17.5918 8.20976 17.1418 8.65519 16.5895 8.65237L16.5831 8.65234C16.0308 8.64953 15.5854 8.19954 15.5882 7.64726Z",
      fill: "currentColor"
    })
  ]),
  disconnect: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.69865 0.449787C10.2482 0.504334 10.6495 0.99408 10.595 1.54366L10.414 3.36719C10.3595 3.91678 9.86971 4.31808 9.32013 4.26354C8.77055 4.20899 8.36924 3.71924 8.42379 3.16966L8.60477 1.34613C8.65932 0.796548 9.14907 0.395241 9.69865 0.449787ZM12.0916 4.57161C13.1214 3.5418 14.5167 2.99024 15.9682 3.00091C17.4166 3.01155 18.8088 3.58084 19.8436 4.61269C20.912 5.65104 21.483 7.0492 21.4937 8.49942C21.5045 9.96667 20.9145 11.3571 19.8958 12.3758L17.6623 14.6092C17.2718 14.9998 16.6386 14.9998 16.2481 14.6092C15.8576 14.2187 15.8576 13.5856 16.2481 13.195L18.4816 10.9616C19.1311 10.312 19.5005 9.4325 19.4937 8.51412C19.4869 7.58127 19.1215 6.69801 18.4461 6.04345L18.4349 6.03245C17.7773 5.37484 16.8881 5.00772 15.9535 5.00085C15.0194 4.99399 14.1443 5.34733 13.5058 5.98583C13.5058 5.98583 13.5058 5.98584 13.5058 5.98584L11.2724 8.21928C10.8818 8.60981 10.2487 8.60981 9.85815 8.21928C9.46763 7.82876 9.46763 7.19559 9.85815 6.80507L12.0916 4.57162L12.0916 4.57161ZM3.76398 3.40376C4.15451 3.01324 4.78767 3.01324 5.17819 3.40376L6.2845 4.51007C6.67502 4.90059 6.67502 5.53376 6.2845 5.92428C5.89398 6.3148 5.26081 6.3148 4.87029 5.92428L3.76398 4.81797C3.37346 4.42745 3.37346 3.79428 3.76398 3.40376ZM16.3543 8.01238C16.7448 8.4029 16.7448 9.03607 16.3543 9.42659L9.65394 16.127C9.26342 16.5175 8.63025 16.5175 8.23973 16.127C7.8492 15.7364 7.8492 15.1033 8.23973 14.7127L14.9401 8.01238C15.3306 7.62185 15.9638 7.62185 16.3543 8.01238ZM4.84873 8.79507C4.90328 9.34465 4.50197 9.8344 3.95239 9.88894L2.06173 10.0766C1.51215 10.1311 1.0224 9.72983 0.967854 9.18025C0.913307 8.63066 1.31461 8.14092 1.8642 8.08637L3.75486 7.89872C4.30444 7.84418 4.79419 8.24548 4.84873 8.79507ZM8.41935 9.57611C8.80987 9.96664 8.80987 10.5998 8.41935 10.9903L6.18589 13.2238C5.53632 13.8734 5.16696 14.7529 5.17371 15.6712C5.18057 16.6041 5.54592 17.4874 6.22134 18.1419C6.22885 18.1492 6.23626 18.1566 6.24354 18.1641C6.89801 18.8395 7.78147 19.2049 8.71418 19.2117C9.67206 19.2188 10.5211 18.8675 11.1618 18.2267L13.3953 15.9933C13.7858 15.6028 14.419 15.6028 14.8095 15.9933C15.2 16.3838 15.2 17.017 14.8095 17.4075L12.5761 19.6409L11.8689 18.9338L12.576 19.641C11.5485 20.6685 10.1813 21.2225 8.69949 21.2117C7.25205 21.201 5.85598 20.632 4.8182 19.5672C3.75344 18.5294 3.1844 17.1336 3.17377 15.6859C3.16298 14.2187 3.75299 12.8283 4.77168 11.8096L5.47879 12.5167L4.77168 11.8096L7.00514 9.57611C7.39566 9.18559 8.02883 9.18559 8.41935 9.57611ZM23.7916 14.5427C23.8461 15.0923 23.4448 15.582 22.8952 15.6366L21.0046 15.8242C20.455 15.8788 19.9652 15.4775 19.9107 14.9279C19.8561 14.3783 20.2575 13.8886 20.807 13.834L22.6977 13.6464C23.2473 13.5918 23.737 13.9931 23.7916 14.5427ZM18.4749 17.7987C18.8655 17.4082 19.4986 17.4082 19.8891 17.7987L20.9954 18.905C21.386 19.2955 21.386 19.9287 20.9954 20.3192C20.6049 20.7097 19.9718 20.7097 19.5812 20.3192L18.4749 19.2129C18.0844 18.8224 18.0844 18.1892 18.4749 17.7987ZM15.4393 19.4594C15.9889 19.514 16.3902 20.0037 16.3356 20.5533L16.1547 22.3768C16.1001 22.9264 15.6104 23.3277 15.0608 23.2732C14.5112 23.2186 14.1099 22.7289 14.1644 22.1793L14.3454 20.3558C14.4 19.8062 14.8897 19.4049 15.4393 19.4594Z",
      fill: "currentColor"
    })
  ]),
  link: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.1551 14.5166C16.5456 14.9071 17.1788 14.9071 17.5693 14.5166L19.8028 12.2832C20.8215 11.2645 21.4115 9.87405 21.4007 8.4068C21.39 6.95655 20.819 5.55838 19.7506 4.52002C18.7158 3.4882 17.3236 2.91893 15.8752 2.90828C14.4237 2.89762 13.0284 3.44918 11.9986 4.47899L9.76514 6.71245C9.37462 7.10297 9.37462 7.73613 9.76514 8.12666C10.1557 8.51718 10.7888 8.51718 11.1794 8.12666L13.4128 5.89322C14.0513 5.25471 14.9263 4.90136 15.8605 4.90823C16.7951 4.9151 17.6843 5.28221 18.3419 5.93982L18.3531 5.95082C19.0285 6.60539 19.3939 7.48864 19.4007 8.4215C19.4075 9.33987 19.0381 10.2194 18.3886 10.869L16.1551 13.1024C15.7646 13.4929 15.7646 14.1261 16.1551 14.5166ZM13.3023 15.9007L11.0688 18.1341C11.0688 18.1341 11.0688 18.1341 11.0688 18.1341C10.4281 18.7749 9.57905 19.1261 8.62118 19.1191C7.68846 19.1122 6.805 18.7469 6.15053 18.0715C6.14325 18.064 6.13584 18.0566 6.12833 18.0493C5.45291 17.3947 5.08756 16.5115 5.0807 15.5786C5.07395 14.6602 5.44331 13.7807 6.09288 13.1312L8.32634 10.8977C8.71687 10.5072 8.71687 9.87401 8.32634 9.48349C7.93582 9.09297 7.30265 9.09297 6.91213 9.48349L4.67867 11.7169C3.65998 12.7356 3.06997 14.1261 3.08076 15.5933C3.0914 17.041 3.66044 18.4368 4.7252 19.4746C5.76299 20.5394 7.15905 21.1084 8.60648 21.119C10.0883 21.1299 11.4555 20.5759 12.483 19.5483L14.7165 17.3149C15.107 16.9243 15.107 16.2912 14.7165 15.9007C14.326 15.5101 13.6928 15.5101 13.3023 15.9007ZM8.14672 16.0343C8.53724 16.4249 9.17041 16.4249 9.56093 16.0343L16.2613 9.33396C16.6518 8.94344 16.6518 8.31028 16.2613 7.91975C15.8708 7.52923 15.2376 7.52923 14.8471 7.91975L8.14672 14.6201C7.7562 15.0106 7.7562 15.6438 8.14672 16.0343Z",
      fill: "currentColor"
    })
  ]),
  snapshot: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.04062 3.3999C4.31514 3.3999 3.64062 4.0343 3.64062 4.92622V19.0736C3.64062 19.9655 4.31514 20.5999 5.04062 20.5999H19.4406C20.1661 20.5999 20.8406 19.9655 20.8406 19.0736V4.92622C20.8406 4.0343 20.1661 3.3999 19.4406 3.3999H5.04062ZM1.64062 4.92622C1.64062 3.02764 3.11514 1.3999 5.04062 1.3999H19.4406C21.3661 1.3999 22.8406 3.02764 22.8406 4.92622V19.0736C22.8406 20.9722 21.3661 22.5999 19.4406 22.5999H5.04062C3.11514 22.5999 1.64062 20.9722 1.64062 19.0736V4.92622Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.55273 9.04053C8.17304 9.04053 7.86523 9.34833 7.86523 9.72803C7.86523 10.1077 8.17304 10.4155 8.55273 10.4155C8.93243 10.4155 9.24023 10.1077 9.24023 9.72803C9.24023 9.34833 8.93243 9.04053 8.55273 9.04053ZM5.86523 9.72803C5.86523 8.24376 7.06847 7.04053 8.55273 7.04053C10.037 7.04053 11.2402 8.24376 11.2402 9.72803C11.2402 11.2123 10.037 12.4155 8.55273 12.4155C7.06847 12.4155 5.86523 11.2123 5.86523 9.72803ZM15.7206 12.9584C16.1112 12.5679 16.7443 12.5679 17.1348 12.9584L21.6348 17.4584C22.0254 17.8489 22.0254 18.4821 21.6348 18.8726C21.2443 19.2632 20.6112 19.2632 20.2206 18.8726L16.4277 15.0797L12.0723 19.4351C11.6818 19.8257 11.0487 19.8257 10.6581 19.4351L9.11523 17.8922L5.32234 21.6851C4.93182 22.0757 4.29865 22.0757 3.90813 21.6851C3.5176 21.2946 3.5176 20.6614 3.90813 20.2709L8.40813 15.7709C8.79865 15.3804 9.43182 15.3804 9.82234 15.7709L11.3652 17.3138L15.7206 12.9584Z",
      fill: "currentColor"
    })
  ]),
  calendar: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.79976 2C7.35204 2 7.79976 2.44772 7.79976 3V3.54285H15.9902V3C15.9902 2.44772 16.4379 2 16.9902 2C17.5425 2 17.9902 2.44772 17.9902 3V3.6709C19.73 4.12672 20.9902 5.74416 20.9902 7.62855L20.9902 15.084C20.9902 15.0846 20.9902 15.0851 20.9902 15.0857C20.9902 15.0863 20.9902 15.0868 20.9902 15.0874V17.9143C20.9902 20.144 19.2257 22 16.9902 22H6.99023C4.75473 22 2.99023 20.144 2.99023 17.9143V7.62855C2.99023 5.81365 4.15925 4.24637 5.79976 3.72603V3C5.79976 2.44772 6.24747 2 6.79976 2ZM4.99023 16.0857V17.9143C4.99023 19.0929 5.91203 20 6.99023 20H8.49023V16.0857H4.99023ZM8.49023 14.0857H4.99023V9.91425H8.49023V14.0857ZM10.4902 16.0857V20H13.4902V16.0857H10.4902ZM13.4902 14.0857H10.4902V9.91425H13.4902V14.0857ZM15.4902 16.0857V20H16.9902C18.0684 20 18.9902 19.0929 18.9902 17.9143V16.0857H15.4902ZM18.9902 14.0857H15.4902V9.91425H18.9902L18.9902 14.0857ZM18.9902 7.91425V7.62855C18.9902 6.44991 18.0684 5.54285 16.9902 5.54285H6.99023C5.91203 5.54285 4.99023 6.44991 4.99023 7.62855V7.91425H18.9902Z",
      fill: "currentColor"
    })
  ]),
  cloud: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.5259 6.60791C8.93381 6.60791 6.81166 8.73847 6.81166 11.3925C6.81166 11.5964 6.82418 11.7969 6.84837 11.9933C6.8834 12.2776 6.79477 12.5634 6.60496 12.778C6.50435 12.8918 6.38043 12.9798 6.24352 13.0373C6.07631 13.1174 5.88836 13.1502 5.70044 13.1292C5.62003 13.1202 5.53799 13.1155 5.45452 13.1155C4.24309 13.1155 3.24023 14.113 3.24023 15.3693C3.24023 16.5303 4.14392 17.392 5.45452 17.392H17.8502C19.799 17.0797 21.2402 15.5412 21.2402 13.5617C21.2402 11.307 19.4379 9.50018 17.2402 9.50018C17.0404 9.50018 16.8446 9.51499 16.6536 9.54342C16.242 9.60471 15.8354 9.40466 15.6328 9.04113C14.8199 7.58243 13.2816 6.60791 11.5259 6.60791ZM4.81541 11.164C4.93454 7.53349 7.88239 4.60791 11.5259 4.60791C13.8073 4.60791 15.8173 5.75717 17.0285 7.5039C17.0988 7.50143 17.1694 7.50018 17.2402 7.50018C20.5654 7.50018 23.2402 10.2256 23.2402 13.5617C23.2402 16.6591 20.9322 18.9671 18.0691 19.3816C18.0216 19.3885 17.9738 19.392 17.9258 19.392H5.45452C3.21472 19.392 1.24023 17.8024 1.24023 15.3693C1.24023 13.2489 2.78311 11.4754 4.81541 11.164Z",
      fill: "currentColor"
    })
  ]),
  update: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M12.2402 4.00003V2.21003C12.2402 1.76003 11.7002 1.54003 11.3902 1.86003L8.59023 4.65003C8.39023 4.85003 8.39023 5.16003 8.59023 5.36003L11.3802 8.15003C11.7002 8.46003 12.2402 8.24003 12.2402 7.79003V6.00003C15.5502 6.00003 18.2402 8.69003 18.2402 12C18.2402 12.79 18.0902 13.56 17.8002 14.25C17.6502 14.61 17.7602 15.02 18.0302 15.29C18.5402 15.8 19.4002 15.62 19.6702 14.95C20.0402 14.04 20.2402 13.04 20.2402 12C20.2402 7.58003 16.6602 4.00003 12.2402 4.00003ZM12.2402 18C8.93023 18 6.24023 15.31 6.24023 12C6.24023 11.21 6.39023 10.44 6.68023 9.75003C6.83023 9.39003 6.72023 8.98003 6.45023 8.71003C5.94023 8.20003 5.08023 8.38003 4.81023 9.05003C4.44023 9.96003 4.24023 10.96 4.24023 12C4.24023 16.42 7.82023 20 12.2402 20V21.79C12.2402 22.24 12.7802 22.46 13.0902 22.14L15.8802 19.35C16.0802 19.15 16.0802 18.84 15.8802 18.64L13.0902 15.85C12.7802 15.54 12.2402 15.76 12.2402 16.21V18Z",
      fill: "currentColor"
    })
  ]),
  updateProgress: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M12.2402 0C5.61623 0 0.240234 5.376 0.240234 12C0.240234 18.624 5.61623 24 12.2402 24C18.8642 24 24.2402 18.624 24.2402 12C24.2402 5.376 18.8642 0 12.2402 0ZM13.3322 19.38C12.9602 19.752 12.3122 19.488 12.3122 18.96V18C12.2882 18 12.2642 18 12.2402 18C10.7042 18 9.16823 17.412 7.99223 16.248C6.27623 14.532 5.82023 12.024 6.62423 9.888C6.85223 9.276 7.65624 9.12 8.11224 9.588C8.37624 9.852 8.43623 10.236 8.31623 10.572C7.76423 12.06 8.07623 13.788 9.27623 14.988C10.1162 15.828 11.2202 16.224 12.3242 16.2V15.072C12.3242 14.532 12.9722 14.268 13.3442 14.652L15.2882 16.596C15.5282 16.836 15.5282 17.208 15.2882 17.448L13.3322 19.38ZM16.3682 14.424C16.1042 14.16 16.0442 13.776 16.1642 13.44C16.7162 11.952 16.4042 10.224 15.2042 9.024C14.3642 8.184 13.2602 7.776 12.1682 7.8V8.928C12.1682 9.468 11.5202 9.732 11.1482 9.348L9.19223 7.416C8.95224 7.176 8.95224 6.804 9.19223 6.564L11.1362 4.62C11.5082 4.248 12.1562 4.512 12.1562 5.04V6.012C13.7162 5.988 15.2882 6.552 16.4762 7.752C18.1922 9.468 18.6482 11.976 17.8442 14.112C17.6162 14.736 16.8242 14.892 16.3682 14.424Z",
      fill: "currentColor"
    })
  ]),
  search: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.6798 4.6001C7.90222 4.6001 4.83984 7.66247 4.83984 11.4401C4.83984 15.2177 7.90222 18.2801 11.6798 18.2801C13.5424 18.2801 15.2311 17.5356 16.4646 16.328C16.4663 16.3264 16.468 16.3247 16.4696 16.3231C17.7349 15.0818 18.5198 13.3526 18.5198 11.4401C18.5198 7.66247 15.4575 4.6001 11.6798 4.6001ZM18.5575 16.9942C19.7848 15.4764 20.5198 13.5441 20.5198 11.4401C20.5198 6.5579 16.562 2.6001 11.6798 2.6001C6.79765 2.6001 2.83984 6.5579 2.83984 11.4401C2.83984 16.3223 6.79765 20.2801 11.6798 20.2801C13.7373 20.2801 15.6305 19.5772 17.1326 18.3985L19.9445 21.1188C20.3415 21.5028 20.9746 21.4923 21.3586 21.0954C21.7426 20.6985 21.7321 20.0654 21.3351 19.6814L18.5575 16.9942Z",
      fill: "currentColor"
    })
  ]),
  check: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M17.7446 7.6908C18.1362 8.08023 18.138 8.71339 17.7486 9.10501L10.589 16.305C10.4013 16.4938 10.1461 16.5999 9.87994 16.5999C9.61374 16.5999 9.35853 16.4938 9.17084 16.305L6.73036 13.8507C6.34093 13.4591 6.34272 12.8259 6.73434 12.4365C7.12597 12.0471 7.75913 12.0489 8.14855 12.4405L9.87994 14.1817L16.3304 7.69479C16.7198 7.30317 17.3529 7.30138 17.7446 7.6908Z",
      fill: "currentColor"
    })
  ]),
  checkCircle: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24023 12C2.24023 6.47715 6.71739 2 12.2402 2C17.7631 2 22.2402 6.47715 22.2402 12C22.2402 17.5228 17.7631 22 12.2402 22C6.71739 22 2.24023 17.5228 2.24023 12ZM12.2402 4C7.82196 4 4.24023 7.58172 4.24023 12C4.24023 16.4183 7.82196 20 12.2402 20C16.6585 20 20.2402 16.4183 20.2402 12C20.2402 7.58172 16.6585 4 12.2402 4ZM16.0893 9.27589C16.4799 9.66641 16.4799 10.2996 16.0893 10.6901L11.8223 14.9571C11.4318 15.3476 10.7987 15.3476 10.4081 14.9571L8.95362 13.5026C8.5631 13.1121 8.5631 12.4789 8.95362 12.0884C9.34415 11.6979 9.97731 11.6979 10.3678 12.0884L11.1152 12.8358L14.6751 9.27589C15.0657 8.88536 15.6988 8.88536 16.0893 9.27589Z",
      fill: "currentColor"
    })
  ]),
  download: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.2414 2C12.7936 2 13.2414 2.44772 13.2414 3V12.5313L16.1063 9.67155C16.4972 9.28138 17.1304 9.28195 17.5205 9.67283C17.9107 10.0637 17.9101 10.6969 17.5192 11.087L12.9478 15.6502C12.5574 16.0399 11.9253 16.0399 11.5349 15.6502L6.96345 11.087C6.57258 10.6969 6.572 10.0637 6.96218 9.67283C7.35235 9.28195 7.98551 9.28138 8.37639 9.67155L11.2414 12.5313V3C11.2414 2.44772 11.6891 2 12.2414 2ZM20.2402 14.2044C20.7925 14.2044 21.2402 14.6521 21.2402 15.2044V18.8925C21.2402 19.7003 20.9362 20.4848 20.3798 21.0711C19.8217 21.6592 19.0533 22 18.2402 22H6.24023C5.42719 22 4.65874 21.6592 4.10066 21.0711C3.54426 20.4848 3.24023 19.7003 3.24023 18.8925L3.24023 15.2044C3.24023 14.6521 3.68795 14.2044 4.24023 14.2044C4.79252 14.2044 5.24023 14.6521 5.24023 15.2044V18.8925C5.24023 19.2026 5.35764 19.4902 5.55138 19.6944C5.74344 19.8967 5.99241 20 6.24023 20H18.2402C18.4881 20 18.737 19.8967 18.9291 19.6944C19.1228 19.4902 19.2402 19.2026 19.2402 18.8925V15.2044C19.2402 14.6521 19.688 14.2044 20.2402 14.2044Z",
      fill: "currentColor"
    })
  ]),
  next: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.8839 4.27586C13.2838 3.89498 13.9168 3.91042 14.2977 4.31035L20.9644 11.3103C21.3322 11.6966 21.3322 12.3034 20.9644 12.6897L14.2977 19.6897C13.9168 20.0896 13.2838 20.105 12.8839 19.7241C12.484 19.3433 12.4685 18.7103 12.8494 18.3103L17.9069 13L4.24023 13C3.68795 13 3.24023 12.5523 3.24023 12C3.24023 11.4477 3.68795 11 4.24023 11L17.9069 11L12.8494 5.68966C12.4685 5.28973 12.484 4.65675 12.8839 4.27586Z",
      fill: "currentColor"
    })
  ]),
  prev: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.5966 4.27586C11.9965 4.65675 12.0119 5.28973 11.631 5.68966L6.57357 11L20.2402 11C20.7925 11 21.2402 11.4477 21.2402 12C21.2402 12.5523 20.7925 13 20.2402 13L6.57357 13L11.631 18.3103C12.0119 18.7103 11.9965 19.3433 11.5966 19.7241C11.1966 20.105 10.5637 20.0896 10.1828 19.6897L3.5161 12.6897C3.14828 12.3034 3.14828 11.6966 3.5161 11.3103L10.1828 4.31035C10.5636 3.91042 11.1966 3.89498 11.5966 4.27586Z",
      fill: "currentColor"
    })
  ]),
  close: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M18.5409 5.71022C18.1509 5.32022 17.5209 5.32022 17.1309 5.71022L12.2409 10.5902L7.35094 5.70021C6.96094 5.31021 6.33094 5.31021 5.94094 5.70021C5.55094 6.09021 5.55094 6.72022 5.94094 7.11022L10.8309 12.0002L5.94094 16.8902C5.55094 17.2802 5.55094 17.9102 5.94094 18.3002C6.33094 18.6902 6.96094 18.6902 7.35094 18.3002L12.2409 13.4102L17.1309 18.3002C17.5209 18.6902 18.1509 18.6902 18.5409 18.3002C18.9309 17.9102 18.9309 17.2802 18.5409 16.8902L13.6509 12.0002L18.5409 7.11022C18.9209 6.73022 18.9209 6.09022 18.5409 5.71022Z",
      fill: "currentColor"
    })
  ]),
  add: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M18.2402 13H13.2402V18C13.2402 18.55 12.7902 19 12.2402 19C11.6902 19 11.2402 18.55 11.2402 18V13H6.24023C5.69023 13 5.24023 12.55 5.24023 12C5.24023 11.45 5.69023 11 6.24023 11H11.2402V6C11.2402 5.45 11.6902 5 12.2402 5C12.7902 5 13.2402 5.45 13.2402 6V11H18.2402C18.7902 11 19.2402 11.45 19.2402 12C19.2402 12.55 18.7902 13 18.2402 13Z",
      fill: "currentColor"
    })
  ]),
  fullscreen: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.53313 3.29289C3.72066 3.10536 3.97502 3 4.24023 3L8.24023 3C8.79252 3 9.24023 3.44772 9.24023 4C9.24023 4.55228 8.79252 5 8.24023 5H6.65445L9.44734 7.79289C9.83787 8.18342 9.83787 8.81658 9.44734 9.20711C9.05682 9.59763 8.42365 9.59763 8.03313 9.20711L5.24023 6.41421V8C5.24023 8.55228 4.79252 9 4.24023 9C3.68795 9 3.24023 8.55228 3.24023 8L3.24023 4C3.24023 3.73478 3.34559 3.48043 3.53313 3.29289ZM17.826 5H16.2402C15.6879 5 15.2402 4.55228 15.2402 4C15.2402 3.44772 15.6879 3 16.2402 3H20.2402C20.7925 3 21.2402 3.44772 21.2402 4V8C21.2402 8.55228 20.7925 9 20.2402 9C19.688 9 19.2402 8.55228 19.2402 8V6.41421L16.4473 9.20711C16.0568 9.59763 15.4237 9.59763 15.0331 9.20711C14.6426 8.81658 14.6426 8.18342 15.0331 7.79289L17.826 5ZM9.44734 14.7929C9.83787 15.1834 9.83787 15.8166 9.44734 16.2071L6.65445 19H8.24023C8.79252 19 9.24023 19.4477 9.24023 20C9.24023 20.5523 8.79252 21 8.24023 21H4.24023C3.68795 21 3.24023 20.5523 3.24023 20V16C3.24023 15.4477 3.68795 15 4.24023 15C4.79252 15 5.24023 15.4477 5.24023 16V17.5858L8.03313 14.7929C8.42365 14.4024 9.05682 14.4024 9.44734 14.7929ZM15.0331 14.7929C15.4237 14.4024 16.0568 14.4024 16.4473 14.7929L19.2402 17.5858V16C19.2402 15.4477 19.688 15 20.2402 15C20.7925 15 21.2402 15.4477 21.2402 16L21.2402 20C21.2402 20.5523 20.7925 21 20.2402 21H16.2402C15.6879 21 15.2402 20.5523 15.2402 20C15.2402 19.4477 15.6879 19 16.2402 19H17.826L15.0331 16.2071C14.6426 15.8166 14.6426 15.1834 15.0331 14.7929Z",
      fill: "currentColor"
    })
  ]),
  syncCheck: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.93955 4.79988C1.93956 2.92212 3.46179 1.3999 5.33955 1.3999H16.1398C18.0176 1.3999 19.5398 2.92213 19.5398 4.7999V11.3999C19.5398 11.9522 19.0921 12.3999 18.5398 12.3999C17.9875 12.3999 17.5398 11.9522 17.5398 11.3999V4.7999C17.5398 4.0267 16.913 3.3999 16.1398 3.3999H5.33955C4.56635 3.3999 3.93955 4.0267 3.93955 4.7999L3.93945 19.1998C3.93945 19.973 4.56625 20.5998 5.33945 20.5998H10.1395C10.6917 20.5998 11.1395 21.0476 11.1395 21.5998C11.1395 22.1521 10.6917 22.5998 10.1395 22.5998H5.33944C3.46167 22.5998 1.93944 21.0776 1.93945 19.1998L1.93955 4.79988ZM22.2221 13.6688C22.6259 14.0457 22.6477 14.6785 22.2709 15.0822L16.6709 21.0822C16.4858 21.2805 16.2282 21.3951 15.9571 21.3998C15.6859 21.4044 15.4245 21.2988 15.2327 21.107L13.0327 18.907C12.6422 18.5165 12.6422 17.8833 13.0327 17.4928C13.4232 17.1023 14.0564 17.1023 14.4469 17.4928L15.915 18.9609L20.8088 13.7176C21.1856 13.3138 21.8184 13.292 22.2221 13.6688Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.1803 5.05905C11.1803 4.55126 10.5663 4.29317 10.2087 4.65943L8.41851 6.44319C8.19293 6.66877 8.19293 7.02537 8.41851 7.25095L10.2033 9.03579L10.2062 9.03855C10.5646 9.38582 11.1803 9.14411 11.1803 8.62869V7.7422C13.0434 7.87087 14.5186 9.42655 14.5186 11.3219C14.5186 11.7961 14.4282 12.2563 14.2563 12.6651C14.1162 13.0016 14.2233 13.3692 14.4575 13.6034C14.9119 14.0578 15.6758 13.8953 15.915 13.3033C16.1639 12.691 16.298 12.0193 16.298 11.3219C16.298 8.44008 14.0297 6.09035 11.1803 5.95986V5.05905ZM7.40306 9.04046C6.9486 8.586 6.1847 8.74854 5.94555 9.34058C5.69662 9.95281 5.5625 10.6245 5.5625 11.3219C5.5625 14.2038 7.8308 16.5535 10.6803 16.684V17.5848C10.6803 18.0927 11.2945 18.3508 11.652 17.9842L13.4356 16.2006C13.6612 15.9751 13.6612 15.6185 13.4356 15.3929L11.6508 13.6081C11.2934 13.2507 10.6803 13.5068 10.6803 14.0151V14.9016C8.81715 14.773 7.34194 13.2173 7.34194 11.3219C7.34194 10.8477 7.43234 10.3876 7.60419 9.9787C7.74437 9.64226 7.63723 9.27463 7.40306 9.04046Z",
      fill: "currentColor"
    })
  ]),
  copy: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.24024 4C6.58338 4 5.24024 5.34314 5.24024 7L5.24023 13.125C5.24023 13.6773 4.79252 14.125 4.24023 14.125C3.68795 14.125 3.24023 13.6773 3.24023 13.125L3.24024 7C3.24024 4.23858 5.47881 2 8.24024 2L14.3652 2C14.9175 2 15.3652 2.44772 15.3652 3C15.3652 3.55229 14.9175 4 14.3652 4L8.24024 4ZM6.99024 9C6.99024 7.20507 8.44531 5.75 10.2402 5.75L16.9902 5.75C18.7852 5.75 20.2402 7.20508 20.2402 9L20.2402 18.75C20.2402 20.5449 18.7852 22 16.9902 22L10.2402 22C8.44531 22 6.99023 20.5449 6.99023 18.75L6.99024 9ZM10.2402 7.75C9.54988 7.75 8.99024 8.30964 8.99024 9L8.99023 18.75C8.99023 19.4404 9.54988 20 10.2402 20L16.9902 20C17.6806 20 18.2402 19.4404 18.2402 18.75L18.2402 9C18.2402 8.30964 17.6806 7.75 16.9902 7.75L10.2402 7.75Z",
      fill: "currentColor"
    })
  ]),
  create: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.44541 4.79988C2.44542 2.92212 3.96764 1.3999 5.84541 1.3999H16.6457C18.5234 1.3999 20.0457 2.92213 20.0457 4.7999V11.3999C20.0457 11.9522 19.598 12.3999 19.0457 12.3999C18.4934 12.3999 18.0457 11.9522 18.0457 11.3999V4.7999C18.0457 4.02671 17.4189 3.3999 16.6457 3.3999H5.84541C5.07221 3.3999 4.44541 4.0267 4.44541 4.7999L4.44531 19.1998C4.44531 19.973 5.07211 20.5998 5.84531 20.5998H10.6453C11.1976 20.5998 11.6453 21.0476 11.6453 21.5998C11.6453 22.1521 11.1976 22.5998 10.6453 22.5998H5.8453C3.96753 22.5998 2.4453 21.0776 2.44531 19.1998L2.44541 4.79988ZM6.64569 7.1999C6.64569 6.64762 7.0934 6.1999 7.64569 6.1999H14.8457C15.398 6.1999 15.8457 6.64762 15.8457 7.1999C15.8457 7.75219 15.398 8.1999 14.8457 8.1999H7.64569C7.0934 8.1999 6.64569 7.75219 6.64569 7.1999ZM6.64569 10.7999C6.64569 10.2476 7.0934 9.7999 7.64569 9.7999H14.8457C15.398 9.7999 15.8457 10.2476 15.8457 10.7999C15.8457 11.3522 15.398 11.7999 14.8457 11.7999H7.64569C7.0934 11.7999 6.64569 11.3522 6.64569 10.7999ZM6.64569 14.3999C6.64569 13.8476 7.0934 13.3999 7.64569 13.3999H11.2457C11.798 13.3999 12.2457 13.8476 12.2457 14.3999C12.2457 14.9522 11.798 15.3999 11.2457 15.3999H7.64569C7.0934 15.3999 6.64569 14.9522 6.64569 14.3999ZM17.6394 13.3999C18.1917 13.3999 18.6394 13.8476 18.6394 14.3999V16.794L21.0336 16.794C21.5858 16.794 22.0336 17.2417 22.0336 17.794C22.0336 18.3463 21.5858 18.794 21.0336 18.794H18.6394V21.1881C18.6394 21.7404 18.1917 22.1881 17.6394 22.1881C17.0872 22.1881 16.6394 21.7404 16.6394 21.1881V18.794H14.2453C13.693 18.794 13.2453 18.3463 13.2453 17.794C13.2453 17.2417 13.693 16.794 14.2453 16.794L16.6394 16.794V14.3999C16.6394 13.8476 17.0872 13.3999 17.6394 13.3999Z",
      fill: "currentColor"
    })
  ]),
  file: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M8.63983 7.1999H15.8398M8.63983 10.7999H15.8398M8.63983 14.3999H12.2398M6.83955 2.3999H17.6398C18.9653 2.3999 20.0398 3.47445 20.0398 4.79995L20.0395 19.2C20.0395 20.5254 18.965 21.5999 17.6395 21.5999L6.83944 21.5998C5.51396 21.5998 4.43944 20.5253 4.43945 19.1998L4.43955 4.79989C4.43955 3.47441 5.51407 2.3999 6.83955 2.3999Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  folder: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M2.64165 8.41649L2.64156 17.9408C2.64155 19.0454 3.53698 19.9408 4.64156 19.9408L19.8403 19.9409C20.9448 19.9409 21.8403 19.0455 21.8403 17.9409L21.8406 8.01226C21.8406 7.45996 21.3929 7.01223 20.8406 7.01223H12.3243L9.55929 4.05859H3.641C3.08857 4.05859 2.64079 4.50581 2.64097 5.05824C2.64127 6.00905 2.64166 7.43597 2.64165 8.41649Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  fileSearch: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.84067 5.05859C3.72937 5.05859 3.64059 5.14825 3.64062 5.25798C3.64092 6.20053 3.64126 7.5024 3.64125 8.4165L3.64116 17.5408C3.64115 18.314 4.26796 18.9408 5.04116 18.9408H12.3239C12.8762 18.9408 13.3239 19.3885 13.3239 19.9408C13.3239 20.4931 12.8762 20.9408 12.3239 20.9408H5.04116C3.16338 20.9408 1.64114 19.4186 1.64116 17.5408L1.64125 8.41648C1.64126 7.50274 1.64092 6.20114 1.64063 5.2586C1.64025 4.04249 2.62614 3.05859 3.84067 3.05859H9.55889C9.83555 3.05859 10.0998 3.17321 10.2889 3.37518L12.7576 6.01223H20.6402C21.8553 6.01223 22.8402 6.9972 22.8402 8.21223V11.3998C22.8402 11.9521 22.3925 12.3998 21.8402 12.3998C21.2879 12.3998 20.8402 11.9521 20.8402 11.3998V8.21223C20.8402 8.10177 20.7507 8.01223 20.6402 8.01223H12.3239C12.0473 8.01223 11.783 7.89762 11.5939 7.69564L9.12523 5.05859H3.84067ZM17.6402 14.1998C16.5357 14.1998 15.6402 15.0952 15.6402 16.1998C15.6402 17.3044 16.5357 18.1998 17.6402 18.1998C18.7448 18.1998 19.6402 17.3044 19.6402 16.1998C19.6402 15.0952 18.7448 14.1998 17.6402 14.1998ZM13.6402 16.1998C13.6402 13.9907 15.4311 12.1998 17.6402 12.1998C19.8494 12.1998 21.6402 13.9907 21.6402 16.1998C21.6402 16.9416 21.4383 17.6363 21.0864 18.2318L21.9473 19.0927C22.3379 19.4832 22.3379 20.1164 21.9473 20.5069C21.5568 20.8974 20.9236 20.8974 20.5331 20.5069L19.6722 19.646C19.0767 19.9979 18.382 20.1998 17.6402 20.1998C15.4311 20.1998 13.6402 18.4089 13.6402 16.1998Z",
      fill: "currentColor"
    })
  ]),
  computer: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.64062 6.0001C1.64062 4.12233 3.16286 2.6001 5.04062 2.6001H19.4406C21.3184 2.6001 22.8406 4.12233 22.8406 6.0001V14.4001C22.8406 16.2779 21.3184 17.8001 19.4406 17.8001H13.2406V19.2001C13.2406 19.2686 13.2337 19.3355 13.2206 19.4001H15.8406C16.3929 19.4001 16.8406 19.8478 16.8406 20.4001C16.8406 20.9524 16.3929 21.4001 15.8406 21.4001H8.64062C8.08834 21.4001 7.64062 20.9524 7.64062 20.4001C7.64062 19.8478 8.08834 19.4001 8.64062 19.4001H11.2606C11.2475 19.3355 11.2406 19.2686 11.2406 19.2001V17.8001H5.04062C3.16286 17.8001 1.64062 16.2779 1.64062 14.4001V6.0001ZM19.4406 15.8001C20.2138 15.8001 20.8406 15.1733 20.8406 14.4001V6.0001C20.8406 5.2269 20.2138 4.6001 19.4406 4.6001H5.04062C4.26743 4.6001 3.64062 5.2269 3.64062 6.0001V14.4001C3.64062 15.1733 4.26743 15.8001 5.04062 15.8001H19.4406Z",
      fill: "currentColor"
    })
  ]),
  duplicateCheck: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M7.87922 4.31989C7.87923 2.70722 9.18655 1.3999 10.7992 1.3999H18.055C18.6079 1.3999 19.1247 1.63251 19.4938 2.02079C19.7675 2.30883 20.1891 2.73933 20.5862 3.09466C20.9532 3.42302 21.5047 3.98771 21.8154 4.30996C22.1684 4.67619 22.3594 5.16221 22.3594 5.6622L22.3592 15.84C22.3591 17.4526 21.0518 18.7599 19.4392 18.7599H16.5992L16.5992 19.68C16.5991 21.2926 15.2918 22.5999 13.6792 22.5999L5.03913 22.5999C3.42645 22.5999 2.11913 21.2925 2.11914 19.6798L2.11921 8.15989C2.11923 6.54722 3.42655 5.2399 5.03922 5.2399H7.87922V4.31989ZM5.03922 7.2399C4.53112 7.2399 4.11922 7.6518 4.11921 8.1599L4.11914 19.6799C4.11914 20.188 4.53103 20.5999 5.03914 20.5999L13.6792 20.5999C14.1873 20.5999 14.5992 20.188 14.5992 19.6799L14.5992 17.7729C14.5992 17.7686 14.5991 17.7642 14.5991 17.7599C14.5991 17.7555 14.5992 17.7512 14.5992 17.7468L14.5994 11.0799H12.7194C11.637 11.0799 10.7594 10.2024 10.7594 9.1199V7.2399H5.03922ZM9.87922 5.2399V4.3199C9.87922 3.8118 10.2911 3.3999 10.7992 3.3999H16.5194V5.2799C16.5194 6.36238 17.397 7.2399 18.4794 7.2399H20.3594L20.3592 15.8399C20.3592 16.348 19.9473 16.7599 19.4392 16.7599H16.5993L16.5994 10.0868C16.5994 10.0845 16.5994 10.0822 16.5994 10.0799C16.5994 10.0776 16.5994 10.0753 16.5994 10.0731L16.5994 9.50219C16.5994 9.0022 16.4084 8.51619 16.0554 8.14996C15.7447 7.82771 15.1932 7.26303 14.8262 6.93466C14.4291 6.57933 14.0075 6.14883 13.7337 5.8608C13.3647 5.47252 12.8479 5.2399 12.295 5.2399H9.87922ZM12.7594 7.72679C12.9852 7.95282 13.2401 8.1992 13.4926 8.42514C13.674 8.58738 13.9263 8.83566 14.1682 9.0799H12.7594V7.72679ZM19.9282 5.2399C19.6863 4.99566 19.434 4.74738 19.2526 4.58514C19.0001 4.3592 18.7452 4.11282 18.5194 3.88679V5.2399H19.9282Z",
      fill: "currentColor"
    })
  ]),
  undo: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M17.5442 8H16.3614C15.8092 8 15.3614 8.44772 15.3614 9C15.3614 9.55228 15.8092 10 16.3614 10H20.2402C20.7925 10 21.2402 9.55228 21.2402 9V5C21.2402 4.44772 20.7925 4 20.2402 4C19.6879 4 19.2402 4.44772 19.2402 5V6.93861C17.67 4.57029 15.0187 3 11.9978 3C7.13235 3 3.24023 7.05867 3.24023 12C3.24023 16.9413 7.13235 21 11.9978 21C15.9003 21 19.1808 18.3837 20.3219 14.8037C20.4896 14.2775 20.199 13.7149 19.6728 13.5472C19.1465 13.3795 18.584 13.6701 18.4163 14.1963C17.5214 17.0042 14.9709 19 11.9978 19C8.29449 19 5.24023 15.8952 5.24023 12C5.24023 8.10478 8.29449 5 11.9978 5C14.2839 5 16.3171 6.17758 17.5442 8Z",
      fill: "currentColor"
    })
  ]),
  restore: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.54111 4.79988C2.54112 2.92212 4.06335 1.3999 5.94111 1.3999H16.7414C18.6191 1.3999 20.1414 2.92213 20.1414 4.7999V10.1999C20.1414 10.7522 19.6937 11.1999 19.1414 11.1999C18.5891 11.1999 18.1414 10.7522 18.1414 10.1999V4.7999C18.1414 4.0267 17.5146 3.3999 16.7414 3.3999H5.94111C5.16791 3.3999 4.54111 4.0267 4.54111 4.7999L4.54102 19.1998C4.54101 19.973 5.16781 20.5998 5.94101 20.5998H10.141C10.6933 20.5998 11.141 21.0476 11.141 21.5998C11.141 22.1521 10.6933 22.5998 10.141 22.5998H5.941C4.06323 22.5998 2.541 21.0776 2.54102 19.1998L2.54111 4.79988ZM15.7414 14.3999C15.7414 13.8476 16.1891 13.3999 16.7414 13.3999H19.1685C20.6999 13.3999 21.9414 14.6414 21.9414 16.1728C21.9414 17.7042 20.6999 18.9456 19.1685 18.9456H14.3475L15.0928 19.6945C15.4823 20.0859 15.4808 20.7191 15.0894 21.1087C14.6979 21.4983 14.0648 21.4968 13.6752 21.1053L11.2326 18.6511C10.8445 18.2611 10.8443 17.6308 11.2322 17.2406L13.5644 14.8948C13.9538 14.5032 14.587 14.5014 14.9786 14.8907C15.3703 15.2801 15.3721 15.9133 14.9827 16.305L14.3457 16.9456H19.1685C19.5954 16.9456 19.9414 16.5996 19.9414 16.1728C19.9414 15.7459 19.5954 15.3999 19.1685 15.3999H16.7414C16.1891 15.3999 15.7414 14.9522 15.7414 14.3999Z",
      fill: "currentColor"
    })
  ]),
  import: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.83994 4.79988C2.83995 2.92212 4.36218 1.3999 6.23994 1.3999H17.0402C18.918 1.3999 20.4402 2.92213 20.4402 4.7999V11.3999C20.4402 11.9522 19.9925 12.3999 19.4402 12.3999C18.8879 12.3999 18.4402 11.9522 18.4402 11.3999V4.7999C18.4402 4.0267 17.8134 3.3999 17.0402 3.3999H6.23994C5.46674 3.3999 4.83994 4.0267 4.83994 4.7999L4.83984 19.1998C4.83984 19.973 5.46664 20.5998 6.23984 20.5998H11.0398C11.5921 20.5998 12.0398 21.0476 12.0398 21.5998C12.0398 22.1521 11.5921 22.5998 11.0398 22.5998H6.23983C4.36206 22.5998 2.83983 21.0776 2.83984 19.1998L2.83994 4.79988Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M13.041 17.8008C13.041 17.2485 13.4887 16.8008 14.041 16.8008L17.6349 16.8008L16.8896 16.0519C16.5001 15.6604 16.5016 15.0273 16.893 14.6377C17.2845 14.2481 17.9176 14.2496 18.3072 14.6411L20.7498 17.0953C21.1379 17.4853 21.1381 18.1156 20.7502 18.5058L18.418 20.8515C18.0286 21.2432 17.3955 21.245 17.0038 20.8556C16.6121 20.4662 16.6103 19.8331 16.9997 19.4414L17.6367 18.8008L14.041 18.8008C13.4887 18.8008 13.041 18.353 13.041 17.8008Z",
      fill: "currentColor"
    })
  ]),
  csv: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M23.4921 19.1996C23.4921 21.0774 21.9699 22.5996 20.0921 22.5996L9.29183 22.5996C7.41406 22.5996 5.89182 21.0774 5.89182 19.1996L5.89182 18.529C5.89182 17.9767 6.33954 17.529 6.89182 17.529C7.44411 17.529 7.89182 17.9767 7.89182 18.529L7.89182 19.1996C7.89182 19.9728 8.51863 20.5996 9.29183 20.5996L20.0921 20.5996C20.8653 20.5996 21.4921 19.9728 21.4921 19.1996L21.4922 4.79967C21.4922 4.02647 20.8654 3.39967 20.0922 3.39967L9.29184 3.39967C8.51863 3.39967 7.89182 4.02647 7.89182 4.79968L7.89182 5.60181C7.89182 6.1541 7.44411 6.60181 6.89182 6.60181C6.33954 6.60181 5.89182 6.1541 5.89182 5.60181L5.89182 4.79968C5.89182 2.9219 7.41406 1.39967 9.29184 1.39967L20.0922 1.39967C21.97 1.39967 23.4922 2.92191 23.4922 4.79968L23.4921 19.1996Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M15.1861 14.3322H14.0328L12.1328 9.66553H13.3928L14.6528 12.8255L15.9395 9.66553H17.0928L15.1861 14.3322Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M10.4603 14.4191C10.1092 14.4191 9.76695 14.3724 9.43362 14.2791C9.10029 14.1813 8.8314 14.0547 8.62695 13.8991L9.01362 12.9791C9.21362 13.1169 9.44251 13.2302 9.70029 13.3191C9.96251 13.4035 10.2203 13.4458 10.4736 13.4458C10.7403 13.4458 10.9358 13.408 11.0603 13.3324C11.1892 13.2569 11.2536 13.1547 11.2536 13.0258C11.2536 12.888 11.1803 12.7858 11.0336 12.7191C10.8914 12.648 10.6647 12.5769 10.3536 12.5058C10.007 12.4213 9.72473 12.3369 9.50695 12.2524C9.29362 12.1635 9.10695 12.0258 8.94695 11.8391C8.78695 11.648 8.70695 11.3924 8.70695 11.0724C8.70695 10.7924 8.77806 10.5391 8.92029 10.3124C9.06695 10.0858 9.28473 9.90799 9.57362 9.7791C9.86251 9.64577 10.2158 9.5791 10.6336 9.5791C10.927 9.5791 11.2092 9.61466 11.4803 9.68577C11.7558 9.75244 11.9981 9.85244 12.207 9.98577L11.8603 10.9124C11.4336 10.6724 11.0203 10.5524 10.6203 10.5524C10.3581 10.5524 10.1647 10.5947 10.0403 10.6791C9.92029 10.7635 9.86029 10.8747 9.86029 11.0124C9.86029 11.1458 9.92918 11.2458 10.067 11.3124C10.2092 11.3791 10.4358 11.448 10.747 11.5191C11.0847 11.5947 11.3647 11.6769 11.587 11.7658C11.8136 11.8502 12.007 11.9858 12.167 12.1724C12.327 12.3591 12.407 12.6124 12.407 12.9324C12.407 13.208 12.3336 13.4591 12.187 13.6858C12.0403 13.908 11.8203 14.0858 11.527 14.2191C11.2336 14.3524 10.8781 14.4191 10.4603 14.4191Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M6.66219 14.4191C6.20441 14.4191 5.79108 14.3169 5.42219 14.1124C5.0533 13.9035 4.76441 13.6147 4.55552 13.2458C4.34663 12.8769 4.24219 12.4613 4.24219 11.9991C4.24219 11.5369 4.34663 11.1213 4.55552 10.7524C4.76885 10.3835 5.05997 10.0969 5.42885 9.89244C5.79774 9.68355 6.21108 9.5791 6.66885 9.5791C7.06441 9.5791 7.42219 9.65466 7.74219 9.80577C8.06663 9.95244 8.3333 10.1635 8.54219 10.4391L7.79552 11.1591C7.50663 10.7947 7.15108 10.6124 6.72885 10.6124C6.47552 10.6124 6.24885 10.6702 6.04885 10.7858C5.8533 10.9013 5.69997 11.0658 5.58885 11.2791C5.47774 11.488 5.42219 11.728 5.42219 11.9991C5.42219 12.2702 5.47774 12.5102 5.58885 12.7191C5.69997 12.928 5.8533 13.0902 6.04885 13.2058C6.24885 13.3213 6.47552 13.3791 6.72885 13.3791C7.15552 13.3791 7.51108 13.1969 7.79552 12.8324L8.54219 13.5524C8.3333 13.8324 8.06663 14.048 7.74219 14.1991C7.42219 14.3458 7.06219 14.4191 6.66219 14.4191Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.96875 8.91113V15.0879H18.3645V8.91113H2.96875ZM1.96875 6.91113C1.41647 6.91113 0.96875 7.35885 0.96875 7.91113V16.0879C0.96875 16.6402 1.41646 17.0879 1.96875 17.0879H19.3645C19.9168 17.0879 20.3645 16.6402 20.3645 16.0879V7.91113C20.3645 7.35885 19.9168 6.91113 19.3645 6.91113H1.96875Z",
      fill: "currentColor"
    })
  ]),
  detail: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24033 4.79988C2.24034 2.92212 3.76257 1.3999 5.64033 1.3999H16.4406C18.3184 1.3999 19.8406 2.92213 19.8406 4.7999V9.5999C19.8406 10.1522 19.3929 10.5999 18.8406 10.5999C18.2883 10.5999 17.8406 10.1522 17.8406 9.5999V4.7999C17.8406 4.0267 17.2138 3.3999 16.4406 3.3999H5.64033C4.86713 3.3999 4.24033 4.0267 4.24033 4.7999L4.24023 19.1998C4.24023 19.973 4.86703 20.5998 5.64023 20.5998H11.6402C12.1925 20.5998 12.6402 21.0476 12.6402 21.5998C12.6402 22.1521 12.1925 22.5998 11.6402 22.5998H5.64022C3.76245 22.5998 2.24022 21.0776 2.24023 19.1998L2.24033 4.79988ZM6.44061 7.1999C6.44061 6.64762 6.88832 6.1999 7.44061 6.1999H14.6406C15.1929 6.1999 15.6406 6.64762 15.6406 7.1999C15.6406 7.75219 15.1929 8.1999 14.6406 8.1999H7.44061C6.88832 8.1999 6.44061 7.75219 6.44061 7.1999ZM6.44061 10.7999C6.44061 10.2476 6.88832 9.7999 7.44061 9.7999H14.6406C15.1929 9.7999 15.6406 10.2476 15.6406 10.7999C15.6406 11.3522 15.1929 11.7999 14.6406 11.7999H7.44061C6.88832 11.7999 6.44061 11.3522 6.44061 10.7999ZM6.44061 14.3999C6.44061 13.8476 6.88832 13.3999 7.44061 13.3999H11.0406C11.5929 13.3999 12.0406 13.8476 12.0406 14.3999C12.0406 14.9522 11.5929 15.3999 11.0406 15.3999H7.44061C6.88832 15.3999 6.44061 14.9522 6.44061 14.3999ZM17.6402 15.3999C16.5357 15.3999 15.6402 16.2953 15.6402 17.3999C15.6402 18.5045 16.5357 19.3999 17.6402 19.3999C18.7448 19.3999 19.6402 18.5045 19.6402 17.3999C19.6402 16.2953 18.7448 15.3999 17.6402 15.3999ZM13.6402 17.3999C13.6402 15.1908 15.4311 13.3999 17.6402 13.3999C19.8494 13.3999 21.6402 15.1908 21.6402 17.3999C21.6402 18.1417 21.4383 18.8364 21.0864 19.4319L21.9473 20.2928C22.3379 20.6833 22.3379 21.3165 21.9473 21.707C21.5568 22.0975 20.9237 22.0975 20.5331 21.707L19.6722 20.8461C19.0767 21.198 18.382 21.3999 17.6402 21.3999C15.4311 21.3999 13.6402 19.609 13.6402 17.3999Z",
      fill: "currentColor"
    })
  ]),
  policyDelete: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.44541 4.79988C2.44542 2.92212 3.96764 1.3999 5.84541 1.3999H16.6457C18.5234 1.3999 20.0457 2.92213 20.0457 4.7999V11.3999C20.0457 11.9522 19.598 12.3999 19.0457 12.3999C18.4934 12.3999 18.0457 11.9522 18.0457 11.3999V4.7999C18.0457 4.02671 17.4189 3.3999 16.6457 3.3999H5.84541C5.07221 3.3999 4.44541 4.0267 4.44541 4.7999L4.44531 19.1998C4.44531 19.973 5.07211 20.5998 5.84531 20.5998H10.6453C11.1976 20.5998 11.6453 21.0476 11.6453 21.5998C11.6453 22.1521 11.1976 22.5998 10.6453 22.5998H5.8453C3.96753 22.5998 2.4453 21.0776 2.44531 19.1998L2.44541 4.79988ZM6.64569 7.1999C6.64569 6.64762 7.0934 6.1999 7.64569 6.1999H14.8457C15.398 6.1999 15.8457 6.64762 15.8457 7.1999C15.8457 7.75219 15.398 8.1999 14.8457 8.1999H7.64569C7.0934 8.1999 6.64569 7.75219 6.64569 7.1999ZM6.64569 10.7999C6.64569 10.2476 7.0934 9.7999 7.64569 9.7999H14.8457C15.398 9.7999 15.8457 10.2476 15.8457 10.7999C15.8457 11.3522 15.398 11.7999 14.8457 11.7999H7.64569C7.0934 11.7999 6.64569 11.3522 6.64569 10.7999ZM6.64569 14.3999C6.64569 13.8476 7.0934 13.3999 7.64569 13.3999H11.2457C11.798 13.3999 12.2457 13.8476 12.2457 14.3999C12.2457 14.9522 11.798 15.3999 11.2457 15.3999H7.64569C7.0934 15.3999 6.64569 14.9522 6.64569 14.3999Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M20.3049 15.3051C20.6954 15.6956 20.6954 16.3288 20.3049 16.7193L19.1027 17.9215L20.3048 19.1236C20.6953 19.5141 20.6953 20.1473 20.3048 20.5378C19.9143 20.9283 19.2811 20.9283 18.8906 20.5378L17.6885 19.3357L16.4865 20.5377C16.096 20.9282 15.4628 20.9282 15.0723 20.5377C14.6818 20.1472 14.6818 19.514 15.0723 19.1235L16.2743 17.9215L15.0722 16.7194C14.6817 16.3289 14.6817 15.6957 15.0722 15.3052C15.4627 14.9147 16.0959 14.9147 16.4864 15.3052L17.6885 16.5073L18.8907 15.3051C19.2812 14.9146 19.9144 14.9146 20.3049 15.3051Z",
      fill: "currentColor"
    })
  ]),
  payment: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.90039 7.50019C1.90034 5.62239 3.42259 4.1001 5.30039 4.1001H19.7C21.5773 4.1001 23.0999 5.62104 23.1 7.49919L23.1003 16.5011C23.1003 18.3794 21.5775 19.9001 19.7003 19.9001L5.30061 19.8999C3.4229 19.8999 1.9007 18.3777 1.90065 16.5L1.90039 7.50019ZM5.30039 6.1001C4.52718 6.1001 3.90037 6.72692 3.90039 7.50014L3.90041 8.29995H21.1L21.1 7.49926C21.1 6.72651 20.4736 6.1001 19.7 6.1001H5.30039ZM21.1001 10.2999H3.90047L3.90065 16.5C3.90067 17.2731 4.52746 17.8999 5.30063 17.8999L19.7003 17.9001C20.4741 17.9001 21.1003 17.2738 21.1003 16.5011L21.1001 10.2999Z",
      fill: "currentColor"
    })
  ]),
  reissue: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.69922 4.8C3.69922 3.39274 4.71582 2 6.25922 2H18.7392C20.2826 2 21.2992 3.39274 21.2992 4.8L21.2992 11.3316C21.2992 11.8839 20.8515 12.3316 20.2992 12.3316C19.7469 12.3316 19.2992 11.8839 19.2992 11.3316L19.2992 4.8C19.2992 4.21904 18.9189 4 18.7392 4H6.25922C6.07949 4 5.69922 4.21904 5.69922 4.8V19.0914L6.73001 18.3778C7.07245 18.1407 7.52598 18.1407 7.86843 18.3778L9.89922 19.7837L11.93 18.3778C12.3841 18.0634 13.007 18.1767 13.3214 18.6308C13.6358 19.0849 13.5225 19.7078 13.0684 20.0222L10.4684 21.8222C10.126 22.0593 9.67245 22.0593 9.33001 21.8222L7.29922 20.4163L5.26843 21.8222C4.96262 22.0339 4.56457 22.0584 4.23511 21.8858C3.90565 21.7132 3.69922 21.3719 3.69922 21V4.8ZM7.29922 7.8C7.29922 7.24772 7.74693 6.8 8.29922 6.8H16.6992C17.2515 6.8 17.6992 7.24772 17.6992 7.8C17.6992 8.35228 17.2515 8.8 16.6992 8.8H8.29922C7.74693 8.8 7.29922 8.35228 7.29922 7.8ZM7.29922 12.6C7.29922 12.0477 7.74693 11.6 8.29922 11.6H14.8684C15.4207 11.6 15.8684 12.0477 15.8684 12.6C15.8684 13.1523 15.4207 13.6 14.8684 13.6H8.29922C7.74693 13.6 7.29922 13.1523 7.29922 12.6Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.1047 13.8267C18.1047 13.2744 18.5524 12.8267 19.1047 12.8267H21.5318C23.0632 12.8267 24.3047 14.0681 24.3047 15.5995C24.3047 17.1309 23.0632 18.3724 21.5318 18.3724H16.7108L17.4561 19.1212C17.8456 19.5127 17.8441 20.1459 17.4527 20.5355C17.0612 20.925 16.4281 20.9235 16.0385 20.5321L13.5959 18.0778C13.2078 17.6878 13.2076 17.0575 13.5955 16.6673L15.9277 14.3216C16.3171 13.93 16.9502 13.9281 17.3419 14.3175C17.7336 14.7069 17.7354 15.3401 17.346 15.7317L16.709 16.3724H21.5318C21.9587 16.3724 22.3047 16.0264 22.3047 15.5995C22.3047 15.1727 21.9587 14.8267 21.5318 14.8267H19.1047C18.5524 14.8267 18.1047 14.3789 18.1047 13.8267Z",
      fill: "currentColor"
    })
  ]),
  "manual-billing": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.36133 4.8C2.36133 3.39274 3.37793 2 4.92133 2H17.4013C18.9447 2 19.9613 3.39274 19.9613 4.8L19.9613 8.78252C19.9613 9.33481 19.5136 9.78252 18.9613 9.78252C18.409 9.78252 17.9613 9.33481 17.9613 8.78252L17.9613 4.8C17.9613 4.21904 17.5811 4 17.4013 4H4.92133C4.7416 4 4.36133 4.21904 4.36133 4.8V19.0914L5.39212 18.3778C5.73456 18.1407 6.18809 18.1407 6.53054 18.3778L8.56133 19.7837L10.5921 18.3778C11.0462 18.0634 11.6692 18.1767 11.9835 18.6308C12.2979 19.0849 12.1846 19.7078 11.7305 20.0222L9.13054 21.8222C8.78809 22.0593 8.33456 22.0593 7.99212 21.8222L5.96133 20.4163L3.93054 21.8222C3.62473 22.0339 3.22668 22.0584 2.89722 21.8858C2.56776 21.7132 2.36133 21.3719 2.36133 21V4.8Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.3841 10.8075C18.7746 10.417 19.4078 10.417 19.7983 10.8075L23.1924 14.2017C23.3799 14.3892 23.4853 14.6435 23.4853 14.9088C23.4853 15.174 23.3799 15.4283 23.1924 15.6159L18.1012 20.707C17.9137 20.8946 17.6593 20.9999 17.3941 20.9999H14C13.4477 20.9999 13 20.5522 13 19.9999V16.6058C13 16.3406 13.1054 16.0862 13.2929 15.8987L18.3841 10.8075ZM19.0912 12.9289L15 17.02V18.9999H16.9799L21.0711 14.9088L19.0912 12.9289Z",
      fill: "currentColor"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.96094 7.25098C5.96094 6.69869 6.40865 6.25098 6.96094 6.25098H15.3609C15.9132 6.25098 16.3609 6.69869 16.3609 7.25098C16.3609 7.80326 15.9132 8.25098 15.3609 8.25098H6.96094C6.40865 8.25098 5.96094 7.80326 5.96094 7.25098ZM5.96094 12.051C5.96094 11.4987 6.40865 11.051 6.96094 11.051H13.6158C14.168 11.051 14.6158 11.4987 14.6158 12.051C14.6158 12.6033 14.168 13.051 13.6158 13.051H6.96094C6.40865 13.051 5.96094 12.6033 5.96094 12.051Z",
      fill: "currentColor"
    })
  ]),
  "billing-history": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.69922 4.8C3.69922 3.39274 4.71582 2 6.25922 2H18.7392C20.2826 2 21.2992 3.39274 21.2992 4.8V21C21.2992 21.3719 21.0928 21.7132 20.7633 21.8858C20.4339 22.0584 20.0358 22.0339 19.73 21.8222L17.6992 20.4163L15.6684 21.8222C15.326 22.0593 14.8725 22.0593 14.53 21.8222L12.4992 20.4163L10.4684 21.8222C10.126 22.0593 9.67245 22.0593 9.33001 21.8222L7.29922 20.4163L5.26843 21.8222C4.96262 22.0339 4.56457 22.0584 4.23511 21.8858C3.90565 21.7132 3.69922 21.3719 3.69922 21V4.8ZM6.25922 4C6.07949 4 5.69922 4.21904 5.69922 4.8V19.0914L6.73001 18.3778C7.07245 18.1407 7.52598 18.1407 7.86843 18.3778L9.89922 19.7837L11.93 18.3778C12.2725 18.1407 12.726 18.1407 13.0684 18.3778L15.0992 19.7837L17.13 18.3778C17.4725 18.1407 17.926 18.1407 18.2684 18.3778L19.2992 19.0914V4.8C19.2992 4.21904 18.9189 4 18.7392 4H6.25922ZM7.29922 7.8C7.29922 7.24772 7.74693 6.8 8.29922 6.8H16.6992C17.2515 6.8 17.6992 7.24772 17.6992 7.8C17.6992 8.35228 17.2515 8.8 16.6992 8.8H8.29922C7.74693 8.8 7.29922 8.35228 7.29922 7.8ZM7.29922 12.6C7.29922 12.0477 7.74693 11.6 8.29922 11.6H16.6992C17.2515 11.6 17.6992 12.0477 17.6992 12.6C17.6992 13.1523 17.2515 13.6 16.6992 13.6H8.29922C7.74693 13.6 7.29922 13.1523 7.29922 12.6Z",
      fill: "currentColor"
    })
  ]),
  manage: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M11.3386 3.80369H5.65213C3.76779 3.80369 2.24023 5.3312 2.24023 7.21548V18.5882C2.24023 20.4725 3.76779 22 5.65213 22H17.0251C18.9095 22 20.437 20.4725 20.437 18.5882L20.437 12.9018M7.92673 16.3136L12.0646 15.4799C12.2843 15.4356 12.4859 15.3274 12.6444 15.1689L21.9073 5.90116C22.3515 5.45682 22.3512 4.73657 21.9067 4.2926L19.9444 2.33264C19.5001 1.88886 18.7802 1.88916 18.3363 2.33332L9.07233 11.6021C8.91423 11.7602 8.80628 11.9615 8.76198 12.1807L7.92673 16.3136Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  "bucket-manage": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M12.9848 18.7203H10.1048C10.1048 18.7203 8.97227 18.7203 8.18477 18.7203C5.53352 18.7203 3.38477 16.5711 3.38477 13.9203C3.38477 11.7429 4.83414 9.90355 6.82164 9.31621C7.85852 6.94059 10.2285 5.28027 12.9848 5.28027C16.4066 5.28027 19.2323 7.83918 19.6504 11.1481C21.3341 11.5554 22.5848 13.0718 22.5848 14.8803",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    G("path", {
      d: "M17.1769 20.3298C16.7306 20.3298 16.3384 20.0341 16.2155 19.6051L15.2909 16.3758C15.108 15.7369 15.5877 15.1006 16.2523 15.1006H22.0038C22.6661 15.1006 23.1455 15.7329 22.9666 16.3706L22.0611 19.5998C21.94 20.0315 21.5465 20.3298 21.0982 20.3298H17.1769Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  "access-key-manage": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M11.925 18.7198H10.1048C10.1048 18.7198 8.97227 18.7198 8.18477 18.7198C5.53352 18.7198 3.38477 16.5706 3.38477 13.9198C3.38477 11.7424 4.83414 9.90307 6.82164 9.31572C7.85852 6.9401 10.2285 5.27979 12.9848 5.27979C16.4066 5.27979 19.2323 7.83869 19.6504 11.1476C21.3341 11.5549 22.5848 13.0713 22.5848 14.8798",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    G("circle", {
      cx: "17.6331",
      cy: "15.7913",
      r: "2.14062",
      transform: "rotate(30 17.6331 15.7913)",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    G("path", {
      d: "M13.1808 21.5022C12.9047 21.9805 13.0686 22.5921 13.5469 22.8682C14.0252 23.1443 14.6368 22.9805 14.9129 22.5022L13.1808 21.5022ZM16.4824 17.7837L15.6164 17.2837L13.1808 21.5022L14.0469 22.0022L14.9129 22.5022L17.3484 18.2837L16.4824 17.7837Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M16.2373 22.018C16.7156 22.2941 17.3272 22.1303 17.6033 21.652C17.8794 21.1737 17.7156 20.5621 17.2373 20.286L16.2373 22.018ZM15.0879 20.1997L14.5879 21.0657L16.2373 22.018L16.7373 21.152L17.2373 20.286L15.5879 19.3337L15.0879 20.1997Z",
      fill: "currentColor"
    })
  ]),
  "file-storage-manage": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M11.9789 19.5145H5.28725C3.96176 19.5145 2.88724 18.44 2.88725 17.1145L2.88734 7.99022C2.88735 7.0763 2.88701 5.77457 2.88672 4.83202C2.88651 4.1691 3.42385 3.63232 4.08677 3.63232H9.80498L12.57 6.58596H20.8863C21.5491 6.58596 22.0863 7.12322 22.0863 7.78596V10.9735",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    G("path", {
      d: "M20.5351 19.873C19.9506 19.873 19.0383 19.873 19.0383 19.873H17.7553C17.7553 19.873 17.2508 19.873 16.9 19.873C15.7189 19.873 14.7617 18.9156 14.7617 17.7347C14.7617 16.7647 15.4074 15.9453 16.2928 15.6837C16.7547 14.6254 17.8105 13.8857 19.0383 13.8857C20.5627 13.8857 21.8215 15.0257 22.0077 16.4997C22.7578 16.6812 23.3149 17.3567 23.3149 18.1624C23.3149 19.1071 22.549 19.873 21.6043 19.873C21.1917 19.873 20.9527 19.873 20.5351 19.873Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  firewall: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M3.70212 15.0205H9.438M21.2402 15.0205H17.0281M3.70212 9.01018H17.0281M21.2402 9.01018H17.0281M9.438 21H5.18245C4.10979 21 3.24023 20.1168 3.24023 19.0274L3.24023 4.9726C3.24023 3.88316 4.10979 3 5.18245 3L9.09611 3M9.438 21H19.0207C20.0934 21 20.963 20.1168 20.963 19.0274V4.9726C20.963 3.88316 20.0934 3 19.0207 3L9.09611 3M9.438 21V15.0205M9.438 15.0205H17.0281M17.0281 15.0205V9.01018M9.09611 8.51822V3",
      stroke: "currentColor",
      "stroke-width": "2"
    })
  ]),
  "firewall-policy-manage": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M3.70212 15.5205H9.438M3.70212 9.51018H17.0281M20.5994 9.51018H17.0281M9.438 21.5H5.18245C4.10979 21.5 3.24023 20.6168 3.24023 19.5274L3.24023 5.4726C3.24023 4.38316 4.10979 3.5 5.18245 3.5L9.09611 3.5M9.438 21.5V15.5205M9.438 21.5H14.2294M9.438 15.5205H14.2294M17.0281 9.51018V13.8082M9.09611 9.51018V3.5M9.09611 3.5L19.0207 3.5C20.0934 3.5 20.963 4.38316 20.963 5.4726V14.8572",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    G("path", {
      d: "M20.3145 17.0705C19.4845 16.6555 18.5075 16.6555 17.6775 17.0705L16.5391 17.6397V20.3792C16.5391 21.1204 17.4134 21.9636 18.996 22.963C20.5785 21.9636 21.4529 21.3251 21.4529 20.3792C21.4529 19.4333 21.4529 17.6397 21.4529 17.6397L20.3145 17.0705Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  "firewall-rule-manage": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M3.70212 15.5205H9.438M3.70212 9.51018H17.0281M20.5994 9.51018H17.0281M9.438 21.5H5.18245C4.10979 21.5 3.24023 20.6168 3.24023 19.5274L3.24023 5.4726C3.24023 4.38316 4.10979 3.5 5.18245 3.5L9.09611 3.5M9.438 21.5V15.5205M9.438 21.5H11.4066M9.438 15.5205H14.2294M17.0281 9.51018V12.8385M9.09611 9.51018V3.5M9.09611 3.5L19.0207 3.5C20.0934 3.5 20.963 4.38316 20.963 5.4726V11.7269",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    G("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.7968 13.8869C19.1473 13.5364 19.7156 13.5364 20.066 13.8869L23.1121 16.933C23.2804 17.1013 23.375 17.3296 23.375 17.5676C23.375 17.8056 23.2804 18.0339 23.1121 18.2022L18.543 22.7713C18.3747 22.9396 18.1464 23.0342 17.9084 23.0342H14.8623C14.3667 23.0342 13.9648 22.6324 13.9648 22.1367V19.0906C13.9648 18.8526 14.0594 18.6243 14.2277 18.456L18.7968 13.8869ZM19.4314 15.7907L15.7598 19.4624V21.2392H17.5367L21.2083 17.5676L19.4314 15.7907Z",
      fill: "currentColor"
    })
  ]),
  "security-group-manage": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M12.9617 21.9671C8.32412 19.0383 5.76172 18.0775 5.76172 14.3951V5.16709C8.57452 5.16709 10.2649 5.05989 12.9617 2.76709C15.6585 5.05989 17.3489 5.16709 20.1617 5.16709C20.1617 5.16709 20.1617 9.61129 20.1617 13.2937",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    G("path", {
      d: "M18.6477 14.4053C18.839 14.4053 19.0088 14.5437 19.0344 14.7402L19.1662 15.6572C19.3445 15.7387 19.5122 15.8363 19.6701 15.9492L20.5324 15.6025C20.5796 15.5837 20.6296 15.5771 20.6731 15.5771C20.8077 15.5772 20.9426 15.6452 21.0158 15.7744L21.7942 17.1201C21.8839 17.2852 21.8496 17.4975 21.6955 17.6191L20.9641 18.1914C20.9735 18.2848 20.9797 18.3815 20.9797 18.4834C20.9797 18.5853 20.9735 18.682 20.9641 18.7754L21.6955 19.3477C21.8496 19.4693 21.8839 19.6816 21.7942 19.8467L21.7912 19.8516L21.0158 21.1924C20.9436 21.3198 20.81 21.3896 20.677 21.3896C20.6313 21.3896 20.5866 21.3823 20.5442 21.3682L20.5383 21.3662L19.6692 21.0166C19.5127 21.127 19.3453 21.2272 19.1662 21.3096L19.0344 22.2266C19.0088 22.423 18.839 22.5615 18.6477 22.5615H17.0959C16.9047 22.5615 16.7348 22.423 16.7092 22.2266L16.5774 21.3096C16.3991 21.2281 16.2313 21.1305 16.0735 21.0176L15.2112 21.3643C15.164 21.3831 15.114 21.3896 15.0705 21.3896C14.9359 21.3895 14.801 21.3216 14.7278 21.1924L13.9494 19.8467C13.8597 19.6816 13.894 19.4693 14.0481 19.3477L14.7795 18.7754C14.77 18.6809 14.7639 18.5828 14.7639 18.4834C14.7639 18.384 14.77 18.2859 14.7795 18.1914L14.0481 17.6191L13.9973 17.5713C13.8896 17.4496 13.8628 17.2667 13.9524 17.1143L14.7278 15.7744C14.8 15.6471 14.9337 15.5773 15.0666 15.5771C15.1123 15.5771 15.1571 15.5845 15.1994 15.5986L15.2053 15.6006L16.0744 15.9502C16.2309 15.8398 16.3984 15.7396 16.5774 15.6572L16.7092 14.7402C16.7348 14.5438 16.9047 14.4053 17.0959 14.4053H18.6477ZM17.719 15.9316V15.9326L17.6408 16.4834L17.1252 16.6924C16.9846 16.7508 16.8397 16.8352 16.6838 16.9512L16.2453 17.2822L15.7375 17.0771L15.4045 16.9434L15.3059 17.1143L15.5891 17.334L16.0227 17.6748L15.9553 18.2227C15.9437 18.3385 15.9367 18.4176 15.9367 18.4834C15.9367 18.5494 15.9437 18.6288 15.9553 18.749L16.0227 19.2959L15.5881 19.6377L15.3059 19.8564L15.4045 20.0273L15.7375 19.8936L16.2541 19.6846L16.6965 20.0244C16.8386 20.1308 16.9789 20.2115 17.1291 20.2744L17.6457 20.4834L17.7727 21.3887H17.9719L18.0246 21.0352V21.0342L18.1028 20.4834L18.6184 20.2744C18.759 20.216 18.9039 20.1316 19.0598 20.0156L19.4983 19.6846L20.0061 19.8896L20.3391 20.0234L20.4377 19.8525L20.1545 19.6328L19.7209 19.292L19.7883 18.7441C19.7999 18.6281 19.8069 18.5529 19.8069 18.4834C19.8069 18.4103 19.8037 18.3373 19.7893 18.2256V18.2246L19.7209 17.6748L20.1545 17.334L20.4348 17.1113L20.3352 16.9395L20.0031 17.0732L19.4856 17.2822L19.0432 16.9424C18.9012 16.836 18.7607 16.7553 18.6106 16.6924L18.0949 16.4834L17.967 15.5781H17.7717L17.719 15.9316ZM17.8723 16.7334C18.8392 16.7336 19.6223 17.5165 19.6223 18.4834C19.6223 19.4503 18.8392 20.2332 17.8723 20.2334C16.9052 20.2334 16.1213 19.4505 16.1213 18.4834C16.1213 17.5163 16.9052 16.7334 17.8723 16.7334ZM17.8723 17.9062C17.5553 17.9062 17.2942 18.1664 17.2942 18.4834C17.2942 18.8004 17.5553 19.0605 17.8723 19.0605C18.1891 19.0603 18.4494 18.8003 18.4494 18.4834C18.4494 18.1665 18.1891 17.9065 17.8723 17.9062Z",
      fill: "currentColor"
    })
  ]),
  "load-balancer": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M13.01 16.1883H11.6527C11.1529 16.1883 10.7478 16.5934 10.7478 17.0932V19.8078C10.7478 20.3075 11.1529 20.7126 11.6527 20.7126H14.3673C14.867 20.7126 15.2721 20.3075 15.2721 19.8078V17.0932C15.2721 16.5934 14.867 16.1883 14.3673 16.1883H13.01ZM13.01 16.1883V8.65479M13.01 8.65479L20.2992 16.1883M13.01 8.65479L5.62348 16.1883M20.2992 16.1883H18.9419C18.4421 16.1883 18.037 16.5934 18.037 17.0932V19.8078C18.037 20.3075 18.4421 20.7126 18.9419 20.7126H21.6565C22.1562 20.7126 22.5613 20.3075 22.5613 19.8078V17.0932C22.5613 16.5934 22.1562 16.1883 21.6565 16.1883H20.2992ZM5.62348 16.1883H4.26619C3.76645 16.1883 3.36133 16.5934 3.36133 17.0932V19.8078C3.36133 20.3075 3.76645 20.7126 4.26619 20.7126H6.98077C7.48051 20.7126 7.88563 20.3075 7.88563 19.8078V17.0932C7.88563 16.5934 7.48051 16.1883 6.98077 16.1883H5.62348Z",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    G("rect", {
      x: "7.21484",
      y: "4.02197",
      width: "11.4932",
      height: "4.16895",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  tokenRegister: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M6.76951 9.30234H6.90954M12.2406 9.30234H12.3806M17.5701 9.30234H17.7101M11.6406 14.7023H4.77396C3.59575 14.7023 2.64062 13.7472 2.64062 12.569V6.03568C2.64062 4.85747 3.59575 3.90234 4.77396 3.90234H19.7073C20.8855 3.90234 21.8406 4.85747 21.8406 6.03568V9.30234M15.6518 13.5974L17.0418 12.9024C18.0553 12.3957 19.2483 12.3957 20.2618 12.9024L21.6518 13.5974C21.6518 13.5974 21.6518 15.7874 21.6518 16.9424C21.6518 18.0974 20.5841 18.8771 18.6518 20.0974C16.7195 18.8771 15.6518 17.8474 15.6518 16.9424V13.5974Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  buildRequest: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M14.243 2.20557C14.4929 2.20557 14.7032 2.38551 14.7332 2.62549L14.8933 3.74463L13.1512 5.75537L12.9334 4.20557H11.5428L11.3426 5.55518L11.1834 6.68604L10.1228 7.11572C9.71292 7.28571 9.30275 7.52529 8.87283 7.84521L7.97342 8.52588L6.93338 8.10596L5.66287 7.59521L4.96268 8.80518L6.04276 9.646L6.93338 10.3452L6.79276 11.4751C6.76276 11.7751 6.74295 12.0056 6.74295 12.2056C6.74295 12.4056 6.76276 12.6358 6.79276 12.9458L6.93338 14.0757L6.04276 14.7759L4.96268 15.6157L5.66287 16.8257L6.93338 16.3159L7.99295 15.8853L8.90311 16.5854C9.30298 16.8854 9.70275 17.1154 10.1326 17.2954L11.1931 17.7251L11.5428 20.2056H12.9431L13.1433 18.856L13.3025 17.7251L14.3631 17.2954C14.773 17.1254 15.1832 16.8858 15.6131 16.5659L16.5125 15.8853L17.5525 16.3052L18.823 16.8159L19.5232 15.606L18.4431 14.7651L17.5525 14.0659L17.6931 12.936C17.7231 12.636 17.743 12.4156 17.743 12.2056C17.743 11.9956 17.7331 11.7851 17.6931 11.4751L17.6658 11.2612L21.5213 8.2749L21.9031 8.93604C22.0228 9.15596 21.9729 9.42578 21.783 9.57568L19.6726 11.2251C19.7126 11.5451 19.743 11.8656 19.743 12.2056C19.743 12.5456 19.7126 12.866 19.6726 13.186L21.783 14.8354C21.9729 14.9854 22.0228 15.2552 21.9031 15.4751L19.9031 18.936C19.8131 19.0957 19.6432 19.1859 19.4734 19.186C19.4134 19.186 19.3528 19.1758 19.2928 19.1558L16.8025 18.1558C16.2827 18.5456 15.7228 18.8853 15.1131 19.1353L14.7332 21.7856C14.7032 22.0256 14.4929 22.2056 14.243 22.2056H10.243C9.99297 22.2056 9.78274 22.0256 9.75272 21.7856L9.37283 19.1353C8.76306 18.8853 8.20322 18.5556 7.68338 18.1558L5.19315 19.1558C5.14322 19.1757 5.08314 19.186 5.02322 19.186C4.84333 19.186 4.67284 19.0959 4.5828 18.936L2.5828 15.4751C2.46309 15.2552 2.51304 14.9854 2.70291 14.8354L4.81326 13.186C4.77326 12.866 4.74295 12.5356 4.74295 12.2056C4.74295 11.8756 4.77326 11.5451 4.81326 11.2251L2.70291 9.57568C2.51303 9.42578 2.45312 9.15596 2.5828 8.93604L4.5828 5.4751C4.67275 5.31543 4.84274 5.22527 5.01248 5.2251C5.07248 5.2251 5.13315 5.23537 5.19315 5.25537L7.68338 6.25537C8.20322 5.86553 8.76306 5.52581 9.37283 5.27588L9.75272 2.62549C9.78274 2.38551 9.99297 2.20557 10.243 2.20557H14.243Z",
      fill: "currentColor"
    }),
    G("path", {
      d: "M8.31573 12.3835C8.3265 12.508 8.60444 12.7472 8.72206 12.7898C8.83998 12.8328 8.97198 12.8035 9.06069 12.7153L10.8401 10.9359L13.1514 13.2472L11.3364 15.0554C11.2475 15.1438 11.2186 15.2753 11.2614 15.3926C11.3046 15.5101 11.5896 15.759 11.7148 15.7698C12.8171 15.8644 13.8972 15.4723 14.678 14.6943C15.7475 13.6287 16.0308 12.0727 15.5292 10.7464C15.584 10.7004 15.6381 10.6517 15.6915 10.5991L21.7501 4.9037C21.7522 4.90163 21.7543 4.89935 21.7566 4.89731C22.4691 4.18745 22.4691 3.03246 21.7566 2.32248C21.044 1.61268 19.8931 1.62131 19.1807 2.33117C19.1777 2.33403 19.1748 2.33688 19.172 2.34006L13.505 8.42284C13.4533 8.47453 13.4053 8.52862 13.3601 8.58413C12.0285 8.08359 10.4656 8.36508 9.39516 9.43132C8.61446 10.2094 8.22064 11.2855 8.31573 12.3835Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  recall: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M10.7398 21.5998H4.73983C3.41435 21.5998 2.33984 20.5253 2.33984 19.1998L2.33994 4.79989C2.33995 3.47441 3.41446 2.3999 4.73994 2.3999H15.5402C16.8657 2.3999 17.9402 3.47442 17.9402 4.7999V9.5999M6.54022 7.1999H13.7402M6.54022 10.7999H13.7402M6.54022 14.3999H10.1402M15.5828 20.3999L13.1402 17.9456M13.1402 17.9456L15.4724 15.5999M13.1402 17.9456H20.3674C21.3465 17.9456 22.1402 17.1519 22.1402 16.1728C22.1402 15.1936 21.3465 14.3999 20.3674 14.3999H17.9402",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  list: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M8.95984 6H21.8398M8.95984 12.48H21.8398M8.95984 18.96H21.8398M3.83984 6V6.0128M3.83984 12.48V12.4928M3.83984 18.96V18.9728",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  approvalHistory: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M7.43985 16.7999L12.4219 16.7999M7.43985 11.9999L16.7005 11.9999M7.43985 7.1999L17.0398 7.1999M21.8398 11.9999L21.8398 4.7999C21.8398 3.47442 20.7653 2.3999 19.4398 2.3999L5.03985 2.3999C3.71436 2.3999 2.63985 3.47442 2.63985 4.7999L2.63985 19.1999C2.63985 20.5254 3.71436 21.5999 5.03985 21.5999L16.7005 21.5999",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    G("path", {
      d: "M18.3086 17.3901L19.5086 18.5901L23.7086 14.3901",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  share: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M21.2404 11.4591L11.6404 5.1001L11.6404 8.7001C3.24023 10.5001 3.24023 18.9001 3.24023 18.9001C3.24023 18.9001 6.84023 14.1001 11.6404 14.7001L11.6404 18.4201L21.2404 11.4591Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  "share-network": () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("circle", {
      cx: "6.85693",
      cy: "12.7656",
      r: "2.37061",
      transform: "rotate(-90 6.85693 12.7656)",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    G("circle", {
      cx: "17.6245",
      cy: "5.46387",
      r: "2.37061",
      transform: "rotate(-90 17.6245 5.46387)",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    G("circle", {
      cx: "17.6245",
      cy: "18.8647",
      r: "2.37061",
      transform: "rotate(-90 17.6245 18.8647)",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    G("path", {
      d: "M8.64844 11.2163L15.791 6.48096M8.64844 14.3218L15.791 18.4456",
      stroke: "currentColor",
      "stroke-width": "2"
    })
  ]),
  exchange: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M14.5029 10.1387C14.4071 9.86184 14.2322 9.62051 14.0005 9.44577C13.7689 9.27103 13.4913 9.17089 13.2033 9.15823H11.278C10.895 9.15823 10.5277 9.31318 10.2569 9.58899C9.98612 9.86481 9.83398 10.2389 9.83398 10.629C9.83398 11.019 9.98612 11.3931 10.2569 11.6689C10.5277 11.9447 10.895 12.0997 11.278 12.0997H13.2033C13.5863 12.0997 13.9536 12.2546 14.2244 12.5304C14.4952 12.8063 14.6473 13.1803 14.6473 13.5704C14.6473 13.9605 14.4952 14.3345 14.2244 14.6104C13.9536 14.8862 13.5863 15.0411 13.2033 15.0411H11.278C10.99 15.0285 10.7124 14.9283 10.4808 14.7536C10.2492 14.5788 10.0742 14.3375 9.97838 14.0606M12.2407 7.6875V9.15823M12.2407 15.0411V16.5119",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    G("path", {
      d: "M19.1624 8.08567C17.7724 5.68616 15.1745 4.07178 12.199 4.07178C8.82536 4.07178 5.9371 6.14713 4.74457 9.08914M17.4159 9.08914H20.7402V6.00006M5.31811 16.1134C6.70805 18.513 9.30596 20.1273 12.2814 20.1273C15.6551 20.1273 18.5434 18.052 19.7359 15.11M6.90391 15.11H3.74023V17.9455",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  discount: () => G("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    G("path", {
      d: "M8.90039 15.5999L16.1004 8.3999M9.45429 8.94924L9.44014 8.93495M15.5648 15.1226L15.5507 15.1083M8.42325 4.38723L7.40534 4.44922C6.0839 4.5297 5.03019 5.58342 4.94971 6.90485L4.88772 7.92276C4.85215 8.50667 4.62218 9.06187 4.23444 9.4999L3.55851 10.2635C2.68102 11.2548 2.68102 12.745 3.55851 13.7363L4.23444 14.4999C4.62218 14.9379 4.85215 15.4931 4.88772 16.077L4.94971 17.0949C5.03019 18.4164 6.0839 19.4701 7.40534 19.5506L8.42325 19.6126C9.00716 19.6481 9.56236 19.8781 10.0004 20.2658L10.764 20.9418C11.7553 21.8193 13.2455 21.8193 14.2368 20.9418L15.0004 20.2658C15.4384 19.8781 15.9936 19.6481 16.5775 19.6126L17.5954 19.5506C18.9169 19.4701 19.9706 18.4164 20.0511 17.0949L20.1131 16.077C20.1486 15.4931 20.3786 14.9379 20.7663 14.4999L21.4423 13.7363C22.3198 12.745 22.3198 11.2548 21.4423 10.2635L20.7663 9.4999C20.3786 9.06187 20.1486 8.50667 20.1131 7.92276L20.0511 6.90485C19.9706 5.58341 18.9169 4.5297 17.5954 4.44922L16.5775 4.38723C15.9936 4.35167 15.4384 4.12169 15.0004 3.73395L14.2368 3.05802C13.2455 2.18053 11.7553 2.18053 10.764 3.05802L10.0004 3.73395C9.56236 4.12169 9.00716 4.35167 8.42325 4.38723Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round"
    })
  ])
}, Pd = {
  __name: "SIcon",
  props: {
    name: {
      type: String,
      required: !0,
      validator: (e) => Object.keys(Af).includes(e)
    },
    size: {
      type: [String, Number],
      default: 24
    },
    color: {
      type: String,
      default: "currentColor"
    },
    className: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e, n = k(() => {
      const l = Af[t.name] || Af["expand-more"];
      return l ? l() : null;
    }), a = k(() => ({
      width: typeof t.size == "number" ? `${t.size}px` : t.size,
      height: typeof t.size == "number" ? `${t.size}px` : t.size,
      color: t.color
    })), i = k(() => {
      const l = ["s-icon"];
      return t.className && l.push(t.className), l.join(" ");
    });
    return (l, r) => (N(), Ce(Lr(n.value), fe({
      class: i.value,
      style: a.value
    }, l.$attrs), null, 16, ["class", "style"]));
  }
}, QN = {
  __name: "SConfirm",
  props: {
    contents: {
      type: String,
      default: "",
      description: "컨펌창 내용"
    },
    modelValue: {
      type: Boolean,
      default: !1,
      description: "컨펌창 오픈 여부"
    },
    teleportId: {
      type: String,
      default: "destination",
      description: "Teleport ID"
    },
    confirmButtonText: {
      type: String,
      default: "확인",
      description: "확인 버튼의 텍스트"
    },
    cancelButtonText: {
      type: String,
      default: "취소",
      description: "취소 버튼의 텍스트"
    },
    noCancel: {
      type: Boolean,
      default: !1,
      description: "취소 버튼의 텍스트"
    }
  },
  emits: ["update:model-value", "click:confirm", "click:cancel"],
  setup(e, { emit: t }) {
    const n = t, a = (r) => {
      n("update:model-value", r);
    }, i = () => n("click:confirm"), l = () => n("click:cancel", !1);
    return (r, s) => {
      const o = Pe("v-card-text"), u = Pe("v-card-actions"), c = Pe("v-card"), d = Pe("v-dialog");
      return N(), Ce(zs, {
        to: `#${e.teleportId}`
      }, [
        p(d, {
          class: "s-confirm-modal",
          width: "446",
          persistent: "",
          "model-value": e.modelValue,
          "onUpdate:modelValue": a
        }, {
          default: re(() => [
            p(c, { "modal-height": "210" }, {
              default: re(() => [
                p(o, { class: "s-confirm-modal__text" }, {
                  default: re(() => [
                    Ee(xe(e.contents), 1)
                  ]),
                  _: 1
                }),
                p(u, { class: "button-wrapper" }, {
                  default: re(() => [
                    p(X(_n), {
                      variant: "elevated",
                      color: "blue",
                      onClick: $t(i, ["stop"])
                    }, {
                      default: re(() => [
                        p(X(Pd), {
                          name: "check",
                          size: 16,
                          class: "mr-1"
                        }),
                        Ee(" " + xe(e.confirmButtonText), 1)
                      ]),
                      _: 1
                    }),
                    e.noCancel ? de("", !0) : (N(), Ce(X(_n), {
                      key: 0,
                      variant: "outlined",
                      color: "blue",
                      onClick: l
                    }, {
                      default: re(() => [
                        p(X(Pd), {
                          name: "close",
                          size: 16,
                          class: "mr-1"
                        }),
                        Ee(" " + xe(e.cancelButtonText), 1)
                      ]),
                      _: 1
                    }))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["model-value"])
      ], 8, ["to"]);
    };
  }
}, AN = /* @__PURE__ */ Ut(QN, [["__scopeId", "data-v-fe676b23"]]), DN = { class: "button-wrapper" }, RN = { class: "s-modal__content-wrapper" }, IN = { class: "s-modal__content" }, BN = { class: "s-modal__footer" }, ZN = {
  key: 0,
  class: "s-modal__footer__positive"
}, EN = {
  key: 1,
  class: "s-modal__footer__negative"
}, NN = {
  __name: "SModal",
  props: {
    title: { type: String, default: "", description: "모달 헤더 이름" },
    className: { type: [Object, String], default: "", description: "클래스 명" },
    modalWidth: { type: String, default: "", description: "모달 넓이" },
    modalHeight: { type: String, default: "", description: "모달 높이" },
    modelValue: { type: Boolean, default: !1, description: "모달 오픈 여부" },
    isWhite: { type: Boolean, default: !1, description: "모달 헤드 색깔 여부" },
    popupCardClass: { type: String, default: "", description: "card의 개별 클래스네임" },
    hideHeader: { type: Boolean, default: !1, description: "헤더 유무" },
    teleportId: { type: String, default: "destination", description: "Teleport ID" },
    size: { type: String, default: "medium", description: "modal size x-small, small, medium, large, x-large" },
    languageCode: { type: String, default: "ko", description: "ko, en" },
    mode: { type: String, default: null, description: "new | detail | update" },
    changeMode: { type: Function, default: () => {
    } },
    onClose: { type: Function, default: null, description: "닫기 버튼 눌렀을 때 함수" },
    onCancel: { type: Function, default: null, description: "취소 버튼 눌렀을 때 함수" },
    onSave: { type: Function, default: null, description: "new 모드에서 저장 버튼 눌렀을 때 함수" },
    onEdit: { type: Function, default: null, description: "detail 모드에서 수정 버튼 눌렀을 때 함수" },
    onUpdate: { type: Function, default: null, description: "update 모드에서 저장 버튼 눌렀을 때 함수" },
    hideEditButton: { type: Boolean, default: !1, description: "detail 모드에서 수정 버튼 숨기기" }
  },
  emits: ["update:model-value", "on-fetch"],
  setup(e, { emit: t }) {
    const n = { size: "16", class: "mr-1" }, a = {
      ko: { save: "저장", update: "수정", close: "닫기", cancel: "취소" },
      en: { save: "Save", update: "Update", close: "Close", cancel: "Cancel" }
    }, i = t;
    K4();
    const l = e, r = k(() => ["s-modal", l.className].join(" ")), s = k(() => l.mode === "new"), o = k(() => l.mode === "detail"), u = k(() => l.mode === "update"), c = k(() => a[l.languageCode]), d = (C) => {
      C && i("on-fetch"), f(C);
    }, f = (C) => {
      C ? (document.body.style.overflow = "hidden", document.body.style.paddingRight = "var(--v-scrollbar-offset)") : (document.body.style.overflow = "", document.body.style.paddingRight = "");
    }, h = () => {
      i("update:model-value", !1);
    }, m = h, g = () => {
      var C, S;
      if (!(l != null && l.changeMode))
        throw Error("Not found changeMode");
      (C = l == null ? void 0 : l.onCancel) == null || C.call(l), l.mode === "update" ? (S = l.changeMode) == null || S.call(l, "detail") : h();
    }, v = () => {
      var C;
      (C = l == null ? void 0 : l.onClose) == null || C.call(l), h();
    }, y = () => {
      var C;
      (C = l == null ? void 0 : l.onUpdate) == null || C.call(l);
    }, b = () => {
      var C;
      l.mode === "detail" && ((C = l.changeMode) == null || C.call(l, "update"));
    };
    return pe(() => l.modelValue, d), mn(() => {
      f(!1);
    }), (C, S) => {
      const x = Pe("v-icon"), w = Pe("s-icon"), V = Pe("v-card"), _ = Pe("v-dialog");
      return N(), Ce(zs, {
        to: `#${e.teleportId}`
      }, [
        p(_, {
          "model-value": e.modelValue,
          width: e.modalWidth,
          "scroll-strategy": "block",
          class: Ie(r.value),
          size: e.size,
          persistent: "",
          scrim: "",
          "onUpdate:modelValue": S[0] || (S[0] = (O) => {
            i("update:model-value", O);
          })
        }, {
          activator: re(({ props: O }) => [
            ke(C.$slots, "buttons", BC(O, !0), void 0, !0)
          ]),
          default: re(() => [
            p(V, {
              class: Ie(e.popupCardClass),
              height: e.modalHeight,
              "min-height": e.modalHeight,
              "no-line": ""
            }, Xt({
              item: re(() => [
                ie("div", RN, [
                  ie("div", IN, [
                    ke(C.$slots, "default", {}, void 0, !0)
                  ])
                ])
              ]),
              append: re(() => [
                ie("div", BN, [
                  ke(C.$slots, "footer", {}, void 0, !0),
                  s.value || !e.hideEditButton && o.value || u.value ? (N(), ee("div", ZN, [
                    s.value ? (N(), Ce(_n, {
                      key: 0,
                      onClick: e.onSave
                    }, {
                      default: re(() => [
                        p(w, fe({ name: "save" }, n), null, 16),
                        Ee(xe(c.value.save), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"])) : de("", !0),
                    !e.hideEditButton && o.value ? (N(), Ce(_n, {
                      key: 1,
                      onClick: b
                    }, {
                      default: re(() => [
                        p(w, fe({ name: "edit" }, n), null, 16),
                        Ee(xe(c.value.update), 1)
                      ]),
                      _: 1
                    })) : de("", !0),
                    u.value ? (N(), Ce(_n, {
                      key: 2,
                      onClick: y
                    }, {
                      default: re(() => [
                        p(w, fe({ name: "edit" }, n), null, 16),
                        Ee(xe(c.value.save), 1)
                      ]),
                      _: 1
                    })) : de("", !0)
                  ])) : de("", !0),
                  o.value || s.value || u.value ? (N(), ee("div", EN, [
                    o.value ? (N(), Ce(_n, {
                      key: 0,
                      variant: "outlined",
                      onClick: v
                    }, {
                      default: re(() => [
                        p(w, {
                          name: "close",
                          size: 16,
                          class: "mr-1"
                        }),
                        Ee(xe(c.value.close), 1)
                      ]),
                      _: 1
                    })) : de("", !0),
                    s.value || u.value ? (N(), Ce(_n, {
                      key: 1,
                      variant: "outlined",
                      onClick: g
                    }, {
                      default: re(() => [
                        p(w, {
                          name: "close",
                          size: 16,
                          class: "mr-1"
                        }),
                        Ee(xe(c.value.cancel), 1)
                      ]),
                      _: 1
                    })) : de("", !0)
                  ])) : de("", !0)
                ])
              ]),
              _: 2
            }, [
              e.hideHeader ? void 0 : {
                name: "prepend",
                fn: re(() => [
                  ie("div", {
                    class: Ie(["s-modal__title", { "s-modal__title--light": e.isWhite, "s-modal__title--dark": !e.isWhite }])
                  }, [
                    ie("span", null, xe(e.title), 1),
                    ie("div", DN, [
                      ke(C.$slots, "header-btn-append", {}, void 0, !0),
                      p(x, {
                        icon: "mdi-close",
                        color: e.isWhite ? "#1A3350" : "#fff",
                        onClick: X(m)
                      }, null, 8, ["color", "onClick"])
                    ])
                  ], 2)
                ]),
                key: "0"
              }
            ]), 1032, ["class", "height", "min-height"])
          ]),
          _: 3
        }, 8, ["model-value", "width", "class", "size"])
      ], 8, ["to"]);
    };
  }
}, HN = /* @__PURE__ */ Ut(NN, [["__scopeId", "data-v-96359cb6"]]), jN = {
  style: { width: "0", height: "0", position: "absolute" },
  "aria-hidden": "true",
  focusable: "false"
}, zN = ["viewBox"], yc = 20, vb = {
  __name: "SProgressCircular",
  props: {
    size: {
      type: Number,
      default: 50
    },
    width: {
      type: Number,
      default: 6
    }
  },
  setup(e) {
    const t = e, n = k(() => Math.max(0, Math.min(100, parseFloat(0)))), a = 2 * Math.PI * yc, i = (o, u = "px") => {
      if (!(o === null || o === ""))
        return isNaN(o) ? String(o) : isFinite(o) ? `${Number(o)}${u}` : void 0;
    }, l = k(() => yc / (1 - t.width / t.size) * 2), r = k(() => t.width / t.size * l.value), s = k(() => i((100 - n.value) / 100 * a));
    return rt(() => {
    }), (o, u) => (N(), ee("div", {
      class: "s-progress-circular",
      style: Ot({ height: e.size + "px", width: e.size + "px", "--stroke-width": e.width + "px" })
    }, [
      (N(), ee("svg", jN, u[0] || (u[0] = [
        ie("linearGradient", { id: "gradientColor" }, [
          ie("stop", {
            offset: "0%",
            "stop-color": "#1B75BB"
          }),
          ie("stop", {
            offset: "100%",
            "stop-color": "#7C0F80"
          })
        ], -1)
      ]))),
      (N(), ee("svg", {
        class: "s-progress-circular__wrapper",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${l.value} ${l.value}`
      }, [
        ie("circle", {
          class: "s-progress-circular__underlay",
          cx: "50%",
          cy: "50%",
          fill: "transparent",
          r: yc,
          style: Ot({
            strokeWidth: r.value,
            strokeDasharray: a,
            strokeDashoffset: 0
          })
        }, null, 4),
        ie("circle", {
          class: "s-progress-circular__overlay",
          fill: "transparent",
          cx: "50%",
          cy: "50%",
          r: yc,
          style: Ot({
            strokeWidth: r.value,
            strokeDasharray: a,
            strokeDashoffset: s.value
          })
        }, null, 4)
      ], 8, zN))
    ], 4));
  }
}, FN = { class: "s-loading" }, XN = { class: "s-loading__message" }, YN = { class: "s-loading__spinner" }, WN = {
  __name: "SGlobalProgress",
  props: {
    loadingMessage: {
      type: String,
      default: "Check-loading",
      description: "로딩창 메세지 값"
    },
    modelValue: {
      type: Boolean,
      default: !1,
      description: "로딩 오픈 여부"
    },
    teleportId: {
      type: String,
      default: "destination",
      description: "Teleport ID"
    }
  },
  setup(e) {
    return (t, n) => (N(), Ce(zs, {
      to: `#${e.teleportId}`
    }, [
      p(X(Ka), {
        "model-value": e.modelValue,
        class: "custom-overlay",
        contained: "",
        persistent: "",
        "no-click-animation": "",
        scrim: "transparent",
        "z-index": "9999",
        offset: [0, 50]
      }, {
        default: re(() => [
          ie("div", FN, [
            ie("div", XN, xe(e.loadingMessage), 1),
            ie("div", YN, [
              p(vb)
            ]),
            n[0] || (n[0] = ie("div", { class: "s-loading__text" }, "Please wait...", -1))
          ])
        ]),
        _: 1
      }, 8, ["model-value"])
    ], 8, ["to"]));
  }
}, qN = { class: "s-card-table__wrapper" }, UN = {
  key: 0,
  class: "s-card-table__header"
}, GN = { class: "s-card-table__header-item" }, KN = {
  key: 0,
  class: "s-card-table__header-item-title",
  style: { width: "50px" }
}, JN = ["data-sorted", "onClick"], eH = { class: "s-card-table__body-row" }, tH = {
  key: 0,
  class: "s-card__body-icon--expand"
}, nH = {
  key: 1,
  style: { width: "50px" }
}, aH = {
  key: 0,
  class: "s-card-table__body-row-expand"
}, iH = {
  __name: "SCardTable",
  props: {
    itemValue: {
      type: String,
      default: "id",
      description: "selected item value"
    },
    itemTitle: {
      type: String,
      default: void 0,
      description: "title이 될 item 값"
    },
    outlined: {
      type: Boolean,
      default: !1,
      description: ""
    },
    shadowed: {
      type: Boolean,
      default: !1,
      description: ""
    },
    items: {
      type: Array,
      default: () => []
    },
    headers: {
      type: Array,
      default: () => [],
      description: "key, title 값으로 구성된 Array(Object)"
    },
    itemsPerPage: {
      type: [Number, String],
      default: 5,
      description: "per page"
    },
    noDataText: {
      type: String,
      default: "no data.",
      description: "구성 요소에 항목이 제공되지 않을 때 표시되는 텍스트"
    },
    page: {
      type: [Number, String],
      default: 1,
      description: "현재 표시된 페이지 번호(인덱스 1개)"
    },
    isPageRender: {
      type: Boolean,
      default: !1,
      description: "서버에서 페이지 정보 전달 여부"
    },
    search: {
      type: [String, Array],
      default: void 0,
      description: "항목 필터링에 사용되는 텍스트 또는 key:value Object를 포함한 텍스트 배열 입력"
    },
    smartSearch: {
      type: Array,
      default: () => [],
      description: "smart search 조건"
    },
    showSelect: {
      type: Boolean,
      default: !1,
      description: "머리글과 행 모두에서 선택 확인란을 표시합니다(기본 행을 사용하는 경우)."
    },
    options: {
      type: Object,
      default: () => ({
        strongs: [],
        pageCnt: 0,
        totalElements: 0
      }),
      description: ""
    },
    selected: {
      type: Array,
      default: () => []
    },
    width: {
      type: [Number, String],
      default: "100%"
    },
    showExpand: {
      type: Boolean,
      default: !1
    },
    hiddenHeader: {
      type: Boolean,
      default: !1
    },
    scrolled: {
      type: Boolean,
      default: !1
    },
    class: {
      type: String,
      default: ""
    },
    setTotal: {
      type: Function,
      default: () => {
      },
      description: "전체 개수 초기화(필터링 적용)"
    },
    showSelect: {
      type: Boolean,
      default: !1
    },
    selectStrategy: {
      type: String,
      default: "single",
      description: "select strategy 가능한 값 single, all (page는 아직 작업이 되지 않았습니다.)"
    },
    disableSort: {
      type: Boolean,
      default: !1,
      description: "정렬 기능 비활성화 여부"
    },
    sortBy: {
      type: Array,
      default: () => [],
      description: "정렬 상태를 관리하는 배열"
    }
  },
  emits: [
    "update:page",
    "update:selected",
    "update:filtered-cnt",
    "update:sort-by"
  ],
  setup(e, { emit: t }) {
    const { isEmpty: n } = l5, a = e, i = t, l = Y(1), r = k({
      get: () => a.page,
      set: (S) => i("update:page", S)
    }), s = k(() => a.headers.filter((S) => S.key !== a.itemTitle)), o = (S) => {
      if (a.disableSort) return;
      let x = [...a.sortBy];
      const w = x.find((V) => V.key === S.key);
      w ? w.order === "asc" ? w.order = "desc" : w.order === "desc" && (x = x.filter((V) => V.key !== S.key)) : x = [{ key: S.key, order: "asc" }], i("update:sort-by", x);
    }, u = k(() => {
      var S;
      if (a.search) {
        const x = a.headers.map((_) => _.key), w = a.search, V = a.items.filter(
          (_) => x.some((O) => {
            var P, M;
            const $ = _[O];
            return (w === "-" || w === "null" || w === "undefined" || w === "") && n($) ? !0 : n($) ? !1 : typeof $ == typeof {} || typeof $ == typeof [] ? ((P = JSON.stringify($)) == null ? void 0 : P.indexOf(w)) > -1 : ((M = $ == null ? void 0 : $.toString()) == null ? void 0 : M.indexOf(w)) > -1;
          })
        );
        return i("update:filtered-cnt", V.length), V;
      }
      if (a.smartSearch.length) {
        const x = a.items.filter((w) => {
          const V = a.smartSearch.reduce((_, O) => (_[O.key] || (_[O.key] = []), _[O.key].push(O), _), {});
          return Object.entries(V).every(([_, O]) => {
            var $;
            return _ === "undefinedTag" ? !(($ = w.tagList) != null && $.length) : O.some((P) => {
              var M, T;
              return P.value ? P.type === "tag" && ((M = w.tagList) != null && M.length) ? w.tagList.some((L) => {
                const A = L.tagKey === P.key;
                return P.value === "-" || P.value === "null" || P.value === "undefined" || P.value === "" ? A && n(L.tagValue) : A && L.tagValue === P.value;
              }) : P.type !== "tag" ? P.value === "-" || P.value === "null" || P.value === "undefined" || P.value === "" ? n(w[P.key]) : typeof w[P.key] == "object" ? JSON.stringify(w[P.key]) === P.value : typeof w[P.key] == "number" ? ((T = w[P.key]) == null ? void 0 : T.toString()) === P.value : w[P.key] === P.value : !1 : !0;
            });
          });
        });
        return i("update:filtered-cnt", x.length), x;
      }
      return i("update:filtered-cnt", ((S = a.items) == null ? void 0 : S.length) || 0), a.items || [];
    }), c = k(() => !u.value.length || !a.sortBy.length ? u.value : [...u.value].sort((S, x) => {
      for (let w = 0; w < a.sortBy.length; w++) {
        const V = a.sortBy[w], _ = V.key || V, O = V.order === "desc", $ = a.headers.find((A) => A.key === _ || A.value === _), P = ($ == null ? void 0 : $.sortKey) || _;
        let M = S[P], T = x[P];
        if ((($ == null ? void 0 : $.type) || ($ != null && $.sortKey ? "number" : "string")) === "number") {
          if (M = Number(String(M).replace(/,/g, "")), T = Number(String(T).replace(/,/g, "")), isNaN(M) && (M = 0), isNaN(T) && (T = 0), M < T) return O ? 1 : -1;
          if (M > T) return O ? -1 : 1;
        } else {
          M == null && (M = ""), T == null && (T = "");
          const A = M.toString().localeCompare(T.toString(), void 0, { numeric: !0 });
          if (A !== 0) return O ? -A : A;
        }
      }
      return 0;
    })), d = k(() => {
      var S;
      if (!((S = a.options) != null && S.pageCnt)) {
        const x = (a.page - 1) * a.itemsPerPage, w = x + a.itemsPerPage;
        return c.value.slice(x, w);
      }
      return c.value;
    }), f = Y([]), h = (S) => {
      a.selectStrategy === "single" ? f.value.includes(S[a.itemValue]) ? f.value = [] : f.value = [S[a.itemValue]] : f.value.includes(S[a.itemValue]) ? f.value = f.value.filter((x) => x !== S[a.itemValue]) : f.value.push(S[a.itemValue]), i("update:selected", f.value);
    }, m = (S) => {
      r.value = S, l.value = S;
    }, g = (S) => {
      m(S);
    }, v = k(() => {
      var S, x;
      return a.itemsPerPage !== -1 ? ((S = a.options) == null ? void 0 : S.pageCnt) || Math.max(1, Math.ceil(u.value.length / a.itemsPerPage)) : ((x = a.options) == null ? void 0 : x.pageCnt) || Math.max(1, Math.ceil(u.value.length));
    }), y = k(() => (S) => typeof S == "number" ? `${S}%` : S || "100px"), b = (S) => {
      S.showExpandRow = !S.showExpandRow;
    };
    pe(
      () => [a.search, a.smartSearch],
      () => {
        m(1);
      },
      { deep: !0 }
    ), pe(
      () => u.value,
      (S) => {
        a.setTotal(S.length);
      }
    ), rt(() => {
      l.value = a.page;
    });
    const C = (S) => {
      const x = a.sortBy.find((w) => w.key === S.key);
      return x ? x.order === "asc" ? "mdi-arrow-up" : "mdi-arrow-down" : "mdi-arrow-up";
    };
    return (S, x) => {
      var $;
      const w = Pe("v-icon"), V = Pe("v-btn"), _ = Pe("v-checkbox-btn"), O = Pe("v-pagination");
      return N(), ee("div", {
        class: Ie(`s-card-table ${a.class}`)
      }, [
        ie("div", qN, [
          e.hiddenHeader ? de("", !0) : (N(), ee("div", UN, [
            ie("ul", GN, [
              e.showSelect ? (N(), ee("li", KN)) : de("", !0),
              (N(!0), ee(ge, null, Ge(s.value, (P, M) => (N(), ee("li", {
                key: "header-key--" + M,
                class: Ie(["s-card-table__header-item-title", { sortable: !P.disableSort }]),
                "data-sorted": !!a.sortBy.find((T) => T.key === P.key),
                style: Ot({
                  width: y.value(P.width),
                  justifyContent: P.align
                }),
                onClick: (T) => !P.disableSort && o(P)
              }, [
                Ee(xe(P.title) + " ", 1),
                P.disableSort ? de("", !0) : (N(), Ce(w, {
                  key: 0,
                  icon: C(P),
                  size: "small",
                  class: "ml-1 sort-icon"
                }, null, 8, ["icon"]))
              ], 14, JN))), 128))
            ])
          ])),
          d.value.length ? (N(!0), ee(ge, { key: 1 }, Ge(d.value, (P, M) => (N(), ee("ul", {
            key: "content-row--" + M,
            class: "s-card-table__body"
          }, [
            ie("li", eH, [
              ie("div", {
                class: Ie(`s-card-table__body-item ${e.showExpand ? "table-expand_header" : "table-expand_body"}`)
              }, [
                e.showExpand ? (N(), ee("div", tH, [
                  ke(S.$slots, "table-expand", {
                    item: P,
                    expanded: P.showExpandRow,
                    onClickExpand: b
                  }, () => [
                    p(V, {
                      density: "comfortable",
                      variant: "text",
                      icon: P.showExpandRow ? "mdi-chevron-up" : "mdi-chevron-down",
                      onClick: $t((T) => b(P), ["stop", "prevent"])
                    }, null, 8, ["icon", "onClick"])
                  ])
                ])) : de("", !0),
                e.showSelect ? (N(), ee("div", nH, [
                  ke(S.$slots, "table-select", { item: P }, () => [
                    p(_, {
                      "model-value": f.value.includes(P[e.itemValue]),
                      "onUpdate:modelValue": (T) => h(P)
                    }, null, 8, ["model-value", "onUpdate:modelValue"])
                  ])
                ])) : de("", !0),
                (N(!0), ee(ge, null, Ge(s.value, (T, L) => {
                  var A, D;
                  return N(), ee("div", {
                    key: "content-row--" + M + "__col--" + L,
                    class: Ie(["s-card-table__body-wrapper", { "strong-text": (D = (A = e.options) == null ? void 0 : A.strongs) == null ? void 0 : D.includes(T.key) }]),
                    style: Ot({
                      width: y.value(T.width),
                      justifyContent: T.align === "d-none" ? "center" : T.align || "center"
                    })
                  }, [
                    ke(S.$slots, `${T.key}`, { item: P }, () => [
                      Ee(xe(X(n)(P[T.key]) ? "-" : P[T.key]), 1)
                    ])
                  ], 6);
                }), 128))
              ], 2),
              P.showExpandRow ? (N(), ee("div", aH, [
                ke(S.$slots, "expanded-row", {
                  item: P,
                  columns: s.value
                })
              ])) : de("", !0)
            ])
          ]))), 128)) : (N(), Ce(C7, {
            key: 2,
            description: e.noDataText,
            class: "s-card-table__empty"
          }, {
            default: re(() => [
              ke(S.$slots, "empty-content")
            ]),
            _: 3
          }, 8, ["description"]))
        ]),
        e.scrolled ? de("", !0) : (N(), Ce(O, {
          key: 0,
          "model-value": r.value,
          class: "s-card-table__pagination",
          size: "small",
          rounded: "",
          "active-color": "#0D69D4",
          variant: "flat",
          "total-visible": 10,
          length: (($ = e.options) == null ? void 0 : $.pageCnt) || v.value,
          "onUpdate:modelValue": g
        }, null, 8, ["model-value", "length"]))
      ], 2);
    };
  }
}, lH = {
  // 문자열/숫자/날짜: '같음' 연산자 (=)
  "=": (e, t, n) => {
    if (t === "-")
      return e == null;
    if (n === "date") {
      const l = Ma.parseDate(e), r = Ma.parseDate(t);
      return !l || !r ? !1 : l.isSame(r, "day");
    }
    const a = String(e).toLowerCase(), i = String(t).toLowerCase();
    return a === i;
  },
  // 문자열 포함 ':' 연산자
  ":": (e, t, n) => {
    if (t === "-")
      return e == null;
    const a = String(e).toLowerCase(), i = String(t).toLowerCase();
    return a.includes(i);
  },
  // 숫자/날짜: '크거나 같음' 연산자 (>=)
  ">=": (e, t, n) => {
    if (n === "date") {
      const a = Ma.parseDate(e), i = Ma.parseDate(t);
      return !a || !i ? !1 : a.isSameOrAfter(i, "day");
    }
    return parseFloat(e) >= parseFloat(t);
  },
  // 숫자/날짜: '작거나 같음' 연산자 (<=)
  "<=": (e, t, n) => {
    if (n === "date") {
      const a = Ma.parseDate(e), i = Ma.parseDate(t);
      return !a || !i ? !1 : a.isSameOrBefore(i, "day");
    }
    return parseFloat(e) <= parseFloat(t);
  },
  // 숫자/날짜: '보다 작음' 연산자 (<)
  "<": (e, t, n) => {
    if (n === "date") {
      const a = Ma.parseDate(e), i = Ma.parseDate(t);
      return !a || !i ? !1 : a.isBefore(i, "day");
    }
    return parseFloat(e) < parseFloat(t);
  },
  // 숫자/날짜: '보다 큼' 연산자 (>)
  ">": (e, t, n) => {
    if (n === "date") {
      const a = Ma.parseDate(e), i = Ma.parseDate(t);
      return !a || !i ? !1 : a.isAfter(i, "day");
    }
    return parseFloat(e) > parseFloat(t);
  }
};
function rH(e, t) {
  const n = t;
  return !n || n.length === 0 ? e : e.filter((a) => n.some((i) => {
    const { field: l, operator: r, value: s, type: o } = i, u = a[l], c = lH[r];
    return c ? s === "-" ? c(u, s, o) : u == null ? !1 : c(u, s, o) : !1;
  }));
}
const sH = ["onClick"], oH = ["onMousedown"], uH = { class: "header-cell checkbox-header d-flex align-center position-relative justify-center" }, cH = { key: 1 }, dH = { class: "text-center no-data" }, fH = { key: 0 }, hH = { class: "v-data-table__tr" }, mH = ["width"], vH = {
  key: 0,
  class: "text-center s-data-table-pagination"
}, gH = {
  __name: "SDataTable",
  props: {
    // search: String,
    options: {
      type: Object,
      default: () => {
      }
    },
    getChipColors: {
      type: Function,
      default: void 0
    },
    // onClickChips: Function,
    customFilter: {
      type: [Number, Boolean, Array],
      default: void 0,
      description: "항목 필터링 기능"
    },
    customKeyFilter: {
      type: Object,
      default: void 0,
      description: ""
    },
    expanded: {
      type: Array,
      default: () => [],
      description: ""
    },
    expandOnClick: {
      type: Boolean,
      default: !1,
      description: ""
    },
    filterKeys: {
      type: [String, Array],
      default: void 0,
      description: ""
    },
    filterMode: {
      type: String,
      default: "intersection",
      description: ""
    },
    fixedFooter: {
      type: Boolean,
      default: !1,
      description: ""
    },
    fixedHeader: {
      type: Boolean,
      default: !1,
      description: "헤더 사이즈가 고정됩니다. (deprecated)"
    },
    groupBy: {
      type: Array,
      default: () => [],
      description: "항목을 그룹화하는 데 사용해야 하는 항목 속성을 변경합니다. 현재 형식의 단일 그룹화만 지원합니다: group또는 [group]. 배열을 사용할 때 첫 번째 요소만 고려됩니다. .sync수정자 와 함께 사용할 수 있습니다."
    },
    headers: {
      type: Array,
      default: () => [],
      description: "각각 헤더 열을 설명하는 개체의 배열입니다."
    },
    height: {
      type: [String, Number],
      default: void 0,
      description: "명시적인 테이블 높이 설정"
    },
    hideNoData: {
      type: Boolean,
      default: !1,
      description: ""
    },
    itemProps: {
      type: [Boolean, String, Array, Function],
      default: "props",
      description: "각 항목 구성 요소에 적용될 props 개체입니다. true원본 개체를 가공되지 않는 props로 취급하고 구성 요소에 직접 전달합니다."
    },
    items: {
      type: Array,
      default: () => [],
      description: "자식 구성 요소를 자동으로 생성하는 데 사용되는 문자열 또는 객체의 배열"
    },
    itemsPerPage: {
      type: [String, Number],
      default: 10,
      description: "페이지당 표시할 항목 수를 변경합니다. .sync 수정자와 함께 사용할 수 있습니다. 이 prop을 -1로 설정하면 페이지의 모든 항목이 표시됩니다."
    },
    itemValue: {
      type: [Boolean, String, Array, Function],
      default: "id",
      description: ""
    },
    modelValue: {
      type: Array,
      default: () => [],
      description: "구성 요소의 v-model 값입니다. 구성 요소가 다중 소품을 지원하는 경우 기본값은 빈 배열입니다."
    },
    multiSort: {
      type: Boolean,
      default: !1,
      description: "true일 경우 여러 속성에 대해 정렬할 수 있습니다."
    },
    mustSort: {
      type: Boolean,
      default: !1,
      description: "true일 경우 정렬을 비활성화할 수 없으면 항상 오름차순과 내림차순 간에 전환됩니다."
    },
    noDataText: {
      type: String,
      default: "no data.",
      description: "구성 요소에 항목이 제공되지 않을 때 표시되는 텍스트"
    },
    noFilter: {
      type: Boolean,
      default: !1,
      description: ""
    },
    page: {
      type: [String, Number],
      default: 1,
      description: "현재 표시된 페이지 번호(인덱스 1개)"
    },
    returnObject: {
      type: Boolean,
      default: !1,
      description: ""
    },
    search: {
      type: String,
      default: void 0,
      description: "항목 필터링에 사용되는 텍스트 입력"
    },
    showExpand: {
      type: Boolean,
      default: !1,
      description: "기본 행에 확장 토글을 표시합니다."
    },
    showSelect: {
      type: Boolean,
      default: !1,
      description: "머리글과 행 모두에서 선택 확인란을 표시합니다(기본 행을 사용하는 경우)."
    },
    sortBy: {
      type: Array,
      default: () => [],
      description: "정렬 순서에 사용해야 하는 항목 속성을 변경합니다. .sync수정자 와 함께 사용할 수 있습니다."
    },
    selectStrategy: {
      type: String,
      default: "page"
    },
    width: {
      type: [String, Number],
      default: void 0,
      description: "구성 요소의 너비를 설정합니다."
    },
    // custom
    single: {
      type: Boolean,
      default: !1,
      description: "select model의 데이터를 단일/다중으로 세팅합니다."
    },
    hideFooter: {
      type: Boolean,
      default: !1,
      description: "footer hide"
    },
    footers: {
      type: Object,
      default: () => {
      },
      description: "tfoot 위치에 그릴 데이터"
    },
    customSlotFooter: {
      type: Object,
      default: () => {
      },
      description: "custom footer"
    },
    smartSearch: {
      type: Array,
      default: () => [],
      description: "Smart Search 검색 기능"
    },
    advancedSearch: {
      type: Array,
      default: () => [],
      description: "Advanced Search 검색 기능"
    },
    setTotal: {
      type: Function,
      default: () => {
      },
      description: "전체 개수 초기화(필터링 적용)"
    },
    density: {
      type: String,
      default: "default",
      description: "default | comfortable | compact 사이즈"
    },
    tooltip: {
      type: Boolean,
      default: !1,
      description: "툴팁 사용 여부(툴팁을 사용하려면 테이블의 class가 fixed-table을 포함하고 있어야 합니다.)"
    },
    itemSelectable: {
      type: String,
      default: null,
      description: "테이블의 checkbox가 선택이 가능한지의 여부를 판단할 수 있는 요소의 키 값입니다. (예: selectable)"
    },
    disableSort: {
      type: Boolean,
      default: !1,
      description: "정렬 기능 비활성화"
    },
    loading: {
      type: Boolean,
      default: !1,
      description: "로딩 상태"
    },
    hover: {
      type: Boolean,
      default: !1,
      description: "hover 상태"
    },
    fixedTable: {
      type: Boolean,
      default: !1,
      description: "테이블 고정 여부"
    },
    resizable: {
      type: Boolean,
      default: !1,
      description: "컬럼 크기 조정 가능 여부"
    }
  },
  emits: [
    "update:page",
    "update:filter",
    "update:search",
    "update:sort-by",
    "update:group-by",
    "update:expanded",
    "update:options",
    "update:model-value",
    "get-checkedbox-item",
    "update:filtered-cnt"
  ],
  setup(e, { emit: t }) {
    const { isEmpty: n } = l5, a = t, i = e, l = Y([]), r = Y([]), s = Y([]), o = Y([]), u = Y(!1), c = Y(!1), d = Y(0), f = Y(0), h = Y(null), m = Y(/* @__PURE__ */ new Map()), g = Y(null), v = Y(!1), y = Y(null), b = Y(0), C = (z) => {
      a("get-checkedbox-item", z), l.value = z, a("update:model-value", l.value);
    }, S = k(() => {
      if (i.search) {
        const E = i.headers.map((se) => se.key), Q = i.search, W = i.items.filter(
          (se) => E.some((Se) => {
            var ne, K;
            const U = se[Se];
            return (Q === "-" || Q === "null" || Q === "undefined" || Q === "") && n(U) ? !0 : n(U) ? !1 : typeof U == typeof {} || typeof U == typeof [] ? ((ne = JSON.stringify(U)) == null ? void 0 : ne.indexOf(Q)) > -1 : ((K = U == null ? void 0 : U.toString()) == null ? void 0 : K.indexOf(Q)) > -1;
          })
        );
        return a("update:filtered-cnt", W.length), W;
      }
      if (i.smartSearch.length) {
        const E = i.items.filter((Q) => {
          const W = i.smartSearch.reduce((se, Se) => (se[Se.key] || (se[Se.key] = []), se[Se.key].push(Se), se), {});
          return Object.entries(W).every(([se, Se]) => {
            var U;
            return se === "undefinedTag" ? !((U = Q.tagList) != null && U.length) : Se.some((ne) => {
              var K, te;
              return ne.value ? ne.type === "tag" && ((K = Q.tagList) != null && K.length) ? Q.tagList.some((H) => {
                const ce = H.tagKey === ne.key;
                return ne.value === "-" || ne.value === "null" || ne.value === "undefined" || ne.value === "" ? ce && (n(H.tagValue) || H.tagValue === "-") : ce && H.tagValue === ne.value;
              }) : ne.type !== "tag" ? ne.value === "-" || ne.value === "null" || ne.value === "undefined" || ne.value === "" ? n(Q[ne.key]) || Q[ne.key] === "-" : typeof Q[ne.key] == "object" ? JSON.stringify(Q[ne.key]) === ne.value : typeof Q[ne.key] == "number" ? ((te = Q[ne.key]) == null ? void 0 : te.toString()) === ne.value : Q[ne.key] === ne.value : !1 : !0;
            });
          });
        });
        return a("update:filtered-cnt", E.length), E;
      }
      if (i.advancedSearch.length > 0)
        return rH(i.items, i.advancedSearch);
      let z = i.items || [];
      return a("update:filtered-cnt", z.length), r.value.length > 0 && (z = [...z].sort((E, Q) => {
        for (let W = 0; W < r.value.length; W++) {
          const se = r.value[W], Se = se.key || se, U = s.value[W] || !1, ne = i.headers.find((he) => he.key === Se || he.value === Se), K = (ne == null ? void 0 : ne.sortKey) || Se;
          let te = E[K], H = Q[K];
          if (((ne == null ? void 0 : ne.type) || (ne != null && ne.sortKey ? "number" : "string")) === "number") {
            if (te = Number(String(te).replace(/,/g, "")), H = Number(String(H).replace(/,/g, "")), isNaN(te) && (te = 0), isNaN(H) && (H = 0), te < H) return U ? 1 : -1;
            if (te > H) return U ? -1 : 1;
          } else {
            te == null && (te = ""), H == null && (H = "");
            const he = te.toString().localeCompare(H.toString(), void 0, { numeric: !0 });
            if (he !== 0) return U ? -he : he;
          }
        }
        return 0;
      })), z;
    }), x = k(() => {
      var z, E;
      return i.itemsPerPage !== -1 ? ((z = i.options) == null ? void 0 : z.pageCnt) || Math.max(1, Math.ceil(S.value.length / i.itemsPerPage)) : ((E = i.options) == null ? void 0 : E.pageCnt) || Math.max(1, Math.ceil(S.value.length));
    }), w = (z) => {
      a("update:page", z);
    }, V = (z) => {
    }, _ = k({
      get: () => i.page,
      set: (z) => w(z)
    });
    pe(
      () => i.headers,
      (z) => {
        o.value = z.filter((E) => E.align !== "d-none"), u.value || (v.value = !1, et(() => {
          O(), i.resizable || q();
        }));
      },
      { immediate: !0 }
    ), pe(
      () => i.modelValue,
      (z) => {
        l.value = z;
      },
      { immediate: !0 }
    ), pe(
      () => i.smartSearch,
      () => {
        w(1);
      },
      {
        deep: !0
      }
    ), pe(
      () => i.advancedSearch,
      () => {
        w(1);
      },
      {
        deep: !0
      }
    ), pe(
      () => i.itemsPerPage,
      () => {
        w(1);
      }
    ), rt(() => {
      if (requestAnimationFrame(() => {
        O(), i.resizable || q();
      }), i.resizable) {
        const z = D();
        z && (y.value = new ResizeObserver((E) => {
          var W;
          const Q = (W = E[0]) == null ? void 0 : W.target.querySelector(".v-table__wrapper");
          if (Q) {
            const se = Q.clientWidth;
            se > 0 && b.value === 0 && (v.value = !1, et(() => {
              O();
            })), b.value = se;
          }
        }), y.value.observe(z));
      }
    });
    const O = () => {
      const z = D(), E = B();
      if (!z || !E || v.value) return;
      const Q = z.querySelector(".v-table__wrapper");
      if (Q && i.resizable) {
        const W = E.querySelectorAll("thead tr th"), se = i.showSelect, Se = se ? 1 : 0, U = /* @__PURE__ */ new Map();
        W.forEach((ce, he) => {
          let Oe, je;
          const be = he - Se, Te = o.value[be];
          se && he === 0 ? (je = "data-table-select-header", Oe = 48) : Te ? (je = Te.key, Te.width ? Oe = parseInt(String(Te.width), 10) : Oe = ce.offsetWidth) : Oe = ce.offsetWidth, je && U.set(je, Oe);
        });
        const ne = Q.clientWidth, K = U.get("data-table-select-header") || 0;
        let te = 0;
        if (U.forEach((ce, he) => {
          he !== "data-table-select-header" && (te += ce || 0);
        }), te + K < ne) {
          const ce = ne - K;
          if (te > 0) {
            const he = (ce - 2) / te;
            U.forEach((Oe, je) => {
              je === "data-table-select-header" ? m.value.set(je, Oe) : m.value.set(je, Math.max(50, Math.floor(Oe * he)));
            });
          } else K > 0 && m.value.set("data-table-select-header", K);
        } else
          U.forEach((ce, he) => {
            m.value.set(he, Math.max(50, ce || 0));
          });
        if (se) {
          const ce = m.value.get("data-table-select-header");
          ce && z.style.setProperty("--column-0-width", `${ce}px`);
        }
        o.value.forEach((ce, he) => {
          const Oe = m.value.get(ce.key);
          if (Oe) {
            const je = he + Se;
            z.style.setProperty(`--column-${je}-width`, `${Oe}px`);
          }
        }), E.style.tableLayout = "fixed", Q == null || Q.classList.add("table-resizing"), J(), v.value = !0;
      }
    }, $ = (z) => z.highlight || "", P = (z) => {
      switch (z) {
        case "start":
        case "left":
          return "justify-start";
        case "center":
          return "justify-center";
        case "end":
        case "right":
          return "justify-end";
        default:
          return "justify-start";
      }
    }, M = (z) => r.value.some((E) => E.key === z), T = (z) => {
      const E = r.value.find((Q) => Q.key === z);
      return E ? E.order : null;
    }, L = (z) => {
      const E = T(z);
      return E === "asc" ? "mdi-arrow-up" : E === "desc" ? "mdi-arrow-down" : "mdi-arrow-up-down";
    }, A = (z) => {
      if (u.value || i.disableSort) return;
      const E = i.headers.find((se) => se.key === z);
      if (E && E.sortable === !1) return;
      const Q = r.value.find((se) => se.key === z);
      let W = "asc";
      Q ? Q.order === "asc" ? W = "desc" : Q.order === "desc" && (W = null) : W = "asc", W === null ? (r.value = [], s.value = []) : (r.value = [{ key: z, order: W }], s.value = [W === "desc"]), a("update:sort-by", r.value), w(1);
    }, D = () => {
      var z;
      return ((z = g.value) == null ? void 0 : z.$el) || null;
    }, B = () => {
      var z;
      return ((z = D()) == null ? void 0 : z.querySelector("table")) || null;
    }, j = (z, E, Q) => {
      if (!i.resizable || (z.preventDefault(), z.stopPropagation(), u.value) || !B()) return;
      v.value || O(), u.value = !0;
      const Se = i.showSelect ? 1 : 0, U = Q === -1 ? 0 : Q + Se;
      d.value = z.clientX, h.value = { key: E, index: U }, f.value = m.value.get(E) || 0, document.addEventListener("mousemove", I), document.addEventListener("mouseup", Z), document.body.style.userSelect = "none", document.body.style.cursor = "col-resize";
    }, I = (z) => {
      if (!u.value || !h.value) return;
      z.preventDefault();
      const E = z.clientX - d.value;
      if (!c.value && Math.abs(E) > 3 && (c.value = !0), c.value) {
        const Q = Math.max(50, f.value + E);
        R(h.value.key, h.value.index, Q);
      }
    }, Z = () => {
      if (u.value) {
        if (!c.value) {
          u.value = !1, document.removeEventListener("mousemove", I), document.removeEventListener("mouseup", Z), document.body.style.userSelect = "", document.body.style.cursor = "";
          return;
        }
        u.value = !1, c.value = !1, h.value = null, document.removeEventListener("mousemove", I), document.removeEventListener("mouseup", Z), document.body.style.userSelect = "", document.body.style.cursor = "";
      }
    }, R = (z, E, Q) => {
      const W = D();
      W && (m.value.set(z, Q), W.style.setProperty(`--column-${E}-width`, `${Q}px`), J());
    }, J = () => {
      var Q;
      const z = B(), E = (Q = D()) == null ? void 0 : Q.querySelector(".v-table__wrapper");
      if (!(!z || !E) && E.classList.contains("table-resizing")) {
        const W = Array.from(m.value.values()).reduce((Se, U) => Se + (U || 0), 0);
        W > 0 && (z.style.width = `${W}px`, z.style.minWidth = `${W}px`);
        const se = E.clientWidth;
        W > se ? E.style.overflowX = "auto" : E.style.overflowX = "hidden";
      }
    }, F = (z) => z ? typeof z == "string" && /\d+(px|%|em|rem|vw|vh)$/.test(z) ? z : typeof z == "number" || typeof z == "string" && /^\d+$/.test(z) ? `${z}px` : "150px" : "150px", q = () => {
      const z = D();
      if (!z) return;
      const E = i.showSelect, Q = E ? 1 : 0;
      o.value.forEach((W, se) => {
        const Se = F(W.width), U = se + Q + 1;
        z.style.setProperty(`--column-${U - 1}-width`, Se);
        const ne = `th:nth-child(${U}), td:nth-child(${U})`;
        z.querySelectorAll(ne).forEach((te) => {
          te.style.setProperty("--column-width", Se);
        });
      }), E && (z.style.setProperty("--column-0-width", "60px"), z.querySelectorAll("th:nth-child(1), td:nth-child(1)").forEach((se) => {
        se.style.setProperty("--column-width", "60px");
      }));
    };
    return mn(() => {
      u.value && (document.removeEventListener("mousemove", I), document.removeEventListener("mouseup", Z), document.body.style.userSelect = "", document.body.style.cursor = ""), y.value && (y.value.disconnect(), y.value = null);
    }), (z, E) => {
      const Q = Pe("v-icon"), W = Pe("v-tooltip"), se = Pe("v-checkbox-btn"), Se = Pe("v-pagination"), U = Pe("v-data-table");
      return N(), Ce(U, fe({
        ref_key: "sDataTableRef",
        ref: g,
        class: ["s-data-table", { "disable-sort": e.disableSort, "fixed-table": e.fixedTable, "no-vertical-lines": !e.resizable }]
      }, z.$attrs, {
        headers: o.value,
        "fixed-header": e.fixedHeader,
        height: e.height,
        items: S.value,
        page: _.value,
        "items-per-page": e.itemsPerPage,
        search: e.search,
        "item-value": e.itemValue,
        "show-select": e.showSelect,
        "return-object": e.returnObject,
        "model-value": l.value,
        "select-strategy": e.selectStrategy,
        loading: e.loading,
        hover: e.hover,
        "show-expand": e.showExpand,
        "disable-sort": e.disableSort,
        expanded: e.expanded,
        "expand-on-click": e.expandOnClick,
        "item-class": $,
        "sort-by": [],
        "item-selectable": "",
        "onUpdate:sortBy": V,
        "onUpdate:modelValue": C,
        "onUpdate:options": E[3] || (E[3] = (ne) => z.$emit("update:options", ne)),
        "onUpdate:expanded": E[4] || (E[4] = (ne) => z.$emit("update:expanded", ne))
      }), Xt({
        "header.data-table-select": re((ne) => [
          ie("div", uH, [
            e.selectStrategy !== "single" || z.$slots["item.data-table-select"] ? (N(), Ce(se, {
              key: 0,
              indeterminate: ne.someSelected && !ne.allSelected,
              "model-value": ne.allSelected,
              "onUpdate:modelValue": (K) => ne.selectAll(!ne.allSelected)
            }, null, 8, ["indeterminate", "model-value", "onUpdate:modelValue"])) : (N(), ee("span", cH)),
            e.resizable ? (N(), ee("div", {
              key: 2,
              class: "resize-handle",
              onMousedown: E[1] || (E[1] = (K) => j(K, "data-table-select-header", -1)),
              onClick: E[2] || (E[2] = $t(() => {
              }, ["stop"]))
            }, null, 32)) : de("", !0)
          ])
        ]),
        "item.data-table-select": re(({ item: ne, isSelected: K, toggleSelect: te, internalItem: H }) => [
          ie("div", {
            class: Ie([(ne == null ? void 0 : ne.highlight) || ""])
          }, [
            z.$slots["item.data-table-select"] ? ke(z.$slots, "item.data-table-select", Pt(fe({ key: 0 }, { item: ne, isSelected: K, toggleSelect: te, internalItem: H })), () => [
              ne.selectable ? (N(), Ce(se, {
                key: 0,
                "model-value": K(H),
                "onUpdate:modelValue": (ce) => te(H)
              }, null, 8, ["model-value", "onUpdate:modelValue"])) : (N(), ee(ge, { key: 1 }, [], 64))
            ], !0) : !e.itemSelectable || ne[e.itemSelectable] !== !1 ? (N(), Ce(se, {
              key: 1,
              "model-value": K(H),
              "onUpdate:modelValue": (ce) => te(H)
            }, null, 8, ["model-value", "onUpdate:modelValue"])) : de("", !0)
          ], 2)
        ]),
        "no-data": re(() => [
          ie("div", dH, xe(e.noDataText), 1)
        ]),
        tfoot: re((ne) => [
          ke(z.$slots, "tfoot", Pt(Jt(ne)), () => [
            e.footers && Object.keys(e.footers).length ? (N(), ee("tfoot", fH, [
              ie("tr", hH, [
                (N(!0), ee(ge, null, Ge(o.value, (K, te) => (N(), ee(ge, {
                  key: "foot__" + te
                }, [
                  K.align !== "d-none" ? (N(), ee("td", {
                    key: 0,
                    class: "v-data-table__td",
                    width: K.width,
                    style: Ot({ textAlign: K.align || "start" })
                  }, [
                    z.$slots[`footer.${K.key}`] ? (N(), ee("span", {
                      key: 0,
                      class: Ie([e.footers.highlight])
                    }, [
                      ke(z.$slots, `footer.${K.key}`, { props: e.footers }, void 0, !0)
                    ], 2)) : (N(), ee("span", {
                      key: 1,
                      class: Ie([e.footers.highlight])
                    }, xe(e.footers[K.key]), 3))
                  ], 12, mH)) : de("", !0)
                ], 64))), 128))
              ])
            ])) : de("", !0)
          ], !0)
        ]),
        bottom: re(() => {
          var ne;
          return [
            ke(z.$slots, "append-content", {}, void 0, !0),
            e.hideFooter ? de("", !0) : (N(), ee("div", vH, [
              p(Se, {
                "model-value": _.value,
                size: "small",
                rounded: "",
                "active-color": "#1B75BB",
                variant: "flat",
                "total-visible": 10,
                length: ((ne = e.options) == null ? void 0 : ne.pageCnt) || x.value,
                "onUpdate:modelValue": w
              }, null, 8, ["model-value", "length"])
            ]))
          ];
        }),
        _: 2
      }, [
        z.$slots.headers ? {
          name: "headers",
          fn: re((ne) => [
            ke(z.$slots, "headers", Pt(Jt(ne)), void 0, !0)
          ]),
          key: "0"
        } : void 0,
        Ge(o.value, (ne, K) => ({
          name: `header.${ne.key}`,
          fn: re(() => [
            ie("div", {
              class: Ie(["header-cell d-flex align-center position-relative", P(ne.align)]),
              onClick: (te) => A(ne.key)
            }, [
              ne.sortable !== !1 && !e.disableSort && (ne.align === "end" || ne.align === "right") ? (N(), Ce(Q, {
                key: 0,
                class: Ie(["custom-sort-icon", {
                  active: M(ne.key)
                }])
              }, {
                default: re(() => [
                  Ee(xe(L(ne.key)), 1)
                ]),
                _: 2
              }, 1032, ["class"])) : de("", !0),
              ie("span", null, xe(ne.title || ne.value), 1),
              ne.sortable !== !1 && !e.disableSort && ne.align !== "end" && ne.align !== "right" ? (N(), Ce(Q, {
                key: 1,
                class: Ie(["custom-sort-icon", {
                  active: M(ne.key)
                }])
              }, {
                default: re(() => [
                  Ee(xe(L(ne.key)), 1)
                ]),
                _: 2
              }, 1032, ["class"])) : de("", !0),
              e.resizable ? (N(), ee("div", {
                key: 2,
                class: "resize-handle",
                onMousedown: (te) => j(te, ne.key, K),
                onClick: E[0] || (E[0] = $t(() => {
                }, ["stop"]))
              }, null, 40, oH)) : de("", !0)
            ], 10, sH)
          ])
        })),
        Ge(o.value, (ne, K) => ({
          name: `item.${ne.key}`,
          fn: re((te) => [
            e.tooltip ? (N(), Ce(W, {
              key: 0,
              location: "bottom",
              "max-width": "450px"
            }, {
              activator: re(({ props: H }) => [
                z.$slots[`item.${ne.key}`] ? (N(), ee("span", {
                  key: 1,
                  class: Ie([te.item.highlight || ""])
                }, [
                  ke(z.$slots, `item.${ne.key}`, Pt(Jt(te)), () => [
                    Ee(xe(X(n)(te.item[ne.key]) ? "-" : te.item[ne.key]), 1)
                  ], !0)
                ], 2)) : (N(), ee("span", fe({ key: 0 }, H, {
                  class: ["d-inline-block text-truncate s-table-column__text", [
                    te.item.highlight
                  ]]
                }), xe(X(n)(te.item[ne.key]) ? "-" : te.item[ne.key]), 17))
              ]),
              default: re(() => [
                ie("span", null, xe(X(n)(te.item[ne.key]) ? "-" : te.item[ne.key]), 1)
              ]),
              _: 2
            }, 1024)) : (N(), ee("div", {
              key: 1,
              class: Ie([
                te.item.highlight
              ])
            }, [
              ke(z.$slots, `item.${ne.key}`, Pt(Jt(te)), () => [
                Ee(xe(X(n)(te.item[ne.key]) ? "-" : te.item[ne.key]), 1)
              ], !0)
            ], 2))
          ])
        })),
        z.$slots.item ? {
          name: "item",
          fn: re((ne) => [
            ke(z.$slots, "item", Pt(Jt(ne)), void 0, !0)
          ]),
          key: "1"
        } : void 0,
        z.$slots.body ? {
          name: "body",
          fn: re((ne) => [
            ke(z.$slots, "body", Pt(Jt({ ...ne, items: S.value })), void 0, !0)
          ]),
          key: "2"
        } : void 0,
        z.$slots["body.append"] ? {
          name: "body.append",
          fn: re((ne) => [
            ke(z.$slots, "body.append", Pt(Jt(ne)), void 0, !0)
          ]),
          key: "3"
        } : void 0,
        z.$slots.tbody ? {
          name: "tbody",
          fn: re((ne) => [
            ke(z.$slots, "tbody", Pt(Jt(ne)), void 0, !0)
          ]),
          key: "4"
        } : void 0,
        z.$slots["expanded-row"] ? {
          name: "expanded-row",
          fn: re((ne) => [
            ke(z.$slots, "expanded-row", Pt(Jt(ne)), void 0, !0)
          ]),
          key: "5"
        } : void 0
      ]), 1040, ["class", "headers", "fixed-header", "height", "items", "page", "items-per-page", "search", "item-value", "show-select", "return-object", "model-value", "select-strategy", "loading", "hover", "show-expand", "disable-sort", "expanded", "expand-on-click"]);
    };
  }
}, pH = /* @__PURE__ */ Ut(gH, [["__scopeId", "data-v-7ac43172"]]), yH = {}, OH = {
  width: "190",
  height: "33",
  viewBox: "0 0 190 33",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function bH(e, t) {
  return N(), ee("svg", OH, t[0] || (t[0] = [
    ZC('<g clip-path="url(#clip0_1478_17785)"><path d="M49.0053 0H33.0018C28.5846 0 25 3.58456 25 8.00176V24.0053C25 28.4225 28.5846 32.0071 33.0018 32.0071H49.0053C53.4225 32.0071 57.0071 28.4225 57.0071 24.0053V8.00176C57 3.58456 53.4225 0 49.0053 0ZM31.1389 20.2867C28.7751 20.2867 26.8558 18.3674 26.8558 16.0035C26.8558 13.6397 28.7751 11.7204 31.1389 11.7204C33.5028 11.7204 35.4221 13.6397 35.4221 16.0035C35.4221 18.3674 33.5028 20.2867 31.1389 20.2867ZM49.6827 20.2867C48.2573 20.2867 46.9943 19.5881 46.2181 18.5155C45.4701 17.7394 44.7292 18.1204 44.3694 18.4238C43.6002 19.5528 42.3019 20.2937 40.8342 20.2937C38.4703 20.2937 36.551 18.3744 36.551 16.0106C36.551 13.6467 38.4703 11.7275 40.8342 11.7275C42.2948 11.7275 43.5861 12.4613 44.3623 13.5832C44.7222 13.8867 45.4701 14.2889 46.2322 13.4845C47.0084 12.419 48.2644 11.7275 49.6827 11.7275C52.0465 11.7275 53.9658 13.6467 53.9658 16.0106C53.9658 18.3744 52.0465 20.2937 49.6827 20.2937V20.2867ZM54.3045 20.1032C53.8318 20.1032 53.4507 19.7222 53.4507 19.2494C53.4507 18.7766 53.8318 18.3956 54.3045 18.3956C54.7773 18.3956 55.1583 18.7766 55.1583 19.2494C55.1583 19.7222 54.7773 20.1032 54.3045 20.1032Z" fill="white"></path><path d="M106.935 3.85976C106.865 1.71466 105.101 0 102.941 0H99.6884C99.2721 0 98.9404 0.338699 98.9404 0.74796V7.24675C98.9404 7.66307 99.2791 7.99471 99.6884 7.99471H102.941C105.15 7.99471 106.942 6.20243 106.942 3.99383C106.942 3.97971 106.942 3.9656 106.942 3.95149C106.942 3.91621 106.942 3.88798 106.942 3.8527L106.935 3.85976ZM102.941 6.49879H100.443V1.50298H102.941C104.324 1.50298 105.439 2.62492 105.439 4.00088C105.439 5.37685 104.317 6.49879 102.941 6.49879Z" fill="white"></path><path d="M71.8443 6.83043C72.1548 6.51996 72.1548 6.01191 71.8443 5.70143C71.5339 5.39096 71.0399 5.39096 70.7224 5.69438C70.7224 5.69438 70.7224 5.69438 70.7153 5.70143C70.7153 5.70143 70.7153 5.70849 70.7083 5.71555C70.2778 6.14598 69.6781 6.40706 69.0218 6.40706C68.3656 6.40706 67.7588 6.13892 67.3213 5.70143C66.8908 5.26395 66.6157 4.67122 66.6157 4.00088C66.6157 3.33054 66.8767 2.74487 67.3072 2.31444C67.3072 2.31444 67.3072 2.31444 67.3213 2.30739L67.3283 2.29327C67.7588 1.86284 68.3585 1.60176 69.0148 1.60176C69.671 1.60176 70.2567 1.86284 70.6871 2.28622C70.6942 2.28622 70.7012 2.30033 70.7083 2.30739C70.7153 2.31444 70.7224 2.3215 70.7294 2.32856C71.0399 2.61786 71.5338 2.61081 71.8373 2.30739C72.1407 2.00397 72.1477 1.51709 71.8584 1.19956C71.8584 1.1925 71.8443 1.18545 71.8373 1.17839C71.8302 1.17133 71.8232 1.16428 71.809 1.15017C71.0893 0.437486 70.1014 0 69.0077 0C67.914 0 66.9261 0.437486 66.2064 1.15017C66.1993 1.15722 66.1923 1.16428 66.1782 1.17839C66.1782 1.17839 66.1641 1.1925 66.157 1.19956C65.4443 1.91929 65.0068 2.90717 65.0068 4.00088C65.0068 5.0946 65.4514 6.10364 66.1782 6.83043C66.905 7.55722 67.8999 8.00176 69.0077 8.00176C70.1155 8.00176 71.1105 7.55722 71.8373 6.83043H71.8443Z" fill="white"></path><path d="M85.9779 0C83.7693 0 81.9771 1.79228 81.9771 4.00088C81.9771 6.20948 83.7693 8.00176 85.9779 8.00176C88.1865 8.00176 89.9788 6.20948 89.9788 4.00088C89.9788 1.79228 88.1865 0 85.9779 0ZM85.9779 6.4C84.6514 6.4 83.5788 5.32745 83.5788 4.00088C83.5788 2.67431 84.6514 1.60176 85.9779 1.60176C87.3045 1.60176 88.3771 2.67431 88.3771 4.00088C88.3771 5.32745 87.3045 6.4 85.9779 6.4Z" fill="white"></path><path d="M80.7 6.4H77.4965C76.8332 6.4 76.2334 6.13186 75.7959 5.69438C75.3655 5.25689 75.0903 4.66417 75.0903 3.99383V0.797354C75.0903 0.352811 74.7304 0 74.293 0C74.0742 0 73.8696 0.091731 73.7285 0.232856C73.5803 0.37398 73.4956 0.578611 73.4956 0.797354V4.00088C73.4956 5.10871 73.9402 6.10364 74.6669 6.83043C75.3937 7.55722 76.3887 8.00176 77.4965 8.00176H80.7C80.9188 8.00176 81.1234 7.91003 81.2645 7.76891C81.4127 7.62778 81.4974 7.42315 81.4974 7.20441C81.4974 6.75987 81.1375 6.40706 80.7 6.40706V6.4Z" fill="white"></path><path d="M98.2206 0.232856C98.0794 0.0846748 97.8748 0 97.6561 0C97.2115 0 96.8587 0.359868 96.8587 0.797354V4.00088C96.8587 4.66417 96.5906 5.26395 96.1531 5.70143C95.7156 6.13186 95.1158 6.40706 94.4525 6.40706C93.7893 6.40706 93.1895 6.13892 92.752 5.70143C92.3216 5.26395 92.0464 4.67122 92.0464 4.00088V1.60176V0.80441C92.0464 0.359868 91.6865 0.00705623 91.249 0.00705623C91.0303 0.00705623 90.8256 0.0987872 90.6845 0.239912C90.5363 0.381036 90.4517 0.585667 90.4517 0.80441V4.00794C90.4517 5.11577 90.8962 6.11069 91.623 6.83749C92.3498 7.56428 93.3447 8.00882 94.4525 8.00882C95.5604 8.00882 96.5553 7.56428 97.2821 6.83749C98.0089 6.11069 98.4534 5.11577 98.4534 4.00794V0.797354C98.4534 0.578611 98.3617 0.37398 98.2206 0.232856Z" fill="white"></path><path d="M114.471 16.4689C114.182 16.1796 113.779 15.9961 113.342 15.9961H106.942C104.733 15.9961 102.736 16.8922 101.29 18.3388C99.8434 19.7853 98.9473 21.7822 98.9473 23.9908V30.3908C98.9473 30.8353 99.1237 31.2305 99.42 31.5198C99.7093 31.8091 100.112 31.9926 100.549 31.9926C101.431 31.9926 102.151 31.2728 102.151 30.3908V23.9908C102.151 22.6642 102.687 21.4647 103.555 20.5968C104.423 19.7288 105.622 19.1926 106.949 19.1926H113.349C114.231 19.1926 114.951 18.4728 114.951 17.5908C114.951 17.1463 114.774 16.7511 114.478 16.4618L114.471 16.4689Z" fill="white"></path><path d="M129.557 18.3458C129.557 18.3458 129.522 18.3106 129.501 18.2964C128.061 16.8781 126.086 16.0032 123.898 16.0032C121.711 16.0032 119.735 16.8781 118.296 18.2964C118.274 18.3106 118.26 18.3317 118.239 18.3458C118.218 18.36 118.204 18.3811 118.197 18.3952C116.779 19.8347 115.896 21.8175 115.896 24.0049C115.896 26.1924 116.793 28.2105 118.239 29.664C119.686 31.1106 121.683 32.0067 123.898 32.0067C125.698 32.0067 127.363 31.414 128.696 30.4049V30.1086C128.696 30.1086 128.718 30.1086 128.725 30.1086C128.704 30.2074 128.696 30.3062 128.696 30.412C128.696 31.3011 129.416 32.0138 130.298 32.0138C131.18 32.0138 131.9 31.294 131.9 30.412V24.012C131.9 21.8246 131.025 19.8418 129.6 18.4023C129.586 18.3882 129.571 18.367 129.557 18.3529V18.3458ZM127.321 27.3778C127.321 27.3778 127.292 27.406 127.278 27.4202C126.41 28.274 125.218 28.8032 123.905 28.8032C122.593 28.8032 121.379 28.2669 120.511 27.399C119.643 26.5311 119.107 25.3315 119.107 24.0049C119.107 22.6925 119.636 21.5 120.49 20.6321C120.504 20.6179 120.518 20.6038 120.532 20.5897C121.4 19.7359 122.593 19.2067 123.905 19.2067C125.218 19.2067 126.389 19.7218 127.257 20.5686C127.285 20.5968 127.313 20.625 127.342 20.6532C128.188 21.5211 128.704 22.6995 128.704 24.0049C128.704 25.3103 128.174 26.517 127.321 27.3778Z" fill="white"></path><path d="M157.825 16.0032C153.407 16.0032 149.823 19.5877 149.823 24.0049C149.823 28.4221 153.407 32.0067 157.825 32.0067C162.242 32.0067 165.826 28.4221 165.826 24.0049C165.826 19.5877 162.242 16.0032 157.825 16.0032ZM157.825 28.8032C155.171 28.8032 153.026 26.6581 153.026 24.0049C153.026 21.3518 155.171 19.2067 157.825 19.2067C160.478 19.2067 162.623 21.3589 162.623 24.0049C162.623 26.651 160.471 28.8032 157.825 28.8032Z" fill="white"></path><path d="M96.3788 16.0032H83.5788C82.6968 16.0032 81.9771 16.7229 81.9771 17.6049C81.9771 18.487 82.6968 19.2067 83.5788 19.2067H88.3771V30.4049C88.3771 31.287 89.0968 32.0067 89.9788 32.0067C90.8608 32.0067 91.5806 31.287 91.5806 30.4049V19.2067H96.3788C97.2608 19.2067 97.9806 18.487 97.9806 17.6049C97.9806 16.7229 97.2608 16.0032 96.3788 16.0032Z" fill="white"></path><path d="M147.261 16.0032H134.461C133.579 16.0032 132.859 16.7229 132.859 17.6049C132.859 18.487 133.579 19.2067 134.461 19.2067H139.259V30.4049C139.259 31.287 139.979 32.0067 140.861 32.0067C141.743 32.0067 142.463 31.287 142.463 30.4049V19.2067H147.261C148.143 19.2067 148.863 18.487 148.863 17.6049C148.863 16.7229 148.143 16.0032 147.261 16.0032Z" fill="white"></path><path d="M77.8139 20.8226C77.0024 20.3992 76.0781 20.1593 75.0902 20.1593H68.6902C68.4221 20.1593 68.2104 19.9476 68.2104 19.6794C68.2104 19.4113 68.4221 19.1996 68.6902 19.1996H76.2121C77.0942 19.1996 77.8139 18.4799 77.8139 17.5979C77.8139 16.7158 77.0942 15.9961 76.2121 15.9961H68.6902C66.8203 15.9961 65.275 17.3932 65.0421 19.1996C65.028 19.3125 65.0139 19.4325 65.0139 19.5524C65.0139 19.5948 65.0139 19.6371 65.0139 19.6794C65.0139 19.7218 65.0139 19.7641 65.0139 19.8065C65.0139 19.9264 65.028 20.0464 65.0421 20.1593C65.275 21.9657 66.8203 23.3628 68.6902 23.3628H75.0902C76.572 23.3628 77.7786 24.5553 77.8139 26.0301V26.1359C77.7857 27.6177 76.572 28.8032 75.0902 28.8032H66.6086C65.7266 28.8032 65.0068 29.5229 65.0068 30.4049C65.0068 31.2869 65.7266 32.0067 66.6086 32.0067H75.0902C76.071 32.0067 76.9954 31.7668 77.8139 31.3434C78.9006 30.7859 79.7896 29.8969 80.3541 28.8032C80.7775 27.9917 81.0174 27.0673 81.0174 26.0794C81.0174 25.0916 80.7775 24.1743 80.3541 23.3557C79.7896 22.2691 78.9006 21.38 77.8139 20.8155V20.8226Z" fill="white"></path></g><defs><clipPath id="clip0_1478_17785"><rect width="165.826" height="32.0137" fill="white"></rect></clipPath></defs>', 2)
  ]));
}
const CH = /* @__PURE__ */ Ut(yH, [["render", bH]]), wH = { class: "s-logo" }, kH = ["src"], SH = {
  key: 0,
  class: "s-item-group"
}, xH = {
  key: 1,
  class: "s-item-group"
}, PH = { class: "s-avater__border" }, $H = { id: "side_menu_background" }, _H = { class: "text-right" }, MH = { id: "side_menu_wrapper" }, VH = {
  key: 0,
  class: "side-menu-footer"
}, TH = {
  __name: "SHeader",
  props: {
    isLoggedIn: {
      type: Boolean,
      default: !1
    },
    userInfo: {
      type: Object,
      default: () => ({
        name: "-",
        picture: {}
      })
    },
    logoSrc: {
      type: String,
      default: null,
      description: "서비스 로고 이미지 주소"
    },
    serviceMenus: {
      type: Array,
      default: () => [],
      description: "서비스 메뉴의 items"
    },
    userMenus: {
      type: Array,
      default: () => [],
      description: "사용자 메뉴의 items (예: 나의 정보, 기업 정보, 로그아웃)"
    },
    showMenuBtn: {
      type: Boolean,
      default: !0
    },
    showMenu: {
      type: Boolean,
      default: !1
    },
    loginText: {
      type: String,
      default: "로그인"
    },
    joinText: {
      type: String,
      default: "회원가입"
    },
    teleportId: {
      type: String,
      default: "destination",
      description: "Teleport Id"
    },
    activeMenuCode: {
      type: String,
      default: "",
      description: "선택된 메뉴코드"
    },
    lang: {
      type: String,
      default: "ko"
    },
    logoStyle: {
      type: Object,
      default: () => ({
        height: "30px",
        paddingLeft: "20px"
      }),
      description: "로고 스타일 객체"
    },
    serviceBtnText: {
      type: String,
      default: "서비스"
    },
    loading: {
      type: Boolean,
      default: !1
    }
  },
  emits: [
    "click:menu",
    "click:log-in",
    "click:sign-up",
    "click:menu-item",
    "click:logo",
    "click:service-item"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, i = Y(n.showMenu), l = () => {
      i.value = !i.value, a("click:menu", i.value);
    }, r = () => {
      i.value = !1, a("click:menu", !1);
    }, s = (c) => {
      a("click:menu-item", c);
    }, o = (c) => {
      a("click:service-item", c);
    }, u = (c) => {
      var d;
      return ((d = n.lang) == null ? void 0 : d.toLowerCase()) === "en" ? c.menuNameEn || c.menuName : c.menuNameKr || c.menuName;
    };
    return pe(
      () => n.showMenu,
      (c, d) => {
        c !== d && (i.value = c);
      }
    ), (c, d) => {
      const f = Pe("v-icon"), h = Pe("v-btn"), m = Pe("v-app-bar-title"), g = Pe("v-img"), v = Pe("v-avatar"), y = Pe("v-app-bar"), b = Pe("v-list-item");
      return N(), ee(ge, null, [
        p(y, {
          class: "s-header",
          color: "#1C2536",
          height: 68,
          elevation: 0
        }, Xt({
          prepend: re(() => [
            ie("div", wH, [
              ie("a", {
                "href.prevent.stop": "#",
                onClick: d[0] || (d[0] = (C) => c.$emit("click:logo"))
              }, [
                d[5] || (d[5] = ie("span", { class: "d-none" }, "main-logo", -1)),
                e.logoSrc ? (N(), ee("img", {
                  key: 0,
                  class: "s-logo__img",
                  src: e.logoSrc,
                  alt: "logo",
                  style: Ot(e.logoStyle)
                }, null, 12, kH)) : (N(), Ce(CH, {
                  key: 1,
                  class: "s-logo__img"
                }))
              ])
            ]),
            p(m, {
              density: "compact",
              variant: "flat",
              size: "small",
              "background-color": "white"
            }, {
              default: re(() => [
                e.showMenuBtn ? (N(), Ce(h, {
                  key: 0,
                  class: Ie(["s-btn__menu", { "s-btn__menu--active": i.value }]),
                  text: e.serviceBtnText,
                  onClick: l
                }, {
                  prepend: re(() => [
                    p(f, {
                      class: "s-btn__menu__icon",
                      variant: "text",
                      density: "compact",
                      icon: "mdi-menu"
                    })
                  ]),
                  _: 1
                }, 8, ["class", "text"])) : de("", !0)
              ]),
              _: 1
            })
          ]),
          _: 2
        }, [
          e.loading ? void 0 : {
            name: "append",
            fn: re(() => [
              e.isLoggedIn ? (N(), ee("div", xH, [
                ke(c.$slots, "inner-append", {}, void 0, !0),
                p(X(hb), {
                  user: e.userInfo,
                  "menu-items": e.userMenus,
                  "class-name": { fontWhite: !0 },
                  "onClick:menuItem": s
                }, {
                  badge: re(() => [
                    p(v, null, {
                      default: re(() => {
                        var C;
                        return [
                          ie("div", PH, [
                            (C = e.userInfo.picture) != null && C.data ? (N(), Ce(X(mb), {
                              key: 0,
                              "lazy-src": "profile.svg",
                              "src-url": `data:image/${e.userInfo.picture.format};base64,${e.userInfo.picture.data}`
                            }, null, 8, ["src-url"])) : (N(), Ce(g, {
                              key: 1,
                              class: "s-img--default_profile"
                            }))
                          ])
                        ];
                      }),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["user", "menu-items"])
              ])) : (N(), ee("div", SH, [
                ie("a", {
                  class: "s-sign__btn",
                  onKeypress: d[1] || (d[1] = Fi($t((C) => c.$emit("click:log-in"), ["ctrl"]), ["i"])),
                  onClick: d[2] || (d[2] = $t((C) => c.$emit("click:log-in"), ["stop"]))
                }, xe(e.loginText), 33),
                ie("a", {
                  class: "s-sign__btn",
                  onKeypress: d[3] || (d[3] = Fi($t((C) => c.$emit("click:sign-up"), ["ctrl"]), ["i"])),
                  onClick: d[4] || (d[4] = $t((C) => c.$emit("click:sign-up"), ["stop"]))
                }, xe(e.joinText), 33)
              ]))
            ]),
            key: "0"
          }
        ]), 1024),
        ie("div", {
          class: Ie(["menu-back-ground", { show: i.value, hide: !i.value }])
        }, [
          ie("div", $H, [
            ie("div", _H, [
              p(f, {
                icon: "mdi-close",
                onClick: r
              })
            ]),
            ie("div", MH, [
              (N(!0), ee(ge, null, Ge(e.serviceMenus, (C, S) => (N(), ee(ge, null, [
                C.accessible ? (N(), Ce(b, {
                  key: S,
                  class: "side-menu",
                  active: C.menuCode === e.activeMenuCode,
                  title: u(C),
                  onClick: (x) => o(C)
                }, null, 8, ["active", "title", "onClick"])) : de("", !0)
              ], 64))), 256))
            ]),
            c.$slots["side-menu-footer"] ? (N(), ee("div", VH, [
              ke(c.$slots, "side-menu-footer", {}, void 0, !0)
            ])) : de("", !0)
          ])
        ], 2)
      ], 64);
    };
  }
}, LH = /* @__PURE__ */ Ut(TH, [["__scopeId", "data-v-99aba070"]]), QH = {}, AH = { class: "footer-wrapper" };
function DH(e, t) {
  const n = Pe("v-footer");
  return N(), ee("div", AH, [
    p(n, { class: "footer-contents" }, {
      default: re(() => t[0] || (t[0] = [
        Ee("Powered by STRATO Cloud Management Platform")
      ])),
      _: 1
    })
  ]);
}
const RH = /* @__PURE__ */ Ut(QH, [["render", DH], ["__scopeId", "data-v-018a6e7c"]]), IH = { class: "s-title-area__content" }, BH = { class: "s-title-area__title" }, ZH = {
  key: 0,
  class: "s-title-area__number"
}, EH = { class: "s-title-area__buttons button-wrapper" }, NH = {
  __name: "SSubHeader",
  props: {
    className: {
      type: String,
      default: "",
      description: "페이지타이틀의 custom class"
    },
    title: {
      type: String,
      required: !0
    },
    showCnt: {
      type: Boolean,
      required: !1,
      default: !0
    },
    listCnt: {
      type: Number,
      default: 0
    }
  },
  setup(e) {
    const t = e, n = k(() => {
      var a;
      return ((a = t.listCnt) == null ? void 0 : a.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")) || "0";
    });
    return (a, i) => (N(), ee("div", {
      class: Ie(["s-title-area", e.className])
    }, [
      ie("div", IH, [
        ie("div", BH, [
          Ee(xe(e.title) + " ", 1),
          ke(a.$slots, "title-append", {}, () => [
            e.showCnt ? (N(), ee("span", ZH, "(" + xe(n.value) + ")", 1)) : de("", !0)
          ], !0)
        ]),
        ie("div", EH, [
          ke(a.$slots, "default", {}, void 0, !0)
        ])
      ])
    ], 2));
  }
}, HH = /* @__PURE__ */ Ut(NH, [["__scopeId", "data-v-1c07246c"]]), jH = { class: "s-accordion-wrapper" }, zH = {
  __name: "SAccordionMenu",
  props: {
    title: {
      type: String,
      required: !0
    },
    titleBold: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = Y(null), n = Y(!1), a = Y("0px"), i = () => {
      n.value ? (a.value = `${t.value.scrollHeight}px`, requestAnimationFrame(() => {
        a.value = "0px", n.value = !1;
      })) : (a.value = `${t.value.scrollHeight}px`, n.value = !0);
    }, l = () => {
      n.value && (a.value = "auto");
    };
    return (r, s) => {
      const o = Pe("v-icon");
      return N(), ee("div", jH, [
        ie("div", {
          class: Ie(["title", { "title-bold": e.titleBold }])
        }, [
          Ee(xe(e.title) + " ", 1),
          p(o, {
            class: "float-right",
            style: { top: "10px" },
            icon: n.value ? "mdi-chevron-down" : "mdi-chevron-right",
            onClick: i
          }, null, 8, ["icon"])
        ], 2),
        ie("div", {
          ref_key: "accordion",
          ref: t,
          class: "s-accordion-contents",
          style: Ot({ height: a.value }),
          onTransitionend: l
        }, [
          ke(r.$slots, "default", {}, void 0, !0)
        ], 36)
      ]);
    };
  }
}, FH = /* @__PURE__ */ Ut(zH, [["__scopeId", "data-v-691469ff"]]), XH = { id: "s-navi" }, YH = { id: "s-menu-title-wrapper" }, WH = { id: "s-menu-title" }, qH = {
  key: 0,
  id: "project_select_wrapper"
}, UH = { class: "project_select" }, GH = {
  key: 1,
  class: "s-navi-inner-menu-title"
}, KH = {
  __name: "SNavi",
  props: {
    useProject: {
      type: Boolean,
      default: !1
    },
    projectList: {
      type: Array,
      default: () => []
    },
    selectedProject: {
      type: Object,
      default: () => {
      }
    },
    menuPath: {
      type: Object,
      default: () => ({
        menuUrl: "",
        menuName: "",
        menuNameKr: "",
        subMenus: []
      })
    },
    serviceName: {
      type: String,
      default: ""
    },
    dependencyTooltipMessage: {
      type: String,
      default: "프로젝트를 선택 해 주세요"
    },
    routerPath: {
      type: String,
      default: ""
    },
    firstMenuPath: {
      type: String,
      default: "",
      description: "Service Name 클릭 시 이동할 메뉴의 path"
    },
    lang: {
      type: String,
      default: "ko"
    },
    noProjectAllSelect: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["change:project", "click:service-name"],
  setup(e, { emit: t }) {
    const n = { projectName: "전체", projectId: 0 }, a = e, i = t, l = Y([]), r = k(() => a.noProjectAllSelect ? a.projectList : [{ ...n }, ...a.projectList]), s = (y) => {
      var b;
      return !a.useProject || a.useProject && (((b = a.selectedProject) == null ? void 0 : b.projectId) > 0 || y.dependency !== "PROJECT");
    }, o = (y) => {
      i("change:project", y);
    }, u = () => {
      if (a.firstMenuPath)
        try {
          const y = new URL(a.firstMenuPath);
          i("click:service-name", { path: y.pathname });
        } catch {
          i("click:service-name", { path: a.firstMenuPath });
        }
      else
        i("click:service-name", { path: "/" });
    }, c = (y) => {
      var b;
      return ((b = a.lang) == null ? void 0 : b.toLowerCase()) === "en" ? y.menuNameEn || y.menuName : y.menuNameKr || y.menuName;
    }, d = k(() => a.serviceName || c(a.menuPath)), f = (y) => {
      var b;
      return !y || !((b = a.selectedProject) != null && b.projectId) ? y : y.includes("/cluster/detail/") ? y.replace(/\/cluster\/detail\/\d+\//, `/cluster/detail/${a.selectedProject.projectId}/`) : y;
    }, h = (y, b) => {
      if (!y || !b) return !1;
      if (y === b) return !0;
      const C = (w) => w.replace(/^\/+|\/+$/g, "").split("/").filter(Boolean), S = C(y), x = C(b);
      return S.length !== x.length ? !1 : S.every((w, V) => {
        const _ = x[V];
        return w.startsWith(":") ? _ !== void 0 && _ !== "" : w === _;
      });
    }, m = (y, b) => {
      if (!y || !b) return !1;
      const C = (w) => w.replace(/^\/+|\/+$/g, "").split("/").filter(Boolean), S = C(y), x = C(b);
      return S.length >= x.length ? !1 : S.every((w, V) => {
        const _ = x[V];
        return w.startsWith(":") ? _ !== void 0 && _ !== "" : w === _;
      });
    };
    pe(
      () => a.routerPath,
      () => {
        var C;
        const y = ((C = a.menuPath) == null ? void 0 : C.subMenus) || [], b = a.routerPath;
        for (const S in y) {
          if (h(y[S].menuUrl, b) || m(y[S].menuUrl, b)) {
            l.value = [y[S].idx];
            break;
          }
          if (y[S].subMenus && y[S].subMenus.some(
            (w) => h(w.menuUrl, b) || m(w.menuUrl, b)
          )) {
            l.value = [y[S].idx];
            break;
          }
        }
      },
      { immediate: !0 }
    );
    const g = (y) => h(y, a.routerPath) || m(y, a.routerPath), v = (y, b) => {
      if (s(b)) {
        const C = y.currentTarget.querySelector(".s-navi-inner-menu-title");
        C && C.click();
      }
    };
    return (y, b) => {
      const C = Pe("v-select"), S = Pe("RouterLink"), x = Pe("v-list-item"), w = Pe("v-tooltip"), V = Pe("v-list-group"), _ = Pe("v-list");
      return N(), ee("div", XH, [
        ie("div", YH, [
          ie("a", {
            "href.stop": "#",
            onClick: u
          }, [
            ie("div", WH, xe(d.value), 1)
          ])
        ]),
        ke(y.$slots, "default", {}, () => [
          e.useProject ? (N(), ee("div", qH, [
            ie("div", UH, [
              p(C, {
                width: "238px",
                "model-value": e.selectedProject,
                variant: "outlined",
                density: "comfortable",
                items: r.value,
                "item-title": "projectName",
                "item-value": "projectId",
                label: "Select",
                "hide-details": "",
                "persistent-hint": "",
                "return-object": "",
                "single-line": "",
                "onUpdate:modelValue": o
              }, null, 8, ["model-value", "items"])
            ])
          ])) : de("", !0)
        ], !0),
        ie("div", {
          id: "s-menu-wrapper",
          class: Ie({ "with-project-select": e.useProject })
        }, [
          e.menuPath && e.menuPath.subMenus && e.menuPath.subMenus.length ? (N(), Ce(_, {
            key: 0,
            opened: l.value,
            "onUpdate:opened": b[0] || (b[0] = (O) => l.value = O),
            class: "navi-menu"
          }, {
            default: re(() => [
              (N(!0), ee(ge, null, Ge(e.menuPath.subMenus, (O) => (N(), Ce(V, {
                key: O.idx,
                value: O.idx
              }, Xt({
                default: re(() => [
                  (N(!0), ee(ge, null, Ge(O.subMenus, ($, P) => {
                    var M;
                    return N(), ee(ge, { key: P }, [
                      $.accessible ? (N(), Ce(x, {
                        key: 0,
                        class: Ie(["s-navi-inner-menu", {
                          disabled: !s($),
                          enabled: ((M = e.selectedProject) == null ? void 0 : M.projectId) > 0 || $.dependency !== "PROJECT"
                        }]),
                        value: $.idx,
                        "active-class": "menu-active",
                        active: g($.menuUrl),
                        "prepend-icon": "mdi-circle-small",
                        onClick: (T) => v(T, $)
                      }, {
                        title: re(() => [
                          s($) ? (N(), Ce(S, {
                            key: 0,
                            class: Ie(["s-navi-inner-menu-title", {
                              "router-link-active": g($.menuUrl),
                              "router-link-exact-active": h($.menuUrl, a.routerPath)
                            }]),
                            to: f($.menuUrl),
                            ref_for: !0,
                            ref: "menuLink"
                          }, {
                            default: re(() => [
                              Ee(xe(c($)), 1)
                            ]),
                            _: 2
                          }, 1032, ["to", "class"])) : (N(), ee("span", GH, [
                            Ee(xe(c($)) + " ", 1),
                            $.dependency === "PROJECT" ? (N(), Ce(w, {
                              key: 0,
                              activator: "parent",
                              location: "start"
                            }, {
                              default: re(() => [
                                Ee(xe(e.dependencyTooltipMessage), 1)
                              ]),
                              _: 1
                            })) : de("", !0)
                          ]))
                        ]),
                        _: 2
                      }, 1032, ["class", "value", "active", "onClick"])) : de("", !0)
                    ], 64);
                  }), 128))
                ]),
                _: 2
              }, [
                O.accessible ? {
                  name: "activator",
                  fn: re(({ props: $ }) => [
                    p(x, fe({ ref_for: !0 }, $, {
                      height: "50px",
                      "active-class": "menu-active",
                      active: g(O.menuUrl),
                      title: c(O),
                      "append-icon": !O.subMenus || O.subMenus.length === 0 ? "" : l.value.includes(O.idx) ? "mdi-chevron-up" : "mdi-chevron-down",
                      onClick: (P) => v(P, O)
                    }), Xt({ _: 2 }, [
                      !O.subMenus || O.subMenus.length === 0 ? {
                        name: "title",
                        fn: re(() => [
                          p(S, {
                            class: Ie(["navi-inner-menu-title", {
                              "router-link-active": g(O.menuUrl),
                              "router-link-exact-active": h(O.menuUrl, a.routerPath)
                            }]),
                            to: f(O.menuUrl)
                          }, {
                            default: re(() => [
                              Ee(xe(c(O)), 1)
                            ]),
                            _: 2
                          }, 1032, ["to", "class"])
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["active", "title", "append-icon", "onClick"])
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["value"]))), 128))
            ]),
            _: 1
          }, 8, ["opened"])) : de("", !0)
        ], 2)
      ]);
    };
  }
}, JH = /* @__PURE__ */ Ut(KH, [["__scopeId", "data-v-16d5bdaf"]]), ej = { class: "s-smart-search" }, tj = { class: "s-smart-search__top" }, nj = {
  key: 0,
  class: "s-smart-search__left"
}, aj = { class: "s-smart-search__input-wrapper" }, ij = {
  key: 1,
  class: "s-smart-search__right"
}, lj = { class: "s-smart-search__chips-wrapper" }, rj = {
  __name: "SSmartSearch",
  props: {
    headers: {
      type: Array,
      default: () => [],
      description: 'data table의 경우 header 값을 의미한다. 데이터 형태: { title: "", key: "" }'
    },
    excludeSearchHeaders: {
      type: Array,
      default: () => [],
      description: "검색에서 제외할 헤더 키 목록"
    },
    multiple: {
      type: Boolean,
      default: !0
    },
    placeholder: {
      type: String,
      default: "검색어를 입력하세요. (Key:Value)"
    },
    items: {
      type: Array,
      default: () => []
    },
    density: {
      type: String,
      default: "comfortable"
    },
    variant: {
      type: String,
      default: "outlined"
    },
    width: {
      type: [Number, String],
      default: 350
    },
    searchTag: {
      type: Boolean,
      default: !1,
      description: "tag 검색 기능을 사용할지에 대한 여부. true일 경우 items의 모든 tag 값들을 headers에 추가한다."
    },
    prependInnerIcon: {
      type: String,
      default: "mdi-magnify"
    },
    modelValue: {
      type: Array,
      default: () => []
    }
  },
  emits: ["update:model-value", "update:key", "update:target-item"],
  setup(e, { emit: t }) {
    const n = e, a = t, i = Y(null), l = Y(!1), r = Y(!1), s = Y(null), o = k({
      get: () => n.modelValue,
      set: (O) => a("update:model-value", Array.isArray(O) ? O : [])
    }), u = Y(null), c = zt({
      closeOnClick: !1,
      closeOnContentClick: !1
    }), d = Y(0), f = () => {
      i.value = null, l.value = !1, r.value = !1;
    }, h = (O) => {
      O || f(), i.value = O;
    }, m = (O) => {
      var P;
      const $ = /* @__PURE__ */ new Set();
      return (P = n.items) != null && P.length && n.items.forEach((M) => {
        var T;
        (T = M.tagList) != null && T.length && M.tagList.forEach((L) => {
          const A = L[O];
          A == null || A === "" || A === "-" ? $.add("-") : $.add(A);
        });
      }), Array.from($);
    }, g = (O, $) => {
      var M;
      const P = /* @__PURE__ */ new Map();
      return (M = n.items) != null && M.length && n.items.forEach((T) => {
        var L;
        (L = T.tagList) != null && L.length && T.tagList.forEach((A) => {
          const D = A[O], B = A[$], j = D == null || D === "" || D === "-" ? "-" : D, I = B == null || B === "" || B === "-" ? "-" : B, Z = P.get(j) || [];
          Z.push(I), P.set(j, Z);
        });
      }), Object.fromEntries(P);
    }, v = (O, $) => {
      const P = [], M = /* @__PURE__ */ new Set();
      return O.forEach((T) => {
        let L = T;
        T == null || T === "" || T === "-" ? L = "-" : (typeof T == "object" || Array.isArray(T)) && (L = JSON.stringify(T)), M.has(L) || (M.add(L), P.push({
          title: String(L),
          value: String(L),
          type: $
        }));
      }), P.sort((T, L) => {
        const A = String(T.title).toLowerCase(), D = String(L.title).toLowerCase();
        return A.localeCompare(D, "ko-KR");
      });
    }, y = k(() => {
      var $, P;
      let O = [];
      if (r.value) {
        const M = ($ = i.value) == null ? void 0 : $.split(":")[0];
        M && O.push({
          subheader: M,
          title: ""
        });
        const T = g("tagKey", "tagValue");
        return O = O.concat(
          v(T[M], "tag")
        ), O;
      }
      if (l.value) {
        if (!n.items.length)
          return [];
        const T = o.value.map((I) => I.key).includes(s.value);
        let L = [];
        if (T) {
          const I = /* @__PURE__ */ new Set();
          o.value.filter((R) => R.key === s.value).forEach((R) => I.add(R.order));
          const Z = (R) => {
            o.value.forEach((J) => {
              J.basedOnOrders && J.basedOnOrders.includes(R) && (I.has(J.order) || (I.add(J.order), Z(J.order)));
            });
          };
          I.forEach((R) => Z(R)), L = o.value.filter((R) => R.order === void 0 || R.order === null ? !0 : !I.has(R.order));
        } else
          L = o.value;
        const A = L.reduce((I, Z) => (I[Z.key] || (I[Z.key] = []), I[Z.key].push(Z.value), I), {}), D = Object.keys(A).length > 0 ? n.items.filter((I) => Object.keys(A).every((Z) => {
          const R = I[Z];
          return A[Z].some((F) => {
            if (F === "-")
              return R == null || R === "" || R === "-";
            const q = R == null ? "" : String(R), z = String(F);
            return q === z;
          });
        })) : n.items, B = /* @__PURE__ */ new Set();
        D.forEach((I) => {
          const Z = I[s.value];
          Z == null || Z === "" || Z === "-" ? B.add("-") : B.add(Z);
        });
        const j = (P = i.value) == null ? void 0 : P.split(":")[0];
        return j && O.push({
          subheader: j,
          title: ""
        }), O = O.concat(v(B)), O;
      }
      return O.push({ subheader: "속성", title: "" }), n.headers.forEach((M) => {
        M.title && !n.excludeSearchHeaders.includes(M.key) && O.push(M);
      }), n.searchTag && (O.push({ subheader: "태그", title: "" }), O = O.concat(
        v(m("tagKey"), "tag")
      )), O;
    }), b = (O, $, P) => {
      var A, D, B;
      const M = $.toLowerCase(), T = (M == null ? void 0 : M.split(":")) || [];
      let L = "";
      return P.raw.subheader ? !0 : ((T == null ? void 0 : T.length) > 1 ? L = T[1].trim().toLowerCase() : L = M.trim().toLowerCase(), typeof (P == null ? void 0 : P.value) == "string" ? ((A = P == null ? void 0 : P.value) == null ? void 0 : A.toLowerCase().indexOf(L.toLowerCase())) > -1 : ((B = (D = P == null ? void 0 : P.value) == null ? void 0 : D.value) == null ? void 0 : B.toLowerCase().indexOf(L.toLowerCase())) > -1);
    }, C = (O) => {
      var A, D, B;
      if (!O)
        return { result: !1, findTitle: "", findKey: "" };
      let $ = "", P = "";
      const M = (A = O.toString()) == null ? void 0 : A.split(":")[0].trim().toLowerCase(), T = [...n.headers];
      let L = !1;
      return L = T.some((j) => {
        const I = typeof j.title == typeof {} ? j.title.value : j.title, Z = typeof j.key == typeof {} ? j.key.value : j.key;
        return I.toLowerCase() === M ? ($ = I, P = Z, !0) : !1;
      }), L || (L = T.some((j) => {
        const I = typeof j.title == typeof {} ? j.title.value : j.title, Z = typeof j.key == typeof {} ? j.key.value : j.key;
        return I.toLowerCase().indexOf(M) > -1 && M.length >= 2 ? ($ = I, P = Z, !0) : !1;
      })), L || ($ = (D = O.toString()) == null ? void 0 : D.split(":")[0].trim(), P = (B = O.toString()) == null ? void 0 : B.split(":")[0].trim(), r.value = !0), { result: L, findTitle: $, findKey: P };
    }, S = (O) => {
      O || f();
    }, x = (O) => {
      const { findKey: $, findTitle: P } = C(O);
      s.value = $, a("update:key", $), i.value = `${P}:`, l.value = !0;
    }, w = (O, $, P, M) => {
      var I, Z, R;
      let T = "";
      if (!$)
        return;
      const L = ((I = i.value) == null ? void 0 : I.split(":")) || [], A = M || ($ == null ? void 0 : $.toString().trim());
      l.value ? T = L.length ? `${L[0]}: ${A}` : "" : T = L.length && L[0].trim() ? L[0] : $ == null ? void 0 : $.toString().trim();
      const D = ((Z = i.value) == null ? void 0 : Z.split(":")) || [], { findTitle: B, findKey: j } = C(D[0]);
      if (l.value && A) {
        if (A) {
          const F = o.value.map((Q) => Q.key).includes(j);
          let q = [];
          if (F) {
            const Q = o.value.find((W) => W.key === j);
            q = (Q == null ? void 0 : Q.basedOnOrders) || [];
          } else
            q = o.value.map((Q) => Q.order);
          const z = {
            title: B,
            value: A,
            // 선택한 options의 value 사용
            key: j,
            type: r.value ? "tag" : null,
            order: d.value++,
            // 순서 저장
            basedOnOrders: q
            // 이 조건이 의존하는 이전 조건들의 order
          };
          o.value.some(
            (Q) => Q.key === z.key && Q.value === z.value
          ) ? d.value-- : (o.value = [...o.value, z], a("update:target-item", z)), setTimeout(() => {
            c.closeOnClick = !1, c.closeOnContentClick = !1;
          }, 500), f();
          return;
        }
      } else {
        if (c.closeOnClick = !0, c.closeOnContentClick = !0, s.value = (R = n.headers.find((J) => J.title === $)) == null ? void 0 : R.key, l.value = !0, P === "tag" && (r.value = !0), T) {
          x(T);
          return;
        }
        setTimeout(() => {
          c.closeOnClick = !1, c.closeOnContentClick = !1;
        }, 500);
      }
      u.value && (u.value.search = "");
    }, V = () => {
      const O = o.value.map((P) => P.order), $ = {
        title: "미지정 태그",
        value: "-",
        key: "undefinedTag",
        type: "tag",
        order: d.value++,
        basedOnOrders: O
      };
      o.value = [...o.value, $], u.value && (u.value.search = "");
    }, _ = (O) => {
      const $ = o.value.slice();
      $.splice(O, 1), o.value = $;
    };
    return (O, $) => {
      const P = Pe("v-list-subheader"), M = Pe("v-list-item"), T = Pe("v-autocomplete"), L = Pe("v-chip"), A = Pe("v-chip-group");
      return N(), ee("div", ej, [
        ie("div", tj, [
          O.$slots.left ? (N(), ee("div", nj, [
            ke(O.$slots, "left", {}, void 0, !0)
          ])) : de("", !0),
          ie("div", aj, [
            p(T, {
              ref_key: "autoComp",
              ref: u,
              class: "s-smart-search__input",
              style: Ot({ width: e.width + "px" }),
              "closable-chips": "",
              multiple: e.multiple,
              density: e.density,
              variant: e.variant,
              items: y.value,
              search: i.value,
              "custom-filter": b,
              placeholder: e.placeholder,
              "menu-props": c,
              "hide-details": "",
              "prepend-inner-icon": e.prependInnerIcon,
              onInput: S,
              "onUpdate:search": h,
              onKeyup: Fi($t(w, ["stop"]), ["enter"])
            }, Xt({
              item: re(({ item: D }) => {
                var B;
                return [
                  D.raw.subheader ? (N(), ee(ge, { key: 0 }, [
                    p(P, { class: "s-list-subheader" }, {
                      default: re(() => [
                        Ee(xe(D.raw.subheader), 1)
                      ]),
                      _: 2
                    }, 1024),
                    $[1] || ($[1] = ie("hr", null, null, -1))
                  ], 64)) : (N(), Ce(M, {
                    key: 1,
                    title: (B = D == null ? void 0 : D.props) == null ? void 0 : B.title,
                    onClick: (j) => w(j, D == null ? void 0 : D.raw.title, D == null ? void 0 : D.raw.type, D == null ? void 0 : D.raw.value)
                  }, null, 8, ["title", "onClick"]))
                ];
              }),
              _: 2
            }, [
              e.searchTag ? {
                name: "append-item",
                fn: re(() => [
                  ke(O.$slots, "null-tag", {}, () => [
                    p(P, null, {
                      default: re(() => $[2] || ($[2] = [
                        Ee("미지정 태그 검색")
                      ])),
                      _: 1
                    }),
                    $[4] || ($[4] = ie("hr", null, null, -1)),
                    p(M, { onClick: V }, {
                      default: re(() => $[3] || ($[3] = [
                        Ee("미지정 태그")
                      ])),
                      _: 1
                    })
                  ], !0)
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["style", "multiple", "density", "variant", "items", "search", "placeholder", "menu-props", "prepend-inner-icon", "onKeyup"])
          ]),
          O.$slots.right ? (N(), ee("div", ij, [
            ke(O.$slots, "right", {}, void 0, !0)
          ])) : de("", !0)
        ]),
        Ct(ie("div", lj, [
          p(A, null, {
            default: re(() => [
              (N(!0), ee(ge, null, Ge(o.value, (D, B) => (N(), Ce(L, {
                key: "smart-search__value--" + D.title + "__" + D.value,
                closable: "",
                onMousedown: $[0] || ($[0] = $t(() => {
                }, ["prevent"])),
                "onClick:close": (j) => _(B)
              }, {
                default: re(() => [
                  ie("strong", null, xe(D.title), 1),
                  Ee(" : " + xe(D.value), 1)
                ]),
                _: 2
              }, 1032, ["onClick:close"]))), 128))
            ]),
            _: 1
          })
        ], 512), [
          [Dn, o.value.length]
        ])
      ]);
    };
  }
}, sj = /* @__PURE__ */ Ut(rj, [["__scopeId", "data-v-be406e10"]]);
var gb = typeof global == "object" && global && global.Object === Object && global, oj = typeof self == "object" && self && self.Object === Object && self, ri = gb || oj || Function("return this")(), Ia = ri.Symbol, pb = Object.prototype, uj = pb.hasOwnProperty, cj = pb.toString, mo = Ia ? Ia.toStringTag : void 0;
function dj(e) {
  var t = uj.call(e, mo), n = e[mo];
  try {
    e[mo] = void 0;
    var a = !0;
  } catch {
  }
  var i = cj.call(e);
  return a && (t ? e[mo] = n : delete e[mo]), i;
}
var fj = Object.prototype, hj = fj.toString;
function mj(e) {
  return hj.call(e);
}
var vj = "[object Null]", gj = "[object Undefined]", G9 = Ia ? Ia.toStringTag : void 0;
function ao(e) {
  return e == null ? e === void 0 ? gj : vj : G9 && G9 in Object(e) ? dj(e) : mj(e);
}
function Al(e) {
  return e != null && typeof e == "object";
}
var pj = "[object Symbol]";
function Ds(e) {
  return typeof e == "symbol" || Al(e) && ao(e) == pj;
}
function Bc(e, t) {
  for (var n = -1, a = e == null ? 0 : e.length, i = Array(a); ++n < a; )
    i[n] = t(e[n], n, e);
  return i;
}
var Ba = Array.isArray, K9 = Ia ? Ia.prototype : void 0, J9 = K9 ? K9.toString : void 0;
function yb(e) {
  if (typeof e == "string")
    return e;
  if (Ba(e))
    return Bc(e, yb) + "";
  if (Ds(e))
    return J9 ? J9.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var yj = /\s/;
function Oj(e) {
  for (var t = e.length; t-- && yj.test(e.charAt(t)); )
    ;
  return t;
}
var bj = /^\s+/;
function Cj(e) {
  return e && e.slice(0, Oj(e) + 1).replace(bj, "");
}
function el(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var e4 = NaN, wj = /^[-+]0x[0-9a-f]+$/i, kj = /^0b[01]+$/i, Sj = /^0o[0-7]+$/i, xj = parseInt;
function t4(e) {
  if (typeof e == "number")
    return e;
  if (Ds(e))
    return e4;
  if (el(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = el(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Cj(e);
  var n = kj.test(e);
  return n || Sj.test(e) ? xj(e.slice(2), n ? 2 : 8) : wj.test(e) ? e4 : +e;
}
function _1(e) {
  return e;
}
var Pj = "[object AsyncFunction]", $j = "[object Function]", _j = "[object GeneratorFunction]", Mj = "[object Proxy]";
function Ob(e) {
  if (!el(e))
    return !1;
  var t = ao(e);
  return t == $j || t == _j || t == Pj || t == Mj;
}
var Df = ri["__core-js_shared__"], n4 = function() {
  var e = /[^.]+$/.exec(Df && Df.keys && Df.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Vj(e) {
  return !!n4 && n4 in e;
}
var Tj = Function.prototype, Lj = Tj.toString;
function jr(e) {
  if (e != null) {
    try {
      return Lj.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var Qj = /[\\^$.*+?()[\]{}|]/g, Aj = /^\[object .+?Constructor\]$/, Dj = Function.prototype, Rj = Object.prototype, Ij = Dj.toString, Bj = Rj.hasOwnProperty, Zj = RegExp(
  "^" + Ij.call(Bj).replace(Qj, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Ej(e) {
  if (!el(e) || Vj(e))
    return !1;
  var t = Ob(e) ? Zj : Aj;
  return t.test(jr(e));
}
function Nj(e, t) {
  return e == null ? void 0 : e[t];
}
function zr(e, t) {
  var n = Nj(e, t);
  return Ej(n) ? n : void 0;
}
var z0 = zr(ri, "WeakMap"), a4 = Object.create, Hj = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!el(t))
      return {};
    if (a4)
      return a4(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function jj(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var zj = 800, Fj = 16, Xj = Date.now;
function Yj(e) {
  var t = 0, n = 0;
  return function() {
    var a = Xj(), i = Fj - (a - n);
    if (n = a, i > 0) {
      if (++t >= zj)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function Wj(e) {
  return function() {
    return e;
  };
}
var $d = function() {
  try {
    var e = zr(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), qj = $d ? function(e, t) {
  return $d(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Wj(t),
    writable: !0
  });
} : _1, Uj = Yj(qj);
function Gj(e, t) {
  for (var n = -1, a = e == null ? 0 : e.length; ++n < a && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function Kj(e, t, n, a) {
  for (var i = e.length, l = n + -1; ++l < i; )
    if (t(e[l], l, e))
      return l;
  return -1;
}
var Jj = 9007199254740991, ez = /^(?:0|[1-9]\d*)$/;
function Gm(e, t) {
  var n = typeof e;
  return t = t ?? Jj, !!t && (n == "number" || n != "symbol" && ez.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function tz(e, t, n) {
  t == "__proto__" && $d ? $d(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function M1(e, t) {
  return e === t || e !== e && t !== t;
}
var nz = Object.prototype, az = nz.hasOwnProperty;
function iz(e, t, n) {
  var a = e[t];
  (!(az.call(e, t) && M1(a, n)) || n === void 0 && !(t in e)) && tz(e, t, n);
}
var i4 = Math.max;
function lz(e, t, n) {
  return t = i4(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var a = arguments, i = -1, l = i4(a.length - t, 0), r = Array(l); ++i < l; )
      r[i] = a[t + i];
    i = -1;
    for (var s = Array(t + 1); ++i < t; )
      s[i] = a[i];
    return s[t] = n(r), jj(e, this, s);
  };
}
function rz(e, t) {
  return Uj(lz(e, t, _1), e + "");
}
var sz = 9007199254740991;
function Km(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= sz;
}
function V1(e) {
  return e != null && Km(e.length) && !Ob(e);
}
function l4(e, t, n) {
  if (!el(n))
    return !1;
  var a = typeof t;
  return (a == "number" ? V1(n) && Gm(t, n.length) : a == "string" && t in n) ? M1(n[t], e) : !1;
}
var oz = Object.prototype;
function bb(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || oz;
  return e === n;
}
function uz(e, t) {
  for (var n = -1, a = Array(e); ++n < e; )
    a[n] = t(n);
  return a;
}
var cz = "[object Arguments]";
function r4(e) {
  return Al(e) && ao(e) == cz;
}
var Cb = Object.prototype, dz = Cb.hasOwnProperty, fz = Cb.propertyIsEnumerable, Jm = r4(/* @__PURE__ */ function() {
  return arguments;
}()) ? r4 : function(e) {
  return Al(e) && dz.call(e, "callee") && !fz.call(e, "callee");
};
function hz() {
  return !1;
}
var wb = typeof exports == "object" && exports && !exports.nodeType && exports, s4 = wb && typeof module == "object" && module && !module.nodeType && module, mz = s4 && s4.exports === wb, o4 = mz ? ri.Buffer : void 0, vz = o4 ? o4.isBuffer : void 0, _d = vz || hz, gz = "[object Arguments]", pz = "[object Array]", yz = "[object Boolean]", Oz = "[object Date]", bz = "[object Error]", Cz = "[object Function]", wz = "[object Map]", kz = "[object Number]", Sz = "[object Object]", xz = "[object RegExp]", Pz = "[object Set]", $z = "[object String]", _z = "[object WeakMap]", Mz = "[object ArrayBuffer]", Vz = "[object DataView]", Tz = "[object Float32Array]", Lz = "[object Float64Array]", Qz = "[object Int8Array]", Az = "[object Int16Array]", Dz = "[object Int32Array]", Rz = "[object Uint8Array]", Iz = "[object Uint8ClampedArray]", Bz = "[object Uint16Array]", Zz = "[object Uint32Array]", Bt = {};
Bt[Tz] = Bt[Lz] = Bt[Qz] = Bt[Az] = Bt[Dz] = Bt[Rz] = Bt[Iz] = Bt[Bz] = Bt[Zz] = !0;
Bt[gz] = Bt[pz] = Bt[Mz] = Bt[yz] = Bt[Vz] = Bt[Oz] = Bt[bz] = Bt[Cz] = Bt[wz] = Bt[kz] = Bt[Sz] = Bt[xz] = Bt[Pz] = Bt[$z] = Bt[_z] = !1;
function Ez(e) {
  return Al(e) && Km(e.length) && !!Bt[ao(e)];
}
function T1(e) {
  return function(t) {
    return e(t);
  };
}
var kb = typeof exports == "object" && exports && !exports.nodeType && exports, Lo = kb && typeof module == "object" && module && !module.nodeType && module, Nz = Lo && Lo.exports === kb, Rf = Nz && gb.process, Rs = function() {
  try {
    var e = Lo && Lo.require && Lo.require("util").types;
    return e || Rf && Rf.binding && Rf.binding("util");
  } catch {
  }
}(), u4 = Rs && Rs.isTypedArray, Sb = u4 ? T1(u4) : Ez, Hz = Object.prototype, jz = Hz.hasOwnProperty;
function zz(e, t) {
  var n = Ba(e), a = !n && Jm(e), i = !n && !a && _d(e), l = !n && !a && !i && Sb(e), r = n || a || i || l, s = r ? uz(e.length, String) : [], o = s.length;
  for (var u in e)
    jz.call(e, u) && !(r && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    l && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    Gm(u, o))) && s.push(u);
  return s;
}
function xb(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var Fz = xb(Object.keys, Object), Xz = Object.prototype, Yz = Xz.hasOwnProperty;
function Wz(e) {
  if (!bb(e))
    return Fz(e);
  var t = [];
  for (var n in Object(e))
    Yz.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function ev(e) {
  return V1(e) ? zz(e) : Wz(e);
}
var qz = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Uz = /^\w*$/;
function tv(e, t) {
  if (Ba(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || Ds(e) ? !0 : Uz.test(e) || !qz.test(e) || t != null && e in Object(t);
}
var du = zr(Object, "create");
function Gz() {
  this.__data__ = du ? du(null) : {}, this.size = 0;
}
function Kz(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Jz = "__lodash_hash_undefined__", eF = Object.prototype, tF = eF.hasOwnProperty;
function nF(e) {
  var t = this.__data__;
  if (du) {
    var n = t[e];
    return n === Jz ? void 0 : n;
  }
  return tF.call(t, e) ? t[e] : void 0;
}
var aF = Object.prototype, iF = aF.hasOwnProperty;
function lF(e) {
  var t = this.__data__;
  return du ? t[e] !== void 0 : iF.call(t, e);
}
var rF = "__lodash_hash_undefined__";
function sF(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = du && t === void 0 ? rF : t, this;
}
function Mr(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
Mr.prototype.clear = Gz;
Mr.prototype.delete = Kz;
Mr.prototype.get = nF;
Mr.prototype.has = lF;
Mr.prototype.set = sF;
function oF() {
  this.__data__ = [], this.size = 0;
}
function L1(e, t) {
  for (var n = e.length; n--; )
    if (M1(e[n][0], t))
      return n;
  return -1;
}
var uF = Array.prototype, cF = uF.splice;
function dF(e) {
  var t = this.__data__, n = L1(t, e);
  if (n < 0)
    return !1;
  var a = t.length - 1;
  return n == a ? t.pop() : cF.call(t, n, 1), --this.size, !0;
}
function fF(e) {
  var t = this.__data__, n = L1(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function hF(e) {
  return L1(this.__data__, e) > -1;
}
function mF(e, t) {
  var n = this.__data__, a = L1(n, e);
  return a < 0 ? (++this.size, n.push([e, t])) : n[a][1] = t, this;
}
function ol(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
ol.prototype.clear = oF;
ol.prototype.delete = dF;
ol.prototype.get = fF;
ol.prototype.has = hF;
ol.prototype.set = mF;
var fu = zr(ri, "Map");
function vF() {
  this.size = 0, this.__data__ = {
    hash: new Mr(),
    map: new (fu || ol)(),
    string: new Mr()
  };
}
function gF(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Q1(e, t) {
  var n = e.__data__;
  return gF(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function pF(e) {
  var t = Q1(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function yF(e) {
  return Q1(this, e).get(e);
}
function OF(e) {
  return Q1(this, e).has(e);
}
function bF(e, t) {
  var n = Q1(this, e), a = n.size;
  return n.set(e, t), this.size += n.size == a ? 0 : 1, this;
}
function ul(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
ul.prototype.clear = vF;
ul.prototype.delete = pF;
ul.prototype.get = yF;
ul.prototype.has = OF;
ul.prototype.set = bF;
var CF = "Expected a function";
function nv(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(CF);
  var n = function() {
    var a = arguments, i = t ? t.apply(this, a) : a[0], l = n.cache;
    if (l.has(i))
      return l.get(i);
    var r = e.apply(this, a);
    return n.cache = l.set(i, r) || l, r;
  };
  return n.cache = new (nv.Cache || ul)(), n;
}
nv.Cache = ul;
var wF = 500;
function kF(e) {
  var t = nv(e, function(a) {
    return n.size === wF && n.clear(), a;
  }), n = t.cache;
  return t;
}
var SF = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, xF = /\\(\\)?/g, PF = kF(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(SF, function(n, a, i, l) {
    t.push(i ? l.replace(xF, "$1") : a || n);
  }), t;
});
function $F(e) {
  return e == null ? "" : yb(e);
}
function Pb(e, t) {
  return Ba(e) ? e : tv(e, t) ? [e] : PF($F(e));
}
function A1(e) {
  if (typeof e == "string" || Ds(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function av(e, t) {
  t = Pb(t, e);
  for (var n = 0, a = t.length; e != null && n < a; )
    e = e[A1(t[n++])];
  return n && n == a ? e : void 0;
}
function _F(e, t, n) {
  var a = e == null ? void 0 : av(e, t);
  return a === void 0 ? n : a;
}
function $b(e, t) {
  for (var n = -1, a = t.length, i = e.length; ++n < a; )
    e[i + n] = t[n];
  return e;
}
var c4 = Ia ? Ia.isConcatSpreadable : void 0;
function MF(e) {
  return Ba(e) || Jm(e) || !!(c4 && e && e[c4]);
}
function VF(e, t, n, a, i) {
  var l = -1, r = e.length;
  for (n || (n = MF), i || (i = []); ++l < r; ) {
    var s = e[l];
    n(s) ? $b(i, s) : i[i.length] = s;
  }
  return i;
}
var TF = xb(Object.getPrototypeOf, Object);
function LF() {
  this.__data__ = new ol(), this.size = 0;
}
function QF(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function AF(e) {
  return this.__data__.get(e);
}
function DF(e) {
  return this.__data__.has(e);
}
var RF = 200;
function IF(e, t) {
  var n = this.__data__;
  if (n instanceof ol) {
    var a = n.__data__;
    if (!fu || a.length < RF - 1)
      return a.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new ul(a);
  }
  return n.set(e, t), this.size = n.size, this;
}
function $i(e) {
  var t = this.__data__ = new ol(e);
  this.size = t.size;
}
$i.prototype.clear = LF;
$i.prototype.delete = QF;
$i.prototype.get = AF;
$i.prototype.has = DF;
$i.prototype.set = IF;
var _b = typeof exports == "object" && exports && !exports.nodeType && exports, d4 = _b && typeof module == "object" && module && !module.nodeType && module, BF = d4 && d4.exports === _b, f4 = BF ? ri.Buffer : void 0;
f4 && f4.allocUnsafe;
function ZF(e, t) {
  return e.slice();
}
function EF(e, t) {
  for (var n = -1, a = e == null ? 0 : e.length, i = 0, l = []; ++n < a; ) {
    var r = e[n];
    t(r, n, e) && (l[i++] = r);
  }
  return l;
}
function NF() {
  return [];
}
var HF = Object.prototype, jF = HF.propertyIsEnumerable, h4 = Object.getOwnPropertySymbols, zF = h4 ? function(e) {
  return e == null ? [] : (e = Object(e), EF(h4(e), function(t) {
    return jF.call(e, t);
  }));
} : NF;
function FF(e, t, n) {
  var a = t(e);
  return Ba(e) ? a : $b(a, n(e));
}
function F0(e) {
  return FF(e, ev, zF);
}
var X0 = zr(ri, "DataView"), Y0 = zr(ri, "Promise"), W0 = zr(ri, "Set"), m4 = "[object Map]", XF = "[object Object]", v4 = "[object Promise]", g4 = "[object Set]", p4 = "[object WeakMap]", y4 = "[object DataView]", YF = jr(X0), WF = jr(fu), qF = jr(Y0), UF = jr(W0), GF = jr(z0), Fa = ao;
(X0 && Fa(new X0(new ArrayBuffer(1))) != y4 || fu && Fa(new fu()) != m4 || Y0 && Fa(Y0.resolve()) != v4 || W0 && Fa(new W0()) != g4 || z0 && Fa(new z0()) != p4) && (Fa = function(e) {
  var t = ao(e), n = t == XF ? e.constructor : void 0, a = n ? jr(n) : "";
  if (a)
    switch (a) {
      case YF:
        return y4;
      case WF:
        return m4;
      case qF:
        return v4;
      case UF:
        return g4;
      case GF:
        return p4;
    }
  return t;
});
var KF = Object.prototype, JF = KF.hasOwnProperty;
function eX(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && JF.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var Md = ri.Uint8Array;
function iv(e) {
  var t = new e.constructor(e.byteLength);
  return new Md(t).set(new Md(e)), t;
}
function tX(e, t) {
  var n = iv(e.buffer);
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var nX = /\w*$/;
function aX(e) {
  var t = new e.constructor(e.source, nX.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var O4 = Ia ? Ia.prototype : void 0, b4 = O4 ? O4.valueOf : void 0;
function iX(e) {
  return b4 ? Object(b4.call(e)) : {};
}
function lX(e, t) {
  var n = iv(e.buffer);
  return new e.constructor(n, e.byteOffset, e.length);
}
var rX = "[object Boolean]", sX = "[object Date]", oX = "[object Map]", uX = "[object Number]", cX = "[object RegExp]", dX = "[object Set]", fX = "[object String]", hX = "[object Symbol]", mX = "[object ArrayBuffer]", vX = "[object DataView]", gX = "[object Float32Array]", pX = "[object Float64Array]", yX = "[object Int8Array]", OX = "[object Int16Array]", bX = "[object Int32Array]", CX = "[object Uint8Array]", wX = "[object Uint8ClampedArray]", kX = "[object Uint16Array]", SX = "[object Uint32Array]";
function xX(e, t, n) {
  var a = e.constructor;
  switch (t) {
    case mX:
      return iv(e);
    case rX:
    case sX:
      return new a(+e);
    case vX:
      return tX(e);
    case gX:
    case pX:
    case yX:
    case OX:
    case bX:
    case CX:
    case wX:
    case kX:
    case SX:
      return lX(e);
    case oX:
      return new a();
    case uX:
    case fX:
      return new a(e);
    case cX:
      return aX(e);
    case dX:
      return new a();
    case hX:
      return iX(e);
  }
}
function PX(e) {
  return typeof e.constructor == "function" && !bb(e) ? Hj(TF(e)) : {};
}
var $X = "[object Map]";
function _X(e) {
  return Al(e) && Fa(e) == $X;
}
var C4 = Rs && Rs.isMap, MX = C4 ? T1(C4) : _X, VX = "[object Set]";
function TX(e) {
  return Al(e) && Fa(e) == VX;
}
var w4 = Rs && Rs.isSet, LX = w4 ? T1(w4) : TX, Mb = "[object Arguments]", QX = "[object Array]", AX = "[object Boolean]", DX = "[object Date]", RX = "[object Error]", Vb = "[object Function]", IX = "[object GeneratorFunction]", BX = "[object Map]", ZX = "[object Number]", Tb = "[object Object]", EX = "[object RegExp]", NX = "[object Set]", HX = "[object String]", jX = "[object Symbol]", zX = "[object WeakMap]", FX = "[object ArrayBuffer]", XX = "[object DataView]", YX = "[object Float32Array]", WX = "[object Float64Array]", qX = "[object Int8Array]", UX = "[object Int16Array]", GX = "[object Int32Array]", KX = "[object Uint8Array]", JX = "[object Uint8ClampedArray]", eY = "[object Uint16Array]", tY = "[object Uint32Array]", Lt = {};
Lt[Mb] = Lt[QX] = Lt[FX] = Lt[XX] = Lt[AX] = Lt[DX] = Lt[YX] = Lt[WX] = Lt[qX] = Lt[UX] = Lt[GX] = Lt[BX] = Lt[ZX] = Lt[Tb] = Lt[EX] = Lt[NX] = Lt[HX] = Lt[jX] = Lt[KX] = Lt[JX] = Lt[eY] = Lt[tY] = !0;
Lt[RX] = Lt[Vb] = Lt[zX] = !1;
function Zc(e, t, n, a, i, l) {
  var r;
  if (r !== void 0)
    return r;
  if (!el(e))
    return e;
  var s = Ba(e);
  if (s)
    r = eX(e);
  else {
    var o = Fa(e), u = o == Vb || o == IX;
    if (_d(e))
      return ZF(e);
    if (o == Tb || o == Mb || u && !i)
      r = u ? {} : PX(e);
    else {
      if (!Lt[o])
        return i ? e : {};
      r = xX(e, o);
    }
  }
  l || (l = new $i());
  var c = l.get(e);
  if (c)
    return c;
  l.set(e, r), LX(e) ? e.forEach(function(h) {
    r.add(Zc(h, t, n, h, e, l));
  }) : MX(e) && e.forEach(function(h, m) {
    r.set(m, Zc(h, t, n, m, e, l));
  });
  var d = F0, f = s ? void 0 : d(e);
  return Gj(f || e, function(h, m) {
    f && (m = h, h = e[m]), iz(r, m, Zc(h, t, n, m, e, l));
  }), r;
}
var nY = 1, aY = 4;
function iY(e) {
  return Zc(e, nY | aY);
}
var lY = "__lodash_hash_undefined__";
function rY(e) {
  return this.__data__.set(e, lY), this;
}
function sY(e) {
  return this.__data__.has(e);
}
function Vd(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new ul(); ++t < n; )
    this.add(e[t]);
}
Vd.prototype.add = Vd.prototype.push = rY;
Vd.prototype.has = sY;
function oY(e, t) {
  for (var n = -1, a = e == null ? 0 : e.length; ++n < a; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function uY(e, t) {
  return e.has(t);
}
var cY = 1, dY = 2;
function Lb(e, t, n, a, i, l) {
  var r = n & cY, s = e.length, o = t.length;
  if (s != o && !(r && o > s))
    return !1;
  var u = l.get(e), c = l.get(t);
  if (u && c)
    return u == t && c == e;
  var d = -1, f = !0, h = n & dY ? new Vd() : void 0;
  for (l.set(e, t), l.set(t, e); ++d < s; ) {
    var m = e[d], g = t[d];
    if (a)
      var v = r ? a(g, m, d, t, e, l) : a(m, g, d, e, t, l);
    if (v !== void 0) {
      if (v)
        continue;
      f = !1;
      break;
    }
    if (h) {
      if (!oY(t, function(y, b) {
        if (!uY(h, b) && (m === y || i(m, y, n, a, l)))
          return h.push(b);
      })) {
        f = !1;
        break;
      }
    } else if (!(m === g || i(m, g, n, a, l))) {
      f = !1;
      break;
    }
  }
  return l.delete(e), l.delete(t), f;
}
function fY(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(a, i) {
    n[++t] = [i, a];
  }), n;
}
function hY(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(a) {
    n[++t] = a;
  }), n;
}
var mY = 1, vY = 2, gY = "[object Boolean]", pY = "[object Date]", yY = "[object Error]", OY = "[object Map]", bY = "[object Number]", CY = "[object RegExp]", wY = "[object Set]", kY = "[object String]", SY = "[object Symbol]", xY = "[object ArrayBuffer]", PY = "[object DataView]", k4 = Ia ? Ia.prototype : void 0, If = k4 ? k4.valueOf : void 0;
function $Y(e, t, n, a, i, l, r) {
  switch (n) {
    case PY:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case xY:
      return !(e.byteLength != t.byteLength || !l(new Md(e), new Md(t)));
    case gY:
    case pY:
    case bY:
      return M1(+e, +t);
    case yY:
      return e.name == t.name && e.message == t.message;
    case CY:
    case kY:
      return e == t + "";
    case OY:
      var s = fY;
    case wY:
      var o = a & mY;
      if (s || (s = hY), e.size != t.size && !o)
        return !1;
      var u = r.get(e);
      if (u)
        return u == t;
      a |= vY, r.set(e, t);
      var c = Lb(s(e), s(t), a, i, l, r);
      return r.delete(e), c;
    case SY:
      if (If)
        return If.call(e) == If.call(t);
  }
  return !1;
}
var _Y = 1, MY = Object.prototype, VY = MY.hasOwnProperty;
function TY(e, t, n, a, i, l) {
  var r = n & _Y, s = F0(e), o = s.length, u = F0(t), c = u.length;
  if (o != c && !r)
    return !1;
  for (var d = o; d--; ) {
    var f = s[d];
    if (!(r ? f in t : VY.call(t, f)))
      return !1;
  }
  var h = l.get(e), m = l.get(t);
  if (h && m)
    return h == t && m == e;
  var g = !0;
  l.set(e, t), l.set(t, e);
  for (var v = r; ++d < o; ) {
    f = s[d];
    var y = e[f], b = t[f];
    if (a)
      var C = r ? a(b, y, f, t, e, l) : a(y, b, f, e, t, l);
    if (!(C === void 0 ? y === b || i(y, b, n, a, l) : C)) {
      g = !1;
      break;
    }
    v || (v = f == "constructor");
  }
  if (g && !v) {
    var S = e.constructor, x = t.constructor;
    S != x && "constructor" in e && "constructor" in t && !(typeof S == "function" && S instanceof S && typeof x == "function" && x instanceof x) && (g = !1);
  }
  return l.delete(e), l.delete(t), g;
}
var LY = 1, S4 = "[object Arguments]", x4 = "[object Array]", Oc = "[object Object]", QY = Object.prototype, P4 = QY.hasOwnProperty;
function AY(e, t, n, a, i, l) {
  var r = Ba(e), s = Ba(t), o = r ? x4 : Fa(e), u = s ? x4 : Fa(t);
  o = o == S4 ? Oc : o, u = u == S4 ? Oc : u;
  var c = o == Oc, d = u == Oc, f = o == u;
  if (f && _d(e)) {
    if (!_d(t))
      return !1;
    r = !0, c = !1;
  }
  if (f && !c)
    return l || (l = new $i()), r || Sb(e) ? Lb(e, t, n, a, i, l) : $Y(e, t, o, n, a, i, l);
  if (!(n & LY)) {
    var h = c && P4.call(e, "__wrapped__"), m = d && P4.call(t, "__wrapped__");
    if (h || m) {
      var g = h ? e.value() : e, v = m ? t.value() : t;
      return l || (l = new $i()), i(g, v, n, a, l);
    }
  }
  return f ? (l || (l = new $i()), TY(e, t, n, a, i, l)) : !1;
}
function D1(e, t, n, a, i) {
  return e === t ? !0 : e == null || t == null || !Al(e) && !Al(t) ? e !== e && t !== t : AY(e, t, n, a, D1, i);
}
var DY = 1, RY = 2;
function IY(e, t, n, a) {
  var i = n.length, l = i;
  if (e == null)
    return !l;
  for (e = Object(e); i--; ) {
    var r = n[i];
    if (r[2] ? r[1] !== e[r[0]] : !(r[0] in e))
      return !1;
  }
  for (; ++i < l; ) {
    r = n[i];
    var s = r[0], o = e[s], u = r[1];
    if (r[2]) {
      if (o === void 0 && !(s in e))
        return !1;
    } else {
      var c = new $i(), d;
      if (!(d === void 0 ? D1(u, o, DY | RY, a, c) : d))
        return !1;
    }
  }
  return !0;
}
function Qb(e) {
  return e === e && !el(e);
}
function BY(e) {
  for (var t = ev(e), n = t.length; n--; ) {
    var a = t[n], i = e[a];
    t[n] = [a, i, Qb(i)];
  }
  return t;
}
function Ab(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function ZY(e) {
  var t = BY(e);
  return t.length == 1 && t[0][2] ? Ab(t[0][0], t[0][1]) : function(n) {
    return n === e || IY(n, e, t);
  };
}
function EY(e, t) {
  return e != null && t in Object(e);
}
function NY(e, t, n) {
  t = Pb(t, e);
  for (var a = -1, i = t.length, l = !1; ++a < i; ) {
    var r = A1(t[a]);
    if (!(l = e != null && n(e, r)))
      break;
    e = e[r];
  }
  return l || ++a != i ? l : (i = e == null ? 0 : e.length, !!i && Km(i) && Gm(r, i) && (Ba(e) || Jm(e)));
}
function HY(e, t) {
  return e != null && NY(e, t, EY);
}
var jY = 1, zY = 2;
function FY(e, t) {
  return tv(e) && Qb(t) ? Ab(A1(e), t) : function(n) {
    var a = _F(n, e);
    return a === void 0 && a === t ? HY(n, e) : D1(t, a, jY | zY);
  };
}
function XY(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function YY(e) {
  return function(t) {
    return av(t, e);
  };
}
function WY(e) {
  return tv(e) ? XY(A1(e)) : YY(e);
}
function Db(e) {
  return typeof e == "function" ? e : e == null ? _1 : typeof e == "object" ? Ba(e) ? FY(e[0], e[1]) : ZY(e) : WY(e);
}
function qY(e) {
  return function(t, n, a) {
    for (var i = -1, l = Object(t), r = a(t), s = r.length; s--; ) {
      var o = r[++i];
      if (n(l[o], o, l) === !1)
        break;
    }
    return t;
  };
}
var UY = qY();
function GY(e, t) {
  return e && UY(e, t, ev);
}
function KY(e, t) {
  return function(n, a) {
    if (n == null)
      return n;
    if (!V1(n))
      return e(n, a);
    for (var i = n.length, l = -1, r = Object(n); ++l < i && a(r[l], l, r) !== !1; )
      ;
    return n;
  };
}
var JY = KY(GY), Bf = function() {
  return ri.Date.now();
}, eW = "Expected a function", tW = Math.max, nW = Math.min;
function aW(e, t, n) {
  var a, i, l, r, s, o, u = 0, c = !1, d = !1, f = !0;
  if (typeof e != "function")
    throw new TypeError(eW);
  t = t4(t) || 0, el(n) && (c = !!n.leading, d = "maxWait" in n, l = d ? tW(t4(n.maxWait) || 0, t) : l, f = "trailing" in n ? !!n.trailing : f);
  function h(w) {
    var V = a, _ = i;
    return a = i = void 0, u = w, r = e.apply(_, V), r;
  }
  function m(w) {
    return u = w, s = setTimeout(y, t), c ? h(w) : r;
  }
  function g(w) {
    var V = w - o, _ = w - u, O = t - V;
    return d ? nW(O, l - _) : O;
  }
  function v(w) {
    var V = w - o, _ = w - u;
    return o === void 0 || V >= t || V < 0 || d && _ >= l;
  }
  function y() {
    var w = Bf();
    if (v(w))
      return b(w);
    s = setTimeout(y, g(w));
  }
  function b(w) {
    return s = void 0, f && a ? h(w) : (a = i = void 0, r);
  }
  function C() {
    s !== void 0 && clearTimeout(s), u = 0, a = o = i = s = void 0;
  }
  function S() {
    return s === void 0 ? r : b(Bf());
  }
  function x() {
    var w = Bf(), V = v(w);
    if (a = arguments, i = this, o = w, V) {
      if (s === void 0)
        return m(o);
      if (d)
        return clearTimeout(s), s = setTimeout(y, t), h(o);
    }
    return s === void 0 && (s = setTimeout(y, t)), r;
  }
  return x.cancel = C, x.flush = S, x;
}
function iW(e, t, n) {
  var a = e == null ? 0 : e.length;
  if (!a)
    return -1;
  var i = 0;
  return Kj(e, Db(t), i);
}
function lW(e, t) {
  var n = -1, a = V1(e) ? Array(e.length) : [];
  return JY(e, function(i, l, r) {
    a[++n] = t(i, l, r);
  }), a;
}
function rW(e, t) {
  return D1(e, t);
}
function sW(e, t) {
  var n = e.length;
  for (e.sort(t); n--; )
    e[n] = e[n].value;
  return e;
}
function oW(e, t) {
  if (e !== t) {
    var n = e !== void 0, a = e === null, i = e === e, l = Ds(e), r = t !== void 0, s = t === null, o = t === t, u = Ds(t);
    if (!s && !u && !l && e > t || l && r && o && !s && !u || a && r && o || !n && o || !i)
      return 1;
    if (!a && !l && !u && e < t || u && n && i && !a && !l || s && n && i || !r && i || !o)
      return -1;
  }
  return 0;
}
function uW(e, t, n) {
  for (var a = -1, i = e.criteria, l = t.criteria, r = i.length, s = n.length; ++a < r; ) {
    var o = oW(i[a], l[a]);
    if (o) {
      if (a >= s)
        return o;
      var u = n[a];
      return o * (u == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
function cW(e, t, n) {
  t.length ? t = Bc(t, function(l) {
    return Ba(l) ? function(r) {
      return av(r, l.length === 1 ? l[0] : l);
    } : l;
  }) : t = [_1];
  var a = -1;
  t = Bc(t, T1(Db));
  var i = lW(e, function(l, r, s) {
    var o = Bc(t, function(u) {
      return u(l);
    });
    return { criteria: o, index: ++a, value: l };
  });
  return sW(i, function(l, r) {
    return uW(l, r, n);
  });
}
var dW = rz(function(e, t) {
  if (e == null)
    return [];
  var n = t.length;
  return n > 1 && l4(e, t[0], t[1]) ? t = [] : n > 2 && l4(t[0], t[1], t[2]) && (t = [t[0]]), cW(e, VF(t), []);
});
const fW = { class: "s-smart-search" }, hW = { class: "s-smart-search__top" }, mW = {
  key: 0,
  class: "s-smart-search__left"
}, vW = { class: "s-smart-search__input-wrapper" }, gW = {
  key: 1,
  class: "s-smart-search__right"
}, pW = { class: "s-smart-search__chips-wrapper" }, yW = {
  __name: "SSmartSearchServer",
  props: {
    headers: {
      type: Array,
      default: () => [],
      description: 'data table의 경우 header 값을 의미한다. 데이터 형태: { title: "", key: "" }'
    },
    excludeSearchHeaders: {
      type: Array,
      default: () => [],
      description: "검색에서 제외할 헤더 키 목록"
    },
    multiple: {
      type: Boolean,
      default: !0
    },
    placeholder: {
      type: String,
      default: "검색어를 입력하세요. (Key:Value)"
    },
    density: {
      type: String,
      default: "default",
      description: "input 밀도"
    },
    variant: {
      type: String,
      default: "filled",
      description: "input 스타일"
    },
    width: {
      type: [Number, String],
      default: 350,
      description: "input 너비"
    },
    searchTag: {
      type: Boolean,
      default: !1,
      description: "tag 검색 기능을 사용할지에 대한 여부. true일 경우 items의 모든 tag 값들을 headers에 추가한다."
    },
    prependInnerIcon: {
      type: String,
      default: void 0,
      description: "prependInnerIcon 값"
    },
    modelValue: {
      type: Array,
      default: () => [],
      description: "선택된 값 배열"
    },
    valueItems: {
      type: Array,
      default: () => [],
      description: "서버에서 제공된 검색 대상이 되는 데이터 배열"
    },
    tagItems: {
      type: Array,
      default: () => [],
      description: "검색 대상이 되는 태그 배열"
    }
  },
  emits: ["update:model-value", "update:key", "update:target-item"],
  setup(e, { emit: t }) {
    const n = e, a = t, i = Y(null), l = Y(!1), r = Y(!1), s = Y(null), o = zt(n.modelValue), u = Y(null), c = zt({
      closeOnClick: !1,
      closeOnContentClick: !1
    }), d = () => {
      i.value = null, l.value = !1, r.value = !1;
    }, f = (O) => {
      O || d(), i.value = O;
    }, h = (O) => {
      var P;
      const $ = /* @__PURE__ */ new Set();
      return (P = n.tagItems) != null && P.length && n.tagItems.forEach((M) => {
        var T;
        (T = M.tagList) != null && T.length && M.tagList.forEach((L) => {
          const A = L[O];
          A == null || A === "" || A === "-" ? $.add("-") : $.add(A);
        });
      }), Array.from($);
    }, m = (O, $) => {
      var M;
      const P = /* @__PURE__ */ new Map();
      return (M = n.tagItems) != null && M.length && n.tagItems.forEach((T) => {
        var L;
        (L = T.tagList) != null && L.length && T.tagList.forEach((A) => {
          const D = A[O], B = A[$], j = D == null || D === "" || D === "-" ? "-" : D, I = B == null || B === "" || B === "-" ? "-" : B, Z = P.get(j) || [];
          Z.push(I), P.set(j, Z);
        });
      }), Object.fromEntries(P);
    }, g = (O, $) => {
      const P = [], M = /* @__PURE__ */ new Set();
      return O.forEach((T) => {
        let L = T;
        T == null || T === "" || T === "-" ? L = "-" : (typeof T == "object" || Array.isArray(T)) && (L = JSON.stringify(T)), M.has(L) || (M.add(L), P.push({
          title: String(L),
          value: String(L),
          type: $
        }));
      }), P;
    }, v = (O) => {
      if (O.length === 2 && (O[0].title === "Y" || O[0].title === "N"))
        return items.sort((M, T) => T.title.localeCompare(M.title));
      const $ = O.filter((M) => typeof M.title == "string"), P = O.filter((M) => typeof M.title == "number");
      return $.sort(
        (M, T) => M.title.localeCompare(T.title, void 0, { sensitivity: "base" })
      ), P.sort((M, T) => T.title - M.title), [...$, ...P];
    }, y = k(() => {
      var $, P;
      let O = [];
      if (r.value) {
        const M = ($ = i.value) == null ? void 0 : $.split(":")[0];
        M && O.push({
          subheader: M,
          title: ""
        });
        const T = m("tagKey", "tagValue");
        return O = O.concat(
          g(T[M], "tag")
        ), O;
      }
      if (l.value) {
        if (!n.valueItems.length)
          return [];
        const M = /* @__PURE__ */ new Set();
        n.valueItems.forEach((D) => {
          const B = D.value;
          B == null || B === "" || B === "-" ? M.add("-") : M.add(B);
        });
        const T = (P = i.value) == null ? void 0 : P.split(":")[0];
        T && O.push({
          subheader: T,
          title: ""
        }), console.log("setFilterDatas", M);
        const L = iY(M), A = v(g(L));
        return O = O.concat(A), O;
      }
      return O.push({ subheader: "속성", title: "" }), n.headers.forEach((M) => {
        M.align !== "d-none" && M.title && !n.excludeSearchHeaders.includes(M.key) && O.push(M);
      }), n.searchTag && (O.push({ subheader: "태그", title: "" }), O = O.concat(
        g(h("tagKey"), "tag")
      )), O;
    }), b = (O, $, P) => {
      var A, D, B;
      const M = $.toLowerCase(), T = (M == null ? void 0 : M.split(":")) || [];
      let L = "";
      return P.raw.subheader ? !0 : ((T == null ? void 0 : T.length) > 1 ? L = T[1].trim().toLowerCase() : L = M.trim().toLowerCase(), typeof (P == null ? void 0 : P.value) == "string" ? ((A = P == null ? void 0 : P.value) == null ? void 0 : A.toLowerCase().indexOf(L.toLowerCase())) > -1 : ((B = (D = P == null ? void 0 : P.value) == null ? void 0 : D.value) == null ? void 0 : B.toLowerCase().indexOf(L.toLowerCase())) > -1);
    }, C = (O) => {
      var L;
      if (!O)
        return { result: !1, findTitle: "", findKey: "" };
      let $ = "", P = "";
      O = (L = O.toString()) == null ? void 0 : L.split(":")[0].trim().toLowerCase();
      const M = n.headers;
      dW(M, "title");
      const T = M.some((A) => {
        const D = typeof A.title == typeof {} ? A.title.value : A.title, B = typeof A.key == typeof {} ? A.key.value : A.key;
        return D.toLowerCase() === O || D.toLowerCase().indexOf(O) > -1 ? ($ = D, P = B, A) : !1;
      });
      return T || ($ = O, P = O, r.value = !0), { result: T, findTitle: $, findKey: P };
    }, S = (O) => {
      O || d();
    }, x = (O) => {
      const { findKey: $, findTitle: P } = C(O);
      s.value = $, a("update:key", $), i.value = `${P}:`, l.value = !0;
    }, w = (O, $, P, M) => {
      var I, Z, R;
      console.log(O.key, $, P, M);
      let T = "";
      if (!$)
        return;
      const L = ((I = i.value) == null ? void 0 : I.split(":")) || [], A = M || ($ == null ? void 0 : $.toString().trim());
      l.value ? T = L.length ? `${L[0]}: ${A}` : "" : T = L.length && L[0].trim() ? L[0] : $ == null ? void 0 : $.toString().trim();
      const D = ((Z = i.value) == null ? void 0 : Z.split(":")) || [], { findTitle: B, findKey: j } = C(D[0]);
      if (l.value && A) {
        if (A) {
          const J = {
            title: B,
            value: A,
            // 선택한 options의 value 사용
            key: j,
            type: r.value ? "tag" : null
          };
          o.push(J), a("update:model-value", o), a("update:target-item", J), setTimeout(() => {
            c.closeOnClick = !1, c.closeOnContentClick = !1;
          }, 500), d();
          return;
        }
      } else {
        if (c.closeOnClick = !0, c.closeOnContentClick = !0, s.value = (R = n.headers.find((J) => J.title === $)) == null ? void 0 : R.key, l.value = !0, P === "tag" && (r.value = !0), T) {
          x(T);
          return;
        }
        setTimeout(() => {
          c.closeOnClick = !1, c.closeOnContentClick = !1;
        }, 500);
      }
      u.value && (u.value.search = "");
    }, V = () => {
      o.push({ title: "미지정 태그", value: "-", key: "undefinedTag", type: "tag" }), a("update:model-value", o), u.value && (u.value.search = "");
    }, _ = (O) => {
      o.splice(O, 1), a("update:model-value", o);
    };
    return (O, $) => {
      const P = Pe("v-list-subheader"), M = Pe("v-list-item"), T = Pe("v-autocomplete"), L = Pe("v-chip"), A = Pe("v-chip-group");
      return N(), ee("div", fW, [
        ie("div", hW, [
          O.$slots.left ? (N(), ee("div", mW, [
            ke(O.$slots, "left", {}, void 0, !0)
          ])) : de("", !0),
          ie("div", vW, [
            p(T, {
              ref_key: "autoComp",
              ref: u,
              class: "s-smart-search__input",
              style: Ot({ width: e.width + "px" }),
              "closable-chips": "",
              multiple: e.multiple,
              density: e.density,
              variant: e.variant,
              items: y.value,
              search: i.value,
              "custom-filter": b,
              placeholder: e.placeholder,
              "menu-props": c,
              "hide-details": "",
              "prepend-inner-icon": e.prependInnerIcon,
              onInput: S,
              "onUpdate:search": f,
              onKeyup: Fi($t(w, ["stop"]), ["enter"])
            }, Xt({
              item: re(({ item: D }) => {
                var B;
                return [
                  D.raw.subheader ? (N(), ee(ge, { key: 0 }, [
                    p(P, { class: "s-list-subheader" }, {
                      default: re(() => [
                        Ee(xe(D.raw.subheader), 1)
                      ]),
                      _: 2
                    }, 1024),
                    $[1] || ($[1] = ie("hr", null, null, -1))
                  ], 64)) : (N(), Ce(M, {
                    key: 1,
                    title: (B = D == null ? void 0 : D.props) == null ? void 0 : B.title,
                    onClick: (j) => w(j, D == null ? void 0 : D.raw.title, D == null ? void 0 : D.raw.type, D == null ? void 0 : D.raw.value)
                  }, null, 8, ["title", "onClick"]))
                ];
              }),
              _: 2
            }, [
              e.searchTag ? {
                name: "append-item",
                fn: re(() => [
                  ke(O.$slots, "null-tag", {}, () => [
                    p(P, null, {
                      default: re(() => $[2] || ($[2] = [
                        Ee("미지정 태그 검색")
                      ])),
                      _: 1
                    }),
                    $[4] || ($[4] = ie("hr", null, null, -1)),
                    p(M, { onClick: V }, {
                      default: re(() => $[3] || ($[3] = [
                        Ee("미지정 태그")
                      ])),
                      _: 1
                    })
                  ], !0)
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["style", "multiple", "density", "variant", "items", "search", "placeholder", "menu-props", "prepend-inner-icon", "onKeyup"])
          ]),
          O.$slots.right ? (N(), ee("div", gW, [
            ke(O.$slots, "right", {}, void 0, !0)
          ])) : de("", !0)
        ]),
        Ct(ie("div", pW, [
          p(A, null, {
            default: re(() => [
              (N(!0), ee(ge, null, Ge(o, (D, B) => (N(), Ce(L, {
                key: "smart-search__value--" + D.title + "__" + D.value,
                closable: "",
                onMousedown: $[0] || ($[0] = $t(() => {
                }, ["prevent"])),
                "onClick:close": (j) => _(B)
              }, {
                default: re(() => [
                  ie("strong", null, xe(D.title), 1),
                  Ee(" : " + xe(D.value), 1)
                ]),
                _: 2
              }, 1032, ["onClick:close"]))), 128))
            ]),
            _: 1
          })
        ], 512), [
          [Dn, o.length]
        ])
      ]);
    };
  }
}, OW = /* @__PURE__ */ Ut(yW, [["__scopeId", "data-v-9726c85b"]]), bW = { class: "progress-stages" }, CW = { class: "d-flex align-center" }, wW = { class: "stage-title" }, kW = { class: "sub-stages" }, SW = { class: "d-flex align-center justify-space-between" }, xW = {
  key: 0,
  class: "sub-stage-children"
}, PW = {
  __name: "SProgressStages",
  props: {
    stages: {
      type: Array,
      required: !0
    }
  },
  setup(e) {
    const t = Y([]), n = (o) => {
      const u = t.value.indexOf(o);
      u === -1 ? t.value.push(o) : t.value.splice(u, 1);
    }, a = (o) => ({
      "stage-header--completed": o.status === "completed",
      "stage-header--in-progress": o.status === "in-progress",
      "stage-header--pending": o.status === "pending",
      "stage-header--delayed": o.status === "delayed"
    }), i = (o) => ({
      "sub-stage-item--completed": o.status === "completed",
      "sub-stage-item--in-progress": o.status === "in-progress",
      "sub-stage-item--pending": o.status === "pending",
      "sub-stage-item--delayed": o.status === "delayed"
    }), l = (o) => {
      switch (o) {
        case "completed":
          return "mdi-check-circle";
        case "in-progress":
          return "mdi-progress-clock";
        default:
          return "mdi-circle-outline";
      }
    }, r = (o) => {
      switch (o) {
        case "completed":
          return "success";
        case "in-progress":
          return "primary";
        default:
          return "grey";
      }
    }, s = (o) => {
      switch (o) {
        case "completed":
          return "#00BA88";
        case "in-progress":
          return "#1297F2";
        default:
          return "#6C6C6C";
      }
    };
    return (o, u) => {
      const c = Pe("v-icon"), d = Pe("v-expand-transition");
      return N(), ee("div", bW, [
        (N(!0), ee(ge, null, Ge(e.stages, (f, h) => (N(), ee("div", {
          key: h,
          class: "stage-item"
        }, [
          ie("div", {
            class: Ie(["stage-header", a(f)])
          }, [
            ie("div", CW, [
              p(c, {
                icon: l(f.status),
                color: r(f.status),
                size: "small",
                class: "mr-2"
              }, null, 8, ["icon", "color"]),
              ie("span", wW, xe(f.title), 1)
            ])
          ], 2),
          ie("div", kW, [
            (N(!0), ee(ge, null, Ge(f.subStages, (m, g) => {
              var v;
              return N(), ee("div", {
                key: `${h}-${g}`,
                class: Ie(["sub-stage-item", i(m)])
              }, [
                ie("div", SW, [
                  ie("span", {
                    style: Ot({ color: s(m.status) })
                  }, xe(m.title), 5),
                  (v = m.children) != null && v.length ? (N(), Ce(c, {
                    key: 0,
                    icon: t.value.includes(`${h}-${g}`) ? "mdi-chevron-up" : "mdi-chevron-down",
                    size: "small",
                    onClick: $t((y) => n(`${h}-${g}`), ["stop"])
                  }, null, 8, ["icon", "onClick"])) : de("", !0)
                ]),
                p(d, null, {
                  default: re(() => {
                    var y;
                    return [
                      t.value.includes(`${h}-${g}`) && ((y = m.children) != null && y.length) ? (N(), ee("div", xW, [
                        (N(!0), ee(ge, null, Ge(m.children, (b, C) => (N(), ee("div", {
                          key: C,
                          class: Ie(["sub-stage-child", i(b)])
                        }, xe(b.title), 3))), 128))
                      ])) : de("", !0)
                    ];
                  }),
                  _: 2
                }, 1024)
              ], 2);
            }), 128))
          ])
        ]))), 128))
      ]);
    };
  }
}, $W = /* @__PURE__ */ Ut(PW, [["__scopeId", "data-v-23d6b697"]]), _W = { class: "s-notification__header-box" }, MW = ["onMouseenter", "onClick", "onKeyup"], VW = { class: "s-notification__prefix" }, TW = { class: "s-notification__title-wrapper" }, LW = { class: "title--left" }, QW = { class: "s-notification__title" }, AW = { class: "created" }, DW = { class: "s-notification__message-box" }, RW = { class: "s-notification__message" }, IW = { class: "s-notification__delete-box" }, BW = ["onClick"], ZW = { class: "s-notification__additional-box" }, EW = {
  key: 1,
  class: "s-notification-no-item"
}, NW = {
  __name: "SNotification",
  props: {
    notificationName: {
      type: String,
      default: "Notifications"
    },
    items: {
      type: Array,
      default: () => []
    },
    totalCnt: {
      type: Number,
      default: 100
    },
    allMessageText: {
      type: String,
      default: "모든 알림 보기"
    },
    noItemText: {
      type: String,
      default: "알림 내역이 없습니다."
    },
    languageCode: {
      type: String,
      default: "ko"
    }
  },
  emits: ["click:delete", "click:content", "click:all-message"],
  setup(e, { emit: t }) {
    const n = t, a = e, i = Y(!1), l = Y(""), r = k(() => (m) => m), s = (m) => {
      switch (m.notificationType) {
        case "SUCCESS":
          return "mdi-check-circle";
        case "ERROR":
          return "mdi-close-octagon";
        default:
          return "mdi-alert-circle";
      }
    }, o = () => {
      i.value = !0;
    }, u = (m) => {
      l.value = m;
    }, c = (m) => {
      n("click:content", m);
    }, d = (m) => {
      n("click:delete", m);
    }, f = (m, g) => {
      if (a.languageCode === "en") {
        const v = `${g}En`;
        return m[v] || m[g];
      }
      return m[g];
    }, h = () => {
      n("click:all-message");
    };
    return (m, g) => {
      const v = Pe("v-icon");
      return N(), ee("div", {
        class: Ie(["s-notification", i.value ? "more" : ""])
      }, [
        ie("div", _W, xe(e.notificationName), 1),
        e.items.length ? (N(), ee(ge, { key: 0 }, [
          ie("div", {
            class: Ie(["s-notification__contents-box", i.value ? "more" : ""])
          }, [
            (N(!0), ee(ge, null, Ge(e.items, (y) => (N(), ee("div", {
              class: "s-notification__content",
              key: y.idx,
              onMouseenter: (b) => u(y.notificationIdx),
              onMouseleave: g[0] || (g[0] = (b) => l.value = ""),
              onClick: (b) => c(y),
              onKeyup: Fi((b) => c(y), ["enter"])
            }, [
              ie("div", VW, [
                p(v, null, {
                  default: re(() => [
                    Ee(xe(s(y)), 1)
                  ]),
                  _: 2
                }, 1024)
              ]),
              ie("div", TW, [
                ie("div", LW, [
                  ie("div", QW, [
                    ie("span", null, xe(f(y, "msgTitle")), 1),
                    ie("span", AW, xe(r.value(y.createdAt) || "-"), 1)
                  ]),
                  ie("div", DW, [
                    ie("div", RW, [
                      ie("div", null, [
                        ie("span", null, xe(f(y, "msgContent")), 1)
                      ])
                    ]),
                    ie("div", IW, [
                      l.value === y.notificationIdx ? (N(), ee("div", {
                        key: 0,
                        class: "s-notification__delete-wrapper",
                        onClick: $t((b) => d(y), ["stop"])
                      }, [
                        p(v, {
                          class: "s-notification__delete-icon",
                          contain: ""
                        }, {
                          default: re(() => g[1] || (g[1] = [
                            Ee("mdi-close")
                          ])),
                          _: 1
                        })
                      ], 8, BW)) : de("", !0)
                    ])
                  ]),
                  ie("div", ZW, [
                    ie("p", null, xe(f(y, "msgAdditional")), 1)
                  ])
                ])
              ])
            ], 40, MW))), 128))
          ], 2),
          i.value ? de("", !0) : (N(), ee("div", {
            key: 0,
            class: "s-notification__footer-box",
            onClick: o,
            onKeypress: o
          }, " ... ", 32)),
          i.value && e.items.length > e.totalCnt - 1 ? (N(), ee("div", {
            key: 1,
            class: "s-notification__footer-box",
            onClick: h,
            onKeypress: h
          }, xe(e.allMessageText) + " > ", 33)) : de("", !0)
        ], 64)) : (N(), ee("div", EW, xe(e.noItemText), 1))
      ], 2);
    };
  }
}, HW = { class: "s-filter-select__filter" }, jW = { style: { "max-height": "350px", "overflow-y": "auto" } }, zW = {
  __name: "SFilterSelect",
  props: {
    itemTitle: {
      type: String,
      default: ""
    },
    itemValue: {
      type: String,
      default: ""
    },
    items: {
      type: Array,
      default: () => []
    },
    label: {
      type: String,
      default: ""
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    displayText: {
      type: String,
      default: ""
    },
    hasNullValue: {
      type: Boolean,
      default: !1
    },
    nullTitle: {
      type: String,
      default: "Value is NULL"
    },
    nullValue: {
      type: String,
      default: "NULL"
    },
    density: {
      type: String,
      default: "default"
    },
    variant: {
      type: String,
      default: "filled"
    },
    hideDetails: {
      type: Boolean,
      default: !1
    },
    placeholder: {
      type: String,
      default: "검색"
    },
    width: {
      type: [String, Number],
      default: 316
    },
    searchByValue: {
      type: Boolean,
      default: !1,
      description: "value(ID) 값으로도 검색할지 여부"
    }
  },
  emits: ["update:model-value"],
  setup(e, { emit: t }) {
    const n = e, a = t, i = Y(""), l = Y([]), r = Y([]), s = Y(!1), o = () => {
      let C = !1;
      r.value.length && (C = r.value.length === l.value.length), s.value = C;
    };
    pe(
      () => n.items,
      () => {
        i.value ? c(i.value) : (l.value = n.items.map((C) => C[n.itemValue] === null ? {
          ...C,
          [n.itemTitle]: n.nullTitle,
          [n.itemValue]: n.nullValue
        } : C), o());
      },
      {
        immediate: !0
      }
    );
    const u = () => {
      const C = f(n.modelValue);
      n.hasNullValue ? r.value = C.filter((S) => S === n.nullValue ? i.value ? n.nullTitle.toLowerCase().includes(i.value.trim().toLowerCase()) : !0 : l.value.map((w) => w[n.itemValue]).includes(S)) : r.value = C.filter((S) => l.value.map((w) => w[n.itemValue]).includes(S));
    }, c = (C) => {
      const S = (C || "").trim();
      if (S) {
        const x = S.toLowerCase();
        l.value = n.items.map((w) => w[n.itemValue] === null ? {
          ...w,
          [n.itemTitle]: n.nullTitle,
          [n.itemValue]: n.nullValue
        } : w).filter((w) => {
          const V = w[n.itemTitle], _ = w[n.itemValue];
          return V === n.nullTitle || V === n.nullValue && _ === n.nullValue ? n.hasNullValue ? n.nullTitle.toLowerCase().includes(x) : !1 : !!(V && V !== n.nullValue && String(V).toLowerCase().includes(x) || n.searchByValue && _ && _ !== n.nullValue && String(_).toLowerCase().includes(x));
        }), u();
      } else
        l.value = n.items.map((x) => x[n.itemValue] === null ? {
          ...x,
          [n.itemTitle]: n.nullTitle,
          [n.itemValue]: n.nullValue
        } : x), u();
      o();
    }, d = (C) => {
      const S = C ?? "";
      i.value = S, c(S);
    }, f = (C) => n.hasNullValue ? C.map((S) => S === null ? n.nullValue : S) : C;
    pe(
      () => n.modelValue,
      () => {
        n.modelValue.length ? r.value = f(n.modelValue) : r.value = [], o();
      },
      {
        immediate: !0
      }
    );
    const h = (C) => {
      const S = new Map(
        l.value.map((x) => [x[n.itemValue], x])
      );
      r.value = C.filter((x) => S.has(x) || x === n.nullValue);
    }, m = k(() => r.value.length > 0), g = (C) => C.map((S) => S === n.nullValue ? null : S), v = () => {
      const C = new Set(r.value);
      if (s.value)
        l.value.forEach((x) => {
          const w = x[n.itemValue];
          w === n.nullValue || w === null ? (C.delete(n.nullValue), C.delete(null)) : C.delete(w);
        });
      else
        try {
          l.value.forEach((x) => {
            const w = x[n.itemValue];
            w === n.nullValue || w === null ? C.add(n.nullValue) : w && C.add(w);
          });
        } catch (x) {
          console.warn(x);
        }
      const S = Array.from(C);
      h(S), a("update:model-value", g(S));
    }, y = (C) => {
      const S = [...r.value], x = S.indexOf(C);
      x > -1 ? S.splice(x, 1) : S.push(C), h(S), a("update:model-value", g(S));
    }, b = (C) => {
      const S = C[n.itemTitle], x = C[n.itemValue];
      return n.searchByValue && x && S !== x ? `${S} (${x})` : S;
    };
    return (C, S) => {
      const x = Pe("v-btn"), w = Pe("v-tooltip"), V = Pe("v-text-field"), _ = Pe("v-divider"), O = Pe("v-checkbox-btn"), $ = Pe("v-list-item-action"), P = Pe("v-list-item"), M = Pe("v-list-item-title"), T = Pe("v-list"), L = Pe("v-menu");
      return N(), Ce(L, {
        class: "s-filter-select",
        "close-on-content-click": !1
      }, {
        activator: re(({ props: A, isActive: D }) => [
          p(w, {
            text: e.displayText,
            location: "end"
          }, {
            activator: re(({ props: B }) => [
              p(x, fe({ ...A, ...B }, {
                width: e.width,
                class: "s-filter-select__button",
                variant: "outlined",
                density: e.density,
                "append-icon": D ? "mdi-menu-up" : "mdi-menu-down"
              }), {
                default: re(() => [
                  Ee(xe(e.displayText), 1)
                ]),
                _: 2
              }, 1040, ["width", "density", "append-icon"])
            ]),
            _: 2
          }, 1032, ["text"])
        ]),
        default: re(() => [
          p(T, {
            "select-strategy": "classic",
            density: e.density,
            "min-width": "360px"
          }, {
            default: re(() => [
              ie("div", HW, [
                p(V, {
                  class: "s-input__inner my-1 pl-3",
                  density: e.density,
                  variant: "plain",
                  "hide-details": "",
                  placeholder: e.placeholder,
                  "model-value": i.value,
                  "onUpdate:modelValue": d,
                  "prepend-icon": "mdi-filter"
                }, null, 8, ["density", "placeholder", "model-value"]),
                p(_, { class: "mb-1" }),
                p(P, {
                  title: i.value ? `필터링 된 검색 ${l.value.length} 건` : "전체 검색",
                  density: e.density,
                  onClick: v
                }, {
                  prepend: re(() => [
                    p($, { start: "" }, {
                      default: re(() => [
                        p(O, {
                          class: "s-filter-select__checkbox-btn",
                          indeterminate: m.value && !s.value,
                          "model-value": s.value,
                          density: e.density
                        }, null, 8, ["indeterminate", "model-value", "density"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["title", "density"]),
                p(_, { class: "my-1" })
              ]),
              ie("div", jW, [
                (N(!0), ee(ge, null, Ge(l.value, (A) => (N(), ee(ge, {
                  key: A[n.itemValue]
                }, [
                  n.hasNullValue && [null, n.nullValue].includes(A[n.itemValue]) ? (N(), Ce(P, {
                    key: 0,
                    active: r.value.includes(n.nullValue),
                    density: e.density,
                    onClick: S[0] || (S[0] = (D) => y(n.nullValue))
                  }, {
                    prepend: re(() => [
                      p($, { start: "" }, {
                        default: re(() => [
                          p(O, {
                            class: "s-filter-select__checkbox-btn",
                            "model-value": r.value.includes(n.nullValue),
                            density: e.density
                          }, null, 8, ["model-value", "density"])
                        ]),
                        _: 1
                      })
                    ]),
                    default: re(() => [
                      p(M, {
                        title: n.nullTitle
                      }, {
                        default: re(() => [
                          Ee(xe(n.nullTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["title"])
                    ]),
                    _: 1
                  }, 8, ["active", "density"])) : (N(), Ce(P, {
                    key: 1,
                    active: r.value.includes(A[n.itemValue]),
                    density: e.density,
                    onClick: (D) => y(A[n.itemValue])
                  }, {
                    prepend: re(() => [
                      p($, { start: "" }, {
                        default: re(() => [
                          p(O, {
                            "model-value": r.value.includes(A[n.itemValue]),
                            density: e.density
                          }, null, 8, ["model-value", "density"])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    default: re(() => [
                      p(M, {
                        title: b(A)
                      }, {
                        default: re(() => [
                          Ee(xe(b(A)), 1)
                        ]),
                        _: 2
                      }, 1032, ["title"])
                    ]),
                    _: 2
                  }, 1032, ["active", "density", "onClick"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["density"])
        ]),
        _: 1
      });
    };
  }
}, FW = /* @__PURE__ */ Ut(zW, [["__scopeId", "data-v-32c0d050"]]), XW = { class: "s-user-setting" }, YW = { class: "s-user-setting__header-box" }, WW = { class: "s-user-setting__contents-box" }, qW = { class: "s-user-setting__content" }, UW = { class: "s-user-setting__title-wrapper" }, GW = { class: "s-user-setting__select-wrapper" }, KW = { class: "s-user-setting__content" }, JW = { class: "s-user-setting__title-wrapper" }, eq = { class: "s-user-setting__title" }, tq = { class: "s-user-setting__select-wrapper" }, nq = { class: "s-user-setting__content" }, aq = { class: "s-user-setting__title-wrapper" }, iq = { class: "s-user-setting__title" }, lq = { class: "s-user-setting__checkbox-wrapper" }, rq = {
  __name: "SUserSettings",
  props: {
    languageCode: {
      type: String,
      default: "ko"
    },
    languageList: {
      type: Array,
      default: () => [
        { value: "ko", name: "한국어" },
        { value: "en", name: "English" }
      ]
    },
    costCurrencyCode: {
      type: String,
      default: "krw"
    },
    costCurrencyList: {
      type: Array,
      default: () => [
        { value: "krw", name: "KRW" },
        { value: "usd", name: "USD" }
      ]
    },
    isEmailAlertEnabled: {
      type: Boolean,
      default: !1
    },
    isSlackAlertEnabled: {
      type: Boolean,
      default: !1
    },
    companySlackEnabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:language", "update:currency", "update:email", "update:slack", "get-company-slack-enabled"],
  setup(e, { emit: t }) {
    const n = t, a = e, i = Y({
      languageCode: "ko",
      costCurrencyCode: "krw",
      isEmailAlertEnabled: !1,
      isSlackAlertEnabled: !1
    }), l = Y({
      title: "사용자 설정",
      costCurrency: "비용 통화 설정",
      alert: "알림 수신"
    }), r = () => {
      n("update:language", i.value.languageCode);
    }, s = () => {
      n("update:currency", i.value.costCurrencyCode);
    }, o = () => {
      n("update:email", i.value.isEmailAlertEnabled);
    }, u = () => {
      n("update:slack", i.value.isSlackAlertEnabled);
    }, c = (f) => {
      f === "en" ? (l.value.title = "User Settings", l.value.costCurrency = "Cost Currency Settings", l.value.alert = "Alert Settings") : (l.value.title = "사용자 설정", l.value.costCurrency = "비용 통화 설정", l.value.alert = "알림 수신");
    }, d = () => {
      n("get-company-slack-enabled");
    };
    return rt(() => {
      i.value = {
        languageCode: a.languageCode || "ko",
        costCurrencyCode: a.costCurrencyCode || "krw",
        isEmailAlertEnabled: a.isEmailAlertEnabled || !1,
        isSlackAlertEnabled: a.isSlackAlertEnabled || !1
      }, c(a.languageCode), d();
    }), (f, h) => {
      const m = Pe("v-select"), g = Pe("v-checkbox");
      return N(), ee("div", XW, [
        ie("div", YW, [
          ie("span", null, xe(l.value.title), 1)
        ]),
        ie("div", WW, [
          ie("div", qW, [
            ie("div", UW, [
              h[4] || (h[4] = ie("div", { class: "s-user-setting__title" }, [
                ie("span", null, " 언어/Language ")
              ], -1)),
              ie("div", GW, [
                p(m, {
                  variant: "outlined",
                  itemTitle: "name",
                  itemValue: "value",
                  items: e.languageList,
                  modelValue: i.value.languageCode,
                  "onUpdate:modelValue": [
                    h[0] || (h[0] = (v) => i.value.languageCode = v),
                    r
                  ]
                }, null, 8, ["items", "modelValue"])
              ])
            ])
          ]),
          ie("div", KW, [
            ie("div", JW, [
              ie("div", eq, [
                ie("span", null, xe(l.value.costCurrency), 1)
              ]),
              ie("div", tq, [
                p(m, {
                  variant: "outlined",
                  itemTitle: "name",
                  itemValue: "value",
                  items: e.costCurrencyList,
                  modelValue: i.value.costCurrencyCode,
                  "onUpdate:modelValue": [
                    h[1] || (h[1] = (v) => i.value.costCurrencyCode = v),
                    s
                  ]
                }, null, 8, ["items", "modelValue"])
              ])
            ])
          ]),
          ie("div", nq, [
            ie("div", aq, [
              ie("div", iq, [
                ie("span", null, xe(l.value.alert), 1)
              ]),
              ie("div", lq, [
                p(g, {
                  class: "table-checkbox",
                  "hide-details": "",
                  modelValue: i.value.isEmailAlertEnabled,
                  "onUpdate:modelValue": h[2] || (h[2] = (v) => i.value.isEmailAlertEnabled = v),
                  label: "Email",
                  onChange: o
                }, null, 8, ["modelValue"]),
                p(g, {
                  class: "table-checkbox",
                  "hide-details": "",
                  disabled: !e.companySlackEnabled,
                  modelValue: i.value.isSlackAlertEnabled,
                  "onUpdate:modelValue": h[3] || (h[3] = (v) => i.value.isSlackAlertEnabled = v),
                  label: "Slack",
                  onChange: u
                }, null, 8, ["disabled", "modelValue"])
              ])
            ])
          ])
        ])
      ]);
    };
  }
}, sq = { class: "text-break" }, lv = {
  __name: "SSimpleTooltip",
  props: {
    title: {
      type: String,
      default: null,
      description: "표시할 텍스트 (짧으면 내용만큼, 길면 말줄임)"
    },
    text: {
      type: String,
      default: null,
      description: "툴팁에 표시할 전체 텍스트 (미지정시 title 사용)"
    },
    titleWidth: {
      type: [Number, String],
      default: null,
      description: "텍스트의 최대 너비 (px) - 짧은 텍스트는 내용만큼만 차지"
    },
    maxWidth: {
      type: [Number, String],
      default: 500,
      description: "툴팁 팝업의 최대 너비 (px)"
    }
  },
  setup(e) {
    const t = e, n = k(() => t.text || t.title), a = k(
      () => t.titleWidth ? `${t.titleWidth}px` : ""
    );
    return (i, l) => {
      const r = Pe("v-tooltip");
      return N(), Ce(r, {
        location: "bottom",
        "max-width": t.maxWidth
      }, {
        activator: re(({ props: s }) => [
          ie("span", fe(s, {
            class: "d-inline-block text-truncate",
            style: { maxWidth: a.value }
          }), xe(t.title), 17)
        ]),
        default: re(() => [
          ie("span", sq, xe(n.value), 1)
        ]),
        _: 1
      }, 8, ["max-width"]);
    };
  }
}, oq = { class: "s-detail-tooltip" }, uq = { class: "label" }, cq = {
  class: "label--text",
  variant: "plain"
}, dq = { key: 1 }, fq = { class: "detail-item mr-2" }, hq = {
  __name: "SDetailTooltip",
  props: {
    label: { type: String, default: "Label" },
    // 기존에 보이는 텍스트
    itemId: { type: String, default: "" },
    // v-for key 및 Item 텍스트에 표시
    itemName: { type: String, default: "" },
    // Item 텍스트에 표시
    list: { type: Array, default: () => [] },
    // 상세에 보일 리스트
    icon: { type: String, default: "" },
    // 상세 아이템 옆에 보일 아이콘
    itemClick: { type: Function, default: () => {
    } },
    // 상세 아이템 클릭 이벤트
    copyText: { type: Function, default: (e) => {
      new Function(e);
    } }
    // 상세 아이템 복사 버튼 클릭 이벤트
  },
  setup(e) {
    const t = (/* @__PURE__ */ new Date()).getTime().toString(), n = e, a = Y(!1), i = () => {
      a.value = !a.value;
    };
    pe(a, (r, s) => {
      var o;
      r && !((o = n.list) != null && o.length) && (a.value = s);
    });
    const l = k(() => (r) => typeof r == typeof {} ? `${r[n.itemName] || "-"} / ${r[n.itemId]}` : r);
    return (r, s) => {
      const o = Pe("v-icon"), u = Pe("v-chip"), c = Pe("v-card"), d = Pe("v-overlay");
      return N(), ee("section", oq, [
        ie("div", uq, [
          ie("a", cq, [
            n.label === "Label" ? (N(), Ce(o, {
              key: 0,
              icon: "mdi-dots-vertical"
            })) : (N(), ee("span", dq, xe(n.label), 1)),
            p(d, {
              modelValue: a.value,
              "onUpdate:modelValue": s[0] || (s[0] = (f) => a.value = f),
              activator: "parent",
              location: "bottom",
              origin: "auto",
              scrim: "",
              "location-strategy": "connected",
              "scroll-strategy": "reposition"
            }, {
              default: re(() => [
                a.value ? (N(), Ce(c, {
                  key: 0,
                  class: "s-detail-tooltip__content"
                }, {
                  default: re(() => [
                    p(o, {
                      class: "close-Btn",
                      icon: "mdi-close",
                      onClick: i
                    }),
                    (N(!0), ee(ge, null, Ge(n.list, (f, h) => (N(), Ce(u, {
                      key: n.keyId || h,
                      variant: "text",
                      size: "small"
                    }, {
                      default: re(() => [
                        ie("span", fq, [
                          p(lv, {
                            uuid: X(t),
                            title: l.value(f),
                            text: l.value(f),
                            titleWidth: "360"
                          }, null, 8, ["uuid", "title", "text"])
                        ]),
                        ke(r.$slots, "append-icon", { item: f }, () => [
                          n.icon !== "" ? (N(), Ce(o, {
                            key: 0,
                            icon: n.icon,
                            onClick: (m) => n.icon === "mdi-content-copy" ? e.copyText(f) : n.itemClick(f)
                          }, null, 8, ["icon", "onClick"])) : de("", !0)
                        ])
                      ]),
                      _: 2
                    }, 1024))), 128))
                  ]),
                  _: 3
                })) : de("", !0)
              ]),
              _: 3
            }, 8, ["modelValue"])
          ])
        ])
      ]);
    };
  }
}, mq = { class: "list-input-wrapper" }, vq = { key: 0 }, gq = {
  __name: "SListInput",
  props: /* @__PURE__ */ Nc({
    headers: {
      type: Array,
      default: () => []
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    errorMessages: {
      type: Array,
      default: () => []
    }
  }, {
    modelValue: {
      type: Array,
      default: []
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Nc(["update:model-value"], ["update:modelValue"]),
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, l = Y(0), r = l2(e, "modelValue"), s = k(() => ({
      gridTemplateColumns: `${Array.from({ length: i.headers.length }, () => "1fr").join(" ")} 40px`
    })), o = k(() => {
      const m = i.headers.map((v) => v.key), g = {};
      return m.forEach((v) => {
        g[v] = null;
      }), {
        idx: l.value,
        ...g
      };
    }), u = (m, g) => typeof m.items == "function" ? m.items(g) : m.items, c = (m) => {
      const g = r.value.findIndex((v) => v.idx === m);
      r.value.splice(g, 1);
    }, d = () => {
      r.value.push(o.value), l.value += 1;
    }, f = Y(null), h = async () => {
      const { valid: m, errors: g } = await f.value.validate();
      return { valid: m, errors: g };
    };
    return rt(() => {
      r.value = i.modelValue;
    }), pe(
      () => r.value,
      (m) => {
        a("update:model-value", m);
      },
      { deep: !0 }
    ), t({ validate: h }), (m, g) => {
      const v = Pe("v-col"), y = Pe("v-icon"), b = Pe("v-row"), C = Pe("v-select"), S = Pe("v-text-field"), x = Pe("v-form");
      return N(), ee("div", mq, [
        p(b, {
          class: "list-input-header list-input-row",
          dense: "",
          "no-gutters": "",
          style: Ot(s.value)
        }, {
          default: re(() => [
            (N(!0), ee(ge, null, Ge(e.headers, (w, V) => (N(), Ce(v, {
              key: V,
              class: "list-input-col"
            }, {
              default: re(() => [
                Ee(xe(w.title), 1)
              ]),
              _: 2
            }, 1024))), 128)),
            e.readonly ? de("", !0) : (N(), Ce(v, {
              key: 0,
              class: "list-input-col icon-col"
            }, {
              default: re(() => [
                p(y, {
                  icon: "mdi-plus-circle",
                  color: "#666666",
                  onClick: d
                })
              ]),
              _: 1
            }))
          ]),
          _: 1
        }, 8, ["style"]),
        p(x, {
          ref_key: "formRef",
          ref: f
        }, {
          default: re(() => [
            (N(!0), ee(ge, null, Ge(r.value, (w, V) => (N(), Ce(b, {
              key: w.idx,
              class: "list-input-row list-input-content",
              style: Ot(s.value),
              dense: "",
              "no-gutters": ""
            }, {
              default: re(() => [
                (N(!0), ee(ge, null, Ge(e.headers, (_, O) => (N(), Ce(v, {
                  key: "row-" + w.idx + "col-" + O,
                  class: "list-input-col"
                }, {
                  default: re(() => [
                    e.readonly ? (N(), ee("span", vq, xe(w[_.key] || "-"), 1)) : (N(), ee(ge, { key: 1 }, [
                      _.type === "select" ? (N(), Ce(C, {
                        key: 0,
                        modelValue: w[_.key],
                        "onUpdate:modelValue": ($) => w[_.key] = $,
                        density: "compact",
                        variant: "outlined",
                        "hide-details": "",
                        "item-title": _.itemTitle,
                        "item-value": _.itemValue,
                        items: u(_, V),
                        placeholder: _.placeholder,
                        rules: _.rules
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "item-title", "item-value", "items", "placeholder", "rules"])) : (N(), Ce(S, {
                        key: 1,
                        modelValue: w[_.key],
                        "onUpdate:modelValue": ($) => w[_.key] = $,
                        density: "compact",
                        variant: "outlined",
                        "hide-details": "",
                        rules: _.rules,
                        placeholder: _.placeholder
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "rules", "placeholder"]))
                    ], 64))
                  ]),
                  _: 2
                }, 1024))), 128)),
                e.readonly ? de("", !0) : (N(), Ce(v, {
                  key: 0,
                  class: "list-input-col icon-col"
                }, {
                  default: re(() => [
                    p(y, {
                      icon: "mdi-minus-circle",
                      color: "#999999",
                      onClick: (_) => c(w.idx)
                    }, null, 8, ["onClick"])
                  ]),
                  _: 2
                }, 1024))
              ]),
              _: 2
            }, 1032, ["style"]))), 128))
          ]),
          _: 1
        }, 512)
      ]);
    };
  }
}, pq = /* @__PURE__ */ Ut(gq, [["__scopeId", "data-v-dbfd9c6e"]]), yq = { class: "list-controls" }, Oq = {
  __name: "SListControl",
  props: {
    list: { type: Array, default: () => [] },
    perPages: { type: [Number, String], default: 10 },
    perPageList: { type: Array, default: () => null },
    refreshDateTitle: { type: String, default: "Date" },
    density: { type: String, default: "comfortable" }
  },
  emits: ["on-refresh", "set-per-pages"],
  setup(e, { emit: t }) {
    const n = Object.freeze([
      { text: "10", value: 10 },
      { text: "15", value: 15 },
      { text: "20", value: 20 }
    ]), a = t, i = e, l = Y(/* @__PURE__ */ new Date()), r = () => {
      a("on-refresh");
    }, s = (u) => {
      a("set-per-pages", u);
    };
    return pe(() => i.list, () => {
      l.value = /* @__PURE__ */ new Date();
    }), (u, c) => {
      const d = Pe("v-select");
      return N(), ee("div", yq, [
        p(b7, {
          "on-click-refresh": r,
          "refresh-date": l.value,
          "refresh-date-title": e.refreshDateTitle
        }, null, 8, ["refresh-date", "refresh-date-title"]),
        p(d, {
          "model-value": e.perPages,
          items: e.perPageList || X(n),
          "item-title": "text",
          "item-value": "value",
          variant: "outlined",
          density: e.density,
          hideDetails: "auto",
          "onUpdate:modelValue": s
        }, null, 8, ["model-value", "items", "density"])
      ]);
    };
  }
}, bq = {
  __name: "SDropdownButton",
  props: {
    label: { type: String, default: "" },
    disabled: { type: Boolean, default: !1 },
    list: {
      type: Array,
      default: () => [],
      description: "드롭다운 항목 리스트"
    },
    whiteList: {
      type: Array,
      default: () => [],
      description: "RBAC 화이트리스트"
    },
    selectedList: {
      type: Array,
      default: () => [],
      description: "테이블 등에서 선택된 항목들"
    },
    iconName: {
      type: String,
      default: () => "manage",
      description: "아이콘 이름"
    }
  },
  setup(e) {
    const t = e, n = (i) => {
      if (!t.whiteList.includes(i.actionCode) || i.disabled === !0) return !0;
      const r = t.selectedList.length;
      switch (i.type) {
        case "multiple":
          return r === 0;
        case "single":
          return r !== 1;
        case "none":
        case null:
        case void 0:
          return !1;
        default:
          return !1;
      }
    }, a = async (i) => {
      var l;
      await ((l = i.onClick) == null ? void 0 : l.call(i));
    };
    return (i, l) => {
      const r = Pe("s-icon"), s = Pe("s-btn"), o = Pe("v-list-item-title"), u = Pe("v-list-item"), c = Pe("v-list"), d = Pe("v-menu");
      return e.list.length ? (N(), Ce(d, {
        key: 0,
        "offset-y": ""
      }, {
        activator: re(({ props: f }) => [
          p(s, fe(f, {
            disabled: e.disabled,
            class: "d-flex align-center"
          }), {
            default: re(() => [
              p(r, {
                name: e.iconName,
                size: 16,
                class: "mr-1"
              }, null, 8, ["name"]),
              Ee(" " + xe(e.label), 1)
            ]),
            _: 2
          }, 1040, ["disabled"])
        ]),
        default: re(() => [
          p(c, null, {
            default: re(() => [
              (N(!0), ee(ge, null, Ge(e.list, (f, h) => (N(), Ce(u, {
                key: (f == null ? void 0 : f.actionCode) || h,
                disabled: n(f),
                onClick: (m) => a(f)
              }, {
                default: re(() => [
                  p(o, null, {
                    default: re(() => [
                      Ee(xe(f.label), 1)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1032, ["disabled", "onClick"]))), 128))
            ]),
            _: 1
          })
        ]),
        _: 1
      })) : de("", !0);
    };
  }
}, Rb = 6048e5, Cq = 864e5, wq = 6e4, Ib = 36e5, kq = 1e3, $4 = Symbol.for("constructDateFrom");
function xt(e, t) {
  return typeof e == "function" ? e(t) : e && typeof e == "object" && $4 in e ? e[$4](t) : e instanceof Date ? new e.constructor(t) : new Date(t);
}
function tt(e, t) {
  return xt(t || e, e);
}
function Va(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in);
  return isNaN(t) ? xt((n == null ? void 0 : n.in) || e, NaN) : (t && a.setDate(a.getDate() + t), a);
}
function Ua(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in);
  if (isNaN(t)) return xt(e, NaN);
  if (!t)
    return a;
  const i = a.getDate(), l = xt(e, a.getTime());
  l.setMonth(a.getMonth() + t + 1, 0);
  const r = l.getDate();
  return i >= r ? l : (a.setFullYear(
    l.getFullYear(),
    l.getMonth(),
    i
  ), a);
}
function Bb(e, t, n) {
  const {
    years: a = 0,
    months: i = 0,
    weeks: l = 0,
    days: r = 0,
    hours: s = 0,
    minutes: o = 0,
    seconds: u = 0
  } = t, c = tt(e, n == null ? void 0 : n.in), d = i || a ? Ua(c, i + a * 12) : c, f = r || l ? Va(d, r + l * 7) : d, h = o + s * 60, g = (u + h * 60) * 1e3;
  return xt(e, +f + g);
}
function Sq(e, t, n) {
  return xt(e, +tt(e) + t);
}
function xq(e, t, n) {
  return Sq(e, t * Ib);
}
let Pq = {};
function Fr() {
  return Pq;
}
function ti(e, t) {
  var s, o, u, c;
  const n = Fr(), a = (t == null ? void 0 : t.weekStartsOn) ?? ((o = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null ? void 0 : o.weekStartsOn) ?? n.weekStartsOn ?? ((c = (u = n.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) ?? 0, i = tt(e, t == null ? void 0 : t.in), l = i.getDay(), r = (l < a ? 7 : 0) + l - a;
  return i.setDate(i.getDate() - r), i.setHours(0, 0, 0, 0), i;
}
function Is(e, t) {
  return ti(e, { ...t, weekStartsOn: 1 });
}
function Zb(e, t) {
  const n = tt(e, t == null ? void 0 : t.in), a = n.getFullYear(), i = xt(n, 0);
  i.setFullYear(a + 1, 0, 4), i.setHours(0, 0, 0, 0);
  const l = Is(i), r = xt(n, 0);
  r.setFullYear(a, 0, 4), r.setHours(0, 0, 0, 0);
  const s = Is(r);
  return n.getTime() >= l.getTime() ? a + 1 : n.getTime() >= s.getTime() ? a : a - 1;
}
function Td(e) {
  const t = tt(e), n = new Date(
    Date.UTC(
      t.getFullYear(),
      t.getMonth(),
      t.getDate(),
      t.getHours(),
      t.getMinutes(),
      t.getSeconds(),
      t.getMilliseconds()
    )
  );
  return n.setUTCFullYear(t.getFullYear()), +e - +n;
}
function Zu(e, ...t) {
  const n = xt.bind(
    null,
    t.find((a) => typeof a == "object")
  );
  return t.map(n);
}
function _4(e, t) {
  const n = tt(e, t == null ? void 0 : t.in);
  return n.setHours(0, 0, 0, 0), n;
}
function Eb(e, t, n) {
  const [a, i] = Zu(
    n == null ? void 0 : n.in,
    e,
    t
  ), l = _4(a), r = _4(i), s = +l - Td(l), o = +r - Td(r);
  return Math.round((s - o) / Cq);
}
function $q(e, t) {
  const n = Zb(e, t), a = xt(e, 0);
  return a.setFullYear(n, 0, 4), a.setHours(0, 0, 0, 0), Is(a);
}
function _q(e, t, n) {
  return Ua(e, t * 3, n);
}
function rv(e, t, n) {
  return Ua(e, t * 12, n);
}
function M4(e, t) {
  const n = +tt(e) - +tt(t);
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function Nb(e) {
  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function Qo(e) {
  return !(!Nb(e) && typeof e != "number" || isNaN(+tt(e)));
}
function V4(e, t) {
  const n = tt(e, t == null ? void 0 : t.in);
  return Math.trunc(n.getMonth() / 3) + 1;
}
function Mq(e, t, n) {
  const [a, i] = Zu(
    n == null ? void 0 : n.in,
    e,
    t
  );
  return a.getFullYear() - i.getFullYear();
}
function Vq(e, t, n) {
  const [a, i] = Zu(
    n == null ? void 0 : n.in,
    e,
    t
  ), l = M4(a, i), r = Math.abs(Mq(a, i));
  a.setFullYear(1584), i.setFullYear(1584);
  const s = M4(a, i) === -l, o = l * (r - +s);
  return o === 0 ? 0 : o;
}
function Hb(e, t) {
  const [n, a] = Zu(e, t.start, t.end);
  return { start: n, end: a };
}
function jb(e, t) {
  const { start: n, end: a } = Hb(t == null ? void 0 : t.in, e);
  let i = +n > +a;
  const l = i ? +n : +a, r = i ? a : n;
  r.setHours(0, 0, 0, 0);
  let s = 1;
  const o = [];
  for (; +r <= l; )
    o.push(xt(n, r)), r.setDate(r.getDate() + s), r.setHours(0, 0, 0, 0);
  return i ? o.reverse() : o;
}
function rr(e, t) {
  const n = tt(e, t == null ? void 0 : t.in), a = n.getMonth(), i = a - a % 3;
  return n.setMonth(i, 1), n.setHours(0, 0, 0, 0), n;
}
function Tq(e, t) {
  const { start: n, end: a } = Hb(t == null ? void 0 : t.in, e);
  let i = +n > +a;
  const l = i ? +rr(n) : +rr(a);
  let r = rr(i ? a : n), s = 1;
  const o = [];
  for (; +r <= l; )
    o.push(xt(n, r)), r = _q(r, s);
  return i ? o.reverse() : o;
}
function Lq(e, t) {
  const n = tt(e, t == null ? void 0 : t.in);
  return n.setDate(1), n.setHours(0, 0, 0, 0), n;
}
function zb(e, t) {
  const n = tt(e, t == null ? void 0 : t.in), a = n.getFullYear();
  return n.setFullYear(a + 1, 0, 0), n.setHours(23, 59, 59, 999), n;
}
function hu(e, t) {
  const n = tt(e, t == null ? void 0 : t.in);
  return n.setFullYear(n.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function Fb(e, t) {
  var s, o, u, c;
  const n = Fr(), a = (t == null ? void 0 : t.weekStartsOn) ?? ((o = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null ? void 0 : o.weekStartsOn) ?? n.weekStartsOn ?? ((c = (u = n.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) ?? 0, i = tt(e, t == null ? void 0 : t.in), l = i.getDay(), r = (l < a ? -7 : 0) + 6 - (l - a);
  return i.setDate(i.getDate() + r), i.setHours(23, 59, 59, 999), i;
}
function T4(e, t) {
  const n = tt(e, t == null ? void 0 : t.in), a = n.getMonth(), i = a - a % 3 + 3;
  return n.setMonth(i, 0), n.setHours(23, 59, 59, 999), n;
}
const Qq = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, Aq = (e, t, n) => {
  let a;
  const i = Qq[e];
  return typeof i == "string" ? a = i : t === 1 ? a = i.one : a = i.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + a : a + " ago" : a;
};
function gs(e) {
  return (t = {}) => {
    const n = t.width ? String(t.width) : e.defaultWidth;
    return e.formats[n] || e.formats[e.defaultWidth];
  };
}
const Dq = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, Rq = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, Iq = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, Bq = {
  date: gs({
    formats: Dq,
    defaultWidth: "full"
  }),
  time: gs({
    formats: Rq,
    defaultWidth: "full"
  }),
  dateTime: gs({
    formats: Iq,
    defaultWidth: "full"
  })
}, Zq = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, Eq = (e, t, n, a) => Zq[e];
function gi(e) {
  return (t, n) => {
    const a = n != null && n.context ? String(n.context) : "standalone";
    let i;
    if (a === "formatting" && e.formattingValues) {
      const r = e.defaultFormattingWidth || e.defaultWidth, s = n != null && n.width ? String(n.width) : r;
      i = e.formattingValues[s] || e.formattingValues[r];
    } else {
      const r = e.defaultWidth, s = n != null && n.width ? String(n.width) : e.defaultWidth;
      i = e.values[s] || e.values[r];
    }
    const l = e.argumentCallback ? e.argumentCallback(t) : t;
    return i[l];
  };
}
const Nq = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, Hq = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, jq = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, zq = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, Fq = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, Xq = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, Yq = (e, t) => {
  const n = Number(e), a = n % 100;
  if (a > 20 || a < 10)
    switch (a % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, Wq = {
  ordinalNumber: Yq,
  era: gi({
    values: Nq,
    defaultWidth: "wide"
  }),
  quarter: gi({
    values: Hq,
    defaultWidth: "wide",
    argumentCallback: (e) => e - 1
  }),
  month: gi({
    values: jq,
    defaultWidth: "wide"
  }),
  day: gi({
    values: zq,
    defaultWidth: "wide"
  }),
  dayPeriod: gi({
    values: Fq,
    defaultWidth: "wide",
    formattingValues: Xq,
    defaultFormattingWidth: "wide"
  })
};
function pi(e) {
  return (t, n = {}) => {
    const a = n.width, i = a && e.matchPatterns[a] || e.matchPatterns[e.defaultMatchWidth], l = t.match(i);
    if (!l)
      return null;
    const r = l[0], s = a && e.parsePatterns[a] || e.parsePatterns[e.defaultParseWidth], o = Array.isArray(s) ? Uq(s, (d) => d.test(r)) : (
      // [TODO] -- I challenge you to fix the type
      qq(s, (d) => d.test(r))
    );
    let u;
    u = e.valueCallback ? e.valueCallback(o) : o, u = n.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      n.valueCallback(u)
    ) : u;
    const c = t.slice(r.length);
    return { value: u, rest: c };
  };
}
function qq(e, t) {
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n]))
      return n;
}
function Uq(e, t) {
  for (let n = 0; n < e.length; n++)
    if (t(e[n]))
      return n;
}
function Xb(e) {
  return (t, n = {}) => {
    const a = t.match(e.matchPattern);
    if (!a) return null;
    const i = a[0], l = t.match(e.parsePattern);
    if (!l) return null;
    let r = e.valueCallback ? e.valueCallback(l[0]) : l[0];
    r = n.valueCallback ? n.valueCallback(r) : r;
    const s = t.slice(i.length);
    return { value: r, rest: s };
  };
}
const Gq = /^(\d+)(th|st|nd|rd)?/i, Kq = /\d+/i, Jq = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, eU = {
  any: [/^b/i, /^(a|c)/i]
}, tU = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, nU = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, aU = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, iU = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, lU = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, rU = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, sU = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, oU = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, uU = {
  ordinalNumber: Xb({
    matchPattern: Gq,
    parsePattern: Kq,
    valueCallback: (e) => parseInt(e, 10)
  }),
  era: pi({
    matchPatterns: Jq,
    defaultMatchWidth: "wide",
    parsePatterns: eU,
    defaultParseWidth: "any"
  }),
  quarter: pi({
    matchPatterns: tU,
    defaultMatchWidth: "wide",
    parsePatterns: nU,
    defaultParseWidth: "any",
    valueCallback: (e) => e + 1
  }),
  month: pi({
    matchPatterns: aU,
    defaultMatchWidth: "wide",
    parsePatterns: iU,
    defaultParseWidth: "any"
  }),
  day: pi({
    matchPatterns: lU,
    defaultMatchWidth: "wide",
    parsePatterns: rU,
    defaultParseWidth: "any"
  }),
  dayPeriod: pi({
    matchPatterns: sU,
    defaultMatchWidth: "any",
    parsePatterns: oU,
    defaultParseWidth: "any"
  })
}, sv = {
  code: "en-US",
  formatDistance: Aq,
  formatLong: Bq,
  formatRelative: Eq,
  localize: Wq,
  match: uU,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function cU(e, t) {
  const n = tt(e, t == null ? void 0 : t.in);
  return Eb(n, hu(n)) + 1;
}
function ov(e, t) {
  const n = tt(e, t == null ? void 0 : t.in), a = +Is(n) - +$q(n);
  return Math.round(a / Rb) + 1;
}
function uv(e, t) {
  var c, d, f, h;
  const n = tt(e, t == null ? void 0 : t.in), a = n.getFullYear(), i = Fr(), l = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((d = (c = t == null ? void 0 : t.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? i.firstWeekContainsDate ?? ((h = (f = i.locale) == null ? void 0 : f.options) == null ? void 0 : h.firstWeekContainsDate) ?? 1, r = xt((t == null ? void 0 : t.in) || e, 0);
  r.setFullYear(a + 1, 0, l), r.setHours(0, 0, 0, 0);
  const s = ti(r, t), o = xt((t == null ? void 0 : t.in) || e, 0);
  o.setFullYear(a, 0, l), o.setHours(0, 0, 0, 0);
  const u = ti(o, t);
  return +n >= +s ? a + 1 : +n >= +u ? a : a - 1;
}
function dU(e, t) {
  var s, o, u, c;
  const n = Fr(), a = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((o = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null ? void 0 : o.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((c = (u = n.locale) == null ? void 0 : u.options) == null ? void 0 : c.firstWeekContainsDate) ?? 1, i = uv(e, t), l = xt((t == null ? void 0 : t.in) || e, 0);
  return l.setFullYear(i, 0, a), l.setHours(0, 0, 0, 0), ti(l, t);
}
function cv(e, t) {
  const n = tt(e, t == null ? void 0 : t.in), a = +ti(n, t) - +dU(n, t);
  return Math.round(a / Rb) + 1;
}
function St(e, t) {
  const n = e < 0 ? "-" : "", a = Math.abs(e).toString().padStart(t, "0");
  return n + a;
}
const fl = {
  // Year
  y(e, t) {
    const n = e.getFullYear(), a = n > 0 ? n : 1 - n;
    return St(t === "yy" ? a % 100 : a, t.length);
  },
  // Month
  M(e, t) {
    const n = e.getMonth();
    return t === "M" ? String(n + 1) : St(n + 1, 2);
  },
  // Day of the month
  d(e, t) {
    return St(e.getDate(), t.length);
  },
  // AM or PM
  a(e, t) {
    const n = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(e, t) {
    return St(e.getHours() % 12 || 12, t.length);
  },
  // Hour [0-23]
  H(e, t) {
    return St(e.getHours(), t.length);
  },
  // Minute
  m(e, t) {
    return St(e.getMinutes(), t.length);
  },
  // Second
  s(e, t) {
    return St(e.getSeconds(), t.length);
  },
  // Fraction of second
  S(e, t) {
    const n = t.length, a = e.getMilliseconds(), i = Math.trunc(
      a * Math.pow(10, n - 3)
    );
    return St(i, t.length);
  }
}, Gr = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, L4 = {
  // Era
  G: function(e, t, n) {
    const a = e.getFullYear() > 0 ? 1 : 0;
    switch (t) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(a, { width: "abbreviated" });
      case "GGGGG":
        return n.era(a, { width: "narrow" });
      case "GGGG":
      default:
        return n.era(a, { width: "wide" });
    }
  },
  // Year
  y: function(e, t, n) {
    if (t === "yo") {
      const a = e.getFullYear(), i = a > 0 ? a : 1 - a;
      return n.ordinalNumber(i, { unit: "year" });
    }
    return fl.y(e, t);
  },
  // Local week-numbering year
  Y: function(e, t, n, a) {
    const i = uv(e, a), l = i > 0 ? i : 1 - i;
    if (t === "YY") {
      const r = l % 100;
      return St(r, 2);
    }
    return t === "Yo" ? n.ordinalNumber(l, { unit: "year" }) : St(l, t.length);
  },
  // ISO week-numbering year
  R: function(e, t) {
    const n = Zb(e);
    return St(n, t.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(e, t) {
    const n = e.getFullYear();
    return St(n, t.length);
  },
  // Quarter
  Q: function(e, t, n) {
    const a = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      case "Q":
        return String(a);
      case "QQ":
        return St(a, 2);
      case "Qo":
        return n.ordinalNumber(a, { unit: "quarter" });
      case "QQQ":
        return n.quarter(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(a, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(e, t, n) {
    const a = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      case "q":
        return String(a);
      case "qq":
        return St(a, 2);
      case "qo":
        return n.ordinalNumber(a, { unit: "quarter" });
      case "qqq":
        return n.quarter(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(a, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(e, t, n) {
    const a = e.getMonth();
    switch (t) {
      case "M":
      case "MM":
        return fl.M(e, t);
      case "Mo":
        return n.ordinalNumber(a + 1, { unit: "month" });
      case "MMM":
        return n.month(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return n.month(a, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(a, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(e, t, n) {
    const a = e.getMonth();
    switch (t) {
      case "L":
        return String(a + 1);
      case "LL":
        return St(a + 1, 2);
      case "Lo":
        return n.ordinalNumber(a + 1, { unit: "month" });
      case "LLL":
        return n.month(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return n.month(a, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(a, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(e, t, n, a) {
    const i = cv(e, a);
    return t === "wo" ? n.ordinalNumber(i, { unit: "week" }) : St(i, t.length);
  },
  // ISO week of year
  I: function(e, t, n) {
    const a = ov(e);
    return t === "Io" ? n.ordinalNumber(a, { unit: "week" }) : St(a, t.length);
  },
  // Day of the month
  d: function(e, t, n) {
    return t === "do" ? n.ordinalNumber(e.getDate(), { unit: "date" }) : fl.d(e, t);
  },
  // Day of year
  D: function(e, t, n) {
    const a = cU(e);
    return t === "Do" ? n.ordinalNumber(a, { unit: "dayOfYear" }) : St(a, t.length);
  },
  // Day of week
  E: function(e, t, n) {
    const a = e.getDay();
    switch (t) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return n.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(a, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return n.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(e, t, n, a) {
    const i = e.getDay(), l = (i - a.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "e":
        return String(l);
      case "ee":
        return St(l, 2);
      case "eo":
        return n.ordinalNumber(l, { unit: "day" });
      case "eee":
        return n.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return n.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(i, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return n.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(e, t, n, a) {
    const i = e.getDay(), l = (i - a.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "c":
        return String(l);
      case "cc":
        return St(l, t.length);
      case "co":
        return n.ordinalNumber(l, { unit: "day" });
      case "ccc":
        return n.day(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return n.day(i, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(i, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return n.day(i, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(e, t, n) {
    const a = e.getDay(), i = a === 0 ? 7 : a;
    switch (t) {
      case "i":
        return String(i);
      case "ii":
        return St(i, t.length);
      case "io":
        return n.ordinalNumber(i, { unit: "day" });
      case "iii":
        return n.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return n.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return n.day(a, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return n.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(e, t, n) {
    const i = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(e, t, n) {
    const a = e.getHours();
    let i;
    switch (a === 12 ? i = Gr.noon : a === 0 ? i = Gr.midnight : i = a / 12 >= 1 ? "pm" : "am", t) {
      case "b":
      case "bb":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(e, t, n) {
    const a = e.getHours();
    let i;
    switch (a >= 17 ? i = Gr.evening : a >= 12 ? i = Gr.afternoon : a >= 4 ? i = Gr.morning : i = Gr.night, t) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(e, t, n) {
    if (t === "ho") {
      let a = e.getHours() % 12;
      return a === 0 && (a = 12), n.ordinalNumber(a, { unit: "hour" });
    }
    return fl.h(e, t);
  },
  // Hour [0-23]
  H: function(e, t, n) {
    return t === "Ho" ? n.ordinalNumber(e.getHours(), { unit: "hour" }) : fl.H(e, t);
  },
  // Hour [0-11]
  K: function(e, t, n) {
    const a = e.getHours() % 12;
    return t === "Ko" ? n.ordinalNumber(a, { unit: "hour" }) : St(a, t.length);
  },
  // Hour [1-24]
  k: function(e, t, n) {
    let a = e.getHours();
    return a === 0 && (a = 24), t === "ko" ? n.ordinalNumber(a, { unit: "hour" }) : St(a, t.length);
  },
  // Minute
  m: function(e, t, n) {
    return t === "mo" ? n.ordinalNumber(e.getMinutes(), { unit: "minute" }) : fl.m(e, t);
  },
  // Second
  s: function(e, t, n) {
    return t === "so" ? n.ordinalNumber(e.getSeconds(), { unit: "second" }) : fl.s(e, t);
  },
  // Fraction of second
  S: function(e, t) {
    return fl.S(e, t);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(e, t, n) {
    const a = e.getTimezoneOffset();
    if (a === 0)
      return "Z";
    switch (t) {
      case "X":
        return A4(a);
      case "XXXX":
      case "XX":
        return Ul(a);
      case "XXXXX":
      case "XXX":
      default:
        return Ul(a, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(e, t, n) {
    const a = e.getTimezoneOffset();
    switch (t) {
      case "x":
        return A4(a);
      case "xxxx":
      case "xx":
        return Ul(a);
      case "xxxxx":
      case "xxx":
      default:
        return Ul(a, ":");
    }
  },
  // Timezone (GMT)
  O: function(e, t, n) {
    const a = e.getTimezoneOffset();
    switch (t) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + Q4(a, ":");
      case "OOOO":
      default:
        return "GMT" + Ul(a, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(e, t, n) {
    const a = e.getTimezoneOffset();
    switch (t) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + Q4(a, ":");
      case "zzzz":
      default:
        return "GMT" + Ul(a, ":");
    }
  },
  // Seconds timestamp
  t: function(e, t, n) {
    const a = Math.trunc(+e / 1e3);
    return St(a, t.length);
  },
  // Milliseconds timestamp
  T: function(e, t, n) {
    return St(+e, t.length);
  }
};
function Q4(e, t = "") {
  const n = e > 0 ? "-" : "+", a = Math.abs(e), i = Math.trunc(a / 60), l = a % 60;
  return l === 0 ? n + String(i) : n + String(i) + t + St(l, 2);
}
function A4(e, t) {
  return e % 60 === 0 ? (e > 0 ? "-" : "+") + St(Math.abs(e) / 60, 2) : Ul(e, t);
}
function Ul(e, t = "") {
  const n = e > 0 ? "-" : "+", a = Math.abs(e), i = St(Math.trunc(a / 60), 2), l = St(a % 60, 2);
  return n + i + t + l;
}
const D4 = (e, t) => {
  switch (e) {
    case "P":
      return t.date({ width: "short" });
    case "PP":
      return t.date({ width: "medium" });
    case "PPP":
      return t.date({ width: "long" });
    case "PPPP":
    default:
      return t.date({ width: "full" });
  }
}, Yb = (e, t) => {
  switch (e) {
    case "p":
      return t.time({ width: "short" });
    case "pp":
      return t.time({ width: "medium" });
    case "ppp":
      return t.time({ width: "long" });
    case "pppp":
    default:
      return t.time({ width: "full" });
  }
}, fU = (e, t) => {
  const n = e.match(/(P+)(p+)?/) || [], a = n[1], i = n[2];
  if (!i)
    return D4(e, t);
  let l;
  switch (a) {
    case "P":
      l = t.dateTime({ width: "short" });
      break;
    case "PP":
      l = t.dateTime({ width: "medium" });
      break;
    case "PPP":
      l = t.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      l = t.dateTime({ width: "full" });
      break;
  }
  return l.replace("{{date}}", D4(a, t)).replace("{{time}}", Yb(i, t));
}, q0 = {
  p: Yb,
  P: fU
}, hU = /^D+$/, mU = /^Y+$/, vU = ["D", "DD", "YY", "YYYY"];
function Wb(e) {
  return hU.test(e);
}
function qb(e) {
  return mU.test(e);
}
function U0(e, t, n) {
  const a = gU(e, t, n);
  if (console.warn(a), vU.includes(e)) throw new RangeError(a);
}
function gU(e, t, n) {
  const a = e[0] === "Y" ? "years" : "days of the month";
  return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${a} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const pU = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, yU = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, OU = /^'([^]*?)'?$/, bU = /''/g, CU = /[a-zA-Z]/;
function _i(e, t, n) {
  var c, d, f, h, m, g, v, y;
  const a = Fr(), i = (n == null ? void 0 : n.locale) ?? a.locale ?? sv, l = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((d = (c = n == null ? void 0 : n.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? a.firstWeekContainsDate ?? ((h = (f = a.locale) == null ? void 0 : f.options) == null ? void 0 : h.firstWeekContainsDate) ?? 1, r = (n == null ? void 0 : n.weekStartsOn) ?? ((g = (m = n == null ? void 0 : n.locale) == null ? void 0 : m.options) == null ? void 0 : g.weekStartsOn) ?? a.weekStartsOn ?? ((y = (v = a.locale) == null ? void 0 : v.options) == null ? void 0 : y.weekStartsOn) ?? 0, s = tt(e, n == null ? void 0 : n.in);
  if (!Qo(s))
    throw new RangeError("Invalid time value");
  let o = t.match(yU).map((b) => {
    const C = b[0];
    if (C === "p" || C === "P") {
      const S = q0[C];
      return S(b, i.formatLong);
    }
    return b;
  }).join("").match(pU).map((b) => {
    if (b === "''")
      return { isToken: !1, value: "'" };
    const C = b[0];
    if (C === "'")
      return { isToken: !1, value: wU(b) };
    if (L4[C])
      return { isToken: !0, value: b };
    if (C.match(CU))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + C + "`"
      );
    return { isToken: !1, value: b };
  });
  i.localize.preprocessor && (o = i.localize.preprocessor(s, o));
  const u = {
    firstWeekContainsDate: l,
    weekStartsOn: r,
    locale: i
  };
  return o.map((b) => {
    if (!b.isToken) return b.value;
    const C = b.value;
    (!(n != null && n.useAdditionalWeekYearTokens) && qb(C) || !(n != null && n.useAdditionalDayOfYearTokens) && Wb(C)) && U0(C, t, String(e));
    const S = L4[C[0]];
    return S(s, C, i.localize, u);
  }).join("");
}
function wU(e) {
  const t = e.match(OU);
  return t ? t[1].replace(bU, "'") : e;
}
function kU(e, t) {
  return tt(e, t == null ? void 0 : t.in).getDay();
}
function SU(e, t) {
  const n = tt(e, t == null ? void 0 : t.in), a = n.getFullYear(), i = n.getMonth(), l = xt(n, 0);
  return l.setFullYear(a, i + 1, 0), l.setHours(0, 0, 0, 0), l.getDate();
}
function xU() {
  return Object.assign({}, Fr());
}
function tl(e, t) {
  return tt(e, t == null ? void 0 : t.in).getHours();
}
function PU(e, t) {
  const n = tt(e, t == null ? void 0 : t.in).getDay();
  return n === 0 ? 7 : n;
}
function Dl(e, t) {
  return tt(e, t == null ? void 0 : t.in).getMinutes();
}
function ft(e, t) {
  return tt(e, t == null ? void 0 : t.in).getMonth();
}
function Bs(e) {
  return tt(e).getSeconds();
}
function it(e, t) {
  return tt(e, t == null ? void 0 : t.in).getFullYear();
}
function Vr(e, t) {
  return +tt(e) > +tt(t);
}
function Zs(e, t) {
  return +tt(e) < +tt(t);
}
function us(e, t) {
  return +tt(e) == +tt(t);
}
function $U(e, t) {
  const n = _U(t) ? new t(0) : xt(t, 0);
  return n.setFullYear(e.getFullYear(), e.getMonth(), e.getDate()), n.setHours(
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  ), n;
}
function _U(e) {
  var t;
  return typeof e == "function" && ((t = e.prototype) == null ? void 0 : t.constructor) === e;
}
const MU = 10;
class Ub {
  constructor() {
    ze(this, "subPriority", 0);
  }
  validate(t, n) {
    return !0;
  }
}
class VU extends Ub {
  constructor(t, n, a, i, l) {
    super(), this.value = t, this.validateValue = n, this.setValue = a, this.priority = i, l && (this.subPriority = l);
  }
  validate(t, n) {
    return this.validateValue(t, this.value, n);
  }
  set(t, n, a) {
    return this.setValue(t, n, this.value, a);
  }
}
class TU extends Ub {
  constructor(n, a) {
    super();
    ze(this, "priority", MU);
    ze(this, "subPriority", -1);
    this.context = n || ((i) => xt(a, i));
  }
  set(n, a) {
    return a.timestampIsSet ? n : xt(n, $U(n, this.context));
  }
}
class wt {
  run(t, n, a, i) {
    const l = this.parse(t, n, a, i);
    return l ? {
      setter: new VU(
        l.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: l.rest
    } : null;
  }
  validate(t, n, a) {
    return !0;
  }
}
class LU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 140);
    ze(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "G":
      case "GG":
      case "GGG":
        return i.era(n, { width: "abbreviated" }) || i.era(n, { width: "narrow" });
      case "GGGGG":
        return i.era(n, { width: "narrow" });
      case "GGGG":
      default:
        return i.era(n, { width: "wide" }) || i.era(n, { width: "abbreviated" }) || i.era(n, { width: "narrow" });
    }
  }
  set(n, a, i) {
    return a.era = i, n.setFullYear(i, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
const dn = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, yi = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function fn(e, t) {
  return e && {
    value: t(e.value),
    rest: e.rest
  };
}
function en(e, t) {
  const n = t.match(e);
  return n ? {
    value: parseInt(n[0], 10),
    rest: t.slice(n[0].length)
  } : null;
}
function Oi(e, t) {
  const n = t.match(e);
  if (!n)
    return null;
  if (n[0] === "Z")
    return {
      value: 0,
      rest: t.slice(1)
    };
  const a = n[1] === "+" ? 1 : -1, i = n[2] ? parseInt(n[2], 10) : 0, l = n[3] ? parseInt(n[3], 10) : 0, r = n[5] ? parseInt(n[5], 10) : 0;
  return {
    value: a * (i * Ib + l * wq + r * kq),
    rest: t.slice(n[0].length)
  };
}
function Gb(e) {
  return en(dn.anyDigitsSigned, e);
}
function sn(e, t) {
  switch (e) {
    case 1:
      return en(dn.singleDigit, t);
    case 2:
      return en(dn.twoDigits, t);
    case 3:
      return en(dn.threeDigits, t);
    case 4:
      return en(dn.fourDigits, t);
    default:
      return en(new RegExp("^\\d{1," + e + "}"), t);
  }
}
function Ld(e, t) {
  switch (e) {
    case 1:
      return en(dn.singleDigitSigned, t);
    case 2:
      return en(dn.twoDigitsSigned, t);
    case 3:
      return en(dn.threeDigitsSigned, t);
    case 4:
      return en(dn.fourDigitsSigned, t);
    default:
      return en(new RegExp("^-?\\d{1," + e + "}"), t);
  }
}
function dv(e) {
  switch (e) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function Kb(e, t) {
  const n = t > 0, a = n ? t : 1 - t;
  let i;
  if (a <= 50)
    i = e || 100;
  else {
    const l = a + 50, r = Math.trunc(l / 100) * 100, s = e >= l % 100;
    i = e + r - (s ? 100 : 0);
  }
  return n ? i : 1 - i;
}
function Jb(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
class QU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 130);
    ze(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(n, a, i) {
    const l = (r) => ({
      year: r,
      isTwoDigitYear: a === "yy"
    });
    switch (a) {
      case "y":
        return fn(sn(4, n), l);
      case "yo":
        return fn(
          i.ordinalNumber(n, {
            unit: "year"
          }),
          l
        );
      default:
        return fn(sn(a.length, n), l);
    }
  }
  validate(n, a) {
    return a.isTwoDigitYear || a.year > 0;
  }
  set(n, a, i) {
    const l = n.getFullYear();
    if (i.isTwoDigitYear) {
      const s = Kb(
        i.year,
        l
      );
      return n.setFullYear(s, 0, 1), n.setHours(0, 0, 0, 0), n;
    }
    const r = !("era" in a) || a.era === 1 ? i.year : 1 - i.year;
    return n.setFullYear(r, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class AU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 130);
    ze(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    const l = (r) => ({
      year: r,
      isTwoDigitYear: a === "YY"
    });
    switch (a) {
      case "Y":
        return fn(sn(4, n), l);
      case "Yo":
        return fn(
          i.ordinalNumber(n, {
            unit: "year"
          }),
          l
        );
      default:
        return fn(sn(a.length, n), l);
    }
  }
  validate(n, a) {
    return a.isTwoDigitYear || a.year > 0;
  }
  set(n, a, i, l) {
    const r = uv(n, l);
    if (i.isTwoDigitYear) {
      const o = Kb(
        i.year,
        r
      );
      return n.setFullYear(
        o,
        0,
        l.firstWeekContainsDate
      ), n.setHours(0, 0, 0, 0), ti(n, l);
    }
    const s = !("era" in a) || a.era === 1 ? i.year : 1 - i.year;
    return n.setFullYear(s, 0, l.firstWeekContainsDate), n.setHours(0, 0, 0, 0), ti(n, l);
  }
}
class DU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 130);
    ze(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a) {
    return Ld(a === "R" ? 4 : a.length, n);
  }
  set(n, a, i) {
    const l = xt(n, 0);
    return l.setFullYear(i, 0, 4), l.setHours(0, 0, 0, 0), Is(l);
  }
}
class RU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 130);
    ze(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(n, a) {
    return Ld(a === "u" ? 4 : a.length, n);
  }
  set(n, a, i) {
    return n.setFullYear(i, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class IU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 120);
    ze(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    switch (a) {
      case "Q":
      case "QQ":
        return sn(a.length, n);
      case "Qo":
        return i.ordinalNumber(n, { unit: "quarter" });
      case "QQQ":
        return i.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return i.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return i.quarter(n, {
          width: "wide",
          context: "formatting"
        }) || i.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(n, a) {
    return a >= 1 && a <= 4;
  }
  set(n, a, i) {
    return n.setMonth((i - 1) * 3, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class BU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 120);
    ze(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    switch (a) {
      case "q":
      case "qq":
        return sn(a.length, n);
      case "qo":
        return i.ordinalNumber(n, { unit: "quarter" });
      case "qqq":
        return i.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || i.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return i.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return i.quarter(n, {
          width: "wide",
          context: "standalone"
        }) || i.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || i.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(n, a) {
    return a >= 1 && a <= 4;
  }
  set(n, a, i) {
    return n.setMonth((i - 1) * 3, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class ZU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    ze(this, "priority", 110);
  }
  parse(n, a, i) {
    const l = (r) => r - 1;
    switch (a) {
      case "M":
        return fn(
          en(dn.month, n),
          l
        );
      case "MM":
        return fn(sn(2, n), l);
      case "Mo":
        return fn(
          i.ordinalNumber(n, {
            unit: "month"
          }),
          l
        );
      case "MMM":
        return i.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.month(n, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return i.month(n, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return i.month(n, { width: "wide", context: "formatting" }) || i.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.month(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 11;
  }
  set(n, a, i) {
    return n.setMonth(i, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class EU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 110);
    ze(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    const l = (r) => r - 1;
    switch (a) {
      case "L":
        return fn(
          en(dn.month, n),
          l
        );
      case "LL":
        return fn(sn(2, n), l);
      case "Lo":
        return fn(
          i.ordinalNumber(n, {
            unit: "month"
          }),
          l
        );
      case "LLL":
        return i.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || i.month(n, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return i.month(n, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return i.month(n, { width: "wide", context: "standalone" }) || i.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || i.month(n, { width: "narrow", context: "standalone" });
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 11;
  }
  set(n, a, i) {
    return n.setMonth(i, 1), n.setHours(0, 0, 0, 0), n;
  }
}
function NU(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in), i = cv(a, n) - t;
  return a.setDate(a.getDate() - i * 7), tt(a, n == null ? void 0 : n.in);
}
class HU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 100);
    ze(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    switch (a) {
      case "w":
        return en(dn.week, n);
      case "wo":
        return i.ordinalNumber(n, { unit: "week" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    return a >= 1 && a <= 53;
  }
  set(n, a, i, l) {
    return ti(NU(n, i, l), l);
  }
}
function jU(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in), i = ov(a, n) - t;
  return a.setDate(a.getDate() - i * 7), a;
}
class zU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 100);
    ze(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    switch (a) {
      case "I":
        return en(dn.week, n);
      case "Io":
        return i.ordinalNumber(n, { unit: "week" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    return a >= 1 && a <= 53;
  }
  set(n, a, i) {
    return Is(jU(n, i));
  }
}
const FU = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], XU = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class YU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 90);
    ze(this, "subPriority", 1);
    ze(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    switch (a) {
      case "d":
        return en(dn.date, n);
      case "do":
        return i.ordinalNumber(n, { unit: "date" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    const i = n.getFullYear(), l = Jb(i), r = n.getMonth();
    return l ? a >= 1 && a <= XU[r] : a >= 1 && a <= FU[r];
  }
  set(n, a, i) {
    return n.setDate(i), n.setHours(0, 0, 0, 0), n;
  }
}
class WU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 90);
    ze(this, "subpriority", 1);
    ze(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    switch (a) {
      case "D":
      case "DD":
        return en(dn.dayOfYear, n);
      case "Do":
        return i.ordinalNumber(n, { unit: "date" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    const i = n.getFullYear();
    return Jb(i) ? a >= 1 && a <= 366 : a >= 1 && a <= 365;
  }
  set(n, a, i) {
    return n.setMonth(0, i), n.setHours(0, 0, 0, 0), n;
  }
}
function fv(e, t, n) {
  var d, f, h, m;
  const a = Fr(), i = (n == null ? void 0 : n.weekStartsOn) ?? ((f = (d = n == null ? void 0 : n.locale) == null ? void 0 : d.options) == null ? void 0 : f.weekStartsOn) ?? a.weekStartsOn ?? ((m = (h = a.locale) == null ? void 0 : h.options) == null ? void 0 : m.weekStartsOn) ?? 0, l = tt(e, n == null ? void 0 : n.in), r = l.getDay(), o = (t % 7 + 7) % 7, u = 7 - i, c = t < 0 || t > 6 ? t - (r + u) % 7 : (o + u) % 7 - (r + u) % 7;
  return Va(l, c, n);
}
class qU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 90);
    ze(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "E":
      case "EE":
      case "EEE":
        return i.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.day(n, { width: "short", context: "formatting" }) || i.day(n, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return i.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return i.day(n, { width: "short", context: "formatting" }) || i.day(n, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return i.day(n, { width: "wide", context: "formatting" }) || i.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.day(n, { width: "short", context: "formatting" }) || i.day(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 6;
  }
  set(n, a, i, l) {
    return n = fv(n, i, l), n.setHours(0, 0, 0, 0), n;
  }
}
class UU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 90);
    ze(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a, i, l) {
    const r = (s) => {
      const o = Math.floor((s - 1) / 7) * 7;
      return (s + l.weekStartsOn + 6) % 7 + o;
    };
    switch (a) {
      case "e":
      case "ee":
        return fn(sn(a.length, n), r);
      case "eo":
        return fn(
          i.ordinalNumber(n, {
            unit: "day"
          }),
          r
        );
      case "eee":
        return i.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.day(n, { width: "short", context: "formatting" }) || i.day(n, { width: "narrow", context: "formatting" });
      case "eeeee":
        return i.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return i.day(n, { width: "short", context: "formatting" }) || i.day(n, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return i.day(n, { width: "wide", context: "formatting" }) || i.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.day(n, { width: "short", context: "formatting" }) || i.day(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 6;
  }
  set(n, a, i, l) {
    return n = fv(n, i, l), n.setHours(0, 0, 0, 0), n;
  }
}
class GU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 90);
    ze(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(n, a, i, l) {
    const r = (s) => {
      const o = Math.floor((s - 1) / 7) * 7;
      return (s + l.weekStartsOn + 6) % 7 + o;
    };
    switch (a) {
      case "c":
      case "cc":
        return fn(sn(a.length, n), r);
      case "co":
        return fn(
          i.ordinalNumber(n, {
            unit: "day"
          }),
          r
        );
      case "ccc":
        return i.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || i.day(n, { width: "short", context: "standalone" }) || i.day(n, { width: "narrow", context: "standalone" });
      case "ccccc":
        return i.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return i.day(n, { width: "short", context: "standalone" }) || i.day(n, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return i.day(n, { width: "wide", context: "standalone" }) || i.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || i.day(n, { width: "short", context: "standalone" }) || i.day(n, { width: "narrow", context: "standalone" });
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 6;
  }
  set(n, a, i, l) {
    return n = fv(n, i, l), n.setHours(0, 0, 0, 0), n;
  }
}
function KU(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in), i = PU(a, n), l = t - i;
  return Va(a, l, n);
}
class JU extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 90);
    ze(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, a, i) {
    const l = (r) => r === 0 ? 7 : r;
    switch (a) {
      case "i":
      case "ii":
        return sn(a.length, n);
      case "io":
        return i.ordinalNumber(n, { unit: "day" });
      case "iii":
        return fn(
          i.day(n, {
            width: "abbreviated",
            context: "formatting"
          }) || i.day(n, {
            width: "short",
            context: "formatting"
          }) || i.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          l
        );
      case "iiiii":
        return fn(
          i.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          l
        );
      case "iiiiii":
        return fn(
          i.day(n, {
            width: "short",
            context: "formatting"
          }) || i.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          l
        );
      case "iiii":
      default:
        return fn(
          i.day(n, {
            width: "wide",
            context: "formatting"
          }) || i.day(n, {
            width: "abbreviated",
            context: "formatting"
          }) || i.day(n, {
            width: "short",
            context: "formatting"
          }) || i.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          l
        );
    }
  }
  validate(n, a) {
    return a >= 1 && a <= 7;
  }
  set(n, a, i) {
    return n = KU(n, i), n.setHours(0, 0, 0, 0), n;
  }
}
class eG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 80);
    ze(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "a":
      case "aa":
      case "aaa":
        return i.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return i.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, a, i) {
    return n.setHours(dv(i), 0, 0, 0), n;
  }
}
class tG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 80);
    ze(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "b":
      case "bb":
      case "bbb":
        return i.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return i.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, a, i) {
    return n.setHours(dv(i), 0, 0, 0), n;
  }
}
class nG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 80);
    ze(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "B":
      case "BB":
      case "BBB":
        return i.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return i.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || i.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, a, i) {
    return n.setHours(dv(i), 0, 0, 0), n;
  }
}
class aG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 70);
    ze(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "h":
        return en(dn.hour12h, n);
      case "ho":
        return i.ordinalNumber(n, { unit: "hour" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    return a >= 1 && a <= 12;
  }
  set(n, a, i) {
    const l = n.getHours() >= 12;
    return l && i < 12 ? n.setHours(i + 12, 0, 0, 0) : !l && i === 12 ? n.setHours(0, 0, 0, 0) : n.setHours(i, 0, 0, 0), n;
  }
}
class iG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 70);
    ze(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "H":
        return en(dn.hour23h, n);
      case "Ho":
        return i.ordinalNumber(n, { unit: "hour" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 23;
  }
  set(n, a, i) {
    return n.setHours(i, 0, 0, 0), n;
  }
}
class lG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 70);
    ze(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "K":
        return en(dn.hour11h, n);
      case "Ko":
        return i.ordinalNumber(n, { unit: "hour" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 11;
  }
  set(n, a, i) {
    return n.getHours() >= 12 && i < 12 ? n.setHours(i + 12, 0, 0, 0) : n.setHours(i, 0, 0, 0), n;
  }
}
class rG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 70);
    ze(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "k":
        return en(dn.hour24h, n);
      case "ko":
        return i.ordinalNumber(n, { unit: "hour" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    return a >= 1 && a <= 24;
  }
  set(n, a, i) {
    const l = i <= 24 ? i % 24 : i;
    return n.setHours(l, 0, 0, 0), n;
  }
}
class sG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 60);
    ze(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "m":
        return en(dn.minute, n);
      case "mo":
        return i.ordinalNumber(n, { unit: "minute" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 59;
  }
  set(n, a, i) {
    return n.setMinutes(i, 0, 0), n;
  }
}
class oG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 50);
    ze(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, a, i) {
    switch (a) {
      case "s":
        return en(dn.second, n);
      case "so":
        return i.ordinalNumber(n, { unit: "second" });
      default:
        return sn(a.length, n);
    }
  }
  validate(n, a) {
    return a >= 0 && a <= 59;
  }
  set(n, a, i) {
    return n.setSeconds(i, 0), n;
  }
}
class uG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 30);
    ze(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, a) {
    const i = (l) => Math.trunc(l * Math.pow(10, -a.length + 3));
    return fn(sn(a.length, n), i);
  }
  set(n, a, i) {
    return n.setMilliseconds(i), n;
  }
}
class cG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 10);
    ze(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(n, a) {
    switch (a) {
      case "X":
        return Oi(
          yi.basicOptionalMinutes,
          n
        );
      case "XX":
        return Oi(yi.basic, n);
      case "XXXX":
        return Oi(
          yi.basicOptionalSeconds,
          n
        );
      case "XXXXX":
        return Oi(
          yi.extendedOptionalSeconds,
          n
        );
      case "XXX":
      default:
        return Oi(yi.extended, n);
    }
  }
  set(n, a, i) {
    return a.timestampIsSet ? n : xt(
      n,
      n.getTime() - Td(n) - i
    );
  }
}
class dG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 10);
    ze(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(n, a) {
    switch (a) {
      case "x":
        return Oi(
          yi.basicOptionalMinutes,
          n
        );
      case "xx":
        return Oi(yi.basic, n);
      case "xxxx":
        return Oi(
          yi.basicOptionalSeconds,
          n
        );
      case "xxxxx":
        return Oi(
          yi.extendedOptionalSeconds,
          n
        );
      case "xxx":
      default:
        return Oi(yi.extended, n);
    }
  }
  set(n, a, i) {
    return a.timestampIsSet ? n : xt(
      n,
      n.getTime() - Td(n) - i
    );
  }
}
class fG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 40);
    ze(this, "incompatibleTokens", "*");
  }
  parse(n) {
    return Gb(n);
  }
  set(n, a, i) {
    return [xt(n, i * 1e3), { timestampIsSet: !0 }];
  }
}
class hG extends wt {
  constructor() {
    super(...arguments);
    ze(this, "priority", 20);
    ze(this, "incompatibleTokens", "*");
  }
  parse(n) {
    return Gb(n);
  }
  set(n, a, i) {
    return [xt(n, i), { timestampIsSet: !0 }];
  }
}
const mG = {
  G: new LU(),
  y: new QU(),
  Y: new AU(),
  R: new DU(),
  u: new RU(),
  Q: new IU(),
  q: new BU(),
  M: new ZU(),
  L: new EU(),
  w: new HU(),
  I: new zU(),
  d: new YU(),
  D: new WU(),
  E: new qU(),
  e: new UU(),
  c: new GU(),
  i: new JU(),
  a: new eG(),
  b: new tG(),
  B: new nG(),
  h: new aG(),
  H: new iG(),
  K: new lG(),
  k: new rG(),
  m: new sG(),
  s: new oG(),
  S: new uG(),
  X: new cG(),
  x: new dG(),
  t: new fG(),
  T: new hG()
}, vG = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, gG = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, pG = /^'([^]*?)'?$/, yG = /''/g, OG = /\S/, bG = /[a-zA-Z]/;
function G0(e, t, n, a) {
  var v, y, b, C, S, x, w, V;
  const i = () => xt((a == null ? void 0 : a.in) || n, NaN), l = xU(), r = (a == null ? void 0 : a.locale) ?? l.locale ?? sv, s = (a == null ? void 0 : a.firstWeekContainsDate) ?? ((y = (v = a == null ? void 0 : a.locale) == null ? void 0 : v.options) == null ? void 0 : y.firstWeekContainsDate) ?? l.firstWeekContainsDate ?? ((C = (b = l.locale) == null ? void 0 : b.options) == null ? void 0 : C.firstWeekContainsDate) ?? 1, o = (a == null ? void 0 : a.weekStartsOn) ?? ((x = (S = a == null ? void 0 : a.locale) == null ? void 0 : S.options) == null ? void 0 : x.weekStartsOn) ?? l.weekStartsOn ?? ((V = (w = l.locale) == null ? void 0 : w.options) == null ? void 0 : V.weekStartsOn) ?? 0;
  if (!t)
    return e ? i() : tt(n, a == null ? void 0 : a.in);
  const u = {
    firstWeekContainsDate: s,
    weekStartsOn: o,
    locale: r
  }, c = [new TU(a == null ? void 0 : a.in, n)], d = t.match(gG).map((_) => {
    const O = _[0];
    if (O in q0) {
      const $ = q0[O];
      return $(_, r.formatLong);
    }
    return _;
  }).join("").match(vG), f = [];
  for (let _ of d) {
    !(a != null && a.useAdditionalWeekYearTokens) && qb(_) && U0(_, t, e), !(a != null && a.useAdditionalDayOfYearTokens) && Wb(_) && U0(_, t, e);
    const O = _[0], $ = mG[O];
    if ($) {
      const { incompatibleTokens: P } = $;
      if (Array.isArray(P)) {
        const T = f.find(
          (L) => P.includes(L.token) || L.token === O
        );
        if (T)
          throw new RangeError(
            `The format string mustn't contain \`${T.fullToken}\` and \`${_}\` at the same time`
          );
      } else if ($.incompatibleTokens === "*" && f.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${_}\` and any other token at the same time`
        );
      f.push({ token: O, fullToken: _ });
      const M = $.run(
        e,
        _,
        r.match,
        u
      );
      if (!M)
        return i();
      c.push(M.setter), e = M.rest;
    } else {
      if (O.match(bG))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + O + "`"
        );
      if (_ === "''" ? _ = "'" : O === "'" && (_ = CG(_)), e.indexOf(_) === 0)
        e = e.slice(_.length);
      else
        return i();
    }
  }
  if (e.length > 0 && OG.test(e))
    return i();
  const h = c.map((_) => _.priority).sort((_, O) => O - _).filter((_, O, $) => $.indexOf(_) === O).map(
    (_) => c.filter((O) => O.priority === _).sort((O, $) => $.subPriority - O.subPriority)
  ).map((_) => _[0]);
  let m = tt(n, a == null ? void 0 : a.in);
  if (isNaN(+m)) return i();
  const g = {};
  for (const _ of h) {
    if (!_.validate(m, u))
      return i();
    const O = _.set(m, g, u);
    Array.isArray(O) ? (m = O[0], Object.assign(g, O[1])) : m = O;
  }
  return m;
}
function CG(e) {
  return e.match(pG)[1].replace(yG, "'");
}
function R4(e, t, n) {
  const [a, i] = Zu(
    n == null ? void 0 : n.in,
    e,
    t
  );
  return +rr(a) == +rr(i);
}
function eC(e, t, n) {
  return Va(e, -t, n);
}
function tC(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in), i = a.getFullYear(), l = a.getDate(), r = xt(e, 0);
  r.setFullYear(i, t, 15), r.setHours(0, 0, 0, 0);
  const s = SU(r);
  return a.setMonth(t, Math.min(l, s)), a;
}
function _t(e, t, n) {
  let a = tt(e, n == null ? void 0 : n.in);
  return isNaN(+a) ? xt(e, NaN) : (t.year != null && a.setFullYear(t.year), t.month != null && (a = tC(a, t.month)), t.date != null && a.setDate(t.date), t.hours != null && a.setHours(t.hours), t.minutes != null && a.setMinutes(t.minutes), t.seconds != null && a.setSeconds(t.seconds), t.milliseconds != null && a.setMilliseconds(t.milliseconds), a);
}
function wG(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in);
  return a.setHours(t), a;
}
function nC(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in);
  return a.setMilliseconds(t), a;
}
function kG(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in);
  return a.setMinutes(t), a;
}
function aC(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in);
  return a.setSeconds(t), a;
}
function xi(e, t, n) {
  const a = tt(e, n == null ? void 0 : n.in);
  return isNaN(+a) ? xt(e, NaN) : (a.setFullYear(t), a);
}
function Es(e, t, n) {
  return Ua(e, -t, n);
}
function SG(e, t, n) {
  const {
    years: a = 0,
    months: i = 0,
    weeks: l = 0,
    days: r = 0,
    hours: s = 0,
    minutes: o = 0,
    seconds: u = 0
  } = t, c = Es(e, i + a * 12, n), d = eC(c, r + l * 7, n), f = o + s * 60, m = (u + f * 60) * 1e3;
  return xt(e, +d - m);
}
function iC(e, t, n) {
  return rv(e, -t, n);
}
function io() {
  const e = K4();
  return N(), ee(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img",
      ...e
    },
    [
      ie("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      ie("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      ie("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      ie("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
io.compatConfig = {
  MODE: 3
};
function lC() {
  return N(), ee(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      ie("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      ie("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
lC.compatConfig = {
  MODE: 3
};
function hv() {
  return N(), ee(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      ie("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
hv.compatConfig = {
  MODE: 3
};
function mv() {
  return N(), ee(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      ie("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
mv.compatConfig = {
  MODE: 3
};
function vv() {
  return N(), ee(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      ie("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      ie("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
vv.compatConfig = {
  MODE: 3
};
function gv() {
  return N(), ee(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      ie("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
gv.compatConfig = {
  MODE: 3
};
function pv() {
  return N(), ee(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      ie("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
pv.compatConfig = {
  MODE: 3
};
const ga = (e, t) => t ? new Date(e.toLocaleString("en-US", { timeZone: t })) : new Date(e), yv = (e, t, n) => K0(e, t, n) || _e(), xG = (e, t, n) => {
  const a = t.dateInTz ? ga(new Date(e), t.dateInTz) : _e(e);
  return n ? In(a, !0) : a;
}, K0 = (e, t, n) => {
  if (!e) return null;
  const a = n ? In(_e(e), !0) : _e(e);
  return t ? t.exactMatch ? xG(e, t, n) : ga(a, t.timezone) : a;
}, PG = (e) => {
  const t = new Date(e.getFullYear(), 0, 1).getTimezoneOffset();
  return e.getTimezoneOffset() < t;
}, $G = (e, t) => {
  if (!e) return 0;
  const n = /* @__PURE__ */ new Date(), a = new Date(n.toLocaleString("en-US", { timeZone: "UTC" })), i = new Date(n.toLocaleString("en-US", { timeZone: e })), l = (PG(t ?? i) ? i : t ?? i).getTimezoneOffset() / 60;
  return (+a - +i) / (1e3 * 60 * 60) - l;
};
var ja = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e))(ja || {}), za = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e))(za || {}), mr = /* @__PURE__ */ ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(mr || {}), qn = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(qn || {});
const _G = ["timestamp", "date", "iso"];
var na = /* @__PURE__ */ ((e) => (e.up = "up", e.down = "down", e.left = "left", e.right = "right", e))(na || {}), Zt = /* @__PURE__ */ ((e) => (e.arrowUp = "ArrowUp", e.arrowDown = "ArrowDown", e.arrowLeft = "ArrowLeft", e.arrowRight = "ArrowRight", e.enter = "Enter", e.space = " ", e.esc = "Escape", e.tab = "Tab", e.home = "Home", e.end = "End", e.pageUp = "PageUp", e.pageDown = "PageDown", e))(Zt || {}), ps = /* @__PURE__ */ ((e) => (e.MONTH_AND_YEAR = "MM-yyyy", e.YEAR = "yyyy", e.DATE = "dd-MM-yyyy", e))(ps || {});
function I4(e) {
  return (t) => {
    const n = new Intl.DateTimeFormat(e, {
      weekday: "short",
      timeZone: "UTC"
    }).format(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`));
    return e === "ar" ? n.slice(2, 5) : n.slice(0, 2);
  };
}
function MG(e) {
  return (t) => _i(ga(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`), "UTC"), "EEEEEE", { locale: e });
}
const VG = (e, t, n) => {
  const a = [1, 2, 3, 4, 5, 6, 7];
  let i;
  if (e !== null)
    try {
      i = a.map(MG(e));
    } catch {
      i = a.map(I4(t));
    }
  else
    i = a.map(I4(t));
  const l = i.slice(0, n), r = i.slice(n + 1, i.length);
  return [i[n]].concat(...r).concat(...l);
}, Ov = (e, t, n) => {
  const a = [];
  for (let i = +e[0]; i <= +e[1]; i++)
    a.push({ value: +i, text: uC(i, t) });
  return n ? a.reverse() : a;
}, rC = (e, t, n) => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((l) => {
    const r = l < 10 ? `0${l}` : l;
    return /* @__PURE__ */ new Date(`2017-${r}-01T00:00:00+00:00`);
  });
  if (e !== null)
    try {
      const l = n === "long" ? "LLLL" : "LLL";
      return a.map((r, s) => {
        const o = _i(ga(r, "UTC"), l, { locale: e });
        return {
          text: o.charAt(0).toUpperCase() + o.substring(1),
          value: s
        };
      });
    } catch {
    }
  const i = new Intl.DateTimeFormat(t, { month: n, timeZone: "UTC" });
  return a.map((l, r) => {
    const s = i.format(l);
    return {
      text: s.charAt(0).toUpperCase() + s.substring(1),
      value: r
    };
  });
}, TG = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Cn = (e) => {
  const t = X(e);
  return t != null && t.$el ? t == null ? void 0 : t.$el : t;
}, LG = (e) => ({ type: "dot", ...e ?? {} }), sC = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, bv = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Qn = (e) => e, B4 = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, Z4 = (e) => e === null, oC = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, QG = (e) => {
  const t = [], n = (a) => a.filter((i) => i);
  for (let a = 0; a < e.length; a += 3) {
    const i = [e[a], e[a + 1], e[a + 2]];
    t.push(n(i));
  }
  return t;
}, mu = (e, t, n) => {
  const a = n != null, i = t != null;
  if (!a && !i) return !1;
  const l = +n, r = +t;
  return a && i ? +e > l || +e < r : a ? +e > l : i ? +e < r : !1;
}, Ns = (e, t) => QG(e).map((n) => n.map((a) => {
  const { active: i, disabled: l, isBetween: r, highlighted: s } = t(a);
  return {
    ...a,
    active: i,
    disabled: l,
    className: {
      dp__overlay_cell_active: i,
      dp__overlay_cell: !i,
      dp__overlay_cell_disabled: l,
      dp__overlay_cell_pad: !0,
      dp__overlay_cell_active_disabled: l && i,
      dp__cell_in_between: r,
      "dp--highlighted": s
    }
  };
})), Sl = (e, t, n = !1) => {
  e && t.allowStopPropagation && (n && e.stopImmediatePropagation(), e.stopPropagation());
}, AG = () => [
  "a[href]",
  "area[href]",
  "input:not([disabled]):not([type='hidden'])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "[tabindex]:not([tabindex='-1'])",
  "[data-datepicker-instance]"
].join(", ");
function DG(e, t) {
  let n = [...document.querySelectorAll(AG())];
  n = n.filter((i) => !e.contains(i) || i.hasAttribute("data-datepicker-instance"));
  const a = n.indexOf(e);
  if (a >= 0 && (t ? a - 1 >= 0 : a + 1 <= n.length))
    return n[a + (t ? -1 : 1)];
}
const J0 = (e, t) => e == null ? void 0 : e.querySelector(`[data-dp-element="${t}"]`), uC = (e, t) => new Intl.NumberFormat(t, { useGrouping: !1, style: "decimal" }).format(e), Cv = (e, t) => _i(e, t ?? ps.DATE), Zf = (e) => Array.isArray(e), Qd = (e, t, n) => t.get(Cv(e, n)), RG = (e, t) => e ? t ? t instanceof Map ? !!Qd(e, t) : t(_e(e)) : !1 : !0, ia = (e, t, n = !1, a) => {
  if (e.key === Zt.enter || e.key === Zt.space)
    return n && e.preventDefault(), t();
  if (a) return a(e);
}, IG = () => "ontouchstart" in window || navigator.maxTouchPoints > 0, cC = (e, t) => e ? ps.MONTH_AND_YEAR : t ? ps.YEAR : ps.DATE, dC = (e) => e < 10 ? `0${e}` : e, E4 = (e, t, n, a, i, l) => {
  const r = G0(e, t.slice(0, e.length), /* @__PURE__ */ new Date(), { locale: l });
  return Qo(r) && Nb(r) ? a || i ? r : _t(r, {
    hours: +n.hours,
    minutes: +(n == null ? void 0 : n.minutes),
    seconds: +(n == null ? void 0 : n.seconds),
    milliseconds: 0
  }) : null;
}, BG = (e, t, n, a, i, l) => {
  const r = Array.isArray(n) ? n[0] : n;
  if (typeof t == "string")
    return E4(e, t, r, a, i, l);
  if (Array.isArray(t)) {
    let s = null;
    for (const o of t)
      if (s = E4(e, o, r, a, i, l), s)
        break;
    return s;
  }
  return typeof t == "function" ? t(e) : null;
}, _e = (e) => e ? new Date(e) : /* @__PURE__ */ new Date(), ZG = (e, t, n) => {
  if (t) {
    const i = (e.getMonth() + 1).toString().padStart(2, "0"), l = e.getDate().toString().padStart(2, "0"), r = e.getHours().toString().padStart(2, "0"), s = e.getMinutes().toString().padStart(2, "0"), o = n ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${i}-${l}T${r}:${s}:${o}.000Z`;
  }
  const a = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(a).toISOString();
}, In = (e, t) => {
  const n = _e(JSON.parse(JSON.stringify(e))), a = _t(n, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
  return t ? Lq(a) : a;
}, xl = (e, t, n, a) => {
  let i = e ? _e(e) : _e();
  return (t || t === 0) && (i = wG(i, +t)), (n || n === 0) && (i = kG(i, +n)), (a || a === 0) && (i = aC(i, +a)), nC(i, 0);
}, an = (e, t) => !e || !t ? !1 : Zs(In(e), In(t)), ht = (e, t) => !e || !t ? !1 : us(In(e), In(t)), cn = (e, t) => !e || !t ? !1 : Vr(In(e), In(t)), vu = (e, t, n) => e != null && e[0] && e != null && e[1] ? cn(n, e[0]) && an(n, e[1]) : e != null && e[0] && t ? cn(n, e[0]) && an(n, t) || an(n, e[0]) && cn(n, t) : !1, Xa = (e) => {
  const t = _t(new Date(e), { date: 1 });
  return In(t);
}, Ef = (e, t, n) => t && (n || n === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((a) => a === t ? [a, n] : [a, isNaN(+e[a]) ? void 0 : +e[a]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
}, vr = (e) => ({
  hours: tl(e),
  minutes: Dl(e),
  seconds: Bs(e)
}), fC = (e, t) => {
  if (t) {
    const n = it(_e(t));
    if (n > e) return 12;
    if (n === e) return ft(_e(t));
  }
}, hC = (e, t) => {
  if (t) {
    const n = it(_e(t));
    return n < e ? -1 : n === e ? ft(_e(t)) : void 0;
  }
}, Hs = (e) => {
  if (e) return it(_e(e));
}, mC = (e, t) => {
  const n = cn(e, t) ? t : e, a = cn(t, e) ? t : e;
  return jb({ start: n, end: a });
}, EG = (e) => {
  const t = Ua(e, 1);
  return { month: ft(t), year: it(t) };
}, Hi = (e, t) => {
  const n = ti(e, { weekStartsOn: +t }), a = Fb(e, { weekStartsOn: +t });
  return [n, a];
}, vC = (e, t) => {
  const n = {
    hours: tl(_e()),
    minutes: Dl(_e()),
    seconds: t ? Bs(_e()) : 0
  };
  return Object.assign(n, e);
}, wl = (e, t, n) => [_t(_e(e), { date: 1 }), _t(_e(), { month: t, year: n, date: 1 })], zi = (e, t, n) => {
  let a = e ? _e(e) : _e();
  return (t || t === 0) && (a = tC(a, t)), n && (a = xi(a, n)), a;
}, gC = (e, t, n, a, i) => {
  if (!a || i && !t || !i && !n) return !1;
  const l = i ? Ua(e, 1) : Es(e, 1), r = [ft(l), it(l)];
  return i ? !HG(...r, t) : !NG(...r, n);
}, NG = (e, t, n) => an(...wl(n, e, t)) || ht(...wl(n, e, t)), HG = (e, t, n) => cn(...wl(n, e, t)) || ht(...wl(n, e, t)), pC = (e, t, n, a, i, l, r) => {
  if (typeof t == "function" && !r) return t(e);
  const s = n ? { locale: n } : void 0;
  return Array.isArray(e) ? `${_i(e[0], l, s)}${i && !e[1] ? "" : a}${e[1] ? _i(e[1], l, s) : ""}` : _i(e, l, s);
}, Kr = (e) => {
  if (e) return null;
  throw new Error(bv.prop("partial-range"));
}, bc = (e, t) => {
  if (t) return e();
  throw new Error(bv.prop("range"));
}, e2 = (e) => Array.isArray(e) ? Qo(e[0]) && (e[1] ? Qo(e[1]) : !0) : e ? Qo(e) : !1, jG = (e, t) => _t(t ?? _e(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), Nf = (e, t, n, a) => {
  if (!e) return !0;
  if (a) {
    const i = n === "max" ? Zs(e, t) : Vr(e, t), l = { seconds: 0, milliseconds: 0 };
    return i || us(_t(e, l), _t(t, l));
  }
  return n === "max" ? e.getTime() <= t.getTime() : e.getTime() >= t.getTime();
}, Hf = (e, t, n) => e ? jG(e, t) : _e(n ?? t), N4 = (e, t, n, a, i) => {
  if (Array.isArray(a)) {
    const r = Hf(e, a[0], t), s = Hf(e, a[1], t);
    return Nf(a[0], r, n, !!t) && Nf(a[1], s, n, !!t) && i;
  }
  const l = Hf(e, a, t);
  return Nf(a, l, n, !!t) && i;
}, jf = (e) => _t(_e(), vr(e)), zG = (e, t, n) => {
  if (e instanceof Map) {
    const a = `${dC(n + 1)}-${t}`;
    return e.size ? e.has(a) : !1;
  }
  return typeof e == "function" ? e(In(_t(_e(), { month: n, year: t }), !0)) : !1;
}, FG = (e, t, n) => {
  if (e instanceof Map) {
    const a = `${dC(n + 1)}-${t}`;
    return e.size ? e.has(a) : !0;
  }
  return !0;
}, yC = (e, t, n) => typeof e == "function" ? e({ month: t, year: n }) : !!e.months.find((a) => a.month === t && a.year === n), wv = (e, t) => typeof e == "function" ? e(t) : e.years.includes(t), t2 = (e) => `dp-${_i(e, "yyyy-MM-dd")}`, H4 = (e, t) => {
  const n = eC(In(t), e), a = Va(In(t), e);
  return { before: n, after: a };
}, vo = zt({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), OC = () => {
  const e = (n) => {
    vo.menuFocused = n;
  }, t = (n) => {
    vo.shiftKeyInMenu !== n && (vo.shiftKeyInMenu = n);
  };
  return {
    control: k(() => ({ shiftKeyInMenu: vo.shiftKeyInMenu, menuFocused: vo.menuFocused })),
    setMenuFocused: e,
    setShiftKey: t
  };
}, It = zt({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), zf = Y(null), Cc = Y(!1), Ff = Y(!1), Xf = Y(!1), Yf = Y(!1), Yn = Y(0), on = Y(0), Hl = () => {
  const e = k(() => Cc.value ? [...It.selectionGrid, It.actionRow].filter((d) => d.length) : Ff.value ? [
    ...It.timePicker[0],
    ...It.timePicker[1],
    Yf.value ? [] : [zf.value],
    It.actionRow
  ].filter((d) => d.length) : Xf.value ? [...It.monthPicker, It.actionRow] : [It.monthYear, ...It.calendar, It.time, It.actionRow].filter((d) => d.length)), t = (d) => {
    Yn.value = d ? Yn.value + 1 : Yn.value - 1;
    let f = null;
    e.value[on.value] && (f = e.value[on.value][Yn.value]), !f && e.value[on.value + (d ? 1 : -1)] ? (on.value = on.value + (d ? 1 : -1), Yn.value = d ? 0 : e.value[on.value].length - 1) : f || (Yn.value = d ? Yn.value - 1 : Yn.value + 1);
  }, n = (d) => {
    on.value === 0 && !d || on.value === e.value.length && d || (on.value = d ? on.value + 1 : on.value - 1, e.value[on.value] ? e.value[on.value] && !e.value[on.value][Yn.value] && Yn.value !== 0 && (Yn.value = e.value[on.value].length - 1) : on.value = d ? on.value - 1 : on.value + 1);
  }, a = (d) => {
    let f = null;
    e.value[on.value] && (f = e.value[on.value][Yn.value]), f ? f.focus({ preventScroll: !Cc.value }) : Yn.value = d ? Yn.value - 1 : Yn.value + 1;
  }, i = () => {
    t(!0), a(!0);
  }, l = () => {
    t(!1), a(!1);
  }, r = () => {
    n(!1), a(!0);
  }, s = () => {
    n(!0), a(!0);
  }, o = (d, f) => {
    It[f] = d;
  }, u = (d, f) => {
    It[f] = d;
  }, c = () => {
    Yn.value = 0, on.value = 0;
  };
  return {
    buildMatrix: o,
    buildMultiLevelMatrix: u,
    setTimePickerBackRef: (d) => {
      zf.value = d;
    },
    setSelectionGrid: (d) => {
      Cc.value = d, c(), d || (It.selectionGrid = []);
    },
    setTimePicker: (d, f = !1) => {
      Ff.value = d, Yf.value = f, c(), d || (It.timePicker[0] = [], It.timePicker[1] = []);
    },
    setTimePickerElements: (d, f = 0) => {
      It.timePicker[f] = d;
    },
    arrowRight: i,
    arrowLeft: l,
    arrowUp: r,
    arrowDown: s,
    clearArrowNav: () => {
      It.monthYear = [], It.calendar = [], It.time = [], It.actionRow = [], It.selectionGrid = [], It.timePicker[0] = [], It.timePicker[1] = [], Cc.value = !1, Ff.value = !1, Yf.value = !1, Xf.value = !1, c(), zf.value = null;
    },
    setMonthPicker: (d) => {
      Xf.value = d, c();
    },
    refSets: It
    // exposed for testing
  };
}, j4 = (e) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e ?? {}
}), XG = (e) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (t) => `Increment ${t}`,
  decrementValue: (t) => `Decrement ${t}`,
  openTpOverlay: (t) => `Open ${t} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: void 0,
  weekDay: void 0,
  clearInput: "Clear value",
  calendarIcon: "Calendar icon",
  timePicker: "Time picker",
  monthPicker: (t) => `Month picker${t ? " overlay" : ""}`,
  yearPicker: (t) => `Year picker${t ? " overlay" : ""}`,
  timeOverlay: (t) => `${t} overlay`,
  ...e ?? {}
}), z4 = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0, YG = (e) => {
  const t = typeof e == "object" && e, n = {
    static: !0,
    solo: !1
  };
  if (!e) return { ...n, count: z4(!1) };
  const a = t ? e : {}, i = t ? a.count ?? !0 : e, l = z4(i);
  return Object.assign(n, a, { count: l });
}, WG = (e, t, n) => e || (typeof n == "string" ? n : t), qG = (e) => typeof e == "boolean" ? e ? j4({}) : !1 : j4(e), UG = (e) => {
  const t = {
    enterSubmit: !0,
    tabSubmit: !0,
    openMenu: "open",
    selectOnFocus: !1,
    rangeSeparator: " - ",
    escClose: !0
  };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: !0 } : { ...t, enabled: e };
}, GG = (e) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e ?? {}
}), KG = (e) => ({
  showSelect: !0,
  showCancel: !0,
  showNow: !1,
  showPreview: !0,
  ...e ?? {}
}), JG = (e) => {
  const t = { input: !1 };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: !0 } : {
    enabled: e,
    ...t
  };
}, eK = (e) => ({ allowStopPropagation: !0, closeOnScroll: !1, modeHeight: 255, allowPreventDefault: !1, closeOnClearValue: !0, closeOnAutoApply: !0, noSwipe: !1, keepActionRow: !1, onClickOutside: void 0, tabOutClosesMenu: !0, arrowLeft: void 0, keepViewOnOffsetClick: !1, timeArrowHoldThreshold: 0, shadowDom: !1, mobileBreakpoint: 600, setDateOnMenuClose: !1, ...e ?? {} }), tK = (e) => {
  const t = {
    dates: Array.isArray(e) ? e.map((n) => _e(n)) : [],
    years: [],
    months: [],
    quarters: [],
    weeks: [],
    weekdays: [],
    options: { highlightDisabled: !1 }
  };
  return typeof e == "function" ? e : { ...t, ...e ?? {} };
}, nK = (e) => typeof e == "object" ? {
  type: (e == null ? void 0 : e.type) ?? "local",
  hideOnOffsetDates: (e == null ? void 0 : e.hideOnOffsetDates) ?? !1
} : {
  type: e,
  hideOnOffsetDates: !1
}, aK = (e) => {
  const t = {
    noDisabledRange: !1,
    showLastInRange: !0,
    minMaxRawRange: !1,
    partialRange: !0,
    disableTimeRangeValidation: !1,
    maxRange: void 0,
    minRange: void 0,
    autoRange: void 0,
    fixedStart: !1,
    fixedEnd: !1
  };
  return typeof e == "object" ? { enabled: !0, ...t, ...e } : {
    enabled: e,
    ...t
  };
}, iK = (e) => e ? typeof e == "string" ? {
  timezone: e,
  exactMatch: !1,
  dateInTz: void 0,
  emitTimezone: void 0,
  convertModel: !0
} : {
  timezone: e.timezone,
  exactMatch: e.exactMatch ?? !1,
  dateInTz: e.dateInTz ?? void 0,
  emitTimezone: e.emitTimezone ?? void 0,
  convertModel: e.convertModel ?? !0
} : { timezone: void 0, exactMatch: !1, emitTimezone: void 0 }, Wf = (e, t, n, a) => new Map(
  e.map((i) => {
    const l = yv(i, t, a);
    return [Cv(l, n), l];
  })
), lK = (e, t) => e.length ? new Map(
  e.map((n) => {
    const a = yv(n.date, t);
    return [Cv(a, ps.DATE), n];
  })
) : null, rK = (e) => {
  var t;
  const n = cC(e.isMonthPicker, e.isYearPicker);
  return {
    minDate: K0(e.minDate, e.timezone, e.isSpecific),
    maxDate: K0(e.maxDate, e.timezone, e.isSpecific),
    disabledDates: Zf(e.disabledDates) ? Wf(e.disabledDates, e.timezone, n, e.isSpecific) : e.disabledDates,
    allowedDates: Zf(e.allowedDates) ? Wf(e.allowedDates, e.timezone, n, e.isSpecific) : null,
    highlight: typeof e.highlight == "object" && Zf((t = e.highlight) == null ? void 0 : t.dates) ? Wf(e.highlight.dates, e.timezone, n) : e.highlight,
    markers: lK(e.markers, e.timezone)
  };
}, sK = (e) => typeof e == "boolean" ? { enabled: e, dragSelect: !0, limit: null } : {
  enabled: !!e,
  limit: e.limit ? +e.limit : null,
  dragSelect: e.dragSelect ?? !0
}, oK = (e) => ({
  ...Object.fromEntries(
    Object.keys(e).map((t) => {
      const n = t, a = e[n], i = typeof e[n] == "string" ? { [a]: !0 } : Object.fromEntries(a.map((l) => [l, !0]));
      return [t, i];
    })
  )
}), Gt = (e) => {
  const t = () => {
    const w = e.enableSeconds ? ":ss" : "", V = e.enableMinutes ? ":mm" : "";
    return e.is24 ? `HH${V}${w}` : `hh${V}${w} aa`;
  }, n = () => {
    var w;
    return e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? t() : e.weekPicker ? `${((w = v.value) == null ? void 0 : w.type) === "iso" ? "II" : "ww"}-RR` : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${t()}` : "MM/dd/yyyy";
  }, a = (w) => vC(w, e.enableSeconds), i = () => S.value.enabled ? e.startTime && Array.isArray(e.startTime) ? [a(e.startTime[0]), a(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? a(e.startTime) : null, l = k(() => YG(e.multiCalendars)), r = k(() => i()), s = k(() => XG(e.ariaLabels)), o = k(() => GG(e.filters)), u = k(() => qG(e.transitions)), c = k(() => KG(e.actionRow)), d = k(
    () => WG(e.previewFormat, e.format, n())
  ), f = k(() => UG(e.textInput)), h = k(() => JG(e.inline)), m = k(() => eK(e.config)), g = k(() => tK(e.highlight)), v = k(() => nK(e.weekNumbers)), y = k(() => iK(e.timezone)), b = k(() => sK(e.multiDates)), C = k(
    () => rK({
      minDate: e.minDate,
      maxDate: e.maxDate,
      disabledDates: e.disabledDates,
      allowedDates: e.allowedDates,
      highlight: g.value,
      markers: e.markers,
      timezone: y.value,
      isSpecific: e.monthPicker || e.yearPicker || e.quarterPicker,
      isMonthPicker: e.monthPicker,
      isYearPicker: e.yearPicker
    })
  ), S = k(() => aK(e.range)), x = k(() => oK(e.ui));
  return {
    defaultedTransitions: u,
    defaultedMultiCalendars: l,
    defaultedStartTime: r,
    defaultedAriaLabels: s,
    defaultedFilters: o,
    defaultedActionRow: c,
    defaultedPreviewFormat: d,
    defaultedTextInput: f,
    defaultedInline: h,
    defaultedConfig: m,
    defaultedHighlight: g,
    defaultedWeekNumbers: v,
    defaultedRange: S,
    propDates: C,
    defaultedTz: y,
    defaultedMultiDates: b,
    defaultedUI: x,
    getDefaultPattern: n,
    getDefaultStartTime: i,
    handleEventPropagation: (w) => {
      m.value.allowStopPropagation && w.stopPropagation(), m.value.allowPreventDefault && w.preventDefault();
    }
  };
}, uK = (e, t, n) => {
  const a = Y(), { defaultedTextInput: i, defaultedRange: l, defaultedTz: r, defaultedMultiDates: s, getDefaultPattern: o } = Gt(t), u = Y(""), c = ue(t, "format"), d = ue(t, "formatLocale");
  pe(
    a,
    () => {
      typeof t.onInternalModelChange == "function" && e("internal-model-change", a.value, E(!0));
    },
    { deep: !0 }
  ), pe(l, (Q, W) => {
    Q.enabled !== W.enabled && (a.value = null);
  }), pe(c, () => {
    j();
  });
  const f = (Q) => r.value.timezone && r.value.convertModel ? ga(Q, r.value.timezone) : Q, h = (Q) => {
    if (r.value.timezone && r.value.convertModel) {
      const W = $G(r.value.timezone, Q);
      return xq(Q, W);
    }
    return Q;
  }, m = (Q, W, se = !1) => pC(
    Q,
    t.format,
    t.formatLocale,
    i.value.rangeSeparator,
    t.modelAuto,
    W ?? o(),
    se
  ), g = (Q) => Q ? t.modelType ? Z(Q) : {
    hours: tl(Q),
    minutes: Dl(Q),
    seconds: t.enableSeconds ? Bs(Q) : 0
  } : null, v = (Q) => t.modelType ? Z(Q) : { month: ft(Q), year: it(Q) }, y = (Q) => Array.isArray(Q) ? s.value.enabled ? Q.map((W) => b(W, xi(_e(), W))) : bc(
    () => [
      xi(_e(), Q[0]),
      Q[1] ? xi(_e(), Q[1]) : Kr(l.value.partialRange)
    ],
    l.value.enabled
  ) : xi(_e(), +Q), b = (Q, W) => (typeof Q == "string" || typeof Q == "number") && t.modelType ? I(Q) : W, C = (Q) => Array.isArray(Q) ? [
    b(
      Q[0],
      xl(null, +Q[0].hours, +Q[0].minutes, Q[0].seconds)
    ),
    b(
      Q[1],
      xl(null, +Q[1].hours, +Q[1].minutes, Q[1].seconds)
    )
  ] : b(Q, xl(null, Q.hours, Q.minutes, Q.seconds)), S = (Q) => {
    const W = _t(_e(), { date: 1 });
    return Array.isArray(Q) ? s.value.enabled ? Q.map((se) => b(se, zi(W, +se.month, +se.year))) : bc(
      () => [
        b(Q[0], zi(W, +Q[0].month, +Q[0].year)),
        b(
          Q[1],
          Q[1] ? zi(W, +Q[1].month, +Q[1].year) : Kr(l.value.partialRange)
        )
      ],
      l.value.enabled
    ) : b(Q, zi(W, +Q.month, +Q.year));
  }, x = (Q) => {
    if (Array.isArray(Q))
      return Q.map((W) => I(W));
    throw new Error(bv.dateArr("multi-dates"));
  }, w = (Q) => {
    if (Array.isArray(Q) && l.value.enabled) {
      const W = Q[0], se = Q[1];
      return [
        _e(Array.isArray(W) ? W[0] : null),
        Array.isArray(se) && se.length ? _e(se[0]) : null
      ];
    }
    return _e(Q[0]);
  }, V = (Q) => t.modelAuto ? Array.isArray(Q) ? [I(Q[0]), I(Q[1])] : t.autoApply ? [I(Q)] : [I(Q), null] : Array.isArray(Q) ? bc(
    () => Q[1] ? [
      I(Q[0]),
      Q[1] ? I(Q[1]) : Kr(l.value.partialRange)
    ] : [I(Q[0])],
    l.value.enabled
  ) : I(Q), _ = () => {
    Array.isArray(a.value) && l.value.enabled && a.value.length === 1 && a.value.push(Kr(l.value.partialRange));
  }, O = () => {
    const Q = a.value;
    return [
      Z(Q[0]),
      Q[1] ? Z(Q[1]) : Kr(l.value.partialRange)
    ];
  }, $ = () => Array.isArray(a.value) ? a.value[1] ? O() : Z(Qn(a.value[0])) : [], P = () => (a.value || []).map((Q) => Z(Q)), M = (Q = !1) => (Q || _(), t.modelAuto ? $() : s.value.enabled ? P() : Array.isArray(a.value) ? bc(() => O(), l.value.enabled) : Z(Qn(a.value))), T = (Q) => !Q || Array.isArray(Q) && !Q.length ? null : t.timePicker ? C(Qn(Q)) : t.monthPicker ? S(Qn(Q)) : t.yearPicker ? y(Qn(Q)) : s.value.enabled ? x(Qn(Q)) : t.weekPicker ? w(Qn(Q)) : V(Qn(Q)), L = (Q) => {
    const W = T(Q);
    e2(Qn(W)) ? (a.value = Qn(W), j()) : (a.value = null, u.value = "");
  }, A = () => {
    const Q = (W) => _i(W, i.value.format);
    return `${Q(a.value[0])} ${i.value.rangeSeparator} ${a.value[1] ? Q(a.value[1]) : ""}`;
  }, D = () => n.value && a.value ? Array.isArray(a.value) ? A() : _i(a.value, i.value.format) : m(a.value), B = () => a.value ? s.value.enabled ? a.value.map((Q) => m(Q)).join("; ") : i.value.enabled && typeof i.value.format == "string" ? D() : m(a.value) : "", j = () => {
    !t.format || typeof t.format == "string" || i.value.enabled && typeof i.value.format == "string" ? u.value = B() : u.value = t.format(a.value);
  }, I = (Q) => {
    if (t.utc) {
      const W = new Date(Q);
      return t.utc === "preserve" ? new Date(W.getTime() + W.getTimezoneOffset() * 6e4) : W;
    }
    return t.modelType ? _G.includes(t.modelType) ? f(new Date(Q)) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? f(
      G0(Q, o(), /* @__PURE__ */ new Date(), { locale: d.value })
    ) : f(
      G0(Q, t.modelType, /* @__PURE__ */ new Date(), { locale: d.value })
    ) : f(new Date(Q));
  }, Z = (Q) => Q ? t.utc ? ZG(Q, t.utc === "preserve", t.enableSeconds) : t.modelType ? t.modelType === "timestamp" ? +h(Q) : t.modelType === "iso" ? h(Q).toISOString() : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? m(h(Q)) : m(h(Q), t.modelType, !0) : h(Q) : "", R = (Q, W = !1, se = !1) => {
    if (se) return Q;
    if (e("update:model-value", Q), r.value.emitTimezone && W) {
      const Se = Array.isArray(Q) ? Q.map((U) => ga(Qn(U), r.value.emitTimezone)) : ga(Qn(Q), r.value.emitTimezone);
      e("update:model-timezone-value", Se);
    }
  }, J = (Q) => Array.isArray(a.value) ? s.value.enabled ? a.value.map((W) => Q(W)) : [
    Q(a.value[0]),
    a.value[1] ? Q(a.value[1]) : Kr(l.value.partialRange)
  ] : Q(Qn(a.value)), F = () => {
    if (Array.isArray(a.value)) {
      const Q = Hi(a.value[0], t.weekStart), W = a.value[1] ? Hi(a.value[1], t.weekStart) : [];
      return [Q.map((se) => _e(se)), W.map((se) => _e(se))];
    }
    return Hi(a.value, t.weekStart).map((Q) => _e(Q));
  }, q = (Q, W) => R(Qn(J(Q)), !1, W), z = (Q) => {
    const W = F();
    return Q ? W : e("update:model-value", F());
  }, E = (Q = !1) => (Q || j(), t.monthPicker ? q(v, Q) : t.timePicker ? q(g, Q) : t.yearPicker ? q(it, Q) : t.weekPicker ? z(Q) : R(M(Q), !0, Q));
  return {
    inputValue: u,
    internalModelValue: a,
    checkBeforeEmit: () => a.value ? l.value.enabled ? l.value.partialRange ? a.value.length >= 1 : a.value.length === 2 : !!a.value : !1,
    parseExternalModelValue: L,
    formatInputValue: j,
    emitModelValue: E
  };
}, cK = (e, t) => {
  const { defaultedFilters: n, propDates: a } = Gt(e), { validateMonthYearInRange: i } = jl(e), l = (c, d) => {
    let f = c;
    return n.value.months.includes(ft(f)) ? (f = d ? Ua(c, 1) : Es(c, 1), l(f, d)) : f;
  }, r = (c, d) => {
    let f = c;
    return n.value.years.includes(it(f)) ? (f = d ? rv(c, 1) : iC(c, 1), r(f, d)) : f;
  }, s = (c, d = !1) => {
    const f = _t(_e(), { month: e.month, year: e.year });
    let h = c ? Ua(f, 1) : Es(f, 1);
    e.disableYearSelect && (h = xi(h, e.year));
    let m = ft(h), g = it(h);
    n.value.months.includes(m) && (h = l(h, c), m = ft(h), g = it(h)), n.value.years.includes(g) && (h = r(h, c), g = it(h)), i(m, g, c, e.preventMinMaxNavigation) && o(m, g, d);
  }, o = (c, d, f) => {
    t("update-month-year", { month: c, year: d, fromNav: f });
  }, u = k(() => (c) => gC(
    _t(_e(), { month: e.month, year: e.year }),
    a.value.maxDate,
    a.value.minDate,
    e.preventMinMaxNavigation,
    c
  ));
  return { handleMonthYearChange: s, isDisabled: u, updateMonthYear: o };
}, R1 = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  autoPosition: { type: [Boolean, String], default: !0 },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: [String, Object], default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  disableYearSelect: { type: Boolean, default: !1 },
  dayClass: {
    type: Function,
    default: null
  },
  yearRange: { type: Array, default: () => [1900, 2100] },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: !1 },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  reverseYears: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  highlight: {
    type: [Function, Object],
    default: null
  },
  teleport: { type: [Boolean, String, Object], default: null },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function, Object],
    default: null
  },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: [Object, Boolean], default: !1 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  alwaysClearable: { type: Boolean, default: !1 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: [Boolean, Object], default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: [Boolean, Object], default: !1 },
  textInput: { type: [Boolean, Object], default: !1 },
  sixWeeks: { type: [Boolean, String], default: !1 },
  actionRow: { type: Object, default: () => ({}) },
  focusStartDate: { type: Boolean, default: !1 },
  disabledTimes: { type: [Function, Array], default: void 0 },
  timePickerInline: { type: Boolean, default: !1 },
  calendar: { type: Function, default: null },
  config: { type: Object, default: void 0 },
  quarterPicker: { type: Boolean, default: !1 },
  yearFirst: { type: Boolean, default: !1 },
  loading: { type: Boolean, default: !1 },
  onInternalModelChange: { type: [Function, Object], default: null },
  enableMinutes: { type: Boolean, default: !0 },
  ui: { type: Object, default: () => ({}) }
}, si = {
  ...R1,
  shadow: { type: Boolean, default: !1 },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  noOverlayFocus: { type: Boolean, default: !1 },
  collapse: { type: Boolean, default: !1 },
  menuWrapRef: { type: Object, default: null },
  getInputRect: { type: Function, default: () => ({}) },
  isTextInputDate: { type: Boolean, default: !1 },
  isMobile: { type: Boolean, default: void 0 }
}, dK = ["title"], fK = ["disabled"], hK = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    ...si
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: t }) {
    const n = t, a = e, {
      defaultedActionRow: i,
      defaultedPreviewFormat: l,
      defaultedMultiCalendars: r,
      defaultedTextInput: s,
      defaultedInline: o,
      defaultedRange: u,
      defaultedMultiDates: c
    } = Gt(a), { isTimeValid: d, isMonthValid: f } = jl(a), { buildMatrix: h } = Hl(), m = Y(null), g = Y(null), v = Y(!1), y = Y({}), b = Y(null), C = Y(null);
    rt(() => {
      a.arrowNavigation && h([Cn(m), Cn(g)], "actionRow"), S(), window.addEventListener("resize", S);
    }), ni(() => {
      window.removeEventListener("resize", S);
    });
    const S = () => {
      v.value = !1, setTimeout(() => {
        var L, A;
        const D = (L = b.value) == null ? void 0 : L.getBoundingClientRect(), B = (A = C.value) == null ? void 0 : A.getBoundingClientRect();
        D && B && (y.value.maxWidth = `${B.width - D.width - 20}px`), v.value = !0;
      }, 0);
    }, x = k(() => u.value.enabled && !u.value.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : !0), w = k(
      () => !d.value(a.internalModelValue) || !f.value(a.internalModelValue) || !x.value
    ), V = () => {
      const L = l.value;
      return a.timePicker || a.monthPicker, L(Qn(a.internalModelValue));
    }, _ = () => {
      const L = a.internalModelValue;
      return r.value.count > 0 ? `${O(L[0])} - ${O(L[1])}` : [O(L[0]), O(L[1])];
    }, O = (L) => pC(
      L,
      l.value,
      a.formatLocale,
      s.value.rangeSeparator,
      a.modelAuto,
      l.value
    ), $ = k(() => !a.internalModelValue || !a.menuMount ? "" : typeof l.value == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? _() : c.value.enabled ? a.internalModelValue.map((L) => `${O(L)}`) : a.modelAuto ? `${O(a.internalModelValue[0])}` : `${O(a.internalModelValue[0])} -` : O(a.internalModelValue) : V()), P = () => c.value.enabled ? "; " : " - ", M = k(
      () => Array.isArray($.value) ? $.value.join(P()) : $.value
    ), T = () => {
      d.value(a.internalModelValue) && f.value(a.internalModelValue) && x.value ? n("select-date") : n("invalid-select");
    };
    return (L, A) => (N(), ee("div", {
      ref_key: "actionRowRef",
      ref: C,
      class: "dp__action_row"
    }, [
      L.$slots["action-row"] ? ke(L.$slots, "action-row", Pt(fe({ key: 0 }, {
        internalModelValue: L.internalModelValue,
        disabled: w.value,
        selectDate: () => L.$emit("select-date"),
        closePicker: () => L.$emit("close-picker")
      }))) : (N(), ee(ge, { key: 1 }, [
        X(i).showPreview ? (N(), ee("div", {
          key: 0,
          class: "dp__selection_preview",
          title: M.value,
          style: Ot(y.value)
        }, [
          L.$slots["action-preview"] && v.value ? ke(L.$slots, "action-preview", {
            key: 0,
            value: L.internalModelValue
          }) : de("", !0),
          !L.$slots["action-preview"] && v.value ? (N(), ee(ge, { key: 1 }, [
            Ee(xe(M.value), 1)
          ], 64)) : de("", !0)
        ], 12, dK)) : de("", !0),
        ie("div", {
          ref_key: "actionBtnContainer",
          ref: b,
          class: "dp__action_buttons",
          "data-dp-element": "action-row"
        }, [
          L.$slots["action-buttons"] ? ke(L.$slots, "action-buttons", {
            key: 0,
            value: L.internalModelValue
          }) : de("", !0),
          L.$slots["action-buttons"] ? de("", !0) : (N(), ee(ge, { key: 1 }, [
            !X(o).enabled && X(i).showCancel ? (N(), ee("button", {
              key: 0,
              ref_key: "cancelButtonRef",
              ref: m,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: A[0] || (A[0] = (D) => L.$emit("close-picker")),
              onKeydown: A[1] || (A[1] = (D) => X(ia)(D, () => L.$emit("close-picker")))
            }, xe(L.cancelText), 545)) : de("", !0),
            X(i).showNow ? (N(), ee("button", {
              key: 1,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: A[2] || (A[2] = (D) => L.$emit("select-now")),
              onKeydown: A[3] || (A[3] = (D) => X(ia)(D, () => L.$emit("select-now")))
            }, xe(L.nowButtonLabel), 33)) : de("", !0),
            X(i).showSelect ? (N(), ee("button", {
              key: 2,
              ref_key: "selectButtonRef",
              ref: g,
              type: "button",
              class: "dp__action_button dp__action_select",
              disabled: w.value,
              "data-test-id": "select-button",
              onKeydown: A[4] || (A[4] = (D) => X(ia)(D, () => T())),
              onClick: T
            }, xe(L.selectText), 41, fK)) : de("", !0)
          ], 64))
        ], 512)
      ], 64))
    ], 512));
  }
}), mK = ["role", "aria-label", "tabindex"], vK = { class: "dp__selection_grid_header" }, gK = ["aria-selected", "aria-disabled", "data-test-id", "onClick", "onKeydown", "onMouseover"], pK = ["aria-label"], Eu = /* @__PURE__ */ Sn({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] },
    config: {},
    noOverlayFocus: { type: Boolean },
    focusValue: {},
    menuWrapRef: {},
    ariaLabels: {},
    overlayLabel: {}
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: t, emit: n }) {
    const { setSelectionGrid: a, buildMultiLevelMatrix: i, setMonthPicker: l } = Hl(), r = n, s = e, { defaultedAriaLabels: o, defaultedTextInput: u, defaultedConfig: c, handleEventPropagation: d } = Gt(
      s
    ), { hideNavigationButtons: f } = Z1(), h = Y(!1), m = Y(null), g = Y(null), v = Y([]), y = Y(), b = Y(null), C = Y(0), S = Y(null);
    G4(() => {
      m.value = null;
    }), rt(() => {
      et().then(() => M()), s.noOverlayFocus || w(), x(!0);
    }), ni(() => x(!1));
    const x = (F) => {
      var q;
      s.arrowNavigation && ((q = s.headerRefs) != null && q.length ? l(F) : a(F));
    }, w = () => {
      var F;
      const q = Cn(g);
      q && (u.value.enabled || (m.value ? (F = m.value) == null || F.focus({ preventScroll: !0 }) : q.focus({ preventScroll: !0 })), h.value = q.clientHeight < q.scrollHeight);
    }, V = k(
      () => ({
        dp__overlay: !0,
        "dp--overlay-absolute": !s.useRelative,
        "dp--overlay-relative": s.useRelative
      })
    ), _ = k(
      () => s.useRelative ? { height: `${s.height}px`, width: "var(--dp-menu-min-width)" } : void 0
    ), O = k(() => ({
      dp__overlay_col: !0
    })), $ = k(
      () => ({
        dp__btn: !0,
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: h.value,
        dp__button_bottom: s.isLast
      })
    ), P = k(() => {
      var F, q;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((F = s.items) == null ? void 0 : F.length) <= 6,
        dp__container_block: ((q = s.items) == null ? void 0 : q.length) > 6
      };
    });
    pe(
      () => s.items,
      () => M(!1),
      { deep: !0 }
    );
    const M = (F = !0) => {
      et().then(() => {
        const q = Cn(m), z = Cn(g), E = Cn(b), Q = Cn(S), W = E ? E.getBoundingClientRect().height : 0;
        z && (z.getBoundingClientRect().height ? C.value = z.getBoundingClientRect().height - W : C.value = c.value.modeHeight - W), q && Q && F && (Q.scrollTop = q.offsetTop - Q.offsetTop - (C.value / 2 - q.getBoundingClientRect().height) - W);
      });
    }, T = (F) => {
      F.disabled || r("selected", F.value);
    }, L = () => {
      r("toggle"), r("reset-flow");
    }, A = (F) => {
      s.escClose && (L(), d(F));
    }, D = (F, q, z, E) => {
      F && ((q.active || q.value === s.focusValue) && (m.value = F), s.arrowNavigation && (Array.isArray(v.value[z]) ? v.value[z][E] = F : v.value[z] = [F], B()));
    }, B = () => {
      var F, q;
      const z = (F = s.headerRefs) != null && F.length ? [s.headerRefs].concat(v.value) : v.value.concat([s.skipButtonRef ? [] : [b.value]]);
      i(Qn(z), (q = s.headerRefs) != null && q.length ? "monthPicker" : "selectionGrid");
    }, j = (F) => {
      s.arrowNavigation || Sl(F, c.value, !0);
    }, I = (F) => {
      y.value = F, r("hover-value", F);
    }, Z = () => {
      if (L(), !s.isLast) {
        const F = J0(s.menuWrapRef ?? null, "action-row");
        if (F) {
          const q = oC(F);
          q == null || q.focus();
        }
      }
    }, R = (F) => {
      switch (F.key) {
        case Zt.esc:
          return A(F);
        case Zt.arrowLeft:
          return j(F);
        case Zt.arrowRight:
          return j(F);
        case Zt.arrowUp:
          return j(F);
        case Zt.arrowDown:
          return j(F);
        default:
          return;
      }
    }, J = (F) => {
      if (F.key === Zt.enter) return L();
      if (F.key === Zt.tab) return Z();
    };
    return t({ focusGrid: w }), (F, q) => {
      var z;
      return N(), ee("div", {
        ref_key: "gridWrapRef",
        ref: g,
        class: Ie(V.value),
        style: Ot(_.value),
        role: F.useRelative ? void 0 : "dialog",
        "aria-label": F.overlayLabel,
        tabindex: F.useRelative ? void 0 : "0",
        onKeydown: R,
        onClick: q[0] || (q[0] = $t(() => {
        }, ["prevent"]))
      }, [
        ie("div", {
          ref_key: "containerRef",
          ref: S,
          class: Ie(P.value),
          style: Ot({ "--dp-overlay-height": `${C.value}px` }),
          role: "grid"
        }, [
          ie("div", vK, [
            ke(F.$slots, "header")
          ]),
          F.$slots.overlay ? ke(F.$slots, "overlay", { key: 0 }) : (N(!0), ee(ge, { key: 1 }, Ge(F.items, (E, Q) => (N(), ee("div", {
            key: Q,
            class: Ie(["dp__overlay_row", { dp__flex_row: F.items.length >= 3 }]),
            role: "row"
          }, [
            (N(!0), ee(ge, null, Ge(E, (W, se) => (N(), ee("div", {
              key: W.value,
              ref_for: !0,
              ref: (Se) => D(Se, W, Q, se),
              role: "gridcell",
              class: Ie(O.value),
              "aria-selected": W.active || void 0,
              "aria-disabled": W.disabled || void 0,
              tabindex: "0",
              "data-test-id": W.text,
              onClick: $t((Se) => T(W), ["prevent"]),
              onKeydown: (Se) => X(ia)(Se, () => T(W), !0),
              onMouseover: (Se) => I(W.value)
            }, [
              ie("div", {
                class: Ie(W.className)
              }, [
                F.$slots.item ? ke(F.$slots, "item", {
                  key: 0,
                  item: W
                }) : de("", !0),
                F.$slots.item ? de("", !0) : (N(), ee(ge, { key: 1 }, [
                  Ee(xe(W.text), 1)
                ], 64))
              ], 2)
            ], 42, gK))), 128))
          ], 2))), 128))
        ], 6),
        F.$slots["button-icon"] ? Ct((N(), ee("button", {
          key: 0,
          ref_key: "toggleButton",
          ref: b,
          type: "button",
          "aria-label": (z = X(o)) == null ? void 0 : z.toggleOverlay,
          class: Ie($.value),
          tabindex: "0",
          onClick: L,
          onKeydown: J
        }, [
          ke(F.$slots, "button-icon")
        ], 42, pK)), [
          [Dn, !X(f)(F.hideNavigation, F.type)]
        ]) : de("", !0)
      ], 46, mK);
    };
  }
}), yK = ["data-dp-mobile"], I1 = /* @__PURE__ */ Sn({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean },
    collapse: { type: Boolean },
    isMobile: { type: Boolean }
  },
  setup(e) {
    const t = e, n = k(
      () => t.multiCalendars > 0 ? [...Array(t.multiCalendars).keys()] : [0]
    ), a = k(() => ({
      dp__instance_calendar: t.multiCalendars > 0
    }));
    return (i, l) => (N(), ee("div", {
      class: Ie({
        dp__menu_inner: !i.stretch,
        "dp--menu--inner-stretched": i.stretch,
        dp__flex_display: i.multiCalendars > 0,
        "dp--flex-display-collapsed": i.collapse
      }),
      "data-dp-mobile": i.isMobile
    }, [
      (N(!0), ee(ge, null, Ge(n.value, (r, s) => (N(), ee("div", {
        key: r,
        class: Ie(a.value)
      }, [
        ke(i.$slots, "default", {
          instance: r,
          index: s
        })
      ], 2))), 128))
    ], 10, yK));
  }
}), OK = ["data-dp-element", "aria-label", "aria-disabled"], Ao = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    elName: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: t }) {
    const n = t, a = Y(null);
    return rt(() => n("set-ref", a)), (i, l) => (N(), ee("button", {
      ref_key: "elRef",
      ref: a,
      type: "button",
      "data-dp-element": i.elName,
      class: "dp__btn dp--arrow-btn-nav",
      tabindex: "0",
      "aria-label": i.ariaLabel,
      "aria-disabled": i.disabled || void 0,
      onClick: l[0] || (l[0] = (r) => i.$emit("activate")),
      onKeydown: l[1] || (l[1] = (r) => X(ia)(r, () => i.$emit("activate"), !0))
    }, [
      ie("span", {
        class: Ie(["dp__inner_nav", { dp__inner_nav_disabled: i.disabled }])
      }, [
        ke(i.$slots, "default")
      ], 2)
    ], 40, OK));
  }
}), bK = ["aria-label", "data-test-id"], bC = /* @__PURE__ */ Sn({
  __name: "YearModePicker",
  props: {
    ...si,
    showYearPicker: { type: Boolean, default: !1 },
    items: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    isDisabled: { type: Function, default: () => !1 }
  },
  emits: ["toggle-year-picker", "year-select", "handle-year"],
  setup(e, { emit: t }) {
    const n = t, a = e, { showRightIcon: i, showLeftIcon: l } = Z1(), { defaultedConfig: r, defaultedMultiCalendars: s, defaultedAriaLabels: o, defaultedTransitions: u, defaultedUI: c } = Gt(a), { showTransition: d, transitionName: f } = Nu(u), h = Y(!1), m = (y = !1, b) => {
      h.value = !h.value, n("toggle-year-picker", { flow: y, show: b });
    }, g = (y) => {
      h.value = !1, n("year-select", y);
    }, v = (y = !1) => {
      n("handle-year", y);
    };
    return (y, b) => {
      var C, S, x, w, V;
      return N(), ee(ge, null, [
        ie("div", {
          class: Ie(["dp--year-mode-picker", { "dp--hidden-el": h.value }])
        }, [
          X(l)(X(s), e.instance) ? (N(), Ce(Ao, {
            key: 0,
            ref: "mpPrevIconRef",
            "aria-label": (C = X(o)) == null ? void 0 : C.prevYear,
            disabled: e.isDisabled(!1),
            class: Ie((S = X(c)) == null ? void 0 : S.navBtnPrev),
            onActivate: b[0] || (b[0] = (_) => v(!1))
          }, {
            default: re(() => [
              y.$slots["arrow-left"] ? ke(y.$slots, "arrow-left", { key: 0 }) : de("", !0),
              y.$slots["arrow-left"] ? de("", !0) : (N(), Ce(X(hv), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : de("", !0),
          ie("button", {
            ref: "mpYearButtonRef",
            class: "dp__btn dp--year-select",
            type: "button",
            "aria-label": `${e.year}-${(x = X(o)) == null ? void 0 : x.openYearsOverlay}`,
            "data-test-id": `year-mode-btn-${e.instance}`,
            onClick: b[1] || (b[1] = () => m(!1)),
            onKeydown: b[2] || (b[2] = Fi(() => m(!1), ["enter"]))
          }, [
            y.$slots.year ? ke(y.$slots, "year", {
              key: 0,
              year: e.year
            }) : de("", !0),
            y.$slots.year ? de("", !0) : (N(), ee(ge, { key: 1 }, [
              Ee(xe(e.year), 1)
            ], 64))
          ], 40, bK),
          X(i)(X(s), e.instance) ? (N(), Ce(Ao, {
            key: 1,
            ref: "mpNextIconRef",
            "aria-label": (w = X(o)) == null ? void 0 : w.nextYear,
            disabled: e.isDisabled(!0),
            class: Ie((V = X(c)) == null ? void 0 : V.navBtnNext),
            onActivate: b[3] || (b[3] = (_) => v(!0))
          }, {
            default: re(() => [
              y.$slots["arrow-right"] ? ke(y.$slots, "arrow-right", { key: 0 }) : de("", !0),
              y.$slots["arrow-right"] ? de("", !0) : (N(), Ce(X(mv), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : de("", !0)
        ], 2),
        p(Jn, {
          name: X(f)(e.showYearPicker),
          css: X(d)
        }, {
          default: re(() => {
            var _, O;
            return [
              e.showYearPicker ? (N(), Ce(Eu, {
                key: 0,
                items: e.items,
                "text-input": y.textInput,
                "esc-close": y.escClose,
                config: y.config,
                "is-last": y.autoApply && !X(r).keepActionRow,
                "hide-navigation": y.hideNavigation,
                "aria-labels": y.ariaLabels,
                "overlay-label": (O = (_ = X(o)) == null ? void 0 : _.yearPicker) == null ? void 0 : O.call(_, !0),
                type: "year",
                onToggle: m,
                onSelected: b[4] || (b[4] = ($) => g($))
              }, Xt({
                "button-icon": re(() => [
                  y.$slots["calendar-icon"] ? ke(y.$slots, "calendar-icon", { key: 0 }) : de("", !0),
                  y.$slots["calendar-icon"] ? de("", !0) : (N(), Ce(X(io), { key: 1 }))
                ]),
                _: 2
              }, [
                y.$slots["year-overlay-value"] ? {
                  name: "item",
                  fn: re(({ item: $ }) => [
                    ke(y.$slots, "year-overlay-value", {
                      text: $.text,
                      value: $.value
                    })
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels", "overlay-label"])) : de("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 64);
    };
  }
}), kv = (e, t, n) => {
  if (t.value && Array.isArray(t.value))
    if (t.value.some((a) => ht(e, a))) {
      const a = t.value.filter((i) => !ht(i, e));
      t.value = a.length ? a : null;
    } else (n && +n > t.value.length || !n) && t.value.push(e);
  else
    t.value = [e];
}, Sv = (e, t, n) => {
  let a = e.value ? e.value.slice() : [];
  return a.length === 2 && a[1] !== null && (a = []), a.length ? (an(t, a[0]) ? a.unshift(t) : a[1] = t, n("range-end", t)) : (a = [t], n("range-start", t)), a;
}, B1 = (e, t, n, a) => {
  e && (e[0] && e[1] && n && t("auto-apply"), e[0] && !e[1] && a && n && t("auto-apply"));
}, CC = (e) => {
  Array.isArray(e.value) && e.value.length <= 2 && e.range ? e.modelValue.value = e.value.map((t) => ga(_e(t), e.timezone)) : Array.isArray(e.value) || (e.modelValue.value = ga(_e(e.value), e.timezone));
}, wC = (e, t, n, a) => Array.isArray(t.value) && (t.value.length === 2 || t.value.length === 1 && a.value.partialRange) ? a.value.fixedStart && (cn(e, t.value[0]) || ht(e, t.value[0])) ? [t.value[0], e] : a.value.fixedEnd && (an(e, t.value[1]) || ht(e, t.value[1])) ? [e, t.value[1]] : (n("invalid-fixed-range", e), t.value) : [], kC = ({
  multiCalendars: e,
  range: t,
  highlight: n,
  propDates: a,
  calendars: i,
  modelValue: l,
  props: r,
  filters: s,
  year: o,
  month: u,
  emit: c
}) => {
  const d = k(() => Ov(r.yearRange, r.locale, r.reverseYears)), f = Y([!1]), h = k(() => ($, P) => {
    const M = _t(Xa(/* @__PURE__ */ new Date()), {
      month: u.value($),
      year: o.value($)
    }), T = P ? zb(M) : hu(M);
    return gC(
      T,
      a.value.maxDate,
      a.value.minDate,
      r.preventMinMaxNavigation,
      P
    );
  }), m = () => Array.isArray(l.value) && e.value.solo && l.value[1], g = () => {
    for (let $ = 0; $ < e.value.count; $++)
      if ($ === 0)
        i.value[$] = i.value[0];
      else if ($ === e.value.count - 1 && m())
        i.value[$] = {
          month: ft(l.value[1]),
          year: it(l.value[1])
        };
      else {
        const P = _t(_e(), i.value[$ - 1]);
        i.value[$] = { month: ft(P), year: it(rv(P, 1)) };
      }
  }, v = ($) => {
    if (!$) return g();
    const P = _t(_e(), i.value[$]);
    return i.value[0].year = it(iC(P, e.value.count - 1)), g();
  }, y = ($, P) => {
    const M = Vq(P, $);
    return t.value.showLastInRange && M > 1 ? P : $;
  }, b = ($) => r.focusStartDate || e.value.solo ? $[0] : $[1] ? y($[0], $[1]) : $[0], C = () => {
    if (l.value) {
      const $ = Array.isArray(l.value) ? b(l.value) : l.value;
      i.value[0] = { month: ft($), year: it($) };
    }
  }, S = () => {
    C(), e.value.count && g();
  };
  pe(l, ($, P) => {
    r.isTextInputDate && JSON.stringify($ ?? {}) !== JSON.stringify(P ?? {}) && S();
  }), rt(() => {
    S();
  });
  const x = ($, P) => {
    i.value[P].year = $, c("update-month-year", { instance: P, year: $, month: i.value[P].month }), e.value.count && !e.value.solo && v(P);
  }, w = k(() => ($) => Ns(d.value, (P) => {
    var M;
    const T = o.value($) === P.value, L = mu(
      P.value,
      Hs(a.value.minDate),
      Hs(a.value.maxDate)
    ) || ((M = s.value.years) == null ? void 0 : M.includes(o.value($))), A = wv(n.value, P.value);
    return { active: T, disabled: L, highlighted: A };
  })), V = ($, P) => {
    x($, P), O(P);
  }, _ = ($, P = !1) => {
    if (!h.value($, P)) {
      const M = P ? o.value($) + 1 : o.value($) - 1;
      x(M, $);
    }
  }, O = ($, P = !1, M) => {
    P || c("reset-flow"), M !== void 0 ? f.value[$] = M : f.value[$] = !f.value[$], f.value[$] ? c("overlay-toggle", { open: !0, overlay: qn.year }) : (c("overlay-closed"), c("overlay-toggle", { open: !1, overlay: qn.year }));
  };
  return {
    isDisabled: h,
    groupedYears: w,
    showYearPicker: f,
    selectYear: x,
    toggleYearPicker: O,
    handleYearSelect: V,
    handleYear: _
  };
}, CK = (e, t) => {
  const {
    defaultedMultiCalendars: n,
    defaultedAriaLabels: a,
    defaultedTransitions: i,
    defaultedConfig: l,
    defaultedRange: r,
    defaultedHighlight: s,
    propDates: o,
    defaultedTz: u,
    defaultedFilters: c,
    defaultedMultiDates: d
  } = Gt(e), f = () => {
    e.isTextInputDate && S(it(_e(e.startDate)), 0);
  }, { modelValue: h, year: m, month: g, calendars: v } = Hu(e, t, f), y = k(() => rC(e.formatLocale, e.locale, e.monthNameFormat)), b = Y(null), { checkMinMaxRange: C } = jl(e), {
    selectYear: S,
    groupedYears: x,
    showYearPicker: w,
    toggleYearPicker: V,
    handleYearSelect: _,
    handleYear: O,
    isDisabled: $
  } = kC({
    modelValue: h,
    multiCalendars: n,
    range: r,
    highlight: s,
    calendars: v,
    year: m,
    propDates: o,
    month: g,
    filters: c,
    props: e,
    emit: t
  });
  rt(() => {
    e.startDate && (h.value && e.focusStartDate || !h.value) && S(it(_e(e.startDate)), 0);
  });
  const P = (q) => q ? { month: ft(q), year: it(q) } : { month: null, year: null }, M = () => h.value ? Array.isArray(h.value) ? h.value.map((q) => P(q)) : P(h.value) : P(), T = (q, z) => {
    const E = v.value[q], Q = M();
    return Array.isArray(Q) ? Q.some((W) => W.year === (E == null ? void 0 : E.year) && W.month === z) : (E == null ? void 0 : E.year) === Q.year && z === Q.month;
  }, L = (q, z, E) => {
    var Q, W;
    const se = M();
    return Array.isArray(se) ? m.value(z) === ((Q = se[E]) == null ? void 0 : Q.year) && q === ((W = se[E]) == null ? void 0 : W.month) : !1;
  }, A = (q, z) => {
    if (r.value.enabled) {
      const E = M();
      if (Array.isArray(h.value) && Array.isArray(E)) {
        const Q = L(q, z, 0) || L(q, z, 1), W = zi(Xa(_e()), q, m.value(z));
        return vu(h.value, b.value, W) && !Q;
      }
      return !1;
    }
    return !1;
  }, D = k(() => (q) => Ns(y.value, (z) => {
    var E;
    const Q = T(q, z.value), W = mu(
      z.value,
      fC(m.value(q), o.value.minDate),
      hC(m.value(q), o.value.maxDate)
    ) || zG(o.value.disabledDates, m.value(q), z.value) || ((E = c.value.months) == null ? void 0 : E.includes(z.value)) || !FG(o.value.allowedDates, m.value(q), z.value), se = A(z.value, q), Se = yC(s.value, z.value, m.value(q));
    return { active: Q, disabled: W, isBetween: se, highlighted: Se };
  })), B = (q, z) => zi(Xa(_e()), q, m.value(z)), j = (q, z) => {
    const E = h.value ? h.value : Xa(/* @__PURE__ */ new Date());
    h.value = zi(E, q, m.value(z)), t("auto-apply"), t("update-flow-step");
  }, I = (q, z) => {
    const E = B(q, z);
    r.value.fixedEnd || r.value.fixedStart ? h.value = wC(E, h, t, r) : h.value ? C(E, h.value) && (h.value = Sv(h, B(q, z), t)) : h.value = [B(q, z)], et().then(() => {
      B1(h.value, t, e.autoApply, e.modelAuto);
    });
  }, Z = (q, z) => {
    kv(B(q, z), h, d.value.limit), t("auto-apply", !0);
  }, R = (q, z) => (v.value[z].month = q, F(z, v.value[z].year, q), d.value.enabled ? Z(q, z) : r.value.enabled ? I(q, z) : j(q, z)), J = (q, z) => {
    S(q, z), F(z, q, null);
  }, F = (q, z, E) => {
    let Q = E;
    if (!Q && Q !== 0) {
      const W = M();
      Q = Array.isArray(W) ? W[q].month : W.month;
    }
    t("update-month-year", { instance: q, year: z, month: Q });
  };
  return {
    groupedMonths: D,
    groupedYears: x,
    year: m,
    isDisabled: $,
    defaultedMultiCalendars: n,
    defaultedAriaLabels: a,
    defaultedTransitions: i,
    defaultedConfig: l,
    showYearPicker: w,
    modelValue: h,
    presetDate: (q, z) => {
      CC({
        value: q,
        modelValue: h,
        range: r.value.enabled,
        timezone: z ? void 0 : u.value.timezone
      }), t("auto-apply");
    },
    setHoverDate: (q, z) => {
      b.value = B(q, z);
    },
    selectMonth: R,
    selectYear: J,
    toggleYearPicker: V,
    handleYearSelect: _,
    handleYear: O,
    getModelMonthYear: M
  };
}, wK = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...si
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year",
    "update-flow-step",
    "mount",
    "invalid-fixed-range",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = Rl(), l = ka(i, "yearMode"), r = e;
    rt(() => {
      r.shadow || a("mount", null);
    });
    const {
      groupedMonths: s,
      groupedYears: o,
      year: u,
      isDisabled: c,
      defaultedMultiCalendars: d,
      defaultedConfig: f,
      showYearPicker: h,
      modelValue: m,
      presetDate: g,
      setHoverDate: v,
      selectMonth: y,
      selectYear: b,
      toggleYearPicker: C,
      handleYearSelect: S,
      handleYear: x,
      getModelMonthYear: w
    } = CK(r, a);
    return t({ getSidebarProps: () => ({
      modelValue: m,
      year: u,
      getModelMonthYear: w,
      selectMonth: y,
      selectYear: b,
      handleYear: x
    }), presetDate: g, toggleYearPicker: (V) => C(0, V) }), (V, _) => (N(), Ce(I1, {
      "multi-calendars": X(d).count,
      collapse: V.collapse,
      stretch: "",
      "is-mobile": V.isMobile
    }, {
      default: re(({ instance: O }) => [
        V.$slots["top-extra"] ? ke(V.$slots, "top-extra", {
          key: 0,
          value: V.internalModelValue
        }) : de("", !0),
        V.$slots["month-year"] ? ke(V.$slots, "month-year", Pt(fe({ key: 1 }, {
          year: X(u),
          months: X(s)(O),
          years: X(o)(O),
          selectMonth: X(y),
          selectYear: X(b),
          instance: O
        }))) : (N(), Ce(Eu, {
          key: 2,
          items: X(s)(O),
          "arrow-navigation": V.arrowNavigation,
          "is-last": V.autoApply && !X(f).keepActionRow,
          "esc-close": V.escClose,
          height: X(f).modeHeight,
          config: V.config,
          "no-overlay-focus": !!(V.noOverlayFocus || V.textInput),
          "use-relative": "",
          type: "month",
          onSelected: ($) => X(y)($, O),
          onHoverValue: ($) => X(v)($, O)
        }, Xt({
          header: re(() => [
            p(bC, fe(V.$props, {
              items: X(o)(O),
              instance: O,
              "show-year-picker": X(h)[O],
              year: X(u)(O),
              "is-disabled": ($) => X(c)(O, $),
              onHandleYear: ($) => X(x)(O, $),
              onYearSelect: ($) => X(S)($, O),
              onToggleYearPicker: ($) => X(C)(O, $ == null ? void 0 : $.flow, $ == null ? void 0 : $.show)
            }), Xt({ _: 2 }, [
              Ge(X(l), ($, P) => ({
                name: $,
                fn: re((M) => [
                  ke(V.$slots, $, Pt(Jt(M)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          _: 2
        }, [
          V.$slots["month-overlay-value"] ? {
            name: "item",
            fn: re(({ item: $ }) => [
              ke(V.$slots, "month-overlay-value", {
                text: $.text,
                value: $.value
              })
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), kK = (e, t) => {
  const n = () => {
    e.isTextInputDate && (c.value = it(_e(e.startDate)));
  }, { modelValue: a } = Hu(e, t, n), i = Y(null), { defaultedHighlight: l, defaultedMultiDates: r, defaultedFilters: s, defaultedRange: o, propDates: u } = Gt(e), c = Y();
  rt(() => {
    e.startDate && (a.value && e.focusStartDate || !a.value) && (c.value = it(_e(e.startDate)));
  });
  const d = (y) => Array.isArray(a.value) ? a.value.some((b) => it(b) === y) : a.value ? it(a.value) === y : !1, f = (y) => o.value.enabled && Array.isArray(a.value) ? vu(a.value, i.value, v(y)) : !1, h = (y) => u.value.allowedDates instanceof Map ? u.value.allowedDates.size ? u.value.allowedDates.has(`${y}`) : !1 : !0, m = (y) => u.value.disabledDates instanceof Map ? u.value.disabledDates.size ? u.value.disabledDates.has(`${y}`) : !1 : !0, g = k(() => Ns(Ov(e.yearRange, e.locale, e.reverseYears), (y) => {
    const b = d(y.value), C = mu(
      y.value,
      Hs(u.value.minDate),
      Hs(u.value.maxDate)
    ) || s.value.years.includes(y.value) || !h(y.value) || m(y.value), S = f(y.value) && !b, x = wv(l.value, y.value);
    return { active: b, disabled: C, isBetween: S, highlighted: x };
  })), v = (y) => xi(Xa(hu(/* @__PURE__ */ new Date())), y);
  return {
    groupedYears: g,
    modelValue: a,
    focusYear: c,
    setHoverValue: (y) => {
      i.value = xi(Xa(/* @__PURE__ */ new Date()), y);
    },
    selectYear: (y) => {
      var b;
      if (t("update-month-year", { instance: 0, year: y }), r.value.enabled)
        return a.value ? Array.isArray(a.value) && (((b = a.value) == null ? void 0 : b.map((C) => it(C))).includes(y) ? a.value = a.value.filter((C) => it(C) !== y) : a.value.push(xi(In(_e()), y))) : a.value = [xi(In(hu(_e())), y)], t("auto-apply", !0);
      o.value.enabled ? (a.value = Sv(a, v(y), t), et().then(() => {
        B1(a.value, t, e.autoApply, e.modelAuto);
      })) : (a.value = v(y), t("auto-apply"));
    }
  };
}, SK = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...si
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, { groupedYears: l, modelValue: r, focusYear: s, selectYear: o, setHoverValue: u } = kK(i, a), { defaultedConfig: c } = Gt(i);
    return t({ getSidebarProps: () => ({
      modelValue: r,
      selectYear: o
    }) }), (d, f) => (N(), ee("div", null, [
      d.$slots["top-extra"] ? ke(d.$slots, "top-extra", {
        key: 0,
        value: d.internalModelValue
      }) : de("", !0),
      d.$slots["month-year"] ? ke(d.$slots, "month-year", Pt(fe({ key: 1 }, {
        years: X(l),
        selectYear: X(o)
      }))) : (N(), Ce(Eu, {
        key: 2,
        items: X(l),
        "is-last": d.autoApply && !X(c).keepActionRow,
        height: X(c).modeHeight,
        config: d.config,
        "no-overlay-focus": !!(d.noOverlayFocus || d.textInput),
        "focus-value": X(s),
        type: "year",
        "use-relative": "",
        onSelected: X(o),
        onHoverValue: X(u)
      }, Xt({ _: 2 }, [
        d.$slots["year-overlay-value"] ? {
          name: "item",
          fn: re(({ item: h }) => [
            ke(d.$slots, "year-overlay-value", {
              text: h.text,
              value: h.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))
    ]));
  }
}), xK = {
  key: 0,
  class: "dp__time_input"
}, PK = ["data-compact", "data-collapsed"], $K = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], _K = ["aria-label", "disabled", "data-test-id", "onKeydown", "onClick"], MK = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], VK = { key: 0 }, TK = ["aria-label", "data-compact"], LK = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: { type: Function, default: () => !1 },
    ...si
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "overlay-opened",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, { setTimePickerElements: l, setTimePickerBackRef: r } = Hl(), {
      defaultedAriaLabels: s,
      defaultedTransitions: o,
      defaultedFilters: u,
      defaultedConfig: c,
      defaultedRange: d,
      defaultedMultiCalendars: f
    } = Gt(i), { transitionName: h, showTransition: m } = Nu(o), g = zt({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), v = Y("AM"), y = Y(null), b = Y([]), C = Y(), S = Y(!1);
    rt(() => {
      a("mounted");
    });
    const x = (H) => _t(/* @__PURE__ */ new Date(), {
      hours: H.hours,
      minutes: H.minutes,
      seconds: i.enableSeconds ? H.seconds : 0,
      milliseconds: 0
    }), w = k(
      () => (H) => I(H, i[H]) || _(H, i[H])
    ), V = k(() => ({ hours: i.hours, minutes: i.minutes, seconds: i.seconds })), _ = (H, ce) => d.value.enabled && !d.value.disableTimeRangeValidation ? !i.validateTime(H, ce) : !1, O = (H, ce) => {
      if (d.value.enabled && !d.value.disableTimeRangeValidation) {
        const he = ce ? +i[`${H}Increment`] : -+i[`${H}Increment`], Oe = i[H] + he;
        return !i.validateTime(H, Oe);
      }
      return !1;
    }, $ = k(() => (H) => !q(+i[H] + +i[`${H}Increment`], H) || O(H, !0)), P = k(() => (H) => !q(+i[H] - +i[`${H}Increment`], H) || O(H, !1)), M = (H, ce) => Bb(_t(_e(), H), ce), T = (H, ce) => SG(_t(_e(), H), ce), L = k(
      () => ({
        dp__time_col: !0,
        dp__time_col_block: !i.timePickerInline,
        dp__time_col_reg_block: !i.enableSeconds && i.is24 && !i.timePickerInline,
        dp__time_col_reg_inline: !i.enableSeconds && i.is24 && i.timePickerInline,
        dp__time_col_reg_with_button: !i.enableSeconds && !i.is24,
        dp__time_col_sec: i.enableSeconds && i.is24,
        dp__time_col_sec_with_button: i.enableSeconds && !i.is24
      })
    ), A = k(
      () => i.timePickerInline && d.value.enabled && !f.value.count
    ), D = k(() => {
      const H = [{ type: "hours" }];
      return i.enableMinutes && H.push({ type: "", separator: !0 }, {
        type: "minutes"
      }), i.enableSeconds && H.push({ type: "", separator: !0 }, {
        type: "seconds"
      }), H;
    }), B = k(() => D.value.filter((H) => !H.separator)), j = k(() => (H) => {
      if (H === "hours") {
        const ce = Se(+i.hours);
        return { text: ce < 10 ? `0${ce}` : `${ce}`, value: ce };
      }
      return { text: i[H] < 10 ? `0${i[H]}` : `${i[H]}`, value: i[H] };
    }), I = (H, ce) => {
      var he;
      if (!i.disabledTimesConfig) return !1;
      const Oe = i.disabledTimesConfig(i.order, H === "hours" ? ce : void 0);
      return Oe[H] ? !!((he = Oe[H]) != null && he.includes(ce)) : !0;
    }, Z = (H, ce) => ce !== "hours" || v.value === "AM" ? H : H + 12, R = (H) => {
      const ce = i.is24 ? 24 : 12, he = H === "hours" ? ce : 60, Oe = +i[`${H}GridIncrement`], je = H === "hours" && !i.is24 ? Oe : 0, be = [];
      for (let Te = je; Te < he; Te += Oe)
        be.push({ value: i.is24 ? Te : Z(Te, H), text: Te < 10 ? `0${Te}` : `${Te}` });
      return H === "hours" && !i.is24 && be.unshift({ value: v.value === "PM" ? 12 : 0, text: "12" }), Ns(be, (Te) => ({ active: !1, disabled: u.value.times[H].includes(Te.value) || !q(Te.value, H) || I(H, Te.value) || _(H, Te.value) }));
    }, J = (H) => H >= 0 ? H : 59, F = (H) => H >= 0 ? H : 23, q = (H, ce) => {
      const he = i.minTime ? x(Ef(i.minTime)) : null, Oe = i.maxTime ? x(Ef(i.maxTime)) : null, je = x(
        Ef(
          V.value,
          ce,
          ce === "minutes" || ce === "seconds" ? J(H) : F(H)
        )
      );
      return he && Oe ? (Zs(je, Oe) || us(je, Oe)) && (Vr(je, he) || us(je, he)) : he ? Vr(je, he) || us(je, he) : Oe ? Zs(je, Oe) || us(je, Oe) : !0;
    }, z = (H) => i[`no${H[0].toUpperCase() + H.slice(1)}Overlay`], E = (H) => {
      z(H) || (g[H] = !g[H], g[H] ? (S.value = !0, a("overlay-opened", H)) : (S.value = !1, a("overlay-closed", H)));
    }, Q = (H) => H === "hours" ? tl : H === "minutes" ? Dl : Bs, W = () => {
      C.value && clearTimeout(C.value);
    }, se = (H, ce = !0, he) => {
      const Oe = ce ? M : T, je = ce ? +i[`${H}Increment`] : -+i[`${H}Increment`];
      q(+i[H] + je, H) && a(
        `update:${H}`,
        Q(H)(Oe({ [H]: +i[H] }, { [H]: +i[`${H}Increment`] }))
      ), !(he != null && he.keyboard) && c.value.timeArrowHoldThreshold && (C.value = setTimeout(() => {
        se(H, ce);
      }, c.value.timeArrowHoldThreshold));
    }, Se = (H) => i.is24 ? H : (H >= 12 ? v.value = "PM" : v.value = "AM", TG(H)), U = () => {
      v.value === "PM" ? (v.value = "AM", a("update:hours", i.hours - 12)) : (v.value = "PM", a("update:hours", i.hours + 12)), a("am-pm-change", v.value);
    }, ne = (H) => {
      g[H] = !0;
    }, K = (H, ce, he) => {
      if (H && i.arrowNavigation) {
        Array.isArray(b.value[ce]) ? b.value[ce][he] = H : b.value[ce] = [H];
        const Oe = b.value.reduce(
          (je, be) => be.map((Te, Be) => [...je[Be] || [], be[Be]]),
          []
        );
        r(i.closeTimePickerBtn), y.value && (Oe[1] = Oe[1].concat(y.value)), l(Oe, i.order);
      }
    }, te = (H, ce) => (E(H), a(`update:${H}`, ce));
    return t({ openChildCmp: ne }), (H, ce) => {
      var he;
      return H.disabled ? de("", !0) : (N(), ee("div", xK, [
        (N(!0), ee(ge, null, Ge(D.value, (Oe, je) => {
          var be, Te, Be;
          return N(), ee("div", {
            key: je,
            class: Ie(L.value),
            "data-compact": A.value && !H.enableSeconds,
            "data-collapsed": A.value && H.enableSeconds
          }, [
            Oe.separator ? (N(), ee(ge, { key: 0 }, [
              S.value ? de("", !0) : (N(), ee(ge, { key: 0 }, [
                Ee(":")
              ], 64))
            ], 64)) : (N(), ee(ge, { key: 1 }, [
              ie("button", {
                ref_for: !0,
                ref: (oe) => K(oe, je, 0),
                type: "button",
                class: Ie({
                  dp__btn: !0,
                  dp__inc_dec_button: !H.timePickerInline,
                  dp__inc_dec_button_inline: H.timePickerInline,
                  dp__tp_inline_btn_top: H.timePickerInline,
                  dp__inc_dec_button_disabled: $.value(Oe.type),
                  "dp--hidden-el": S.value
                }),
                "data-test-id": `${Oe.type}-time-inc-btn-${i.order}`,
                "aria-label": (be = X(s)) == null ? void 0 : be.incrementValue(Oe.type),
                tabindex: "0",
                onKeydown: (oe) => X(ia)(oe, () => se(Oe.type, !0, { keyboard: !0 }), !0),
                onClick: (oe) => X(c).timeArrowHoldThreshold ? void 0 : se(Oe.type, !0),
                onMousedown: (oe) => X(c).timeArrowHoldThreshold ? se(Oe.type, !0) : void 0,
                onMouseup: W
              }, [
                i.timePickerInline ? (N(), ee(ge, { key: 1 }, [
                  H.$slots["tp-inline-arrow-up"] ? ke(H.$slots, "tp-inline-arrow-up", { key: 0 }) : (N(), ee(ge, { key: 1 }, [
                    ce[2] || (ce[2] = ie("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    ce[3] || (ce[3] = ie("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (N(), ee(ge, { key: 0 }, [
                  H.$slots["arrow-up"] ? ke(H.$slots, "arrow-up", { key: 0 }) : de("", !0),
                  H.$slots["arrow-up"] ? de("", !0) : (N(), Ce(X(gv), { key: 1 }))
                ], 64))
              ], 42, $K),
              ie("button", {
                ref_for: !0,
                ref: (oe) => K(oe, je, 1),
                type: "button",
                "aria-label": `${j.value(Oe.type).text}-${(Te = X(s)) == null ? void 0 : Te.openTpOverlay(Oe.type)}`,
                class: Ie({
                  dp__time_display: !0,
                  dp__time_display_block: !H.timePickerInline,
                  dp__time_display_inline: H.timePickerInline,
                  "dp--time-invalid": w.value(Oe.type),
                  "dp--time-overlay-btn": !w.value(Oe.type),
                  "dp--hidden-el": S.value
                }),
                disabled: z(Oe.type),
                tabindex: "0",
                "data-test-id": `${Oe.type}-toggle-overlay-btn-${i.order}`,
                onKeydown: (oe) => X(ia)(oe, () => E(Oe.type), !0),
                onClick: (oe) => E(Oe.type)
              }, [
                H.$slots[Oe.type] ? ke(H.$slots, Oe.type, {
                  key: 0,
                  text: j.value(Oe.type).text,
                  value: j.value(Oe.type).value
                }) : de("", !0),
                H.$slots[Oe.type] ? de("", !0) : (N(), ee(ge, { key: 1 }, [
                  Ee(xe(j.value(Oe.type).text), 1)
                ], 64))
              ], 42, _K),
              ie("button", {
                ref_for: !0,
                ref: (oe) => K(oe, je, 2),
                type: "button",
                class: Ie({
                  dp__btn: !0,
                  dp__inc_dec_button: !H.timePickerInline,
                  dp__inc_dec_button_inline: H.timePickerInline,
                  dp__tp_inline_btn_bottom: H.timePickerInline,
                  dp__inc_dec_button_disabled: P.value(Oe.type),
                  "dp--hidden-el": S.value
                }),
                "data-test-id": `${Oe.type}-time-dec-btn-${i.order}`,
                "aria-label": (Be = X(s)) == null ? void 0 : Be.decrementValue(Oe.type),
                tabindex: "0",
                onKeydown: (oe) => X(ia)(oe, () => se(Oe.type, !1, { keyboard: !0 }), !0),
                onClick: (oe) => X(c).timeArrowHoldThreshold ? void 0 : se(Oe.type, !1),
                onMousedown: (oe) => X(c).timeArrowHoldThreshold ? se(Oe.type, !1) : void 0,
                onMouseup: W
              }, [
                i.timePickerInline ? (N(), ee(ge, { key: 1 }, [
                  H.$slots["tp-inline-arrow-down"] ? ke(H.$slots, "tp-inline-arrow-down", { key: 0 }) : (N(), ee(ge, { key: 1 }, [
                    ce[4] || (ce[4] = ie("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    ce[5] || (ce[5] = ie("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (N(), ee(ge, { key: 0 }, [
                  H.$slots["arrow-down"] ? ke(H.$slots, "arrow-down", { key: 0 }) : de("", !0),
                  H.$slots["arrow-down"] ? de("", !0) : (N(), Ce(X(pv), { key: 1 }))
                ], 64))
              ], 42, MK)
            ], 64))
          ], 10, PK);
        }), 128)),
        H.is24 ? de("", !0) : (N(), ee("div", VK, [
          H.$slots["am-pm-button"] ? ke(H.$slots, "am-pm-button", {
            key: 0,
            toggle: U,
            value: v.value
          }) : de("", !0),
          H.$slots["am-pm-button"] ? de("", !0) : (N(), ee("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: y,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (he = X(s)) == null ? void 0 : he.amPmButton,
            tabindex: "0",
            "data-compact": A.value,
            onClick: U,
            onKeydown: ce[0] || (ce[0] = (Oe) => X(ia)(Oe, () => U(), !0))
          }, xe(v.value), 41, TK))
        ])),
        (N(!0), ee(ge, null, Ge(B.value, (Oe, je) => (N(), Ce(Jn, {
          key: je,
          name: X(h)(g[Oe.type]),
          css: X(m)
        }, {
          default: re(() => {
            var be, Te;
            return [
              g[Oe.type] ? (N(), Ce(Eu, {
                key: 0,
                items: R(Oe.type),
                "is-last": H.autoApply && !X(c).keepActionRow,
                "esc-close": H.escClose,
                type: Oe.type,
                "text-input": H.textInput,
                config: H.config,
                "arrow-navigation": H.arrowNavigation,
                "aria-labels": H.ariaLabels,
                "overlay-label": (Te = (be = X(s)).timeOverlay) == null ? void 0 : Te.call(be, Oe.type),
                onSelected: (Be) => te(Oe.type, Be),
                onToggle: (Be) => E(Oe.type),
                onResetFlow: ce[1] || (ce[1] = (Be) => H.$emit("reset-flow"))
              }, Xt({
                "button-icon": re(() => [
                  H.$slots["clock-icon"] ? ke(H.$slots, "clock-icon", { key: 0 }) : de("", !0),
                  H.$slots["clock-icon"] ? de("", !0) : (N(), Ce(Lr(H.timePickerInline ? X(io) : X(vv)), { key: 1 }))
                ]),
                _: 2
              }, [
                H.$slots[`${Oe.type}-overlay-value`] ? {
                  name: "item",
                  fn: re(({ item: Be }) => [
                    ke(H.$slots, `${Oe.type}-overlay-value`, {
                      text: Be.text,
                      value: Be.value
                    })
                  ]),
                  key: "0"
                } : void 0,
                H.$slots[`${Oe.type}-overlay-header`] ? {
                  name: "header",
                  fn: re(() => [
                    ke(H.$slots, `${Oe.type}-overlay-header`, {
                      toggle: () => E(Oe.type)
                    })
                  ]),
                  key: "1"
                } : void 0
              ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : de("", !0)
            ];
          }),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), QK = ["data-dp-mobile"], AK = ["aria-label", "tabindex"], DK = ["role", "aria-label", "tabindex"], RK = ["aria-label"], SC = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: {
      type: Function,
      default: () => !1
    },
    ...si
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, { buildMatrix: l, setTimePicker: r } = Hl(), s = Rl(), { defaultedTransitions: o, defaultedAriaLabels: u, defaultedTextInput: c, defaultedConfig: d, defaultedRange: f } = Gt(i), { transitionName: h, showTransition: m } = Nu(o), { hideNavigationButtons: g } = Z1(), v = Y(null), y = Y(null), b = Y([]), C = Y(null), S = Y(!1);
    rt(() => {
      a("mount"), !i.timePicker && i.arrowNavigation ? l([Cn(v.value)], "time") : r(!0, i.timePicker);
    });
    const x = k(() => f.value.enabled && i.modelAuto ? sC(i.internalModelValue) : !0), w = Y(!1), V = (I) => ({
      hours: Array.isArray(i.hours) ? i.hours[I] : i.hours,
      minutes: Array.isArray(i.minutes) ? i.minutes[I] : i.minutes,
      seconds: Array.isArray(i.seconds) ? i.seconds[I] : i.seconds
    }), _ = k(() => {
      const I = [];
      if (f.value.enabled)
        for (let Z = 0; Z < 2; Z++)
          I.push(V(Z));
      else
        I.push(V(0));
      return I;
    }), O = (I, Z = !1, R = "") => {
      Z || a("reset-flow"), w.value = I, a(I ? "overlay-opened" : "overlay-closed", qn.time), i.arrowNavigation && r(I), et(() => {
        R !== "" && b.value[0] && b.value[0].openChildCmp(R);
      });
    }, $ = k(() => ({
      dp__btn: !0,
      dp__button: !0,
      dp__button_bottom: i.autoApply && !d.value.keepActionRow
    })), P = ka(s, "timePicker"), M = (I, Z, R) => f.value.enabled ? Z === 0 ? [I, _.value[1][R]] : [_.value[0][R], I] : I, T = (I) => {
      a("update:hours", I);
    }, L = (I) => {
      a("update:minutes", I);
    }, A = (I) => {
      a("update:seconds", I);
    }, D = () => {
      if (C.value && !c.value.enabled && !i.noOverlayFocus) {
        const I = oC(C.value);
        I && I.focus({ preventScroll: !0 });
      }
    }, B = (I) => {
      S.value = !1, a("overlay-closed", I);
    }, j = (I) => {
      S.value = !0, a("overlay-opened", I);
    };
    return t({ toggleTimePicker: O }), (I, Z) => {
      var R;
      return N(), ee("div", {
        class: "dp--tp-wrap",
        "data-dp-mobile": I.isMobile
      }, [
        !I.timePicker && !I.timePickerInline ? Ct((N(), ee("button", {
          key: 0,
          ref_key: "openTimePickerBtn",
          ref: v,
          type: "button",
          class: Ie({ ...$.value, "dp--hidden-el": w.value }),
          "aria-label": (R = X(u)) == null ? void 0 : R.openTimePicker,
          tabindex: I.noOverlayFocus ? void 0 : 0,
          "data-test-id": "open-time-picker-btn",
          onKeydown: Z[0] || (Z[0] = (J) => X(ia)(J, () => O(!0))),
          onClick: Z[1] || (Z[1] = (J) => O(!0))
        }, [
          I.$slots["clock-icon"] ? ke(I.$slots, "clock-icon", { key: 0 }) : de("", !0),
          I.$slots["clock-icon"] ? de("", !0) : (N(), Ce(X(vv), { key: 1 }))
        ], 42, AK)), [
          [Dn, !X(g)(I.hideNavigation, "time")]
        ]) : de("", !0),
        p(Jn, {
          name: X(h)(w.value),
          css: X(m) && !I.timePickerInline
        }, {
          default: re(() => {
            var J, F;
            return [
              w.value || I.timePicker || I.timePickerInline ? (N(), ee("div", {
                key: 0,
                ref_key: "overlayRef",
                ref: C,
                role: I.timePickerInline ? void 0 : "dialog",
                class: Ie({
                  dp__overlay: !I.timePickerInline,
                  "dp--overlay-absolute": !i.timePicker && !I.timePickerInline,
                  "dp--overlay-relative": i.timePicker
                }),
                style: Ot(I.timePicker ? { height: `${X(d).modeHeight}px` } : void 0),
                "aria-label": (J = X(u)) == null ? void 0 : J.timePicker,
                tabindex: I.timePickerInline ? void 0 : 0
              }, [
                ie("div", {
                  class: Ie(
                    I.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  I.$slots["time-picker-overlay"] ? ke(I.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: T,
                    setMinutes: L,
                    setSeconds: A
                  }) : de("", !0),
                  I.$slots["time-picker-overlay"] ? de("", !0) : (N(), ee("div", {
                    key: 1,
                    class: Ie(I.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (N(!0), ee(ge, null, Ge(_.value, (q, z) => Ct((N(), Ce(LK, fe({
                      key: z,
                      ref_for: !0
                    }, {
                      ...I.$props,
                      order: z,
                      hours: q.hours,
                      minutes: q.minutes,
                      seconds: q.seconds,
                      closeTimePickerBtn: y.value,
                      disabledTimesConfig: e.disabledTimesConfig,
                      disabled: z === 0 ? X(f).fixedStart : X(f).fixedEnd
                    }, {
                      ref_for: !0,
                      ref_key: "timeInputRefs",
                      ref: b,
                      "validate-time": (E, Q) => e.validateTime(E, M(Q, z, E)),
                      "onUpdate:hours": (E) => T(M(E, z, "hours")),
                      "onUpdate:minutes": (E) => L(M(E, z, "minutes")),
                      "onUpdate:seconds": (E) => A(M(E, z, "seconds")),
                      onMounted: D,
                      onOverlayClosed: B,
                      onOverlayOpened: j,
                      onAmPmChange: Z[2] || (Z[2] = (E) => I.$emit("am-pm-change", E))
                    }), Xt({ _: 2 }, [
                      Ge(X(P), (E, Q) => ({
                        name: E,
                        fn: re((W) => [
                          ke(I.$slots, E, fe({ ref_for: !0 }, W))
                        ])
                      }))
                    ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [Dn, z === 0 ? !0 : x.value]
                    ])), 128))
                  ], 2)),
                  !I.timePicker && !I.timePickerInline ? Ct((N(), ee("button", {
                    key: 2,
                    ref_key: "closeTimePickerBtn",
                    ref: y,
                    type: "button",
                    class: Ie({ ...$.value, "dp--hidden-el": S.value }),
                    "aria-label": (F = X(u)) == null ? void 0 : F.closeTimePicker,
                    tabindex: "0",
                    onKeydown: Z[3] || (Z[3] = (q) => X(ia)(q, () => O(!1))),
                    onClick: Z[4] || (Z[4] = (q) => O(!1))
                  }, [
                    I.$slots["calendar-icon"] ? ke(I.$slots, "calendar-icon", { key: 0 }) : de("", !0),
                    I.$slots["calendar-icon"] ? de("", !0) : (N(), Ce(X(io), { key: 1 }))
                  ], 42, RK)), [
                    [Dn, !X(g)(I.hideNavigation, "time")]
                  ]) : de("", !0)
                ], 2)
              ], 14, DK)) : de("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 8, QK);
    };
  }
}), xC = (e, t, n, a) => {
  const { defaultedRange: i } = Gt(e), l = (C, S) => Array.isArray(t[C]) ? t[C][S] : t[C], r = (C) => e.enableSeconds ? Array.isArray(t.seconds) ? t.seconds[C] : t.seconds : 0, s = (C, S) => C ? S !== void 0 ? xl(C, l("hours", S), l("minutes", S), r(S)) : xl(C, t.hours, t.minutes, r()) : aC(_e(), r(S)), o = (C, S) => {
    t[C] = S;
  }, u = k(() => e.modelAuto && i.value.enabled ? Array.isArray(n.value) ? n.value.length > 1 : !1 : i.value.enabled), c = (C, S) => {
    const x = Object.fromEntries(
      Object.keys(t).map((w) => w === C ? [w, S] : [w, t[w]].slice())
    );
    if (u.value && !i.value.disableTimeRangeValidation) {
      const w = (_) => n.value ? xl(
        n.value[_],
        x.hours[_],
        x.minutes[_],
        x.seconds[_]
      ) : null, V = (_) => nC(n.value[_], 0);
      return !(ht(w(0), w(1)) && (Vr(w(0), V(1)) || Zs(w(1), V(0))));
    }
    return !0;
  }, d = (C, S) => {
    c(C, S) && (o(C, S), a && a());
  }, f = (C) => {
    d("hours", C);
  }, h = (C) => {
    d("minutes", C);
  }, m = (C) => {
    d("seconds", C);
  }, g = (C, S, x, w) => {
    S && f(C), !S && !x && h(C), x && m(C), n.value && w(n.value);
  }, v = (C) => {
    if (C) {
      const S = Array.isArray(C), x = S ? [+C[0].hours, +C[1].hours] : +C.hours, w = S ? [+C[0].minutes, +C[1].minutes] : +C.minutes, V = S ? [+C[0].seconds, +C[1].seconds] : +C.seconds;
      o("hours", x), o("minutes", w), e.enableSeconds && o("seconds", V);
    }
  }, y = (C, S) => {
    const x = {
      hours: Array.isArray(t.hours) ? t.hours[C] : t.hours,
      disabledArr: []
    };
    return (S || S === 0) && (x.hours = S), Array.isArray(e.disabledTimes) && (x.disabledArr = i.value.enabled && Array.isArray(e.disabledTimes[C]) ? e.disabledTimes[C] : e.disabledTimes), x;
  }, b = k(() => (C, S) => {
    var x;
    if (Array.isArray(e.disabledTimes)) {
      const { disabledArr: w, hours: V } = y(C, S), _ = w.filter((O) => +O.hours === V);
      return ((x = _[0]) == null ? void 0 : x.minutes) === "*" ? { hours: [V], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (_ == null ? void 0 : _.map((O) => +O.minutes)) ?? [],
        seconds: (_ == null ? void 0 : _.map((O) => O.seconds ? +O.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: o,
    updateHours: f,
    updateMinutes: h,
    updateSeconds: m,
    getSetDateTime: s,
    updateTimeValues: g,
    getSecondsValue: r,
    assignStartTime: v,
    validateTime: c,
    disabledTimesConfig: b
  };
}, IK = (e, t) => {
  const n = () => {
    e.isTextInputDate && S();
  }, { modelValue: a, time: i } = Hu(e, t, n), { defaultedStartTime: l, defaultedRange: r, defaultedTz: s } = Gt(e), { updateTimeValues: o, getSetDateTime: u, setTime: c, assignStartTime: d, disabledTimesConfig: f, validateTime: h } = xC(e, i, a, m);
  function m() {
    t("update-flow-step");
  }
  const g = (w) => {
    const { hours: V, minutes: _, seconds: O } = w;
    return { hours: +V, minutes: +_, seconds: O ? +O : 0 };
  }, v = () => {
    if (e.startTime) {
      if (Array.isArray(e.startTime)) {
        const V = g(e.startTime[0]), _ = g(e.startTime[1]);
        return [_t(_e(), V), _t(_e(), _)];
      }
      const w = g(e.startTime);
      return _t(_e(), w);
    }
    return r.value.enabled ? [null, null] : null;
  }, y = () => {
    if (r.value.enabled) {
      const [w, V] = v();
      a.value = [
        ga(u(w, 0), s.value.timezone),
        ga(u(V, 1), s.value.timezone)
      ];
    } else
      a.value = ga(u(v()), s.value.timezone);
  }, b = (w) => Array.isArray(w) ? [vr(_e(w[0])), vr(_e(w[1]))] : [vr(w ?? _e())], C = (w, V, _) => {
    c("hours", w), c("minutes", V), c("seconds", e.enableSeconds ? _ : 0);
  }, S = () => {
    const [w, V] = b(a.value);
    return r.value.enabled ? C(
      [w.hours, V.hours],
      [w.minutes, V.minutes],
      [w.seconds, V.seconds]
    ) : C(w.hours, w.minutes, w.seconds);
  };
  rt(() => {
    if (!e.shadow)
      return d(l.value), a.value ? S() : y();
  });
  const x = () => {
    Array.isArray(a.value) ? a.value = a.value.map((w, V) => w && u(w, V)) : a.value = u(a.value), t("time-update");
  };
  return {
    modelValue: a,
    time: i,
    disabledTimesConfig: f,
    updateTime: (w, V = !0, _ = !1) => {
      o(w, V, _, x);
    },
    validateTime: h
  };
}, BK = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...si
  },
  emits: [
    "update:internal-model-value",
    "time-update",
    "am-pm-change",
    "mount",
    "reset-flow",
    "update-flow-step",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, l = Rl(), r = ka(l, "timePicker"), s = Y(null), { time: o, modelValue: u, disabledTimesConfig: c, updateTime: d, validateTime: f } = IK(i, a);
    return rt(() => {
      i.shadow || a("mount", null);
    }), t({ getSidebarProps: () => ({
      modelValue: u,
      time: o,
      updateTime: d
    }), toggleTimePicker: (h, m = !1, g = "") => {
      var v;
      (v = s.value) == null || v.toggleTimePicker(h, m, g);
    } }), (h, m) => (N(), Ce(I1, {
      "multi-calendars": 0,
      stretch: "",
      "is-mobile": h.isMobile
    }, {
      default: re(() => [
        p(SC, fe({
          ref_key: "tpRef",
          ref: s
        }, h.$props, {
          hours: X(o).hours,
          minutes: X(o).minutes,
          seconds: X(o).seconds,
          "internal-model-value": h.internalModelValue,
          "disabled-times-config": X(c),
          "validate-time": X(f),
          "onUpdate:hours": m[0] || (m[0] = (g) => X(d)(g)),
          "onUpdate:minutes": m[1] || (m[1] = (g) => X(d)(g, !1)),
          "onUpdate:seconds": m[2] || (m[2] = (g) => X(d)(g, !1, !0)),
          onAmPmChange: m[3] || (m[3] = (g) => h.$emit("am-pm-change", g)),
          onResetFlow: m[4] || (m[4] = (g) => h.$emit("reset-flow")),
          onOverlayClosed: m[5] || (m[5] = (g) => h.$emit("overlay-toggle", { open: !1, overlay: g })),
          onOverlayOpened: m[6] || (m[6] = (g) => h.$emit("overlay-toggle", { open: !0, overlay: g }))
        }), Xt({ _: 2 }, [
          Ge(X(r), (g, v) => ({
            name: g,
            fn: re((y) => [
              ke(h.$slots, g, Pt(Jt(y)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
      ]),
      _: 3
    }, 8, ["is-mobile"]));
  }
}), ZK = { class: "dp--header-wrap" }, EK = {
  key: 0,
  class: "dp__month_year_wrap"
}, NK = { key: 0 }, HK = { class: "dp__month_year_wrap" }, jK = ["data-dp-element", "aria-label", "data-test-id", "onClick", "onKeydown"], zK = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...si
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed", "overlay-opened"],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, {
      defaultedTransitions: l,
      defaultedAriaLabels: r,
      defaultedMultiCalendars: s,
      defaultedFilters: o,
      defaultedConfig: u,
      defaultedHighlight: c,
      propDates: d,
      defaultedUI: f
    } = Gt(i), { transitionName: h, showTransition: m } = Nu(l), { buildMatrix: g } = Hl(), { handleMonthYearChange: v, isDisabled: y, updateMonthYear: b } = cK(i, a), { showLeftIcon: C, showRightIcon: S } = Z1(), x = Y(!1), w = Y(!1), V = Y(!1), _ = Y([null, null, null, null]);
    rt(() => {
      a("mount");
    });
    const O = (F) => ({
      get: () => i[F],
      set: (q) => {
        const z = F === ja.month ? ja.year : ja.month;
        a("update-month-year", { [F]: q, [z]: i[z] }), F === ja.month ? B(!0) : j(!0);
      }
    }), $ = k(O(ja.month)), P = k(O(ja.year)), M = k(() => (F) => ({
      month: i.month,
      year: i.year,
      items: F === ja.month ? i.months : i.years,
      instance: i.instance,
      updateMonthYear: b,
      toggle: F === ja.month ? B : j
    })), T = k(() => i.months.find((q) => q.value === i.month) || { text: "", value: 0 }), L = k(() => Ns(i.months, (F) => {
      const q = i.month === F.value, z = mu(
        F.value,
        fC(i.year, d.value.minDate),
        hC(i.year, d.value.maxDate)
      ) || o.value.months.includes(F.value), E = yC(c.value, F.value, i.year);
      return { active: q, disabled: z, highlighted: E };
    })), A = k(() => Ns(i.years, (F) => {
      const q = i.year === F.value, z = mu(
        F.value,
        Hs(d.value.minDate),
        Hs(d.value.maxDate)
      ) || o.value.years.includes(F.value), E = wv(c.value, F.value);
      return { active: q, disabled: z, highlighted: E };
    })), D = (F, q, z) => {
      z !== void 0 ? F.value = z : F.value = !F.value, F.value ? (V.value = !0, a("overlay-opened", q)) : (V.value = !1, a("overlay-closed", q));
    }, B = (F = !1, q) => {
      I(F), D(x, qn.month, q);
    }, j = (F = !1, q) => {
      I(F), D(w, qn.year, q);
    }, I = (F) => {
      F || a("reset-flow");
    }, Z = (F, q) => {
      i.arrowNavigation && (_.value[q] = Cn(F), g(_.value, "monthYear"));
    }, R = k(() => {
      var F, q, z, E, Q, W;
      return [
        {
          type: ja.month,
          index: 1,
          toggle: B,
          modelValue: $.value,
          updateModelValue: (se) => $.value = se,
          text: T.value.text,
          showSelectionGrid: x.value,
          items: L.value,
          ariaLabel: (F = r.value) == null ? void 0 : F.openMonthsOverlay,
          overlayLabel: ((z = (q = r.value).monthPicker) == null ? void 0 : z.call(q, !0)) ?? void 0
        },
        {
          type: ja.year,
          index: 2,
          toggle: j,
          modelValue: P.value,
          updateModelValue: (se) => P.value = se,
          text: uC(i.year, i.locale),
          showSelectionGrid: w.value,
          items: A.value,
          ariaLabel: (E = r.value) == null ? void 0 : E.openYearsOverlay,
          overlayLabel: ((W = (Q = r.value).yearPicker) == null ? void 0 : W.call(Q, !0)) ?? void 0
        }
      ];
    }), J = k(() => i.disableYearSelect ? [R.value[0]] : i.yearFirst ? [...R.value].reverse() : R.value);
    return t({
      toggleMonthPicker: B,
      toggleYearPicker: j,
      handleMonthYearChange: v
    }), (F, q) => {
      var z, E, Q, W, se, Se;
      return N(), ee("div", ZK, [
        F.$slots["month-year"] ? (N(), ee("div", EK, [
          ke(F.$slots, "month-year", Pt(Jt({
            month: e.month,
            year: e.year,
            months: e.months,
            years: e.years,
            updateMonthYear: X(b),
            handleMonthYearChange: X(v),
            instance: e.instance,
            isDisabled: X(y)
          })))
        ])) : (N(), ee(ge, { key: 1 }, [
          F.$slots["top-extra"] ? (N(), ee("div", NK, [
            ke(F.$slots, "top-extra", { value: F.internalModelValue })
          ])) : de("", !0),
          ie("div", HK, [
            X(C)(X(s), e.instance) && !F.vertical ? (N(), Ce(Ao, {
              key: 0,
              "aria-label": (z = X(r)) == null ? void 0 : z.prevMonth,
              disabled: X(y)(!1),
              class: Ie((E = X(f)) == null ? void 0 : E.navBtnPrev),
              "el-name": "action-prev",
              onActivate: q[0] || (q[0] = (U) => X(v)(!1, !0)),
              onSetRef: q[1] || (q[1] = (U) => Z(U, 0))
            }, {
              default: re(() => [
                F.$slots["arrow-left"] ? ke(F.$slots, "arrow-left", { key: 0 }) : de("", !0),
                F.$slots["arrow-left"] ? de("", !0) : (N(), Ce(X(hv), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : de("", !0),
            ie("div", {
              class: Ie(["dp__month_year_wrap", {
                dp__year_disable_select: F.disableYearSelect
              }])
            }, [
              (N(!0), ee(ge, null, Ge(J.value, (U, ne) => (N(), ee(ge, {
                key: U.type
              }, [
                ie("button", {
                  ref_for: !0,
                  ref: (K) => Z(K, ne + 1),
                  type: "button",
                  "data-dp-element": `overlay-${U.type}`,
                  class: Ie(["dp__btn dp__month_year_select", { "dp--hidden-el": V.value }]),
                  "aria-label": `${U.text}-${U.ariaLabel}`,
                  "data-test-id": `${U.type}-toggle-overlay-${e.instance}`,
                  onClick: U.toggle,
                  onKeydown: (K) => X(ia)(K, () => U.toggle(), !0)
                }, [
                  F.$slots[U.type] ? ke(F.$slots, U.type, {
                    key: 0,
                    text: U.text,
                    value: i[U.type]
                  }) : de("", !0),
                  F.$slots[U.type] ? de("", !0) : (N(), ee(ge, { key: 1 }, [
                    Ee(xe(U.text), 1)
                  ], 64))
                ], 42, jK),
                p(Jn, {
                  name: X(h)(U.showSelectionGrid),
                  css: X(m)
                }, {
                  default: re(() => [
                    U.showSelectionGrid ? (N(), Ce(Eu, {
                      key: 0,
                      items: U.items,
                      "arrow-navigation": F.arrowNavigation,
                      "hide-navigation": F.hideNavigation,
                      "is-last": F.autoApply && !X(u).keepActionRow,
                      "skip-button-ref": !1,
                      config: F.config,
                      type: U.type,
                      "header-refs": [],
                      "esc-close": F.escClose,
                      "menu-wrap-ref": F.menuWrapRef,
                      "text-input": F.textInput,
                      "aria-labels": F.ariaLabels,
                      "overlay-label": U.overlayLabel,
                      onSelected: U.updateModelValue,
                      onToggle: U.toggle
                    }, Xt({
                      "button-icon": re(() => [
                        F.$slots["calendar-icon"] ? ke(F.$slots, "calendar-icon", { key: 0 }) : de("", !0),
                        F.$slots["calendar-icon"] ? de("", !0) : (N(), Ce(X(io), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      F.$slots[`${U.type}-overlay-value`] ? {
                        name: "item",
                        fn: re(({ item: K }) => [
                          ke(F.$slots, `${U.type}-overlay-value`, {
                            text: K.text,
                            value: K.value
                          })
                        ]),
                        key: "0"
                      } : void 0,
                      F.$slots[`${U.type}-overlay`] ? {
                        name: "overlay",
                        fn: re(() => [
                          ke(F.$slots, `${U.type}-overlay`, fe({ ref_for: !0 }, M.value(U.type)))
                        ]),
                        key: "1"
                      } : void 0,
                      F.$slots[`${U.type}-overlay-header`] ? {
                        name: "header",
                        fn: re(() => [
                          ke(F.$slots, `${U.type}-overlay-header`, {
                            toggle: U.toggle
                          })
                        ]),
                        key: "2"
                      } : void 0
                    ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : de("", !0)
                  ]),
                  _: 2
                }, 1032, ["name", "css"])
              ], 64))), 128))
            ], 2),
            X(C)(X(s), e.instance) && F.vertical ? (N(), Ce(Ao, {
              key: 1,
              "aria-label": (Q = X(r)) == null ? void 0 : Q.prevMonth,
              "el-name": "action-prev",
              disabled: X(y)(!1),
              class: Ie((W = X(f)) == null ? void 0 : W.navBtnPrev),
              onActivate: q[2] || (q[2] = (U) => X(v)(!1, !0))
            }, {
              default: re(() => [
                F.$slots["arrow-up"] ? ke(F.$slots, "arrow-up", { key: 0 }) : de("", !0),
                F.$slots["arrow-up"] ? de("", !0) : (N(), Ce(X(gv), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : de("", !0),
            X(S)(X(s), e.instance) ? (N(), Ce(Ao, {
              key: 2,
              ref: "rightIcon",
              "el-name": "action-next",
              disabled: X(y)(!0),
              "aria-label": (se = X(r)) == null ? void 0 : se.nextMonth,
              class: Ie((Se = X(f)) == null ? void 0 : Se.navBtnNext),
              onActivate: q[3] || (q[3] = (U) => X(v)(!0, !0)),
              onSetRef: q[4] || (q[4] = (U) => Z(U, F.disableYearSelect ? 2 : 3))
            }, {
              default: re(() => [
                F.$slots[F.vertical ? "arrow-down" : "arrow-right"] ? ke(F.$slots, F.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : de("", !0),
                F.$slots[F.vertical ? "arrow-down" : "arrow-right"] ? de("", !0) : (N(), Ce(Lr(F.vertical ? X(pv) : X(mv)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label", "class"])) : de("", !0)
          ])
        ], 64))
      ]);
    };
  }
}), FK = {
  class: "dp__calendar_header",
  role: "row"
}, XK = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, YK = ["aria-label"], WK = {
  key: 0,
  class: "dp__calendar_item dp__week_num",
  role: "gridcell"
}, qK = { class: "dp__cell_inner" }, UK = ["id", "aria-pressed", "aria-disabled", "aria-label", "tabindex", "data-test-id", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"], GK = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...si
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, { buildMultiLevelMatrix: l } = Hl(), {
      defaultedTransitions: r,
      defaultedConfig: s,
      defaultedAriaLabels: o,
      defaultedMultiCalendars: u,
      defaultedWeekNumbers: c,
      defaultedMultiDates: d,
      defaultedUI: f
    } = Gt(i), h = Y(null), m = Y({
      bottom: "",
      left: "",
      transform: ""
    }), g = Y([]), v = Y(null), y = Y(!0), b = Y(""), C = Y({ startX: 0, endX: 0, startY: 0, endY: 0 }), S = Y([]), x = Y({ left: "50%" }), w = Y(!1), V = k(() => i.calendar ? i.calendar(i.mappedDates) : i.mappedDates), _ = k(() => i.dayNames ? Array.isArray(i.dayNames) ? i.dayNames : i.dayNames(i.locale, +i.weekStart) : VG(i.formatLocale, i.locale, +i.weekStart));
    rt(() => {
      a("mount", { cmp: "calendar", refs: g }), s.value.noSwipe || v.value && (v.value.addEventListener("touchstart", Z, { passive: !1 }), v.value.addEventListener("touchend", R, { passive: !1 }), v.value.addEventListener("touchmove", J, { passive: !1 })), i.monthChangeOnScroll && v.value && v.value.addEventListener("wheel", z, { passive: !1 });
    }), ni(() => {
      s.value.noSwipe || v.value && (v.value.removeEventListener("touchstart", Z), v.value.removeEventListener("touchend", R), v.value.removeEventListener("touchmove", J)), i.monthChangeOnScroll && v.value && v.value.removeEventListener("wheel", z);
    });
    const O = (U) => U ? i.vertical ? "vNext" : "next" : i.vertical ? "vPrevious" : "previous", $ = (U, ne) => {
      if (i.transitions) {
        const K = In(zi(_e(), i.month, i.year));
        b.value = cn(In(zi(_e(), U, ne)), K) ? r.value[O(!0)] : r.value[O(!1)], y.value = !1, et(() => {
          y.value = !0;
        });
      }
    }, P = k(
      () => ({
        ...f.value.calendar ?? {}
      })
    ), M = k(() => (U) => {
      const ne = LG(U);
      return {
        dp__marker_dot: ne.type === "dot",
        dp__marker_line: ne.type === "line"
      };
    }), T = k(() => (U) => ht(U, h.value)), L = k(() => ({
      dp__calendar: !0,
      dp__calendar_next: u.value.count > 0 && i.instance !== 0
    })), A = k(() => (U) => i.hideOffsetDates ? U.current : !0), D = async (U, ne) => {
      const { width: K, height: te } = U.getBoundingClientRect();
      h.value = ne.value;
      let H = { left: `${K / 2}px` }, ce = -50;
      if (await et(), S.value[0]) {
        const { left: he, width: Oe } = S.value[0].getBoundingClientRect();
        he < 0 && (H = { left: "0" }, ce = 0, x.value.left = `${K / 2}px`), window.innerWidth < he + Oe && (H = { right: "0" }, ce = 0, x.value.left = `${Oe - K / 2}px`);
      }
      m.value = {
        bottom: `${te}px`,
        ...H,
        transform: `translateX(${ce}%)`
      };
    }, B = async (U, ne, K) => {
      var te, H, ce;
      const he = Cn(g.value[ne][K]);
      he && ((te = U.marker) != null && te.customPosition && (ce = (H = U.marker) == null ? void 0 : H.tooltip) != null && ce.length ? m.value = U.marker.customPosition(he) : await D(he, U), a("tooltip-open", U.marker));
    }, j = async (U, ne, K) => {
      var te, H;
      if (w.value && d.value.enabled && d.value.dragSelect)
        return a("select-date", U);
      if (a("set-hover-date", U), (H = (te = U.marker) == null ? void 0 : te.tooltip) != null && H.length) {
        if (i.hideOffsetDates && !U.current) return;
        await B(U, ne, K);
      }
    }, I = (U) => {
      h.value && (h.value = null, m.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", U.marker));
    }, Z = (U) => {
      C.value.startX = U.changedTouches[0].screenX, C.value.startY = U.changedTouches[0].screenY;
    }, R = (U) => {
      C.value.endX = U.changedTouches[0].screenX, C.value.endY = U.changedTouches[0].screenY, F();
    }, J = (U) => {
      i.vertical && !i.inline && U.preventDefault();
    }, F = () => {
      const U = i.vertical ? "Y" : "X";
      Math.abs(C.value[`start${U}`] - C.value[`end${U}`]) > 10 && a("handle-swipe", C.value[`start${U}`] > C.value[`end${U}`] ? "right" : "left");
    }, q = (U, ne, K) => {
      U && (Array.isArray(g.value[ne]) ? g.value[ne][K] = U : g.value[ne] = [U]), i.arrowNavigation && l(g.value, "calendar");
    }, z = (U) => {
      i.monthChangeOnScroll && (U.preventDefault(), a("handle-scroll", U));
    }, E = (U) => c.value.type === "local" ? cv(U.value, { weekStartsOn: +i.weekStart }) : c.value.type === "iso" ? ov(U.value) : typeof c.value.type == "function" ? c.value.type(U.value) : "", Q = (U) => {
      const ne = U[0];
      return c.value.hideOnOffsetDates ? U.some((K) => K.current) ? E(ne) : "" : E(ne);
    }, W = (U, ne, K = !0) => {
      !K && IG() || (!d.value.enabled || s.value.allowPreventDefault) && (Sl(U, s.value), a("select-date", ne));
    }, se = (U) => {
      Sl(U, s.value);
    }, Se = (U) => {
      d.value.enabled && d.value.dragSelect ? (w.value = !0, a("select-date", U)) : d.value.enabled && a("select-date", U);
    };
    return t({ triggerTransition: $ }), (U, ne) => (N(), ee("div", {
      class: Ie(L.value)
    }, [
      ie("div", {
        ref_key: "calendarWrapRef",
        ref: v,
        class: Ie(P.value),
        role: "grid"
      }, [
        ie("div", FK, [
          U.weekNumbers ? (N(), ee("div", XK, xe(U.weekNumName), 1)) : de("", !0),
          (N(!0), ee(ge, null, Ge(_.value, (K, te) => {
            var H, ce;
            return N(), ee("div", {
              key: te,
              class: "dp__calendar_header_item",
              role: "gridcell",
              "data-test-id": "calendar-header",
              "aria-label": (ce = (H = X(o)) == null ? void 0 : H.weekDay) == null ? void 0 : ce.call(H, te)
            }, [
              U.$slots["calendar-header"] ? ke(U.$slots, "calendar-header", {
                key: 0,
                day: K,
                index: te
              }) : de("", !0),
              U.$slots["calendar-header"] ? de("", !0) : (N(), ee(ge, { key: 1 }, [
                Ee(xe(K), 1)
              ], 64))
            ], 8, YK);
          }), 128))
        ]),
        ne[2] || (ne[2] = ie("div", { class: "dp__calendar_header_separator" }, null, -1)),
        p(Jn, {
          name: b.value,
          css: !!U.transitions
        }, {
          default: re(() => [
            y.value ? (N(), ee("div", {
              key: 0,
              class: "dp__calendar",
              role: "rowgroup",
              onMouseleave: ne[1] || (ne[1] = (K) => w.value = !1)
            }, [
              (N(!0), ee(ge, null, Ge(V.value, (K, te) => (N(), ee("div", {
                key: te,
                class: "dp__calendar_row",
                role: "row"
              }, [
                U.weekNumbers ? (N(), ee("div", WK, [
                  ie("div", qK, xe(Q(K.days)), 1)
                ])) : de("", !0),
                (N(!0), ee(ge, null, Ge(K.days, (H, ce) => {
                  var he, Oe, je;
                  return N(), ee("div", {
                    id: X(t2)(H.value),
                    ref_for: !0,
                    ref: (be) => q(be, te, ce),
                    key: ce + te,
                    role: "gridcell",
                    class: "dp__calendar_item",
                    "aria-pressed": (H.classData.dp__active_date || H.classData.dp__range_start || H.classData.dp__range_start) ?? void 0,
                    "aria-disabled": H.classData.dp__cell_disabled || void 0,
                    "aria-label": (Oe = (he = X(o)) == null ? void 0 : he.day) == null ? void 0 : Oe.call(he, H),
                    tabindex: !H.current && U.hideOffsetDates ? void 0 : 0,
                    "data-test-id": X(t2)(H.value),
                    onClick: $t((be) => W(be, H), ["prevent"]),
                    onTouchend: (be) => W(be, H, !1),
                    onKeydown: (be) => X(ia)(be, () => U.$emit("select-date", H)),
                    onMouseenter: (be) => j(H, te, ce),
                    onMouseleave: (be) => I(H),
                    onMousedown: (be) => Se(H),
                    onMouseup: ne[0] || (ne[0] = (be) => w.value = !1)
                  }, [
                    ie("div", {
                      class: Ie(["dp__cell_inner", H.classData])
                    }, [
                      U.$slots.day && A.value(H) ? ke(U.$slots, "day", {
                        key: 0,
                        day: +H.text,
                        date: H.value
                      }) : de("", !0),
                      U.$slots.day ? de("", !0) : (N(), ee(ge, { key: 1 }, [
                        Ee(xe(H.text), 1)
                      ], 64)),
                      H.marker && A.value(H) ? (N(), ee(ge, { key: 2 }, [
                        U.$slots.marker ? ke(U.$slots, "marker", {
                          key: 0,
                          marker: H.marker,
                          day: +H.text,
                          date: H.value
                        }) : (N(), ee("div", {
                          key: 1,
                          class: Ie(M.value(H.marker)),
                          style: Ot(H.marker.color ? { backgroundColor: H.marker.color } : {})
                        }, null, 6))
                      ], 64)) : de("", !0),
                      T.value(H.value) ? (N(), ee("div", {
                        key: 3,
                        ref_for: !0,
                        ref_key: "activeTooltip",
                        ref: S,
                        class: "dp__marker_tooltip",
                        style: Ot(m.value)
                      }, [
                        (je = H.marker) != null && je.tooltip ? (N(), ee("div", {
                          key: 0,
                          class: "dp__tooltip_content",
                          onClick: se
                        }, [
                          (N(!0), ee(ge, null, Ge(H.marker.tooltip, (be, Te) => (N(), ee("div", {
                            key: Te,
                            class: "dp__tooltip_text"
                          }, [
                            U.$slots["marker-tooltip"] ? ke(U.$slots, "marker-tooltip", {
                              key: 0,
                              tooltip: be,
                              day: H.value
                            }) : de("", !0),
                            U.$slots["marker-tooltip"] ? de("", !0) : (N(), ee(ge, { key: 1 }, [
                              ie("div", {
                                class: "dp__tooltip_mark",
                                style: Ot(be.color ? { backgroundColor: be.color } : {})
                              }, null, 4),
                              ie("div", null, xe(be.text), 1)
                            ], 64))
                          ]))), 128)),
                          ie("div", {
                            class: "dp__arrow_bottom_tp",
                            style: Ot(x.value)
                          }, null, 4)
                        ])) : de("", !0)
                      ], 4)) : de("", !0)
                    ], 2)
                  ], 40, UK);
                }), 128))
              ]))), 128))
            ], 32)) : de("", !0)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ], 2)
    ], 2));
  }
}), F4 = (e) => Array.isArray(e), KK = (e, t, n, a) => {
  const i = Y([]), l = Y(/* @__PURE__ */ new Date()), r = Y(), s = () => R(e.isTextInputDate), { modelValue: o, calendars: u, time: c, today: d } = Hu(e, t, s), {
    defaultedMultiCalendars: f,
    defaultedStartTime: h,
    defaultedRange: m,
    defaultedConfig: g,
    defaultedTz: v,
    propDates: y,
    defaultedMultiDates: b
  } = Gt(e), { validateMonthYearInRange: C, isDisabled: S, isDateRangeAllowed: x, checkMinMaxRange: w } = jl(e), { updateTimeValues: V, getSetDateTime: _, setTime: O, assignStartTime: $, validateTime: P, disabledTimesConfig: M } = xC(e, c, o, a), T = k(
    () => (me) => u.value[me] ? u.value[me].month : 0
  ), L = k(
    () => (me) => u.value[me] ? u.value[me].year : 0
  ), A = (me) => !g.value.keepViewOnOffsetClick || me ? !0 : !r.value, D = (me, Le, Je, st = !1) => {
    var $e, Ze;
    A(st) && (u.value[me] || (u.value[me] = { month: 0, year: 0 }), u.value[me].month = Z4(Le) ? ($e = u.value[me]) == null ? void 0 : $e.month : Le, u.value[me].year = Z4(Je) ? (Ze = u.value[me]) == null ? void 0 : Ze.year : Je);
  }, B = () => {
    e.autoApply && t("select-date");
  }, j = () => {
    h.value && $(h.value);
  };
  rt(() => {
    e.shadow || (o.value || (ne(), j()), R(!0), e.focusStartDate && e.startDate && ne());
  });
  const I = k(() => {
    var me;
    return (me = e.flow) != null && me.length && !e.partialFlow ? e.flowStep === e.flow.length : !0;
  }), Z = () => {
    e.autoApply && I.value && t("auto-apply", e.partialFlow ? e.flowStep !== e.flow.length : !1);
  }, R = (me = !1) => {
    if (o.value)
      return Array.isArray(o.value) ? (i.value = o.value, W(me)) : q(o.value, me);
    if (f.value.count && me && !e.startDate)
      return F(_e(), me);
  }, J = () => Array.isArray(o.value) && m.value.enabled ? ft(o.value[0]) === ft(o.value[1] ?? o.value[0]) : !1, F = (me = /* @__PURE__ */ new Date(), Le = !1) => {
    if ((!f.value.count || !f.value.static || Le) && D(0, ft(me), it(me)), f.value.count && (!o.value || J() || !f.value.solo) && (!f.value.solo || Le))
      for (let Je = 1; Je < f.value.count; Je++) {
        const st = _t(_e(), { month: T.value(Je - 1), year: L.value(Je - 1) }), $e = Bb(st, { months: 1 });
        u.value[Je] = { month: ft($e), year: it($e) };
      }
  }, q = (me, Le) => {
    F(me), O("hours", tl(me)), O("minutes", Dl(me)), O("seconds", Bs(me)), f.value.count && Le && U();
  }, z = (me) => {
    if (f.value.count) {
      if (f.value.solo) return 0;
      const Le = ft(me[0]), Je = ft(me[1]);
      return Math.abs(Je - Le) < f.value.count ? 0 : 1;
    }
    return 1;
  }, E = (me, Le) => {
    me[1] && m.value.showLastInRange ? F(me[z(me)], Le) : F(me[0], Le);
    const Je = (st, $e) => [
      st(me[0]),
      me[1] ? st(me[1]) : c[$e][1]
    ];
    O("hours", Je(tl, "hours")), O("minutes", Je(Dl, "minutes")), O("seconds", Je(Bs, "seconds"));
  }, Q = (me, Le) => {
    if ((m.value.enabled || e.weekPicker) && !b.value.enabled)
      return E(me, Le);
    if (b.value.enabled && Le) {
      const Je = me[me.length - 1];
      return q(Je, Le);
    }
  }, W = (me) => {
    const Le = o.value;
    Q(Le, me), f.value.count && f.value.solo && U();
  }, se = (me, Le) => {
    const Je = _t(_e(), { month: T.value(Le), year: L.value(Le) }), st = me < 0 ? Ua(Je, 1) : Es(Je, 1);
    C(ft(st), it(st), me < 0, e.preventMinMaxNavigation) && (D(Le, ft(st), it(st)), t("update-month-year", { instance: Le, month: ft(st), year: it(st) }), f.value.count && !f.value.solo && Se(Le), n());
  }, Se = (me) => {
    for (let Le = me - 1; Le >= 0; Le--) {
      const Je = Es(_t(_e(), { month: T.value(Le + 1), year: L.value(Le + 1) }), 1);
      D(Le, ft(Je), it(Je));
    }
    for (let Le = me + 1; Le <= f.value.count - 1; Le++) {
      const Je = Ua(_t(_e(), { month: T.value(Le - 1), year: L.value(Le - 1) }), 1);
      D(Le, ft(Je), it(Je));
    }
  }, U = () => {
    if (Array.isArray(o.value) && o.value.length === 2) {
      const me = _e(
        _e(o.value[1] ? o.value[1] : Ua(o.value[0], 1))
      ), [Le, Je] = [ft(o.value[0]), it(o.value[0])], [st, $e] = [ft(o.value[1]), it(o.value[1])];
      (Le !== st || Le === st && Je !== $e) && f.value.solo && D(1, ft(me), it(me));
    } else o.value && !Array.isArray(o.value) && (D(0, ft(o.value), it(o.value)), F(_e()));
  }, ne = () => {
    e.startDate && (D(0, ft(_e(e.startDate)), it(_e(e.startDate))), f.value.count && Se(0));
  }, K = (me, Le) => {
    if (e.monthChangeOnScroll) {
      const Je = (/* @__PURE__ */ new Date()).getTime() - l.value.getTime(), st = Math.abs(me.deltaY);
      let $e = 500;
      st > 1 && ($e = 100), st > 100 && ($e = 0), Je > $e && (l.value = /* @__PURE__ */ new Date(), se(e.monthChangeOnScroll !== "inverse" ? -me.deltaY : me.deltaY, Le));
    }
  }, te = (me, Le, Je = !1) => {
    e.monthChangeOnArrows && e.vertical === Je && H(me, Le);
  }, H = (me, Le) => {
    se(me === "right" ? -1 : 1, Le);
  }, ce = (me) => {
    if (y.value.markers)
      return Qd(me.value, y.value.markers);
  }, he = (me, Le) => {
    switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
      case "prepend":
        return [!0, !1];
      case "center":
        return [me == 0, !0];
      case "fair":
        return [me == 0 || Le > me, !0];
      case "append":
        return [!1, !1];
      default:
        return [!1, !1];
    }
  }, Oe = (me, Le, Je, st) => {
    if (e.sixWeeks && me.length < 6) {
      const $e = 6 - me.length, Ze = (Le.getDay() + 7 - st) % 7, We = 6 - (Je.getDay() + 7 - st) % 7, [Zi, oi] = he(Ze, We);
      for (let Xl = 1; Xl <= $e; Xl++)
        if (oi ? !!(Xl % 2) == Zi : Zi) {
          const dl = me[0].days[0], z1 = je(Va(dl.value, -7), ft(Le));
          me.unshift({ days: z1 });
        } else {
          const dl = me[me.length - 1], z1 = dl.days[dl.days.length - 1], $C = je(Va(z1.value, 1), ft(Le));
          me.push({ days: $C });
        }
    }
    return me;
  }, je = (me, Le) => {
    const Je = _e(me), st = [];
    for (let $e = 0; $e < 7; $e++) {
      const Ze = Va(Je, $e), We = ft(Ze) !== Le;
      st.push({
        text: e.hideOffsetDates && We ? "" : Ze.getDate(),
        value: Ze,
        current: !We,
        classData: {}
      });
    }
    return st;
  }, be = (me, Le) => {
    const Je = [], st = new Date(Le, me), $e = new Date(Le, me + 1, 0), Ze = e.weekStart, We = ti(st, { weekStartsOn: Ze }), Zi = (oi) => {
      const Xl = je(oi, me);
      if (Je.push({ days: Xl }), !Je[Je.length - 1].days.some(
        (dl) => ht(In(dl.value), In($e))
      )) {
        const dl = Va(oi, 7);
        Zi(dl);
      }
    };
    return Zi(We), Oe(Je, st, $e, Ze);
  }, Te = (me) => {
    const Le = xl(_e(me.value), c.hours, c.minutes, Ye());
    t("date-update", Le), b.value.enabled ? kv(Le, o, b.value.limit) : o.value = Le, a(), et().then(() => {
      Z();
    });
  }, Be = (me) => m.value.noDisabledRange ? mC(i.value[0], me).some((Le) => S(Le)) : !1, oe = () => {
    i.value = o.value ? o.value.slice() : [], i.value.length === 2 && !(m.value.fixedStart || m.value.fixedEnd) && (i.value = []);
  }, Me = (me, Le) => {
    const Je = [
      _e(me.value),
      Va(_e(me.value), +m.value.autoRange)
    ];
    x(Je) ? (Le && Xe(me.value), i.value = Je) : t("invalid-date", me.value);
  }, Xe = (me) => {
    const Le = ft(_e(me)), Je = it(_e(me));
    if (D(0, Le, Je), f.value.count > 0)
      for (let st = 1; st < f.value.count; st++) {
        const $e = EG(
          _t(_e(me), { year: L.value(st - 1), month: T.value(st - 1) })
        );
        D(st, $e.month, $e.year);
      }
  }, Ke = (me) => {
    if (Be(me.value) || !w(me.value, o.value, m.value.fixedStart ? 0 : 1))
      return t("invalid-date", me.value);
    i.value = wC(_e(me.value), o, t, m);
  }, Kt = (me, Le) => {
    if (oe(), m.value.autoRange) return Me(me, Le);
    if (m.value.fixedStart || m.value.fixedEnd) return Ke(me);
    i.value[0] ? w(_e(me.value), o.value) && !Be(me.value) ? an(_e(me.value), _e(i.value[0])) ? (i.value.unshift(_e(me.value)), t("range-end", i.value[0])) : (i.value[1] = _e(me.value), t("range-end", i.value[1])) : (e.autoApply && t("auto-apply-invalid", me.value), t("invalid-date", me.value)) : (i.value[0] = _e(me.value), t("range-start", i.value[0]));
  }, Ye = (me = !0) => e.enableSeconds ? Array.isArray(c.seconds) ? me ? c.seconds[0] : c.seconds[1] : c.seconds : 0, pn = (me) => {
    i.value[me] = xl(
      i.value[me],
      c.hours[me],
      c.minutes[me],
      Ye(me !== 1)
    );
  }, Rt = () => {
    var me, Le;
    i.value[0] && i.value[1] && +((me = i.value) == null ? void 0 : me[0]) > +((Le = i.value) == null ? void 0 : Le[1]) && (i.value.reverse(), t("range-start", i.value[0]), t("range-end", i.value[1]));
  }, zl = () => {
    i.value.length && (i.value[0] && !i.value[1] ? pn(0) : (pn(0), pn(1), a()), Rt(), o.value = i.value.slice(), B1(i.value, t, e.autoApply, e.modelAuto));
  }, Fl = (me, Le = !1) => {
    if (S(me.value) || !me.current && e.hideOffsetDates) return t("invalid-date", me.value);
    if (r.value = JSON.parse(JSON.stringify(me)), !m.value.enabled) return Te(me);
    F4(c.hours) && F4(c.minutes) && !b.value.enabled && (Kt(me, Le), zl());
  }, cl = (me, Le) => {
    var Je;
    D(me, Le.month, Le.year, !0), f.value.count && !f.value.solo && Se(me), t("update-month-year", { instance: me, month: Le.month, year: Le.year }), n(f.value.solo ? me : void 0);
    const st = (Je = e.flow) != null && Je.length ? e.flow[e.flowStep] : void 0;
    !Le.fromNav && (st === qn.month || st === qn.year) && a();
  }, E1 = (me, Le) => {
    CC({
      value: me,
      modelValue: o,
      range: m.value.enabled,
      timezone: Le ? void 0 : v.value.timezone
    }), B(), e.multiCalendars && et().then(() => R(!0));
  }, N1 = () => {
    const me = yv(_e(), v.value);
    !m.value.enabled && !b.value.enabled ? o.value = me : o.value && Array.isArray(o.value) && o.value[0] ? b.value.enabled ? o.value = [...o.value, me] : o.value = an(me, o.value[0]) ? [me, o.value[0]] : [o.value[0], me] : o.value = [me], B();
  }, H1 = () => {
    if (Array.isArray(o.value))
      if (b.value.enabled) {
        const me = j1();
        o.value[o.value.length - 1] = _(me);
      } else
        o.value = o.value.map((me, Le) => me && _(me, Le));
    else
      o.value = _(o.value);
    t("time-update");
  }, j1 = () => Array.isArray(o.value) && o.value.length ? o.value[o.value.length - 1] : null;
  return {
    calendars: u,
    modelValue: o,
    month: T,
    year: L,
    time: c,
    disabledTimesConfig: M,
    today: d,
    validateTime: P,
    getCalendarDays: be,
    getMarker: ce,
    handleScroll: K,
    handleSwipe: H,
    handleArrow: te,
    selectDate: Fl,
    updateMonthYear: cl,
    presetDate: E1,
    selectCurrentDate: N1,
    updateTime: (me, Le = !0, Je = !1) => {
      V(me, Le, Je, H1);
    },
    assignMonthAndYear: F,
    setStartTime: j
  };
}, JK = { key: 0 }, eJ = /* @__PURE__ */ Sn({
  __name: "DatePicker",
  props: {
    ...si
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, {
      calendars: l,
      month: r,
      year: s,
      modelValue: o,
      time: u,
      disabledTimesConfig: c,
      today: d,
      validateTime: f,
      getCalendarDays: h,
      getMarker: m,
      handleArrow: g,
      handleScroll: v,
      handleSwipe: y,
      selectDate: b,
      updateMonthYear: C,
      presetDate: S,
      selectCurrentDate: x,
      updateTime: w,
      assignMonthAndYear: V,
      setStartTime: _
    } = KK(i, a, J, F), O = Rl(), { setHoverDate: $, getDayClassData: P, clearHoverDate: M } = pJ(o, i), { defaultedMultiCalendars: T } = Gt(i), L = Y([]), A = Y([]), D = Y(null), B = ka(O, "calendar"), j = ka(O, "monthYear"), I = ka(O, "timePicker"), Z = (K) => {
      i.shadow || a("mount", K);
    };
    pe(
      l,
      () => {
        i.shadow || setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    ), pe(
      T,
      (K, te) => {
        K.count - te.count > 0 && V();
      },
      { deep: !0 }
    );
    const R = k(() => (K) => h(r.value(K), s.value(K)).map((te) => ({
      ...te,
      days: te.days.map((H) => (H.marker = m(H), H.classData = P(H), H))
    })));
    function J(K) {
      var te;
      K || K === 0 ? (te = A.value[K]) == null || te.triggerTransition(r.value(K), s.value(K)) : A.value.forEach((H, ce) => H.triggerTransition(r.value(ce), s.value(ce)));
    }
    function F() {
      a("update-flow-step");
    }
    const q = (K, te = !1) => {
      b(K, te), i.spaceConfirm && a("select-date");
    }, z = (K, te, H = 0) => {
      var ce;
      (ce = L.value[H]) == null || ce.toggleMonthPicker(K, te);
    }, E = (K, te, H = 0) => {
      var ce;
      (ce = L.value[H]) == null || ce.toggleYearPicker(K, te);
    }, Q = (K, te, H) => {
      var ce;
      (ce = D.value) == null || ce.toggleTimePicker(K, te, H);
    }, W = (K, te) => {
      var H;
      if (!i.range) {
        const ce = o.value ? o.value : d, he = te ? new Date(te) : ce, Oe = K ? ti(he, { weekStartsOn: 1 }) : Fb(he, { weekStartsOn: 1 });
        b({
          value: Oe,
          current: ft(he) === r.value(0),
          text: "",
          classData: {}
        }), (H = document.getElementById(t2(Oe))) == null || H.focus();
      }
    }, se = (K) => {
      var te;
      (te = L.value[0]) == null || te.handleMonthYearChange(K, !0);
    }, Se = (K) => {
      C(0, { month: r.value(0), year: s.value(0) + (K ? 1 : -1), fromNav: !0 });
    }, U = (K, te) => {
      K === qn.time && a(`time-picker-${te ? "open" : "close"}`), a("overlay-toggle", { open: te, overlay: K });
    }, ne = (K) => {
      a("overlay-toggle", { open: !1, overlay: K }), a("focus-menu");
    };
    return t({
      clearHoverDate: M,
      presetDate: S,
      selectCurrentDate: x,
      toggleMonthPicker: z,
      toggleYearPicker: E,
      toggleTimePicker: Q,
      handleArrow: g,
      updateMonthYear: C,
      getSidebarProps: () => ({
        modelValue: o,
        month: r,
        year: s,
        time: u,
        updateTime: w,
        updateMonthYear: C,
        selectDate: b,
        presetDate: S
      }),
      changeMonth: se,
      changeYear: Se,
      selectWeekDate: W,
      setStartTime: _
    }), (K, te) => (N(), ee(ge, null, [
      p(I1, {
        "multi-calendars": X(T).count,
        collapse: K.collapse,
        "is-mobile": K.isMobile
      }, {
        default: re(({ instance: H, index: ce }) => [
          K.disableMonthYearSelect ? de("", !0) : (N(), Ce(zK, fe({
            key: 0,
            ref: (he) => {
              he && (L.value[ce] = he);
            },
            months: X(rC)(K.formatLocale, K.locale, K.monthNameFormat),
            years: X(Ov)(K.yearRange, K.locale, K.reverseYears),
            month: X(r)(H),
            year: X(s)(H),
            instance: H
          }, K.$props, {
            onMount: te[0] || (te[0] = (he) => Z(X(mr).header)),
            onResetFlow: te[1] || (te[1] = (he) => K.$emit("reset-flow")),
            onUpdateMonthYear: (he) => X(C)(H, he),
            onOverlayClosed: ne,
            onOverlayOpened: te[2] || (te[2] = (he) => K.$emit("overlay-toggle", { open: !0, overlay: he }))
          }), Xt({ _: 2 }, [
            Ge(X(j), (he, Oe) => ({
              name: he,
              fn: re((je) => [
                ke(K.$slots, he, Pt(Jt(je)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          p(GK, fe({
            ref: (he) => {
              he && (A.value[ce] = he);
            },
            "mapped-dates": R.value(H),
            month: X(r)(H),
            year: X(s)(H),
            instance: H
          }, K.$props, {
            onSelectDate: (he) => X(b)(he, H !== 1),
            onHandleSpace: (he) => q(he, H !== 1),
            onSetHoverDate: te[3] || (te[3] = (he) => X($)(he)),
            onHandleScroll: (he) => X(v)(he, H),
            onHandleSwipe: (he) => X(y)(he, H),
            onMount: te[4] || (te[4] = (he) => Z(X(mr).calendar)),
            onResetFlow: te[5] || (te[5] = (he) => K.$emit("reset-flow")),
            onTooltipOpen: te[6] || (te[6] = (he) => K.$emit("tooltip-open", he)),
            onTooltipClose: te[7] || (te[7] = (he) => K.$emit("tooltip-close", he))
          }), Xt({ _: 2 }, [
            Ge(X(B), (he, Oe) => ({
              name: he,
              fn: re((je) => [
                ke(K.$slots, he, Pt(Jt({ ...je })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]),
      K.enableTimePicker ? (N(), ee("div", JK, [
        K.$slots["time-picker"] ? ke(K.$slots, "time-picker", Pt(fe({ key: 0 }, { time: X(u), updateTime: X(w) }))) : (N(), Ce(SC, fe({
          key: 1,
          ref_key: "timePickerRef",
          ref: D
        }, K.$props, {
          hours: X(u).hours,
          minutes: X(u).minutes,
          seconds: X(u).seconds,
          "internal-model-value": K.internalModelValue,
          "disabled-times-config": X(c),
          "validate-time": X(f),
          onMount: te[8] || (te[8] = (H) => Z(X(mr).timePicker)),
          "onUpdate:hours": te[9] || (te[9] = (H) => X(w)(H)),
          "onUpdate:minutes": te[10] || (te[10] = (H) => X(w)(H, !1)),
          "onUpdate:seconds": te[11] || (te[11] = (H) => X(w)(H, !1, !0)),
          onResetFlow: te[12] || (te[12] = (H) => K.$emit("reset-flow")),
          onOverlayClosed: te[13] || (te[13] = (H) => U(H, !1)),
          onOverlayOpened: te[14] || (te[14] = (H) => U(H, !0)),
          onAmPmChange: te[15] || (te[15] = (H) => K.$emit("am-pm-change", H))
        }), Xt({ _: 2 }, [
          Ge(X(I), (H, ce) => ({
            name: H,
            fn: re((he) => [
              ke(K.$slots, H, Pt(Jt(he)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
      ])) : de("", !0)
    ], 64));
  }
}), tJ = (e, t) => {
  const n = Y(), {
    defaultedMultiCalendars: a,
    defaultedConfig: i,
    defaultedHighlight: l,
    defaultedRange: r,
    propDates: s,
    defaultedFilters: o,
    defaultedMultiDates: u
  } = Gt(e), { modelValue: c, year: d, month: f, calendars: h } = Hu(e, t), { isDisabled: m } = jl(e), { selectYear: g, groupedYears: v, showYearPicker: y, isDisabled: b, toggleYearPicker: C, handleYearSelect: S, handleYear: x } = kC({
    modelValue: c,
    multiCalendars: a,
    range: r,
    highlight: l,
    calendars: h,
    propDates: s,
    month: f,
    year: d,
    filters: o,
    props: e,
    emit: t
  }), w = (A, D) => [A, D].map((B) => _i(B, "MMMM", { locale: e.formatLocale })).join("-"), V = k(() => (A) => c.value ? Array.isArray(c.value) ? c.value.some((D) => R4(A, D)) : R4(c.value, A) : !1), _ = (A) => {
    if (r.value.enabled) {
      if (Array.isArray(c.value)) {
        const D = ht(A, c.value[0]) || ht(A, c.value[1]);
        return vu(c.value, n.value, A) && !D;
      }
      return !1;
    }
    return !1;
  }, O = (A, D) => A.quarter === V4(D) && A.year === it(D), $ = (A) => typeof l.value == "function" ? l.value({ quarter: V4(A), year: it(A) }) : !!l.value.quarters.find((D) => O(D, A)), P = k(() => (A) => {
    const D = _t(/* @__PURE__ */ new Date(), { year: d.value(A) });
    return Tq({
      start: hu(D),
      end: zb(D)
    }).map((B) => {
      const j = rr(B), I = T4(B), Z = m(B), R = _(j), J = $(j);
      return {
        text: w(j, I),
        value: j,
        active: V.value(j),
        highlighted: J,
        disabled: Z,
        isBetween: R
      };
    });
  }), M = (A) => {
    kv(A, c, u.value.limit), t("auto-apply", !0);
  }, T = (A) => {
    c.value = Sv(c, A, t), B1(c.value, t, e.autoApply, e.modelAuto);
  }, L = (A) => {
    c.value = A, t("auto-apply");
  };
  return {
    defaultedConfig: i,
    defaultedMultiCalendars: a,
    groupedYears: v,
    year: d,
    isDisabled: b,
    quarters: P,
    showYearPicker: y,
    modelValue: c,
    setHoverDate: (A) => {
      n.value = A;
    },
    selectYear: g,
    selectQuarter: (A, D, B) => {
      if (!B)
        return h.value[D].month = ft(T4(A)), u.value.enabled ? M(A) : r.value.enabled ? T(A) : L(A);
    },
    toggleYearPicker: C,
    handleYearSelect: S,
    handleYear: x
  };
}, nJ = { class: "dp--quarter-items" }, aJ = ["data-test-id", "disabled", "onClick", "onMouseover"], iJ = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "QuarterPicker",
  props: {
    ...si
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "overlay-closed",
    "auto-apply",
    "range-start",
    "range-end",
    "overlay-toggle",
    "update-month-year"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, l = Rl(), r = ka(l, "yearMode"), {
      defaultedMultiCalendars: s,
      defaultedConfig: o,
      groupedYears: u,
      year: c,
      isDisabled: d,
      quarters: f,
      modelValue: h,
      showYearPicker: m,
      setHoverDate: g,
      selectQuarter: v,
      toggleYearPicker: y,
      handleYearSelect: b,
      handleYear: C
    } = tJ(i, a);
    return t({ getSidebarProps: () => ({
      modelValue: h,
      year: c,
      selectQuarter: v,
      handleYearSelect: b,
      handleYear: C
    }) }), (S, x) => (N(), Ce(I1, {
      "multi-calendars": X(s).count,
      collapse: S.collapse,
      stretch: "",
      "is-mobile": S.isMobile
    }, {
      default: re(({ instance: w }) => [
        ie("div", {
          class: "dp-quarter-picker-wrap",
          style: Ot({ minHeight: `${X(o).modeHeight}px` })
        }, [
          S.$slots["top-extra"] ? ke(S.$slots, "top-extra", {
            key: 0,
            value: S.internalModelValue
          }) : de("", !0),
          ie("div", null, [
            p(bC, fe(S.$props, {
              items: X(u)(w),
              instance: w,
              "show-year-picker": X(m)[w],
              year: X(c)(w),
              "is-disabled": (V) => X(d)(w, V),
              onHandleYear: (V) => X(C)(w, V),
              onYearSelect: (V) => X(b)(V, w),
              onToggleYearPicker: (V) => X(y)(w, V == null ? void 0 : V.flow, V == null ? void 0 : V.show)
            }), Xt({ _: 2 }, [
              Ge(X(r), (V, _) => ({
                name: V,
                fn: re((O) => [
                  ke(S.$slots, V, Pt(Jt(O)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          ie("div", nJ, [
            (N(!0), ee(ge, null, Ge(X(f)(w), (V, _) => (N(), ee("div", { key: _ }, [
              ie("button", {
                type: "button",
                class: Ie(["dp--qr-btn", {
                  "dp--qr-btn-active": V.active,
                  "dp--qr-btn-between": V.isBetween,
                  "dp--qr-btn-disabled": V.disabled,
                  "dp--highlighted": V.highlighted
                }]),
                "data-test-id": V.value,
                disabled: V.disabled,
                onClick: (O) => X(v)(V.value, w, V.disabled),
                onMouseover: (O) => X(g)(V.value)
              }, [
                S.$slots.quarter ? ke(S.$slots, "quarter", {
                  key: 0,
                  value: V.value,
                  text: V.text
                }) : (N(), ee(ge, { key: 1 }, [
                  Ee(xe(V.text), 1)
                ], 64))
              ], 42, aJ)
            ]))), 128))
          ])
        ], 4)
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), PC = (e, t) => {
  const n = Y(0);
  rt(() => {
    a(), window.addEventListener("resize", a, { passive: !0 });
  }), ni(() => {
    window.removeEventListener("resize", a);
  });
  const a = () => {
    n.value = window.document.documentElement.clientWidth;
  };
  return {
    isMobile: k(
      () => n.value <= e.value.mobileBreakpoint && !t ? !0 : void 0
    )
  };
}, lJ = ["id", "tabindex", "role", "aria-label"], rJ = {
  key: 0,
  class: "dp--menu-load-container"
}, sJ = {
  key: 1,
  class: "dp--menu-header"
}, oJ = ["data-dp-mobile"], uJ = {
  key: 0,
  class: "dp__sidebar_left"
}, cJ = ["data-dp-mobile"], dJ = ["data-test-id", "data-dp-mobile", "onClick", "onKeydown"], fJ = {
  key: 2,
  class: "dp__sidebar_right"
}, hJ = {
  key: 3,
  class: "dp__action_extra"
}, X4 = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...R1,
    shadow: { type: Boolean, default: !1 },
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    noOverlayFocus: { type: Boolean, default: !1 },
    collapse: { type: Boolean, default: !1 },
    getInputRect: { type: Function, default: () => ({}) },
    isTextInputDate: { type: Boolean, default: !1 }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "menu-blur"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, l = Y(null), r = k(() => {
      const { openOnTop: oe, ...Me } = i;
      return {
        ...Me,
        isMobile: v.value,
        flowStep: T.value,
        menuWrapRef: l.value
      };
    }), { setMenuFocused: s, setShiftKey: o, control: u } = OC(), c = Rl(), { defaultedTextInput: d, defaultedInline: f, defaultedConfig: h, defaultedUI: m, handleEventPropagation: g } = Gt(i), { isMobile: v } = PC(h, i.shadow), y = Y(null), b = Y(0), C = Y(null), S = Y(!1), x = Y(null), w = Y(!1), V = (oe) => {
      w.value = !0, h.value.allowPreventDefault && oe.preventDefault(), Sl(oe, h.value, !0);
    };
    rt(() => {
      if (!i.shadow) {
        S.value = !0, _(), window.addEventListener("resize", _);
        const oe = Cn(l);
        oe && !d.value.enabled && !f.value.enabled && (s(!0), Z()), oe && (oe.addEventListener("pointerdown", V), oe.addEventListener("mousedown", V));
      }
      document.addEventListener("mousedown", Be);
    }), ni(() => {
      window.removeEventListener("resize", _), document.removeEventListener("mousedown", Be);
      const oe = Cn(l);
      oe && (oe.removeEventListener("pointerdown", V), oe.removeEventListener("mousedown", V));
    });
    const _ = () => {
      const oe = Cn(C);
      oe && (b.value = oe.getBoundingClientRect().width);
    }, { arrowRight: O, arrowLeft: $, arrowDown: P, arrowUp: M } = Hl(), { flowStep: T, updateFlowStep: L, childMount: A, resetFlow: D, handleFlow: B } = yJ(i, a, x), j = k(() => i.monthPicker ? wK : i.yearPicker ? SK : i.timePicker ? BK : i.quarterPicker ? iJ : eJ), I = k(() => {
      var oe;
      if (h.value.arrowLeft) return h.value.arrowLeft;
      const Me = (oe = l.value) == null ? void 0 : oe.getBoundingClientRect(), Xe = i.getInputRect();
      return (Xe == null ? void 0 : Xe.width) < (b == null ? void 0 : b.value) && (Xe == null ? void 0 : Xe.left) <= ((Me == null ? void 0 : Me.left) ?? 0) ? `${(Xe == null ? void 0 : Xe.width) / 2}px` : (Xe == null ? void 0 : Xe.right) >= ((Me == null ? void 0 : Me.right) ?? 0) && (Xe == null ? void 0 : Xe.width) < (b == null ? void 0 : b.value) ? `${(b == null ? void 0 : b.value) - (Xe == null ? void 0 : Xe.width) / 2}px` : "50%";
    }), Z = () => {
      const oe = Cn(l);
      oe && oe.focus({ preventScroll: !0 });
    }, R = k(() => {
      var oe;
      return ((oe = x.value) == null ? void 0 : oe.getSidebarProps()) || {};
    }), J = () => {
      i.openOnTop && a("recalculate-position");
    }, F = ka(c, "action"), q = k(() => i.monthPicker || i.yearPicker ? ka(c, "monthYear") : i.timePicker ? ka(c, "timePicker") : ka(c, "shared")), z = k(() => i.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), E = k(() => ({
      dp__menu_disabled: i.disabled,
      dp__menu_readonly: i.readonly,
      "dp-menu-loading": i.loading
    })), Q = k(
      () => ({
        dp__menu: !0,
        dp__menu_index: !f.value.enabled,
        dp__relative: f.value.enabled,
        ...m.value.menu ?? {}
      })
    ), W = (oe) => {
      Sl(oe, h.value, !0);
    }, se = (oe) => {
      i.escClose && (a("close-picker"), g(oe));
    }, Se = (oe) => {
      if (i.arrowNavigation) {
        if (oe === na.up) return M();
        if (oe === na.down) return P();
        if (oe === na.left) return $();
        if (oe === na.right) return O();
      } else oe === na.left || oe === na.up ? H("handleArrow", na.left, 0, oe === na.up) : H("handleArrow", na.right, 0, oe === na.down);
    }, U = (oe) => {
      o(oe.shiftKey), !i.disableMonthYearSelect && oe.code === Zt.tab && oe.target.classList.contains("dp__menu") && u.value.shiftKeyInMenu && (oe.preventDefault(), Sl(oe, h.value, !0), a("close-picker"));
    }, ne = () => {
      Z(), a("time-picker-close");
    }, K = (oe) => {
      var Me, Xe, Ke;
      (Me = x.value) == null || Me.toggleTimePicker(!1, !1), (Xe = x.value) == null || Xe.toggleMonthPicker(!1, !1, oe), (Ke = x.value) == null || Ke.toggleYearPicker(!1, !1, oe);
    }, te = (oe, Me = 0) => {
      var Xe, Ke, Kt;
      return oe === "month" ? (Xe = x.value) == null ? void 0 : Xe.toggleMonthPicker(!1, !0, Me) : oe === "year" ? (Ke = x.value) == null ? void 0 : Ke.toggleYearPicker(!1, !0, Me) : oe === "time" ? (Kt = x.value) == null ? void 0 : Kt.toggleTimePicker(!0, !1) : K(Me);
    }, H = (oe, ...Me) => {
      var Xe, Ke;
      (Xe = x.value) != null && Xe[oe] && ((Ke = x.value) == null || Ke[oe](...Me));
    }, ce = () => {
      H("selectCurrentDate");
    }, he = (oe, Me) => {
      H("presetDate", nn(oe), Me);
    }, Oe = () => {
      H("clearHoverDate");
    }, je = (oe, Me) => {
      H("updateMonthYear", oe, Me);
    }, be = (oe, Me) => {
      oe.preventDefault(), Se(Me);
    }, Te = (oe) => {
      var Me, Xe, Ke;
      if (U(oe), oe.key === Zt.home || oe.key === Zt.end)
        return H(
          "selectWeekDate",
          oe.key === Zt.home,
          oe.target.getAttribute("id")
        );
      switch ((oe.key === Zt.pageUp || oe.key === Zt.pageDown) && (oe.shiftKey ? (H("changeYear", oe.key === Zt.pageUp), (Me = J0(l.value, "overlay-year")) == null || Me.focus()) : (H("changeMonth", oe.key === Zt.pageUp), (Xe = J0(l.value, oe.key === Zt.pageUp ? "action-prev" : "action-next")) == null || Xe.focus()), oe.target.getAttribute("id") && ((Ke = l.value) == null || Ke.focus({ preventScroll: !0 }))), oe.key) {
        case Zt.esc:
          return se(oe);
        case Zt.arrowLeft:
          return be(oe, na.left);
        case Zt.arrowRight:
          return be(oe, na.right);
        case Zt.arrowUp:
          return be(oe, na.up);
        case Zt.arrowDown:
          return be(oe, na.down);
        default:
          return;
      }
    }, Be = (oe) => {
      var Me;
      f.value.enabled && !f.value.input && !((Me = l.value) != null && Me.contains(oe.target)) && w.value && (w.value = !1, a("menu-blur"));
    };
    return t({
      updateMonthYear: je,
      switchView: te,
      handleFlow: B,
      onValueCleared: () => {
        var oe, Me;
        (Me = (oe = x.value) == null ? void 0 : oe.setStartTime) == null || Me.call(oe);
      }
    }), (oe, Me) => {
      var Xe, Ke, Kt;
      return N(), ee("div", {
        id: oe.uid ? `dp-menu-${oe.uid}` : void 0,
        ref_key: "dpMenuRef",
        ref: l,
        tabindex: X(f).enabled ? void 0 : "0",
        role: X(f).enabled ? void 0 : "dialog",
        "aria-label": (Xe = oe.ariaLabels) == null ? void 0 : Xe.menu,
        class: Ie(Q.value),
        style: Ot({ "--dp-arrow-left": I.value }),
        onMouseleave: Oe,
        onClick: W,
        onKeydown: Te
      }, [
        (oe.disabled || oe.readonly) && X(f).enabled || oe.loading ? (N(), ee("div", {
          key: 0,
          class: Ie(E.value)
        }, [
          oe.loading ? (N(), ee("div", rJ, Me[19] || (Me[19] = [
            ie("span", { class: "dp--menu-loader" }, null, -1)
          ]))) : de("", !0)
        ], 2)) : de("", !0),
        oe.$slots["menu-header"] ? (N(), ee("div", sJ, [
          ke(oe.$slots, "menu-header")
        ])) : de("", !0),
        !X(f).enabled && !oe.teleportCenter ? (N(), ee("div", {
          key: 2,
          class: Ie(z.value)
        }, null, 2)) : de("", !0),
        ie("div", {
          ref_key: "innerMenuRef",
          ref: C,
          class: Ie({
            dp__menu_content_wrapper: ((Ke = oe.presetDates) == null ? void 0 : Ke.length) || !!oe.$slots["left-sidebar"] || !!oe.$slots["right-sidebar"],
            "dp--menu-content-wrapper-collapsed": e.collapse && (((Kt = oe.presetDates) == null ? void 0 : Kt.length) || !!oe.$slots["left-sidebar"] || !!oe.$slots["right-sidebar"])
          }),
          "data-dp-mobile": X(v),
          style: Ot({ "--dp-menu-width": `${b.value}px` })
        }, [
          oe.$slots["left-sidebar"] ? (N(), ee("div", uJ, [
            ke(oe.$slots, "left-sidebar", Pt(Jt(R.value)))
          ])) : de("", !0),
          oe.presetDates.length ? (N(), ee("div", {
            key: 1,
            class: Ie({ "dp--preset-dates-collapsed": e.collapse, "dp--preset-dates": !0 }),
            "data-dp-mobile": X(v)
          }, [
            (N(!0), ee(ge, null, Ge(oe.presetDates, (Ye, pn) => (N(), ee(ge, { key: pn }, [
              Ye.slot ? ke(oe.$slots, Ye.slot, {
                key: 0,
                presetDate: he,
                label: Ye.label,
                value: Ye.value
              }) : (N(), ee("button", {
                key: 1,
                type: "button",
                style: Ot(Ye.style || {}),
                class: Ie(["dp__btn dp--preset-range", { "dp--preset-range-collapsed": e.collapse }]),
                "data-test-id": Ye.testId ?? void 0,
                "data-dp-mobile": X(v),
                onClick: $t((Rt) => he(Ye.value, Ye.noTz), ["prevent"]),
                onKeydown: (Rt) => X(ia)(Rt, () => he(Ye.value, Ye.noTz), !0)
              }, xe(Ye.label), 47, dJ))
            ], 64))), 128))
          ], 10, cJ)) : de("", !0),
          ie("div", {
            ref_key: "calendarWrapperRef",
            ref: y,
            class: "dp__instance_calendar",
            role: "document"
          }, [
            (N(), Ce(Lr(j.value), fe({
              ref_key: "dynCmpRef",
              ref: x
            }, r.value, {
              "flow-step": X(T),
              onMount: X(A),
              onUpdateFlowStep: X(L),
              onResetFlow: X(D),
              onFocusMenu: Z,
              onSelectDate: Me[0] || (Me[0] = (Ye) => oe.$emit("select-date")),
              onDateUpdate: Me[1] || (Me[1] = (Ye) => oe.$emit("date-update", Ye)),
              onTooltipOpen: Me[2] || (Me[2] = (Ye) => oe.$emit("tooltip-open", Ye)),
              onTooltipClose: Me[3] || (Me[3] = (Ye) => oe.$emit("tooltip-close", Ye)),
              onAutoApply: Me[4] || (Me[4] = (Ye) => oe.$emit("auto-apply", Ye)),
              onRangeStart: Me[5] || (Me[5] = (Ye) => oe.$emit("range-start", Ye)),
              onRangeEnd: Me[6] || (Me[6] = (Ye) => oe.$emit("range-end", Ye)),
              onInvalidFixedRange: Me[7] || (Me[7] = (Ye) => oe.$emit("invalid-fixed-range", Ye)),
              onTimeUpdate: Me[8] || (Me[8] = (Ye) => oe.$emit("time-update")),
              onAmPmChange: Me[9] || (Me[9] = (Ye) => oe.$emit("am-pm-change", Ye)),
              onTimePickerOpen: Me[10] || (Me[10] = (Ye) => oe.$emit("time-picker-open", Ye)),
              onTimePickerClose: ne,
              onRecalculatePosition: J,
              onUpdateMonthYear: Me[11] || (Me[11] = (Ye) => oe.$emit("update-month-year", Ye)),
              onAutoApplyInvalid: Me[12] || (Me[12] = (Ye) => oe.$emit("auto-apply-invalid", Ye)),
              onInvalidDate: Me[13] || (Me[13] = (Ye) => oe.$emit("invalid-date", Ye)),
              onOverlayToggle: Me[14] || (Me[14] = (Ye) => oe.$emit("overlay-toggle", Ye)),
              "onUpdate:internalModelValue": Me[15] || (Me[15] = (Ye) => oe.$emit("update:internal-model-value", Ye))
            }), Xt({ _: 2 }, [
              Ge(q.value, (Ye, pn) => ({
                name: Ye,
                fn: re((Rt) => [
                  ke(oe.$slots, Ye, Pt(Jt({ ...Rt })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          oe.$slots["right-sidebar"] ? (N(), ee("div", fJ, [
            ke(oe.$slots, "right-sidebar", Pt(Jt(R.value)))
          ])) : de("", !0),
          oe.$slots["action-extra"] ? (N(), ee("div", hJ, [
            oe.$slots["action-extra"] ? ke(oe.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: ce
            }) : de("", !0)
          ])) : de("", !0)
        ], 14, oJ),
        !oe.autoApply || X(h).keepActionRow ? (N(), Ce(hK, fe({
          key: 3,
          "menu-mount": S.value
        }, r.value, {
          "calendar-width": b.value,
          onClosePicker: Me[16] || (Me[16] = (Ye) => oe.$emit("close-picker")),
          onSelectDate: Me[17] || (Me[17] = (Ye) => oe.$emit("select-date")),
          onInvalidSelect: Me[18] || (Me[18] = (Ye) => oe.$emit("invalid-select")),
          onSelectNow: ce
        }), Xt({ _: 2 }, [
          Ge(X(F), (Ye, pn) => ({
            name: Ye,
            fn: re((Rt) => [
              ke(oe.$slots, Ye, Pt(Jt({ ...Rt })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : de("", !0)
      ], 46, lJ);
    };
  }
});
var as = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(as || {});
const mJ = ({
  menuRef: e,
  menuRefInner: t,
  inputRef: n,
  pickerWrapperRef: a,
  inline: i,
  emit: l,
  props: r,
  slots: s
}) => {
  const { defaultedConfig: o } = Gt(r), u = Y({}), c = Y(!1), d = Y({
    top: "0",
    left: "0"
  }), f = Y(!1), h = ue(r, "teleportCenter");
  pe(h, () => {
    d.value = JSON.parse(JSON.stringify({})), x();
  });
  const m = (D) => {
    if (r.teleport) {
      const B = D.getBoundingClientRect();
      return {
        left: B.left + window.scrollX,
        top: B.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, g = (D, B) => {
    d.value.left = `${D + B - u.value.width}px`;
  }, v = (D) => {
    d.value.left = `${D}px`;
  }, y = (D, B) => {
    r.position === as.left && v(D), r.position === as.right && g(D, B), r.position === as.center && (d.value.left = `${D + B / 2 - u.value.width / 2}px`);
  }, b = (D) => {
    const { width: B, height: j } = D.getBoundingClientRect(), { top: I, left: Z } = m(D);
    return { top: +I, left: +Z, width: B, height: j };
  }, C = () => {
    d.value.left = "50%", d.value.top = "50%", d.value.transform = "translate(-50%, -50%)", d.value.position = "fixed", delete d.value.opacity;
  }, S = () => {
    const D = Cn(n);
    d.value = r.altPosition(D);
  }, x = (D = !0) => {
    var B;
    if (!i.value.enabled) {
      if (h.value) return C();
      if (r.altPosition !== null) return S();
      if (D) {
        const j = r.teleport ? (B = t.value) == null ? void 0 : B.$el : e.value;
        j && (u.value = j.getBoundingClientRect()), l("recalculate-position");
      }
      return M();
    }
  }, w = ({ inputEl: D, left: B, width: j }) => {
    window.screen.width > 768 && !c.value && y(B, j), O(D);
  }, V = (D) => {
    const { top: B, left: j, height: I, width: Z } = b(D);
    d.value.top = `${I + B + +r.offset}px`, f.value = !1, c.value || (d.value.left = `${j + Z / 2 - u.value.width / 2}px`), w({ inputEl: D, left: j, width: Z });
  }, _ = (D) => {
    const { top: B, left: j, width: I } = b(D);
    d.value.top = `${B - +r.offset - u.value.height}px`, f.value = !0, w({ inputEl: D, left: j, width: I });
  }, O = (D) => {
    if (r.autoPosition) {
      const { left: B, width: j } = b(D), { left: I, right: Z } = u.value;
      if (!c.value) {
        if (Math.abs(I) !== Math.abs(Z)) {
          if (I <= 0)
            return c.value = !0, v(B);
          if (Z >= document.documentElement.clientWidth)
            return c.value = !0, g(B, j);
        }
        return y(B, j);
      }
    }
  }, $ = () => {
    const D = Cn(n);
    if (D) {
      if (r.autoPosition === za.top) return za.top;
      if (r.autoPosition === za.bottom) return za.bottom;
      const { height: B } = u.value, { top: j, height: I } = D.getBoundingClientRect(), Z = window.innerHeight - j - I, R = j;
      return B <= Z ? za.bottom : B > Z && B <= R ? za.top : Z >= R ? za.bottom : za.top;
    }
    return za.bottom;
  }, P = (D) => $() === za.bottom ? V(D) : _(D), M = () => {
    const D = Cn(n);
    if (D)
      return r.autoPosition ? P(D) : V(D);
  }, T = function(D) {
    if (D) {
      const B = D.scrollHeight > D.clientHeight, j = window.getComputedStyle(D).overflowY.indexOf("hidden") !== -1;
      return B && !j;
    }
    return !0;
  }, L = function(D) {
    return !D || D === document.body || D.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : T(D) ? D : L(
      D.assignedSlot && o.value.shadowDom ? D.assignedSlot.parentNode : D.parentNode
    );
  }, A = (D) => {
    if (D)
      switch (r.position) {
        case as.left:
          return { left: 0, transform: "translateX(0)" };
        case as.right:
          return { left: `${D.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${D.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: f,
    menuStyle: d,
    xCorrect: c,
    setMenuPosition: x,
    getScrollableParent: L,
    shadowRender: (D, B, j) => {
      var I, Z, R;
      const J = document.createElement("div"), F = (I = Cn(n)) == null ? void 0 : I.getBoundingClientRect();
      J.setAttribute("id", "dp--temp-container");
      const q = (Z = a.value) != null && Z.clientWidth ? a.value : document.body;
      q.append(J);
      const z = A(F), E = o.value.shadowDom ? Object.keys(s).filter(
        (W) => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(W)
      ) : Object.keys(s), Q = G(
        B,
        {
          ...j,
          shadow: !0,
          style: { opacity: 0, position: "absolute", ...z }
        },
        Object.fromEntries(E.map((W) => [W, s[W]]))
      );
      D != null && (Q.appContext = D.appContext), Ec(Q, J), u.value = (R = Q.el) == null ? void 0 : R.getBoundingClientRect(), Ec(null, J), q.removeChild(J);
    }
  };
}, hl = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] },
  { name: "top-extra", use: ["shared", "month-year"] },
  { name: "tp-inline-arrow-up", use: ["shared", "time"] },
  { name: "tp-inline-arrow-down", use: ["shared", "time"] },
  { name: "menu-header", use: ["menu"] }
], vJ = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], gJ = {
  all: () => hl,
  monthYear: () => hl.filter((e) => e.use.includes("month-year")),
  input: () => vJ,
  timePicker: () => hl.filter((e) => e.use.includes("time")),
  action: () => hl.filter((e) => e.use.includes("action")),
  calendar: () => hl.filter((e) => e.use.includes("calendar")),
  menu: () => hl.filter((e) => e.use.includes("menu")),
  shared: () => hl.filter((e) => e.use.includes("shared")),
  yearMode: () => hl.filter((e) => e.use.includes("year-mode"))
}, ka = (e, t, n) => {
  const a = [];
  return gJ[t]().forEach((i) => {
    e[i.name] && a.push(i.name);
  }), n != null && n.length && n.forEach((i) => {
    i.slot && a.push(i.slot);
  }), a;
}, Nu = (e) => {
  const t = k(() => (a) => e.value ? a ? e.value.open : e.value.close : ""), n = k(() => (a) => e.value ? a ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: t, showTransition: !!e.value, menuTransition: n };
}, Hu = (e, t, n) => {
  const { defaultedRange: a, defaultedTz: i } = Gt(e), l = _e(ga(_e(), i.value.timezone)), r = Y([{ month: ft(l), year: it(l) }]), s = (f) => {
    const h = {
      hours: tl(l),
      minutes: Dl(l),
      seconds: 0
    };
    return a.value.enabled ? [h[f], h[f]] : h[f];
  }, o = zt({
    hours: s("hours"),
    minutes: s("minutes"),
    seconds: s("seconds")
  });
  pe(
    a,
    (f, h) => {
      f.enabled !== h.enabled && (o.hours = s("hours"), o.minutes = s("minutes"), o.seconds = s("seconds"));
    },
    { deep: !0 }
  );
  const u = k({
    get: () => e.internalModelValue,
    set: (f) => {
      !e.readonly && !e.disabled && t("update:internal-model-value", f);
    }
  }), c = k(
    () => (f) => r.value[f] ? r.value[f].month : 0
  ), d = k(
    () => (f) => r.value[f] ? r.value[f].year : 0
  );
  return pe(
    u,
    (f, h) => {
      n && JSON.stringify(f ?? {}) !== JSON.stringify(h ?? {}) && n();
    },
    { deep: !0 }
  ), {
    calendars: r,
    time: o,
    modelValue: u,
    month: c,
    year: d,
    today: l
  };
}, pJ = (e, t) => {
  const {
    defaultedMultiCalendars: n,
    defaultedMultiDates: a,
    defaultedUI: i,
    defaultedHighlight: l,
    defaultedTz: r,
    propDates: s,
    defaultedRange: o
  } = Gt(t), { isDisabled: u } = jl(t), c = Y(null), d = Y(ga(/* @__PURE__ */ new Date(), r.value.timezone)), f = (Q) => {
    !Q.current && t.hideOffsetDates || (c.value = Q.value);
  }, h = () => {
    c.value = null;
  }, m = (Q) => Array.isArray(e.value) && o.value.enabled && e.value[0] && c.value ? Q ? cn(c.value, e.value[0]) : an(c.value, e.value[0]) : !0, g = (Q, W) => {
    const se = () => e.value ? W ? e.value[0] || null : e.value[1] : null, Se = e.value && Array.isArray(e.value) ? se() : null;
    return ht(_e(Q.value), Se);
  }, v = (Q) => {
    const W = Array.isArray(e.value) ? e.value[0] : null;
    return Q ? !an(c.value ?? null, W) : !0;
  }, y = (Q, W = !0) => (o.value.enabled || t.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? t.hideOffsetDates && !Q.current ? !1 : ht(_e(Q.value), e.value[W ? 0 : 1]) : o.value.enabled ? g(Q, W) && v(W) || ht(Q.value, Array.isArray(e.value) ? e.value[0] : null) && m(W) : !1, b = (Q, W) => {
    if (Array.isArray(e.value) && e.value[0] && e.value.length === 1) {
      const se = ht(Q.value, c.value);
      return W ? cn(e.value[0], Q.value) && se : an(e.value[0], Q.value) && se;
    }
    return !1;
  }, C = (Q) => !e.value || t.hideOffsetDates && !Q.current ? !1 : o.value.enabled ? t.modelAuto && Array.isArray(e.value) ? ht(Q.value, e.value[0] ? e.value[0] : d.value) : !1 : a.value.enabled && Array.isArray(e.value) ? e.value.some((W) => ht(W, Q.value)) : ht(Q.value, e.value ? e.value : d.value), S = (Q) => {
    if (o.value.autoRange || t.weekPicker) {
      if (c.value) {
        if (t.hideOffsetDates && !Q.current) return !1;
        const W = Va(c.value, +o.value.autoRange), se = Hi(_e(c.value), t.weekStart);
        return t.weekPicker ? ht(se[1], _e(Q.value)) : ht(W, _e(Q.value));
      }
      return !1;
    }
    return !1;
  }, x = (Q) => {
    if (o.value.autoRange || t.weekPicker) {
      if (c.value) {
        const W = Va(c.value, +o.value.autoRange);
        if (t.hideOffsetDates && !Q.current) return !1;
        const se = Hi(_e(c.value), t.weekStart);
        return t.weekPicker ? cn(Q.value, se[0]) && an(Q.value, se[1]) : cn(Q.value, c.value) && an(Q.value, W);
      }
      return !1;
    }
    return !1;
  }, w = (Q) => {
    if (o.value.autoRange || t.weekPicker) {
      if (c.value) {
        if (t.hideOffsetDates && !Q.current) return !1;
        const W = Hi(_e(c.value), t.weekStart);
        return t.weekPicker ? ht(W[0], Q.value) : ht(c.value, Q.value);
      }
      return !1;
    }
    return !1;
  }, V = (Q) => vu(e.value, c.value, Q.value), _ = () => t.modelAuto && Array.isArray(t.internalModelValue) ? !!t.internalModelValue[0] : !1, O = () => t.modelAuto ? sC(t.internalModelValue) : !0, $ = (Q) => {
    if (t.weekPicker) return !1;
    const W = o.value.enabled ? !y(Q) && !y(Q, !1) : !0;
    return !u(Q.value) && !C(Q) && !(!Q.current && t.hideOffsetDates) && W;
  }, P = (Q) => o.value.enabled ? t.modelAuto ? _() && C(Q) : !1 : C(Q), M = (Q) => l.value ? RG(Q.value, s.value.highlight) : !1, T = (Q) => {
    const W = u(Q.value);
    return W && (typeof l.value == "function" ? !l.value(Q.value, W) : !l.value.options.highlightDisabled);
  }, L = (Q) => {
    var W;
    return typeof l.value == "function" ? l.value(Q.value) : (W = l.value.weekdays) == null ? void 0 : W.includes(Q.value.getDay());
  }, A = (Q) => (o.value.enabled || t.weekPicker) && (!(n.value.count > 0) || Q.current) && O() && !(!Q.current && t.hideOffsetDates) && !C(Q) ? V(Q) : !1, D = (Q) => {
    if (Array.isArray(e.value) && e.value.length === 1) {
      const { before: W, after: se } = H4(+o.value.maxRange, e.value[0]);
      return Zs(Q.value, W) || Vr(Q.value, se);
    }
    return !1;
  }, B = (Q) => {
    if (Array.isArray(e.value) && e.value.length === 1) {
      const { before: W, after: se } = H4(+o.value.minRange, e.value[0]);
      return vu([W, se], e.value[0], Q.value);
    }
    return !1;
  }, j = (Q) => o.value.enabled && (o.value.maxRange || o.value.minRange) ? o.value.maxRange && o.value.minRange ? D(Q) || B(Q) : o.value.maxRange ? D(Q) : B(Q) : !1, I = (Q) => {
    const { isRangeStart: W, isRangeEnd: se } = F(Q), Se = o.value.enabled ? W || se : !1;
    return {
      dp__cell_offset: !Q.current,
      dp__pointer: !t.disabled && !(!Q.current && t.hideOffsetDates) && !u(Q.value) && !j(Q),
      dp__cell_disabled: u(Q.value) || j(Q),
      dp__cell_highlight: !T(Q) && (M(Q) || L(Q)) && !P(Q) && !Se && !w(Q) && !(A(Q) && t.weekPicker) && !se,
      dp__cell_highlight_active: !T(Q) && (M(Q) || L(Q)) && P(Q),
      dp__today: !t.noToday && ht(Q.value, d.value) && Q.current,
      "dp--past": an(Q.value, d.value),
      "dp--future": cn(Q.value, d.value)
    };
  }, Z = (Q) => ({
    dp__active_date: P(Q),
    dp__date_hover: $(Q)
  }), R = (Q) => {
    if (e.value && !Array.isArray(e.value)) {
      const W = Hi(e.value, t.weekStart);
      return {
        ...z(Q),
        dp__range_start: ht(W[0], Q.value),
        dp__range_end: ht(W[1], Q.value),
        dp__range_between_week: cn(Q.value, W[0]) && an(Q.value, W[1])
      };
    }
    return {
      ...z(Q)
    };
  }, J = (Q) => {
    if (e.value && Array.isArray(e.value)) {
      const W = Hi(e.value[0], t.weekStart), se = e.value[1] ? Hi(e.value[1], t.weekStart) : [];
      return {
        ...z(Q),
        dp__range_start: ht(W[0], Q.value) || ht(se[0], Q.value),
        dp__range_end: ht(W[1], Q.value) || ht(se[1], Q.value),
        dp__range_between_week: cn(Q.value, W[0]) && an(Q.value, W[1]) || cn(Q.value, se[0]) && an(Q.value, se[1]),
        dp__range_between: cn(Q.value, W[1]) && an(Q.value, se[0])
      };
    }
    return {
      ...z(Q)
    };
  }, F = (Q) => {
    const W = n.value.count > 0 ? Q.current && y(Q) && O() : y(Q) && O(), se = n.value.count > 0 ? Q.current && y(Q, !1) && O() : y(Q, !1) && O();
    return { isRangeStart: W, isRangeEnd: se };
  }, q = (Q) => {
    const { isRangeStart: W, isRangeEnd: se } = F(Q);
    return {
      dp__range_start: W,
      dp__range_end: se,
      dp__range_between: A(Q),
      dp__date_hover: ht(Q.value, c.value) && !W && !se && !t.weekPicker,
      dp__date_hover_start: b(Q, !0),
      dp__date_hover_end: b(Q, !1)
    };
  }, z = (Q) => ({
    ...q(Q),
    dp__cell_auto_range: x(Q),
    dp__cell_auto_range_start: w(Q),
    dp__cell_auto_range_end: S(Q)
  }), E = (Q) => o.value.enabled ? o.value.autoRange ? z(Q) : t.modelAuto ? { ...Z(Q), ...q(Q) } : t.weekPicker ? J(Q) : q(Q) : t.weekPicker ? R(Q) : Z(Q);
  return {
    setHoverDate: f,
    clearHoverDate: h,
    getDayClassData: (Q) => t.hideOffsetDates && !Q.current ? {} : {
      ...I(Q),
      ...E(Q),
      [t.dayClass ? t.dayClass(Q.value, t.internalModelValue) : ""]: !0,
      ...i.value.calendarCell ?? {}
    }
  };
}, jl = (e) => {
  const { defaultedFilters: t, defaultedRange: n, propDates: a, defaultedMultiDates: i } = Gt(e), l = (L) => a.value.disabledDates ? typeof a.value.disabledDates == "function" ? a.value.disabledDates(_e(L)) : !!Qd(L, a.value.disabledDates) : !1, r = (L) => a.value.maxDate ? e.yearPicker ? it(L) > it(a.value.maxDate) : cn(L, a.value.maxDate) : !1, s = (L) => a.value.minDate ? e.yearPicker ? it(L) < it(a.value.minDate) : an(L, a.value.minDate) : !1, o = (L) => {
    const A = r(L), D = s(L), B = l(L), j = t.value.months.map((F) => +F).includes(ft(L)), I = e.disabledWeekDays.length ? e.disabledWeekDays.some((F) => +F === kU(L)) : !1, Z = h(L), R = it(L), J = R < +e.yearRange[0] || R > +e.yearRange[1];
    return !(A || D || B || j || J || I || Z);
  }, u = (L, A) => an(...wl(a.value.minDate, L, A)) || ht(...wl(a.value.minDate, L, A)), c = (L, A) => cn(...wl(a.value.maxDate, L, A)) || ht(...wl(a.value.maxDate, L, A)), d = (L, A, D) => {
    let B = !1;
    return a.value.maxDate && D && c(L, A) && (B = !0), a.value.minDate && !D && u(L, A) && (B = !0), B;
  }, f = (L, A, D, B) => {
    let j = !1;
    return B && (a.value.minDate || a.value.maxDate) ? a.value.minDate && a.value.maxDate ? j = d(L, A, D) : (a.value.minDate && u(L, A) || a.value.maxDate && c(L, A)) && (j = !0) : j = !0, j;
  }, h = (L) => Array.isArray(a.value.allowedDates) && !a.value.allowedDates.length ? !0 : a.value.allowedDates ? !Qd(L, a.value.allowedDates, cC(e.monthPicker, e.yearPicker)) : !1, m = (L) => !o(L), g = (L) => n.value.noDisabledRange ? !jb({ start: L[0], end: L[1] }).some((A) => m(A)) : !0, v = (L) => {
    if (L) {
      const A = it(L);
      return A >= +e.yearRange[0] && A <= e.yearRange[1];
    }
    return !0;
  }, y = (L, A) => !!(Array.isArray(L) && L[A] && (n.value.maxRange || n.value.minRange) && v(L[A])), b = (L, A, D = 0) => {
    if (y(A, D) && v(L)) {
      const B = Eb(L, A[D]), j = mC(A[D], L), I = j.length === 1 ? 0 : j.filter((R) => m(R)).length, Z = Math.abs(B) - (n.value.minMaxRawRange ? 0 : I);
      if (n.value.minRange && n.value.maxRange)
        return Z >= +n.value.minRange && Z <= +n.value.maxRange;
      if (n.value.minRange) return Z >= +n.value.minRange;
      if (n.value.maxRange) return Z <= +n.value.maxRange;
    }
    return !0;
  }, C = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, S = (L) => Array.isArray(L) ? [L[0] ? jf(L[0]) : null, L[1] ? jf(L[1]) : null] : jf(L), x = (L, A, D) => L.find(
    (B) => +B.hours === tl(A) && B.minutes === "*" ? !0 : +B.minutes === Dl(A) && +B.hours === tl(A)
  ) && D, w = (L, A, D) => {
    const [B, j] = L, [I, Z] = A;
    return !x(B, I, D) && !x(j, Z, D) && D;
  }, V = (L, A) => {
    const D = Array.isArray(A) ? A : [A];
    return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? w(e.disabledTimes, D, L) : !D.some((B) => x(e.disabledTimes, B, L)) : L;
  }, _ = (L, A) => {
    const D = Array.isArray(A) ? [vr(A[0]), A[1] ? vr(A[1]) : void 0] : vr(A), B = !e.disabledTimes(D);
    return L && B;
  }, O = (L, A) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? V(A, L) : _(A, L) : A, $ = (L) => {
    let A = !0;
    if (!L || C()) return !0;
    const D = !a.value.minDate && !a.value.maxDate ? S(L) : L;
    return (e.maxTime || a.value.maxDate) && (A = N4(
      e.maxTime,
      a.value.maxDate,
      "max",
      Qn(D),
      A
    )), (e.minTime || a.value.minDate) && (A = N4(
      e.minTime,
      a.value.minDate,
      "min",
      Qn(D),
      A
    )), O(L, A);
  }, P = (L) => {
    if (!e.monthPicker) return !0;
    let A = !0;
    const D = _e(Xa(L));
    if (a.value.minDate && a.value.maxDate) {
      const B = _e(Xa(a.value.minDate)), j = _e(Xa(a.value.maxDate));
      return cn(D, B) && an(D, j) || ht(D, B) || ht(D, j);
    }
    if (a.value.minDate) {
      const B = _e(Xa(a.value.minDate));
      A = cn(D, B) || ht(D, B);
    }
    if (a.value.maxDate) {
      const B = _e(Xa(a.value.maxDate));
      A = an(D, B) || ht(D, B);
    }
    return A;
  }, M = k(() => (L) => !e.enableTimePicker || e.ignoreTimeValidation ? !0 : $(L)), T = k(() => (L) => e.monthPicker ? Array.isArray(L) && (n.value.enabled || i.value.enabled) ? !L.filter((A) => !P(A)).length : P(L) : !0);
  return {
    isDisabled: m,
    validateDate: o,
    validateMonthYearInRange: f,
    isDateRangeAllowed: g,
    checkMinMaxRange: b,
    isValidTime: $,
    isTimeValid: M,
    isMonthValid: T
  };
}, Z1 = () => {
  const e = k(() => (a, i) => a == null ? void 0 : a.includes(i)), t = k(() => (a, i) => a.count ? a.solo ? !0 : i === 0 : !0), n = k(() => (a, i) => a.count ? a.solo ? !0 : i === a.count - 1 : !0);
  return { hideNavigationButtons: e, showLeftIcon: t, showRightIcon: n };
}, yJ = (e, t, n) => {
  const a = Y(0), i = zt({
    [mr.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
    [mr.calendar]: !1,
    [mr.header]: !1
  }), l = k(() => e.monthPicker || e.timePicker), r = (d) => {
    var f;
    if ((f = e.flow) != null && f.length) {
      if (!d && l.value) return c();
      i[d] = !0, Object.keys(i).filter((h) => !i[h]).length || c();
    }
  }, s = () => {
    var d, f;
    (d = e.flow) != null && d.length && a.value !== -1 && (a.value += 1, t("flow-step", a.value), c()), ((f = e.flow) == null ? void 0 : f.length) === a.value && et().then(() => o());
  }, o = () => {
    a.value = -1;
  }, u = (d, f, ...h) => {
    var m, g;
    e.flow[a.value] === d && n.value && ((g = (m = n.value)[f]) == null || g.call(m, ...h));
  }, c = (d = 0) => {
    d && (a.value += d), u(qn.month, "toggleMonthPicker", !0), u(qn.year, "toggleYearPicker", !0), u(qn.calendar, "toggleTimePicker", !1, !0), u(qn.time, "toggleTimePicker", !0, !0);
    const f = e.flow[a.value];
    (f === qn.hours || f === qn.minutes || f === qn.seconds) && u(f, "toggleTimePicker", !0, !0, f);
  };
  return { childMount: r, updateFlowStep: s, resetFlow: o, handleFlow: c, flowStep: a };
}, OJ = {
  key: 1,
  class: "dp__input_wrap"
}, bJ = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"], CJ = {
  key: 2,
  class: "dp--clear-btn"
}, wJ = ["aria-label"], kJ = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...R1
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur",
    "text-input"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, {
      defaultedTextInput: l,
      defaultedAriaLabels: r,
      defaultedInline: s,
      defaultedConfig: o,
      defaultedRange: u,
      defaultedMultiDates: c,
      defaultedUI: d,
      getDefaultPattern: f,
      getDefaultStartTime: h
    } = Gt(i), { checkMinMaxRange: m } = jl(i), g = Y(), v = Y(null), y = Y(!1), b = Y(!1), C = k(
      () => ({
        dp__pointer: !i.disabled && !i.readonly && !l.value.enabled,
        dp__disabled: i.disabled,
        dp__input_readonly: !l.value.enabled,
        dp__input: !0,
        dp__input_icon_pad: !i.hideInputIcon,
        dp__input_valid: typeof i.state == "boolean" ? i.state : !1,
        dp__input_invalid: typeof i.state == "boolean" ? !i.state : !1,
        dp__input_focus: y.value || i.isMenuOpen,
        dp__input_reg: !l.value.enabled,
        ...d.value.input ?? {}
      })
    ), S = () => {
      a("set-input-date", null), i.clearable && i.autoApply && (a("set-empty-date"), g.value = null);
    }, x = (R) => {
      const J = h();
      return BG(
        R,
        l.value.format ?? f(),
        J ?? vC({}, i.enableSeconds),
        i.inputValue,
        b.value,
        i.formatLocale
      );
    }, w = (R) => {
      const { rangeSeparator: J } = l.value, [F, q] = R.split(`${J}`);
      if (F) {
        const z = x(F.trim()), E = q ? x(q.trim()) : void 0;
        if (Vr(z, E)) return;
        const Q = z && E ? [z, E] : [z];
        m(E, Q, 0) && (g.value = z ? Q : null);
      }
    }, V = () => {
      b.value = !0;
    }, _ = (R) => {
      if (u.value.enabled)
        w(R);
      else if (c.value.enabled) {
        const J = R.split(";");
        g.value = J.map((F) => x(F.trim())).filter((F) => F);
      } else
        g.value = x(R);
    }, O = (R) => {
      var J;
      const F = typeof R == "string" ? R : (J = R.target) == null ? void 0 : J.value;
      F !== "" ? (l.value.openMenu && !i.isMenuOpen && a("open"), _(F), a("set-input-date", g.value)) : S(), b.value = !1, a("update:input-value", F), a("text-input", R, g.value);
    }, $ = (R) => {
      l.value.enabled ? (_(R.target.value), l.value.enterSubmit && e2(g.value) && i.inputValue !== "" ? (a("set-input-date", g.value, !0), g.value = null) : l.value.enterSubmit && i.inputValue === "" && (g.value = null, a("clear"))) : T(R);
    }, P = (R, J) => {
      l.value.enabled && l.value.tabSubmit && !J && _(R.target.value), l.value.tabSubmit && e2(g.value) && i.inputValue !== "" ? (a("set-input-date", g.value, !0, !0), g.value = null) : l.value.tabSubmit && i.inputValue === "" && (g.value = null, a("clear", !0));
    }, M = () => {
      y.value = !0, a("focus"), et().then(() => {
        var R;
        l.value.enabled && l.value.selectOnFocus && ((R = v.value) == null || R.select());
      });
    }, T = (R) => {
      if (Sl(R, o.value, !0), l.value.enabled && l.value.openMenu && !s.value.input) {
        if (l.value.openMenu === "open" && !i.isMenuOpen) return a("open");
        if (l.value.openMenu === "toggle") return a("toggle");
      } else l.value.enabled || a("toggle");
    }, L = () => {
      a("real-blur"), y.value = !1, (!i.isMenuOpen || s.value.enabled && s.value.input) && a("blur"), i.autoApply && l.value.enabled && g.value && !i.isMenuOpen && (a("set-input-date", g.value), a("select-date"), g.value = null);
    }, A = (R) => {
      Sl(R, o.value, !0), a("clear");
    }, D = () => {
      a("close");
    }, B = (R) => {
      if (R.key === "Tab" && P(R), R.key === "Enter" && $(R), R.key === "Escape" && l.value.escClose && D(), !l.value.enabled) {
        if (R.code === "Tab") return;
        R.preventDefault();
      }
    }, j = () => {
      var R;
      (R = v.value) == null || R.focus({ preventScroll: !0 });
    }, I = (R) => {
      g.value = R;
    }, Z = (R) => {
      R.key === Zt.tab && P(R, !0);
    };
    return t({
      focusInput: j,
      setParsedDate: I
    }), (R, J) => {
      var F, q, z;
      return N(), ee("div", { onClick: T }, [
        R.$slots.trigger && !R.$slots["dp-input"] && !X(s).enabled ? ke(R.$slots, "trigger", { key: 0 }) : de("", !0),
        !R.$slots.trigger && (!X(s).enabled || X(s).input) ? (N(), ee("div", OJ, [
          R.$slots["dp-input"] && !R.$slots.trigger && (!X(s).enabled || X(s).enabled && X(s).input) ? ke(R.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            isMenuOpen: e.isMenuOpen,
            onInput: O,
            onEnter: $,
            onTab: P,
            onClear: A,
            onBlur: L,
            onKeypress: B,
            onPaste: V,
            onFocus: M,
            openMenu: () => R.$emit("open"),
            closeMenu: () => R.$emit("close"),
            toggleMenu: () => R.$emit("toggle")
          }) : de("", !0),
          R.$slots["dp-input"] ? de("", !0) : (N(), ee("input", {
            key: 1,
            id: R.uid ? `dp-input-${R.uid}` : void 0,
            ref_key: "inputRef",
            ref: v,
            "data-test-id": "dp-input",
            name: R.name,
            class: Ie(C.value),
            inputmode: X(l).enabled ? "text" : "none",
            placeholder: R.placeholder,
            disabled: R.disabled,
            readonly: R.readonly,
            required: R.required,
            value: e.inputValue,
            autocomplete: R.autocomplete,
            "aria-label": (F = X(r)) == null ? void 0 : F.input,
            "aria-disabled": R.disabled || void 0,
            "aria-invalid": R.state === !1 ? !0 : void 0,
            onInput: O,
            onBlur: L,
            onFocus: M,
            onKeypress: B,
            onKeydown: J[0] || (J[0] = (E) => B(E)),
            onPaste: V
          }, null, 42, bJ)),
          ie("div", {
            onClick: J[3] || (J[3] = (E) => a("toggle"))
          }, [
            R.$slots["input-icon"] && !R.hideInputIcon ? (N(), ee("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: J[1] || (J[1] = (E) => a("toggle"))
            }, [
              ke(R.$slots, "input-icon")
            ])) : de("", !0),
            !R.$slots["input-icon"] && !R.hideInputIcon && !R.$slots["dp-input"] ? (N(), Ce(X(io), {
              key: 1,
              "aria-label": (q = X(r)) == null ? void 0 : q.calendarIcon,
              class: "dp__input_icon dp__input_icons",
              onClick: J[2] || (J[2] = (E) => a("toggle"))
            }, null, 8, ["aria-label"])) : de("", !0)
          ]),
          R.$slots["clear-icon"] && (R.alwaysClearable || e.inputValue && R.clearable && !R.disabled && !R.readonly) ? (N(), ee("span", CJ, [
            ke(R.$slots, "clear-icon", { clear: A })
          ])) : de("", !0),
          !R.$slots["clear-icon"] && (R.alwaysClearable || R.clearable && e.inputValue && !R.disabled && !R.readonly) ? (N(), ee("button", {
            key: 3,
            "aria-label": (z = X(r)) == null ? void 0 : z.clearInput,
            class: "dp--clear-btn",
            type: "button",
            onKeydown: J[4] || (J[4] = (E) => X(ia)(E, () => A(E), !0, Z)),
            onClick: J[5] || (J[5] = $t((E) => A(E), ["prevent"]))
          }, [
            p(X(lC), {
              class: "dp__input_icons",
              "data-test-id": "clear-icon"
            })
          ], 40, wJ)) : de("", !0)
        ])) : de("", !0)
      ]);
    };
  }
}), SJ = typeof window < "u" ? window : void 0, qf = () => {
}, xJ = (e) => EC() ? (Xn(e), !0) : !1, PJ = (e, t, n, a) => {
  if (!e) return qf;
  let i = qf;
  const l = pe(
    () => X(e),
    (s) => {
      i(), s && (s.removeEventListener(t, n), s.addEventListener(t, n, a), i = () => {
        s.removeEventListener(t, n, a), i = qf;
      });
    },
    { immediate: !0, flush: "post" }
  ), r = () => {
    l(), i();
  };
  return xJ(r), r;
}, $J = (e, t, n, a = {}) => {
  const { window: i = SJ, event: l = "pointerdown" } = a;
  return i ? PJ(i, l, (r) => {
    const s = Cn(e), o = Cn(t);
    !s || !o || s === r.target || r.composedPath().includes(s) || r.composedPath().includes(o) || n(r);
  }, { passive: !0 }) : void 0;
}, _J = ["data-dp-mobile"], MJ = /* @__PURE__ */ Sn({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...R1
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "text-input"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, i = e, l = Rl(), r = Y(!1), s = ue(i, "modelValue"), o = ue(i, "timezone"), u = Y(null), c = Y(null), d = Y(null), f = Y(!1), h = Y(null), m = Y(!1), g = Y(!1), v = Y(!1), y = Y(!1), { setMenuFocused: b, setShiftKey: C } = OC(), { clearArrowNav: S } = Hl(), { validateDate: x, isValidTime: w } = jl(i), {
      defaultedTransitions: V,
      defaultedTextInput: _,
      defaultedInline: O,
      defaultedConfig: $,
      defaultedRange: P,
      defaultedMultiDates: M
    } = Gt(i), { menuTransition: T, showTransition: L } = Nu(V), { isMobile: A } = PC($), D = Pl();
    rt(() => {
      Q(i.modelValue), et().then(() => {
        if (!O.value.enabled) {
          const $e = F(h.value);
          $e == null || $e.addEventListener("scroll", he), window == null || window.addEventListener("resize", Oe);
        }
      }), O.value.enabled && (r.value = !0), window == null || window.addEventListener("keyup", je), window == null || window.addEventListener("keydown", be);
    }), ni(() => {
      if (!O.value.enabled) {
        const $e = F(h.value);
        $e == null || $e.removeEventListener("scroll", he), window == null || window.removeEventListener("resize", Oe);
      }
      window == null || window.removeEventListener("keyup", je), window == null || window.removeEventListener("keydown", be);
    });
    const B = ka(l, "all", i.presetDates), j = ka(l, "input");
    pe(
      [s, o],
      () => {
        Q(s.value);
      },
      { deep: !0 }
    );
    const { openOnTop: I, menuStyle: Z, xCorrect: R, setMenuPosition: J, getScrollableParent: F, shadowRender: q } = mJ({
      menuRef: u,
      menuRefInner: c,
      inputRef: d,
      pickerWrapperRef: h,
      inline: O,
      emit: a,
      props: i,
      slots: l
    }), {
      inputValue: z,
      internalModelValue: E,
      parseExternalModelValue: Q,
      emitModelValue: W,
      formatInputValue: se,
      checkBeforeEmit: Se
    } = uK(a, i, f), U = k(
      () => ({
        dp__main: !0,
        dp__theme_dark: i.dark,
        dp__theme_light: !i.dark,
        dp__flex_display: O.value.enabled,
        "dp--flex-display-collapsed": v.value,
        dp__flex_display_with_input: O.value.input
      })
    ), ne = k(() => i.dark ? "dp__theme_dark" : "dp__theme_light"), K = k(() => i.teleport ? {
      to: typeof i.teleport == "boolean" ? "body" : i.teleport,
      disabled: !i.teleport || O.value.enabled
    } : {}), te = k(() => ({ class: "dp__outer_menu_wrap" })), H = k(() => O.value.enabled && (i.timePicker || i.monthPicker || i.yearPicker || i.quarterPicker)), ce = () => {
      var $e, Ze;
      return ((Ze = ($e = d.value) == null ? void 0 : $e.$el) == null ? void 0 : Ze.getBoundingClientRect()) ?? { width: 0, left: 0, right: 0 };
    }, he = () => {
      r.value && ($.value.closeOnScroll ? pn() : J());
    }, Oe = () => {
      var $e;
      r.value && J();
      const Ze = (($e = c.value) == null ? void 0 : $e.$el.getBoundingClientRect().width) ?? 0;
      v.value = document.body.offsetWidth <= Ze;
    }, je = ($e) => {
      $e.key === "Tab" && !O.value.enabled && !i.teleport && $.value.tabOutClosesMenu && (h.value.contains(document.activeElement) || pn()), g.value = $e.shiftKey;
    }, be = ($e) => {
      g.value = $e.shiftKey;
    }, Te = () => {
      !i.disabled && !i.readonly && (q(D, X4, i), J(!1), r.value = !0, r.value && a("open"), r.value || Ye(), Q(i.modelValue));
    }, Be = () => {
      var $e, Ze;
      z.value = "", Ye(), ($e = c.value) == null || $e.onValueCleared(), (Ze = d.value) == null || Ze.setParsedDate(null), a("update:model-value", null), a("update:model-timezone-value", null), a("cleared"), $.value.closeOnClearValue && pn();
    }, oe = () => {
      const $e = E.value;
      return !$e || !Array.isArray($e) && x($e) ? !0 : Array.isArray($e) ? M.value.enabled || $e.length === 2 && x($e[0]) && x($e[1]) ? !0 : P.value.partialRange && !i.timePicker ? x($e[0]) : !1 : !1;
    }, Me = () => {
      Se() && oe() ? (W(), pn()) : a("invalid-select", E.value);
    }, Xe = ($e) => {
      Ke(), W(), $.value.closeOnAutoApply && !$e && pn();
    }, Ke = () => {
      d.value && _.value.enabled && d.value.setParsedDate(E.value);
    }, Kt = ($e = !1) => {
      i.autoApply && w(E.value) && oe() && (P.value.enabled && Array.isArray(E.value) ? (P.value.partialRange || E.value.length === 2) && Xe($e) : Xe($e));
    }, Ye = () => {
      _.value.enabled || (E.value = null);
    }, pn = ($e = !1) => {
      var Ze, We;
      $e && E.value && $.value.setDateOnMenuClose && Me(), O.value.enabled || (r.value && (r.value = !1, R.value = !1, b(!1), C(!1), S(), a("closed"), z.value && Q(s.value)), Ye(), a("blur"), (We = (Ze = c.value) == null ? void 0 : Ze.$el) == null || We.remove());
    }, Rt = ($e, Ze, We = !1) => {
      if (!$e) {
        E.value = null;
        return;
      }
      const Zi = Array.isArray($e) ? !$e.some((Xl) => !x(Xl)) : x($e), oi = w($e);
      Zi && oi ? (y.value = !0, E.value = $e, Ze ? (m.value = We, Me(), a("text-submit")) : i.autoApply && Kt(), et().then(() => {
        y.value = !1;
      })) : a("invalid-date", $e);
    }, zl = () => {
      i.autoApply && w(E.value) && W(), Ke();
    }, Fl = () => r.value ? pn() : Te(), cl = ($e) => {
      E.value = $e;
    }, E1 = () => {
      _.value.enabled && (f.value = !0, se()), a("focus");
    }, N1 = () => {
      if (_.value.enabled && (f.value = !1, Q(i.modelValue), m.value)) {
        const $e = DG(h.value, g.value);
        $e == null || $e.focus();
      }
      a("blur");
    }, H1 = ($e) => {
      c.value && c.value.updateMonthYear(0, {
        month: B4($e.month),
        year: B4($e.year)
      });
    }, j1 = ($e) => {
      Q($e ?? i.modelValue);
    }, me = ($e, Ze) => {
      var We;
      (We = c.value) == null || We.switchView($e, Ze);
    }, Le = ($e, Ze) => $.value.onClickOutside ? $.value.onClickOutside($e, Ze) : pn(!0), Je = ($e = 0) => {
      var Ze;
      (Ze = c.value) == null || Ze.handleFlow($e);
    }, st = () => u;
    return $J(
      u,
      d,
      ($e) => Le(oe, $e)
    ), t({
      closeMenu: pn,
      selectDate: Me,
      clearValue: Be,
      openMenu: Te,
      onScroll: he,
      formatInputValue: se,
      // exposed for testing purposes
      updateInternalModelValue: cl,
      // modify internal modelValue
      setMonthYear: H1,
      parseModel: j1,
      switchView: me,
      toggleMenu: Fl,
      handleFlow: Je,
      getDpWrapMenuRef: st
    }), ($e, Ze) => (N(), ee("div", {
      ref_key: "pickerWrapperRef",
      ref: h,
      class: Ie(U.value),
      "data-datepicker-instance": "",
      "data-dp-mobile": X(A)
    }, [
      p(kJ, fe({
        ref_key: "inputRef",
        ref: d,
        "input-value": X(z),
        "onUpdate:inputValue": Ze[0] || (Ze[0] = (We) => Mi(z) ? z.value = We : null),
        "is-menu-open": r.value
      }, $e.$props, {
        onClear: Be,
        onOpen: Te,
        onSetInputDate: Rt,
        onSetEmptyDate: X(W),
        onSelectDate: Me,
        onToggle: Fl,
        onClose: pn,
        onFocus: E1,
        onBlur: N1,
        onRealBlur: Ze[1] || (Ze[1] = (We) => f.value = !1),
        onTextInput: Ze[2] || (Ze[2] = (We) => $e.$emit("text-input", We))
      }), Xt({ _: 2 }, [
        Ge(X(j), (We, Zi) => ({
          name: We,
          fn: re((oi) => [
            ke($e.$slots, We, Pt(Jt(oi)))
          ])
        }))
      ]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]),
      (N(), Ce(Lr($e.teleport ? zs : "div"), Pt(Jt(K.value)), {
        default: re(() => [
          p(Jn, {
            name: X(T)(X(I)),
            css: X(L) && !X(O).enabled
          }, {
            default: re(() => [
              r.value ? (N(), ee("div", fe({
                key: 0,
                ref_key: "dpWrapMenuRef",
                ref: u
              }, te.value, {
                class: { "dp--menu-wrapper": !X(O).enabled },
                style: X(O).enabled ? void 0 : X(Z)
              }), [
                p(X4, fe({
                  ref_key: "dpMenuRef",
                  ref: c
                }, $e.$props, {
                  "internal-model-value": X(E),
                  "onUpdate:internalModelValue": Ze[3] || (Ze[3] = (We) => Mi(E) ? E.value = We : null),
                  class: { [ne.value]: !0, "dp--menu-wrapper": $e.teleport },
                  "open-on-top": X(I),
                  "no-overlay-focus": H.value,
                  collapse: v.value,
                  "get-input-rect": ce,
                  "is-text-input-date": y.value,
                  onClosePicker: pn,
                  onSelectDate: Me,
                  onAutoApply: Kt,
                  onTimeUpdate: zl,
                  onFlowStep: Ze[4] || (Ze[4] = (We) => $e.$emit("flow-step", We)),
                  onUpdateMonthYear: Ze[5] || (Ze[5] = (We) => $e.$emit("update-month-year", We)),
                  onInvalidSelect: Ze[6] || (Ze[6] = (We) => $e.$emit("invalid-select", X(E))),
                  onAutoApplyInvalid: Ze[7] || (Ze[7] = (We) => $e.$emit("invalid-select", We)),
                  onInvalidFixedRange: Ze[8] || (Ze[8] = (We) => $e.$emit("invalid-fixed-range", We)),
                  onRecalculatePosition: X(J),
                  onTooltipOpen: Ze[9] || (Ze[9] = (We) => $e.$emit("tooltip-open", We)),
                  onTooltipClose: Ze[10] || (Ze[10] = (We) => $e.$emit("tooltip-close", We)),
                  onTimePickerOpen: Ze[11] || (Ze[11] = (We) => $e.$emit("time-picker-open", We)),
                  onTimePickerClose: Ze[12] || (Ze[12] = (We) => $e.$emit("time-picker-close", We)),
                  onAmPmChange: Ze[13] || (Ze[13] = (We) => $e.$emit("am-pm-change", We)),
                  onRangeStart: Ze[14] || (Ze[14] = (We) => $e.$emit("range-start", We)),
                  onRangeEnd: Ze[15] || (Ze[15] = (We) => $e.$emit("range-end", We)),
                  onDateUpdate: Ze[16] || (Ze[16] = (We) => $e.$emit("date-update", We)),
                  onInvalidDate: Ze[17] || (Ze[17] = (We) => $e.$emit("invalid-date", We)),
                  onOverlayToggle: Ze[18] || (Ze[18] = (We) => $e.$emit("overlay-toggle", We)),
                  onMenuBlur: Ze[19] || (Ze[19] = (We) => $e.$emit("blur"))
                }), Xt({ _: 2 }, [
                  Ge(X(B), (We, Zi) => ({
                    name: We,
                    fn: re((oi) => [
                      ke($e.$slots, We, Pt(Jt({ ...oi })))
                    ])
                  }))
                ]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "is-text-input-date", "onRecalculatePosition"])
              ], 16)) : de("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 3
      }, 16))
    ], 10, _J));
  }
}), xv = /* @__PURE__ */ (() => {
  const e = MJ;
  return e.install = (t) => {
    t.component("Vue3DatePicker", e);
  }, e;
})(), VJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: xv
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(VJ).forEach(([e, t]) => {
  e !== "default" && (xv[e] = t);
});
const TJ = {
  lessThanXSeconds: {
    one: "1초 미만",
    other: "{{count}}초 미만"
  },
  xSeconds: {
    one: "1초",
    other: "{{count}}초"
  },
  halfAMinute: "30초",
  lessThanXMinutes: {
    one: "1분 미만",
    other: "{{count}}분 미만"
  },
  xMinutes: {
    one: "1분",
    other: "{{count}}분"
  },
  aboutXHours: {
    one: "약 1시간",
    other: "약 {{count}}시간"
  },
  xHours: {
    one: "1시간",
    other: "{{count}}시간"
  },
  xDays: {
    one: "1일",
    other: "{{count}}일"
  },
  aboutXWeeks: {
    one: "약 1주",
    other: "약 {{count}}주"
  },
  xWeeks: {
    one: "1주",
    other: "{{count}}주"
  },
  aboutXMonths: {
    one: "약 1개월",
    other: "약 {{count}}개월"
  },
  xMonths: {
    one: "1개월",
    other: "{{count}}개월"
  },
  aboutXYears: {
    one: "약 1년",
    other: "약 {{count}}년"
  },
  xYears: {
    one: "1년",
    other: "{{count}}년"
  },
  overXYears: {
    one: "1년 이상",
    other: "{{count}}년 이상"
  },
  almostXYears: {
    one: "거의 1년",
    other: "거의 {{count}}년"
  }
}, LJ = (e, t, n) => {
  let a;
  const i = TJ[e];
  return typeof i == "string" ? a = i : t === 1 ? a = i.one : a = i.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? a + " 후" : a + " 전" : a;
}, QJ = {
  full: "y년 M월 d일 EEEE",
  long: "y년 M월 d일",
  medium: "y.MM.dd",
  short: "y.MM.dd"
}, AJ = {
  full: "a H시 mm분 ss초 zzzz",
  long: "a H:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
}, DJ = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
}, RJ = {
  date: gs({
    formats: QJ,
    defaultWidth: "full"
  }),
  time: gs({
    formats: AJ,
    defaultWidth: "full"
  }),
  dateTime: gs({
    formats: DJ,
    defaultWidth: "full"
  })
}, IJ = {
  lastWeek: "'지난' eeee p",
  yesterday: "'어제' p",
  today: "'오늘' p",
  tomorrow: "'내일' p",
  nextWeek: "'다음' eeee p",
  other: "P"
}, BJ = (e, t, n, a) => IJ[e], ZJ = {
  narrow: ["BC", "AD"],
  abbreviated: ["BC", "AD"],
  wide: ["기원전", "서기"]
}, EJ = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1분기", "2분기", "3분기", "4분기"]
}, NJ = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "1월",
    "2월",
    "3월",
    "4월",
    "5월",
    "6월",
    "7월",
    "8월",
    "9월",
    "10월",
    "11월",
    "12월"
  ],
  wide: [
    "1월",
    "2월",
    "3월",
    "4월",
    "5월",
    "6월",
    "7월",
    "8월",
    "9월",
    "10월",
    "11월",
    "12월"
  ]
}, HJ = {
  narrow: ["일", "월", "화", "수", "목", "금", "토"],
  short: ["일", "월", "화", "수", "목", "금", "토"],
  abbreviated: ["일", "월", "화", "수", "목", "금", "토"],
  wide: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
}, jJ = {
  narrow: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  },
  abbreviated: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  },
  wide: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  }
}, zJ = {
  narrow: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  },
  abbreviated: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  },
  wide: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  }
}, FJ = (e, t) => {
  const n = Number(e);
  switch (String(t == null ? void 0 : t.unit)) {
    case "minute":
    case "second":
      return String(n);
    case "date":
      return n + "일";
    default:
      return n + "번째";
  }
}, XJ = {
  ordinalNumber: FJ,
  era: gi({
    values: ZJ,
    defaultWidth: "wide"
  }),
  quarter: gi({
    values: EJ,
    defaultWidth: "wide",
    argumentCallback: (e) => e - 1
  }),
  month: gi({
    values: NJ,
    defaultWidth: "wide"
  }),
  day: gi({
    values: HJ,
    defaultWidth: "wide"
  }),
  dayPeriod: gi({
    values: jJ,
    defaultWidth: "wide",
    formattingValues: zJ,
    defaultFormattingWidth: "wide"
  })
}, YJ = /^(\d+)(일|번째)?/i, WJ = /\d+/i, qJ = {
  narrow: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(기원전|서기)/i
}, UJ = {
  any: [/^(bc|기원전)/i, /^(ad|서기)/i]
}, GJ = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]사?분기/i
}, KJ = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, JJ = {
  narrow: /^(1[012]|[123456789])/,
  abbreviated: /^(1[012]|[123456789])월/i,
  wide: /^(1[012]|[123456789])월/i
}, eee = {
  any: [
    /^1월?$/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/
  ]
}, tee = {
  narrow: /^[일월화수목금토]/,
  short: /^[일월화수목금토]/,
  abbreviated: /^[일월화수목금토]/,
  wide: /^[일월화수목금토]요일/
}, nee = {
  any: [/^일/, /^월/, /^화/, /^수/, /^목/, /^금/, /^토/]
}, aee = {
  any: /^(am|pm|오전|오후|자정|정오|아침|저녁|밤)/i
}, iee = {
  any: {
    am: /^(am|오전)/i,
    pm: /^(pm|오후)/i,
    midnight: /^자정/i,
    noon: /^정오/i,
    morning: /^아침/i,
    afternoon: /^오후/i,
    evening: /^저녁/i,
    night: /^밤/i
  }
}, lee = {
  ordinalNumber: Xb({
    matchPattern: YJ,
    parsePattern: WJ,
    valueCallback: (e) => parseInt(e, 10)
  }),
  era: pi({
    matchPatterns: qJ,
    defaultMatchWidth: "wide",
    parsePatterns: UJ,
    defaultParseWidth: "any"
  }),
  quarter: pi({
    matchPatterns: GJ,
    defaultMatchWidth: "wide",
    parsePatterns: KJ,
    defaultParseWidth: "any",
    valueCallback: (e) => e + 1
  }),
  month: pi({
    matchPatterns: JJ,
    defaultMatchWidth: "wide",
    parsePatterns: eee,
    defaultParseWidth: "any"
  }),
  day: pi({
    matchPatterns: tee,
    defaultMatchWidth: "wide",
    parsePatterns: nee,
    defaultParseWidth: "any"
  }),
  dayPeriod: pi({
    matchPatterns: aee,
    defaultMatchWidth: "any",
    parsePatterns: iee,
    defaultParseWidth: "any"
  })
}, ree = {
  code: "ko",
  formatDistance: LJ,
  formatLong: RJ,
  formatRelative: BJ,
  localize: XJ,
  match: lee,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
}, see = {
  __name: "SDatePicker",
  props: {
    modelValue: {
      type: [String, Object, Array],
      default: null
    },
    format: {
      type: String,
      default: "yyyy-MM-dd"
    },
    minDate: {
      type: [String, Date],
      default: "1999-01-01"
    },
    maxDate: {
      type: [String, Date],
      default: "2100-01-01"
    },
    clearable: {
      type: Boolean,
      default: !1
    },
    enableTimePicker: {
      type: Boolean,
      default: !1
    },
    preventMinMaxNavigation: {
      type: Boolean,
      default: !0
    },
    range: {
      type: Boolean,
      default: !1
    },
    multiCalendars: {
      type: Boolean,
      default: !1
    },
    width: {
      type: [String, Number],
      default: null
    },
    height: {
      type: [String, Number],
      default: "40px"
    },
    lang: {
      type: String,
      default: "ko"
    },
    selectText: {
      type: String,
      default: "선택"
    },
    cancelText: {
      type: String,
      default: "취소"
    }
  },
  emits: ["update:modelValue", "onChangeDate"],
  setup(e, { emit: t }) {
    const n = e, a = t, i = k(() => n.lang === "ko" ? ree : sv), l = {
      ko: {
        select: "선택",
        cancel: "취소"
      },
      en: {
        select: "Select",
        cancel: "Cancel"
      }
    }, r = k(() => {
      var c;
      return ((c = l[n.lang]) == null ? void 0 : c.select) || l.ko.select;
    }), s = k(() => {
      var c;
      return ((c = l[n.lang]) == null ? void 0 : c.cancel) || l.ko.cancel;
    }), o = k({
      get: () => n.modelValue,
      set: (c) => {
        a("update:modelValue", c);
      }
    }), u = (c) => {
      a("update:modelValue", c), a("onChangeDate", c);
    };
    return (c, d) => (N(), Ce(X(xv), {
      modelValue: o.value,
      "onUpdate:modelValue": [
        d[0] || (d[0] = (f) => o.value = f),
        u
      ],
      class: "s-date-picker",
      format: e.format,
      "min-date": e.minDate,
      "max-date": e.maxDate,
      clearable: e.clearable,
      "enable-time-picker": e.enableTimePicker,
      "prevent-min-max-navigation": e.preventMinMaxNavigation,
      range: e.range,
      "multi-calendars": e.multiCalendars,
      "format-locale": i.value,
      "select-text": r.value,
      "cancel-text": s.value,
      style: Ot({ width: e.width, height: e.height })
    }, null, 8, ["modelValue", "format", "min-date", "max-date", "clearable", "enable-time-picker", "prevent-min-max-navigation", "range", "multi-calendars", "format-locale", "select-text", "cancel-text", "style"]));
  }
}, oee = {
  key: 1,
  class: "panel__container__header"
}, uee = { class: "panel__container__header__title" }, cee = { class: "panel__container__header__buttons" }, dee = ["title"], fee = {
  key: 0,
  width: "24px",
  height: "24px",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, hee = {
  key: 1,
  width: "24px",
  height: "24px",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, mee = {
  __name: "SSlidePanel",
  props: {
    isOpen: {
      type: Boolean,
      default: !1
    },
    className: {
      type: String,
      default: "",
      description: "클래스 명"
    },
    onClose: {
      type: Function,
      default: () => {
      }
    },
    title: {
      type: String,
      default: 0,
      validator: (e) => ["string"].includes(typeof e)
    },
    direction: {
      type: String,
      default: "bottom",
      validator: (e) => [void 0, "right", "bottom"].includes(e)
    },
    closeOnOutsideClick: {
      type: Boolean,
      default: !1,
      validator: (e) => ["boolean"].includes(typeof e),
      description: "패널 외부 클릭 시 자동 닫힘 여부"
    },
    top: {
      type: [Number, String, null],
      default: null,
      description: "Container Top 사이즈"
    },
    isBackdrop: {
      type: Boolean,
      default: !1,
      validator: (e) => ["boolean"].includes(typeof e),
      description: "불투명 배경 활성화 여부"
    },
    backdropOpacity: {
      type: Number,
      default: 1,
      validator: (e) => ["number"].includes(typeof e),
      description: "불투명 배경 opacity 조절"
    },
    backdropBlur: {
      type: Number,
      default: 0,
      validator: (e) => ["number"].includes(typeof e),
      description: "불투명 배경 블러 효과 조절"
    },
    size: {
      type: [String, Number],
      default: 380,
      validator: (e) => ["string", "number"].includes(typeof e)
    },
    resizable: {
      type: Boolean,
      default: !0,
      description: "리사이징 가능 여부"
    },
    teleportId: {
      type: String,
      default: "body",
      description: "Teleport ID"
    },
    isMinimized: {
      type: Boolean,
      default: !1,
      description: "최소화 상태 여부"
    },
    showMinimizeButton: {
      type: Boolean,
      default: !0,
      description: "최소화 버튼 표시 여부"
    }
  },
  emits: ["update:is-minimized", "update:model-value"],
  setup(e, { emit: t }) {
    const n = t, a = e, i = k(() => typeof a.size == "number" ? a.size : parseInt(a.size)), l = Y(i.value), r = Y(a.isMinimized), s = Y(!1), o = Y(null), u = Y(null), c = k(() => a.direction === "right"), d = k(() => typeof a.size == "number" ? a.size : parseInt(a.size)), f = k(() => {
      const B = getComputedStyle(document.documentElement).getPropertyValue("--global-nav-header-height").replace("px", "");
      return Number(B);
    });
    r5(o, a.onClose, () => a.isOpen && a.closeOnOutsideClick);
    const h = k(() => ({
      opacity: a != null && a.isBackdrop ? a.backdropOpacity : 0,
      backdropFilter: a.backdropBlur ? `blur(${a.backdropBlur}px)` : "none"
    })), m = k(() => ({
      width: c.value ? `${l.value}px` : void 0,
      height: c.value ? void 0 : `${l.value}px`,
      top: a.top
    })), g = k(() => ({
      "s-slide-panel": !0,
      "s-slide-panel--right": c.value,
      "s-slide-panel--bottom": !c.value
    })), v = k(() => ({
      "s-slide-panel__container": !0,
      "s-slide-panel__container--resize-on": s.value,
      "s-slide-panel__container__resize-off": !s.value,
      "s-slide-panel__container--minimized": r.value
    })), y = k(() => ({
      "s-slide-panel__container__resizer": !0,
      "s-slide-panel__container__resizer--on": s.value,
      "s-slide-panel__container__resizer--off": !s.value
    })), b = () => document.querySelector(".show-navi"), C = () => {
      s.value = !1, window.removeEventListener("mousemove", M), window.removeEventListener("mousemove", P);
      const B = b();
      B.style.paddingBottom = "0", document.body.style.cursor = "default";
    }, S = (B) => {
      const j = b();
      if (B && j) {
        const I = l.value;
        j.style.paddingBottom = `${I}px`;
      } else
        j.style.paddingBottom = "0";
    }, x = (B) => {
      B && (l.value = localStorage.getItem(Mv.SLIDE_PANEL) || i.value);
    }, w = (B) => {
      B || (r.value = !1);
    }, _ = aW((B) => {
      localStorage.setItem(Mv.SLIDE_PANEL, B);
    }, 100), O = () => {
      const B = document.querySelector(".show-navi");
      r.value ? (r.value = !1, B && (B.style.paddingBottom = `${l.value}px`), n("update:is-minimized", !1)) : (r.value = !0, B && (B.style.paddingBottom = "64px"), n("update:is-minimized", !0));
    }, $ = () => {
      s.value = !0, document.body.style.cursor = c.value ? "col-resize" : "row-resize", window.addEventListener("mousemove", M), window.addEventListener("mouseup", P);
    }, P = () => {
      s.value = !1, document.body.style.cursor = "default", window.removeEventListener("mousemove", M), window.removeEventListener("mousemove", P);
    }, M = (B) => {
      if (!s.value) return;
      const j = c.value ? window.innerWidth : window.innerHeight, { padding: I } = window.getComputedStyle(u.value), Z = c.value && parseInt(I, 10) || 0, R = j - (c.value ? B.clientX : B.clientY) - Z;
      c.value ? R >= d.value && R <= j && (l.value = R) : R >= d.value && R <= j - f.value ? l.value = R : R >= d.value && (l.value = j - f.value);
    }, T = (B) => {
      r.value = B, n("update:is-minimized", B);
      const j = document.querySelector(".show-navi");
      j && a.isOpen && (B ? j.style.paddingBottom = "64px" : j.style.paddingBottom = `${l.value}px`);
    }, L = (B) => {
      const j = b();
      j && a.isOpen && !r.value && (j.style.paddingBottom = `${B}px`), _(B);
    }, A = (B) => n("update:model-value", B), D = (B) => n("update:is-minimized", B);
    return pe(() => a.isOpen, S), pe(() => a.isOpen, x), pe(() => a.isOpen, C), pe(() => a.isOpen, w), pe(() => a.isMinimized, T), pe(() => l.value, L), pe(() => a.isOpen, A), pe(() => a.isMinimized, D), mn(C), (B, j) => (N(), Ce(zs, { to: e.teleportId }, [
      ie("div", {
        class: Ie(g.value)
      }, [
        p(Jn, { name: "fade" }, {
          default: re(() => [
            Ct(ie("div", {
              class: "s-slide-panel__backdrop",
              style: Ot(h.value)
            }, null, 4), [
              [Dn, e.isOpen && e.isBackdrop]
            ])
          ]),
          _: 1
        }),
        p(Jn, {
          name: c.value ? "right-slide" : "bottom-slide"
        }, {
          default: re(() => [
            e.isOpen ? (N(), ee("div", {
              key: 0,
              ref_key: "slidePanelContainerRef",
              ref: o,
              class: Ie(v.value),
              style: Ot(m.value)
            }, [
              e.resizable ? (N(), ee("div", {
                key: 0,
                class: Ie(y.value),
                onMousedown: $
              }, null, 34)) : de("", !0),
              e.title ? (N(), ee("div", oee, [
                ie("h2", uee, [
                  ke(B.$slots, "title", {}, void 0, !0),
                  Ee(" " + xe(e.title), 1)
                ]),
                ie("div", cee, [
                  e.showMinimizeButton && !c.value ? (N(), ee("button", {
                    key: 0,
                    onClick: O,
                    class: "panel__container__header__minimize-button",
                    title: r.value ? "복원" : "최소화"
                  }, [
                    r.value ? (N(), ee("svg", hee, j[2] || (j[2] = [
                      ie("g", { "stroke-width": "0" }, null, -1),
                      ie("g", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round"
                      }, null, -1),
                      ie("g", null, [
                        ie("path", {
                          d: "M6 15L12 9L18 15",
                          stroke: "currentColor",
                          "stroke-width": "2",
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round"
                        })
                      ], -1)
                    ]))) : (N(), ee("svg", fee, j[1] || (j[1] = [
                      ie("g", { "stroke-width": "0" }, null, -1),
                      ie("g", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round"
                      }, null, -1),
                      ie("g", null, [
                        ie("path", {
                          d: "M6 9L12 15L18 9",
                          stroke: "currentColor",
                          "stroke-width": "2",
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round"
                        })
                      ], -1)
                    ])))
                  ], 8, dee)) : de("", !0),
                  ie("button", {
                    onClick: j[0] || (j[0] = (...I) => e.onClose && e.onClose(...I)),
                    class: "panel__container__header__close-button"
                  }, j[3] || (j[3] = [
                    ie("svg", {
                      width: "24px",
                      height: "24px",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      xmlns: "http://www.w3.org/2000/svg"
                    }, [
                      ie("g", { "stroke-width": "0" }),
                      ie("g", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round"
                      }),
                      ie("g", null, [
                        ie("path", {
                          "fill-rule": "evenodd",
                          "clip-rule": "evenodd",
                          d: "M5.29289 5.29289C5.68342 4.90237 6.31658 4.90237 6.70711 5.29289L12 10.5858L17.2929 5.29289C17.6834 4.90237 18.3166 4.90237 18.7071 5.29289C19.0976 5.68342 19.0976 6.31658 18.7071 6.70711L13.4142 12L18.7071 17.2929C19.0976 17.6834 19.0976 18.3166 18.7071 18.7071C18.3166 19.0976 17.6834 19.0976 17.2929 18.7071L12 13.4142L6.70711 18.7071C6.31658 19.0976 5.68342 19.0976 5.29289 18.7071C4.90237 18.3166 4.90237 17.6834 5.29289 17.2929L10.5858 12L5.29289 6.70711C4.90237 6.31658 4.90237 5.68342 5.29289 5.29289Z",
                          fill: "currentColor"
                        })
                      ])
                    ], -1)
                  ]))
                ])
              ])) : de("", !0),
              ie("div", {
                ref_key: "panelContentRef",
                ref: u,
                class: Ie(["panel__container__content", { "panel__container__content--minimized": r.value }])
              }, [
                ke(B.$slots, "default", {}, void 0, !0)
              ], 2)
            ], 6)) : de("", !0)
          ]),
          _: 3
        }, 8, ["name"])
      ], 2)
    ], 8, ["to"]));
  }
}, vee = /* @__PURE__ */ Ut(mee, [["__scopeId", "data-v-660852b6"]]), gee = { class: "s-advanced-search" }, pee = { class: "s-advanced-search__top" }, yee = { class: "s-advanced-search__top__search" }, Oee = {
  key: 0,
  class: "s-advanced-search__top__left"
}, bee = {
  key: 0,
  class: "s-advanced-search__top__right"
}, Cee = {
  __name: "SAdvancedSearch",
  props: {
    modelValue: { type: Array, default: () => [] },
    headers: { type: Array, default: () => [], description: '[{ title: "", key: "" }]' },
    items: { type: Array, default: () => [], description: "테이블 리스트 데이터" },
    density: { type: String, default: "comfortable" },
    variant: { type: String, default: "outlined" },
    width: { type: String, default: "350px" },
    placeholder: { type: String, default: "검색어를 입력하세요. (Key<=Value)" },
    languageCode: { type: String, default: "ko", description: '언어 구분 문자열 "ko" | "en"' }
    // searchTag: { type: Boolean, default: false, description: 'tag 검색 기능 사용 여부. true면 items의 모든 tag 값을 headers에 추가' },
  },
  emits: ["update:model-value", "update:key", "update:target-item"],
  setup(e, { emit: t }) {
    const n = ["field", "operator", "value"], a = [
      { title: "같음 (=)", value: "=" },
      { title: "크거나 같음 (>=)", value: ">=" },
      { title: "작거나 같음 (<=)", value: "<=" },
      { title: "보다 작음 (<)", value: "<" },
      { title: "보다 큼 (>)", value: ">" }
    ], i = [{ title: "같음 (=)", value: "=" }, { title: "포함 (:)", value: ":" }], l = t, r = e;
    let s = null;
    const o = Y(null), u = Y(null), c = Y([]), d = Y(!1), f = Y(""), h = Y(null), m = Y(n[0]), g = Y([]), v = zt({ top: 0, left: 0 }), y = zt({
      field: null,
      fieldText: null,
      type: null,
      operator: null,
      value: null
    }), b = k(() => {
      var be;
      return (be = u.value) == null ? void 0 : be.$el;
    }), C = k(() => {
      var be;
      return (be = o.value) == null ? void 0 : be.$el;
    }), S = k(() => r.languageCode === "ko"), x = k(() => ["number", "date"].includes(y.type) ? a : y.type === "string" ? i : []), w = k(() => O.value ? M() : $.value ? x.value ?? [] : P.value ? T() : []), V = k(() => {
      if (m.value === n[0])
        return S.value ? "속성" : "Attribute";
      if (m.value === n[1])
        return S.value ? "연산자" : "Operator";
      if (m.value === n[2])
        return S.value ? `${y.fieldText}값` : `${y.fieldText} values`;
    }), _ = k(() => y.type === "date" && (y == null ? void 0 : y.operator) && P.value), O = k(() => m.value === n[0]), $ = k(() => m.value === n[1]), P = k(() => m.value === n[2]);
    r5(b, D, d, C);
    function M() {
      const be = f.value.trim().toLowerCase(), Te = r.headers.filter((Be) => Be.key !== "tagList").map((Be) => ({ title: Be.title, value: Be.key }));
      return be === "" ? Te : Te.filter((Be) => Be.title.toLowerCase().includes(be));
    }
    function T() {
      var Xe;
      const be = (Xe = y.value) == null ? void 0 : Xe.toLowerCase(), Te = y.operator === "=";
      let Be = r.items.map((Ke) => {
        const Kt = Ke[y.field];
        let Ye;
        return Kt == null ? Ye = Te ? "-" : null : Ye = Kt, { title: Ye, value: Ye };
      });
      Be = Be.filter((Ke) => Ke.value !== null), Be.sort((Ke, Kt) => Ke.value === "-" && Kt.value !== "-" ? 1 : Ke.value !== "-" && Kt.value === "-" ? -1 : 0);
      const oe = Array.from(new Map(Be.map((Ke) => [Ke.value, Ke]))).map(([Ke, Kt]) => Kt);
      if (!be)
        return oe;
      const Me = oe.filter((Ke) => String(Ke.value).toLowerCase().includes(be));
      return y.operator === ":" ? [{ title: y.value, value: y.value }, ...Me] : Me;
    }
    function L(be, Te) {
      const Be = be[Te];
      return typeof Be == "string" && Ma.isValidDateFormat(Be) ? "date" : typeof Be;
    }
    function A() {
      const Te = n.findIndex((Be) => Be === m.value) + 1;
      Te < n.length && (m.value = n[Te]), Te === n.length && F();
    }
    function D() {
      d.value = !1;
    }
    function B() {
      d.value = !0;
    }
    const j = () => {
      setTimeout(() => {
        var be;
        (be = u.value) == null || be.focus();
      }, 80);
    }, I = (be) => {
      const Te = Ma.getFormattedDate(be);
      R(null, Te);
    }, Z = () => {
      var Be;
      if (!(o != null && o.value))
        throw Error("not found inputRef:", o);
      const be = (Be = o.value) == null ? void 0 : Be.getBoundingClientRect(), Te = { top: 1 };
      v.top = `${be.bottom + Te.top}px`, v.left = `${be.left + Te.bottom}px`;
    }, R = (be, Te) => {
      if (O.value) {
        f.value = be, y.fieldText = be, y.field = Te, l("update:key", Te);
        const oe = r.items.filter((Xe) => {
          const Ke = Xe[Te];
          return Ke != null;
        }).map((Xe) => L(Xe, Te)).reduce((Xe, Ke) => (Xe[Ke] = (Xe[Ke] || 0) + 1, Xe), {}), Me = Object.keys(oe).sort((Xe, Ke) => oe[Ke] - oe[Xe])[0];
        Object.keys(oe).length > 1 && console.error(`Multiple types found. Using majority type: ${Me}`), y.type = Me;
      }
      $.value && (y.operator = Te, f.value.includes(Te) || (f.value += Te)), P.value && (y.value = Te), A();
    };
    function J(be) {
      const Te = be.trim().toLowerCase(), Be = w.value[0], Me = r.headers.map((Xe) => Xe.title).some((Xe) => Te === Xe.toLowerCase());
      if (Te === "" && q(), O.value && Me && R(Be.title, Be.value), $.value) {
        const Xe = y.fieldText.toLowerCase();
        if (!Te.includes(Xe)) {
          q();
          return;
        }
        const Ke = w.value.find((Kt) => Te.includes(Kt.value));
        Ke && R(Ke.title, Ke.value);
      }
      if (P.value) {
        const Xe = Te.includes(y.fieldText.toLowerCase() + y.operator), Ke = y.fieldText.length + y.operator.length;
        Xe ? y.value = be.slice(Ke).trim() : m.value = n[1];
      }
    }
    function F() {
      g.value = [...g.value, { ...y }], q(), D(), f.value = "", o.value.blur(), l("update:target-item", { ...y });
    }
    function q() {
      y.field = null, y.fieldText = null, y.operator = null, y.type = null, y.value = null, m.value = n[0];
    }
    function z() {
      O.value && (f.value = ""), $.value && q(), P.value && q();
    }
    function E(be) {
      const Te = iW(g.value, (Be) => rW(be, Be));
      Te !== -1 ? g.value.splice(Te, 1) : console.error("제거하려는 항목을 filterOptions에서 찾을 수 없습니다.", be);
    }
    const Q = () => {
      d.value && Z();
    }, W = () => {
      window.removeEventListener("scroll", Q), window.removeEventListener("resize", Q);
    }, se = (be) => {
      be ? (Z(), window.addEventListener("scroll", Q, { passive: !0 }), window.addEventListener("resize", Q)) : W();
    }, Se = () => {
      s && clearTimeout(s), Z(), B();
    }, U = () => {
      s = setTimeout(() => {
        var Be;
        const be = document.activeElement, Te = (Be = u.value) == null ? void 0 : Be.$el;
        Te && Te.contains(be) || D();
      }, 100);
    }, ne = () => {
      var Te;
      const be = (Te = u.value) == null ? void 0 : Te.$el;
      be && be.contains(document.activeElement) && s && (clearTimeout(s), s = null);
    }, K = (be) => {
      w.value.length - 1 === be && setTimeout(() => {
        var Me, Xe;
        const Te = document.activeElement, Be = (Me = u.value) == null ? void 0 : Me.$el, oe = (Xe = o.value) == null ? void 0 : Xe.$el;
        Be && Be.contains(Te) || oe && oe.contains(Te) || D();
      }, 100);
    }, te = R, H = E, ce = z, he = j, Oe = j, je = () => {
      P.value && ((y.operator === ":" || y.type === "number") && R(null, y.value), w.value.length === 1 && R(null, w.value[0].value));
    };
    return pe(f, J), pe(h, I), pe(g, (be) => l("update:model-value", be)), pe(d, se), ni(W), (be, Te) => {
      const Be = Pe("v-text-field"), oe = Pe("v-list-subheader"), Me = Pe("v-divider"), Xe = Pe("v-list-item"), Ke = Pe("v-date-picker"), Kt = Pe("v-list"), Ye = Pe("v-chip"), pn = Pe("v-chip-group");
      return N(), ee("div", gee, [
        ie("div", pee, [
          ie("div", yee, [
            be.$slots.left ? (N(), ee("div", Oee, [
              ke(be.$slots, "left")
            ])) : de("", !0),
            p(Be, {
              ref_key: "inputRef",
              ref: o,
              modelValue: f.value,
              "onUpdate:modelValue": Te[0] || (Te[0] = (Rt) => f.value = Rt),
              density: e.density,
              variant: e.variant,
              width: e.width,
              placeholder: e.placeholder,
              hideDetails: !0,
              prependInnerIcon: "mdi-magnify",
              appendInnerIcon: `mdi-menu-${d.value ? "up" : "down"}`,
              onFocus: Se,
              onBlur: U,
              onKeydown: [
                Fi(X(he), ["arrow-down"]),
                Fi(je, ["enter"])
              ]
            }, null, 8, ["modelValue", "density", "variant", "width", "placeholder", "appendInnerIcon", "onKeydown"]),
            d.value ? (N(), Ce(Kt, {
              key: 1,
              ref_key: "popoverRef",
              ref: u,
              class: "s-advanced-search__top__left__popover",
              style: Ot({ minWidth: e.width, ...v }),
              onMousedown: Te[2] || (Te[2] = $t(() => {
              }, ["prevent"])),
              onFocusin: ne
            }, {
              default: re(() => [
                p(oe, { title: V.value }, null, 8, ["title"]),
                p(Me),
                _.value ? (N(), Ce(Ke, {
                  key: 1,
                  modelValue: h.value,
                  "onUpdate:modelValue": Te[1] || (Te[1] = (Rt) => h.value = Rt),
                  class: "s-advanced-search__top__left__date-picker",
                  "hide-header": ""
                }, null, 8, ["modelValue"])) : (N(), ee(ge, { key: 0 }, [
                  (N(!0), ee(ge, null, Ge(w.value, ({ title: Rt, value: zl }, Fl) => (N(), Ce(Xe, {
                    key: zl,
                    ref_for: !0,
                    ref: (cl) => {
                      cl && (c.value[Fl] = cl);
                    },
                    title: Rt,
                    tabindex: "0",
                    onClick: (cl) => X(te)(Rt, zl),
                    onBlur: (cl) => K(Fl),
                    onKeydown: Fi(X(Oe), ["enter"])
                  }, null, 8, ["title", "onClick", "onBlur", "onKeydown"]))), 128)),
                  w.value.length === 0 ? (N(), Ce(Xe, {
                    key: 0,
                    title: "No Data"
                  })) : de("", !0),
                  w.value.length === 0 ? (N(), Ce(Xe, {
                    key: 1,
                    title: "초기화",
                    onClick: X(ce)
                  }, null, 8, ["onClick"])) : de("", !0)
                ], 64))
              ]),
              _: 1
            }, 8, ["style"])) : de("", !0)
          ]),
          be.$slots.right ? (N(), ee("div", bee, [
            ke(be.$slots, "right")
          ])) : de("", !0)
        ]),
        p(pn, { class: "s-advanced-search__bottom" }, {
          default: re(() => [
            (N(!0), ee(ge, null, Ge(g.value, (Rt) => (N(), Ce(Ye, {
              key: `${Rt.field}_${Rt.operator}_${Rt.value}`,
              closable: "",
              ripple: !1,
              "onClick:close": (zl) => X(H)(Rt),
              link: !1
            }, {
              default: re(() => [
                ie("span", null, xe(Rt.fieldText), 1),
                ie("b", null, xe(Rt.operator), 1),
                ie("span", null, xe(Rt.value), 1)
              ]),
              _: 2
            }, 1032, ["onClick:close"]))), 128))
          ]),
          _: 1
        })
      ]);
    };
  }
}, wee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SAccordionMenu: FH,
  SAdvancedSearch: Cee,
  SAlert: $T,
  SAvatar: hb,
  SBtn: _n,
  SCardTable: iH,
  SConfirm: AN,
  SDataTable: pH,
  SDatePicker: see,
  SDetailTooltip: hq,
  SDropdownButton: bq,
  SEmpty: C7,
  SFileInputBtn: vT,
  SFilterSelect: FW,
  SFooter: RH,
  SFormGenerator: MN,
  SFormItem: Z0,
  SFormTable: CE,
  SGlobalProgress: WN,
  SHeader: LH,
  SIcon: Pd,
  SImg: mb,
  SKeyValueSelect: ST,
  SListControl: Oq,
  SListInput: pq,
  SModal: HN,
  SNavi: JH,
  SNotification: NW,
  SProgressCircular: vb,
  SProgressStages: $W,
  SRefreshBtn: b7,
  SScriptEditor: pE,
  SShellScriptInput: hT,
  SSimpleTooltip: lv,
  SSlidePanel: vee,
  SSmartSearch: sj,
  SSmartSearchServer: OW,
  SSubHeader: HH,
  STextCheckBoxInput: cT,
  SUserSettings: rq,
  customTheme: O7
}, Symbol.toStringTag, { value: "Module" })), Jr = {
  variant: "outlined",
  density: "compact",
  hideDetails: "auto"
}, Aee = Y5({
  components: { ...eT, ...wee },
  directives: dx,
  icons: {
    defaultSet: "mdi",
    aliases: E5,
    sets: { mdi: N5 }
  },
  locale: {
    locale: "ko",
    messages: { ko: yw }
  },
  theme: { ...O7 },
  defaults: {
    VTextField: { ...Jr },
    VSelect: { ...Jr },
    VTextarea: { ...Jr },
    VSwitch: { ...Jr },
    VCheckbox: { ...Jr },
    VRadio: { ...Jr }
  }
});
export {
  Mv as COMPONENT_KEY,
  _v as LOCALSTORAGE_KEY,
  gw as PER_PAGES,
  $ee as SESSIONSTORAGE_KEY,
  Aee as StratoVuetify,
  _ee as TOKEN_KEY,
  Aee as Vuetify,
  Ma as dateUtil,
  cw as regexUtil,
  xee as standardApi,
  l5 as stringUtil,
  Pee as useModal,
  r5 as useOutsideClick,
  Vee as useSlidePanel,
  Mee as useTablePage
};
