import { reactive as Xt, computed as C, ref as z, watch as ee, onMounted as it, onScopeDispose as tn, effectScope as Gd, shallowRef as ie, Fragment as le, watchEffect as ft, toRefs as Nl, capitalize as Xa, isVNode as r7, Comment as s7, unref as Me, warn as du, getCurrentInstance as o7, inject as Be, provide as lt, defineComponent as E9, camelize as z9, h as A, toRaw as nt, createVNode as m, mergeProps as q, onBeforeUnmount as Wt, readonly as Kd, onDeactivated as H9, onActivated as u7, nextTick as He, isRef as xa, resolveDynamicComponent as j9, toRef as H, TransitionGroup as Jd, Transition as Ui, Teleport as fu, withDirectives as Je, vShow as xn, resolveDirective as Pn, resolveComponent as ae, render as X9, onBeforeMount as N9, onUpdated as c7, Text as d7, markRaw as f7, cloneVNode as h7, createTextVNode as ke, onUnmounted as ef, onBeforeUpdate as m7, withModifiers as _t, toDisplayString as he, vModelText as g7, useSlots as v7, openBlock as j, createBlock as xe, createSlots as Gi, withCtx as W, renderSlot as Ae, createElementBlock as ne, createElementVNode as G, mergeModels as So, useModel as tf, createCommentVNode as _e, renderList as vt, normalizeClass as ct, normalizeStyle as on, toHandlers as p7, normalizeProps as Hn, guardReactiveProps as jn, createStaticVNode as O7, withKeys as Pr } from "vue";
const y7 = /^[a-zA-Z]+$/, b7 = /^[a-zA-Z0-9-]+$/, C7 = /[^a-zA-Z0-9!@#$%^&*(),.?":;{}|<>~`'[\]\\/\-_+=]/g, S7 = /[\u3131-\u318E\uAC00-\uD7A3]/g, w7 = /(?:www\.)?([a-zA-Z0-9-]+)\.([a-zA-Z]{2,})(?:\.[a-zA-Z]{2,})?$/, k7 = { REG_ALLOW_ENG: y7, REG_ALLOW_ENG_NUM_HYPHEN: b7, REG_ALLOW_ENG_NUM_AND_SPECIAL_CHARS: C7, REG_ALLOW_KOR: S7, REG_DOMAIN: w7 }, x7 = [void 0, null, "", "undefined"], P7 = (e) => {
  var n;
  const t = (n = e == null ? void 0 : e.toString()) == null ? void 0 : n.trim();
  return !!x7.includes(t);
}, $7 = (e) => {
  if (typeof e != "string")
    throw Error("Invalid stringData type");
  return e.replace(k7.REG_ALLOW_KOR, "");
}, V7 = (e, t) => e.replace(/{([a-zA-Z]+)}/g, (n, i) => t[i]), q9 = {
  isEmpty: P7,
  removeKoreanCharacters: $7,
  resolvePathVariable: V7
}, Kh = ["new", "detail", "update"], Gz = (e) => {
  const t = Xt({
    open: !1,
    mode: "",
    data: null
  }), n = ({ mode: r, data: s }) => {
    if (!Kh.includes(r))
      throw Error("invalid modalType");
    t.open = !0, t.mode = r, t.data = s;
  }, i = () => {
    t.open = !1, t.mode = "", t.data = null;
  }, l = (r) => {
    if (!Kh.includes(r))
      throw Error("invalid modalType");
    t.mode = r;
  };
  return { modalProps: C(() => ({
    ...t,
    closeModal: i,
    changeMode: l,
    getDatas: e
  })), openModal: n, closeModal: i };
}, Jh = Object.freeze({
  SERVICE_GROUP_UUID: "STRATO_SG_UUID",
  SERVICE_GROUP_NAME: "STRATO_SG_NAME",
  PROJECT: "STRATO_INFRA_PROJECT",
  // project
  PER_PAGES: "STRATO_PER_PAGES"
}), Kz = Object.freeze({
  STRATO_SERVICE_MENUS: "STRATO_SERVICE_MENUS",
  STRATO_INFRA_MENU: "STRATO_INFRA_MENU",
  STRATO_INFRA_MENU_FLAT: "STRATO_INFRA_MENU_FLAT",
  STRATO_TENANT_SELECTABLE: "STRATO_TENANT_SELECTABLE"
}), Jz = Object.freeze({
  LOCAL_ACCESS: "local_access_token",
  LOCAL_REFRESH: "local_refresh_token"
}), Q7 = Object.freeze([
  { text: "10", value: 10 },
  { text: "15", value: 15 },
  { text: "20", value: 20 }
]), eH = (e) => {
  const t = z(1), n = z([]), i = z(localStorage.getItem(Jh.PER_PAGES) || Q7[0].value), l = z([]), a = (c) => {
    t.value = c;
  }, r = (c) => {
    i.value = c;
  }, s = (c) => {
    console.log(c), l.value = c;
  }, o = () => {
    e == null || e(), a(1), s([]);
  };
  return ee(i, (c) => {
    localStorage.setItem(Jh.PER_PAGES, c);
  }), it(() => {
    e && typeof e == "function" && e().then();
  }), { pageNum: t, searchs: n, perPages: i, checkedList: l, setPage: a, setPerPages: r, setCheckedList: s, onRefresh: o };
};
function un(e, t) {
  let n;
  function i() {
    n = Gd(), n.run(() => t.length ? t(() => {
      n == null || n.stop(), i();
    }) : t());
  }
  ee(e, (l) => {
    l && !n ? i() : l || (n == null || n.stop(), n = void 0);
  }, {
    immediate: !0
  }), tn(() => {
    n == null || n.stop();
  });
}
const qe = typeof window < "u", nf = qe && "IntersectionObserver" in window, L7 = qe && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0), e2 = qe && "EyeDropper" in window;
function t2(e, t, n) {
  M7(e, t), t.set(e, n);
}
function M7(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function T7(e, t, n) {
  return e.set(Y9(e, t), n), n;
}
function ml(e, t) {
  return e.get(Y9(e, t));
}
function Y9(e, t, n) {
  if (typeof e == "function" ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function F9(e, t, n) {
  const i = t.length - 1;
  if (i < 0) return e === void 0 ? n : e;
  for (let l = 0; l < i; l++) {
    if (e == null)
      return n;
    e = e[t[l]];
  }
  return e == null || e[t[i]] === void 0 ? n : e[t[i]];
}
function vi(e, t) {
  if (e === t) return !0;
  if (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime() || e !== Object(e) || t !== Object(t))
    return !1;
  const n = Object.keys(e);
  return n.length !== Object.keys(t).length ? !1 : n.every((i) => vi(e[i], t[i]));
}
function Ml(e, t, n) {
  return e == null || !t || typeof t != "string" ? n : e[t] !== void 0 ? e[t] : (t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, ""), F9(e, t.split("."), n));
}
function Pt(e, t, n) {
  if (t === !0) return e === void 0 ? n : e;
  if (t == null || typeof t == "boolean") return n;
  if (e !== Object(e)) {
    if (typeof t != "function") return n;
    const l = t(e, n);
    return typeof l > "u" ? n : l;
  }
  if (typeof t == "string") return Ml(e, t, n);
  if (Array.isArray(t)) return F9(e, t, n);
  if (typeof t != "function") return n;
  const i = t(e, n);
  return typeof i > "u" ? n : i;
}
function si(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length: e
  }, (n, i) => t + i);
}
function se(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (!(e == null || e === ""))
    return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0;
}
function lf(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function n2(e) {
  let t;
  return e !== null && typeof e == "object" && ((t = Object.getPrototypeOf(e)) === Object.prototype || t === null);
}
function af(e) {
  if (e && "$el" in e) {
    const t = e.$el;
    return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE ? t.nextElementSibling : t;
  }
  return e;
}
const i2 = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
}), n1 = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function W9(e) {
  return Object.keys(e);
}
function bl(e, t) {
  return t.every((n) => e.hasOwnProperty(n));
}
function rf(e, t) {
  const n = {}, i = new Set(Object.keys(e));
  for (const l of t)
    i.has(l) && (n[l] = e[l]);
  return n;
}
function i1(e, t, n) {
  const i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null);
  for (const a in e)
    t.some((r) => r instanceof RegExp ? r.test(a) : r === a) && !(n != null && n.some((r) => r === a)) ? i[a] = e[a] : l[a] = e[a];
  return [i, l];
}
function St(e, t) {
  const n = {
    ...e
  };
  return t.forEach((i) => delete n[i]), n;
}
function hu(e, t) {
  const n = {};
  return t.forEach((i) => n[i] = e[i]), n;
}
const U9 = /^on[^a-z]/, mu = (e) => U9.test(e), _7 = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"], A7 = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
function R7(e) {
  return e.isComposing && A7.includes(e.key);
}
function sl(e) {
  const [t, n] = i1(e, [U9]), i = St(t, _7), [l, a] = i1(n, ["class", "style", "id", /^data-/]);
  return Object.assign(l, t), Object.assign(a, i), [l, a];
}
function ut(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function Z7(e, t) {
  let n = 0;
  const i = function() {
    for (var l = arguments.length, a = new Array(l), r = 0; r < l; r++)
      a[r] = arguments[r];
    clearTimeout(n), n = setTimeout(() => e(...a), Me(t));
  };
  return i.clear = () => {
    clearTimeout(n);
  }, i.immediate = e, i;
}
function Ot(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(t, Math.min(n, e));
}
function l2(e) {
  const t = e.toString().trim();
  return t.includes(".") ? t.length - t.indexOf(".") - 1 : 0;
}
function a2(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return e + n.repeat(Math.max(0, t - e.length));
}
function r2(e, t) {
  return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0").repeat(Math.max(0, t - e.length)) + e;
}
function I7(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const n = [];
  let i = 0;
  for (; i < e.length; )
    n.push(e.substr(i, t)), i += t;
  return n;
}
function s2(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
  if (e < t)
    return `${e} B`;
  const n = t === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
  let i = -1;
  for (; Math.abs(e) >= t && i < n.length - 1; )
    e /= t, ++i;
  return `${e.toFixed(1)} ${n[i]}B`;
}
function Jt() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  const i = {};
  for (const l in e)
    i[l] = e[l];
  for (const l in t) {
    const a = e[l], r = t[l];
    if (n2(a) && n2(r)) {
      i[l] = Jt(a, r, n);
      continue;
    }
    if (n && Array.isArray(a) && Array.isArray(r)) {
      i[l] = n(a, r);
      continue;
    }
    i[l] = r;
  }
  return i;
}
function G9(e) {
  return e.map((t) => t.type === le ? G9(t.children) : t).flat();
}
function xl() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (xl.cache.has(e)) return xl.cache.get(e);
  const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return xl.cache.set(e, t), t;
}
xl.cache = /* @__PURE__ */ new Map();
function ha(e, t) {
  if (!t || typeof t != "object") return [];
  if (Array.isArray(t))
    return t.map((n) => ha(e, n)).flat(1);
  if (t.suspense)
    return ha(e, t.ssContent);
  if (Array.isArray(t.children))
    return t.children.map((n) => ha(e, n)).flat(1);
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e))
      return [t.component];
    if (t.component.subTree)
      return ha(e, t.component.subTree).flat(1);
  }
  return [];
}
var Vs = /* @__PURE__ */ new WeakMap(), la = /* @__PURE__ */ new WeakMap();
class D7 {
  constructor(t) {
    t2(this, Vs, []), t2(this, la, 0), this.size = t;
  }
  push(t) {
    ml(Vs, this)[ml(la, this)] = t, T7(la, this, (ml(la, this) + 1) % this.size);
  }
  values() {
    return ml(Vs, this).slice(ml(la, this)).concat(ml(Vs, this).slice(0, ml(la, this)));
  }
}
function B7(e) {
  return "touches" in e ? {
    clientX: e.touches[0].clientX,
    clientY: e.touches[0].clientY
  } : {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function sf(e) {
  const t = Xt({}), n = C(e);
  return ft(() => {
    for (const i in n.value)
      t[i] = n.value[i];
  }, {
    flush: "sync"
  }), Nl(t);
}
function wo(e, t) {
  return e.includes(t);
}
function K9(e) {
  return e[2].toLowerCase() + e.slice(3);
}
const Dt = () => [Function, Array];
function o2(e, t) {
  return t = "on" + Xa(t), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`]);
}
function of(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  if (Array.isArray(e))
    for (const l of e)
      l(...n);
  else typeof e == "function" && e(...n);
}
function $r(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((i) => `${i}${t ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...e.querySelectorAll(n)];
}
function J9(e, t, n) {
  let i, l = e.indexOf(document.activeElement);
  const a = t === "next" ? 1 : -1;
  do
    l += a, i = e[l];
  while ((!i || i.offsetParent == null || !((n == null ? void 0 : n(i)) ?? !0)) && l < e.length && l >= 0);
  return i;
}
function Pl(e, t) {
  var i, l, a, r;
  const n = $r(e);
  if (!t)
    (e === document.activeElement || !e.contains(document.activeElement)) && ((i = n[0]) == null || i.focus());
  else if (t === "first")
    (l = n[0]) == null || l.focus();
  else if (t === "last")
    (a = n.at(-1)) == null || a.focus();
  else if (typeof t == "number")
    (r = n[t]) == null || r.focus();
  else {
    const s = J9(n, t);
    s ? s.focus() : Pl(e, t === "next" ? "first" : "last");
  }
}
function Qs(e) {
  return e == null || typeof e == "string" && e.trim() === "";
}
function eg() {
}
function Pa(e, t) {
  if (!(qe && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${t})`))) return null;
  try {
    return !!e && e.matches(t);
  } catch {
    return null;
  }
}
function gu(e) {
  return e.some((t) => r7(t) ? t.type === s7 ? !1 : t.type !== le || gu(t.children) : !0) ? e : null;
}
function E7(e, t) {
  if (!qe || e === 0)
    return t(), () => {
    };
  const n = window.setTimeout(t, e);
  return () => window.clearTimeout(n);
}
function z7(e, t) {
  const n = e.clientX, i = e.clientY, l = t.getBoundingClientRect(), a = l.left, r = l.top, s = l.right, o = l.bottom;
  return n >= a && n <= s && i >= r && i <= o;
}
function ko() {
  const e = ie(), t = (n) => {
    e.value = n;
  };
  return Object.defineProperty(t, "value", {
    enumerable: !0,
    get: () => e.value,
    set: (n) => e.value = n
  }), Object.defineProperty(t, "el", {
    enumerable: !0,
    get: () => af(e.value)
  }), t;
}
function xo(e) {
  const t = e.key.length === 1, n = !e.ctrlKey && !e.metaKey && !e.altKey;
  return t && n;
}
const tg = ["top", "bottom"], H7 = ["start", "end", "left", "right"];
function l1(e, t) {
  let [n, i] = e.split(" ");
  return i || (i = wo(tg, n) ? "start" : wo(H7, n) ? "top" : "center"), {
    side: a1(n, t),
    align: a1(i, t)
  };
}
function a1(e, t) {
  return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e;
}
function fc(e) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.side],
    align: e.align
  };
}
function hc(e) {
  return {
    side: e.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.align]
  };
}
function u2(e) {
  return {
    side: e.align,
    align: e.side
  };
}
function c2(e) {
  return wo(tg, e.side) ? "y" : "x";
}
class $l {
  constructor(t) {
    let {
      x: n,
      y: i,
      width: l,
      height: a
    } = t;
    this.x = n, this.y = i, this.width = l, this.height = a;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function d2(e, t) {
  return {
    x: {
      before: Math.max(0, t.left - e.left),
      after: Math.max(0, e.right - t.right)
    },
    y: {
      before: Math.max(0, t.top - e.top),
      after: Math.max(0, e.bottom - t.bottom)
    }
  };
}
function ng(e) {
  return Array.isArray(e) ? new $l({
    x: e[0],
    y: e[1],
    width: 0,
    height: 0
  }) : e.getBoundingClientRect();
}
function uf(e) {
  const t = e.getBoundingClientRect(), n = getComputedStyle(e), i = n.transform;
  if (i) {
    let l, a, r, s, o;
    if (i.startsWith("matrix3d("))
      l = i.slice(9, -1).split(/, /), a = +l[0], r = +l[5], s = +l[12], o = +l[13];
    else if (i.startsWith("matrix("))
      l = i.slice(7, -1).split(/, /), a = +l[0], r = +l[3], s = +l[4], o = +l[5];
    else
      return new $l(t);
    const u = n.transformOrigin, c = t.x - s - (1 - a) * parseFloat(u), d = t.y - o - (1 - r) * parseFloat(u.slice(u.indexOf(" ") + 1)), f = a ? t.width / a : e.offsetWidth + 1, h = r ? t.height / r : e.offsetHeight + 1;
    return new $l({
      x: c,
      y: d,
      width: f,
      height: h
    });
  } else
    return new $l(t);
}
function Cl(e, t, n) {
  if (typeof e.animate > "u") return {
    finished: Promise.resolve()
  };
  let i;
  try {
    i = e.animate(t, n);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof i.finished > "u" && (i.finished = new Promise((l) => {
    i.onfinish = () => {
      l(i);
    };
  })), i;
}
const lo = /* @__PURE__ */ new WeakMap();
function j7(e, t) {
  Object.keys(t).forEach((n) => {
    if (mu(n)) {
      const i = K9(n), l = lo.get(e);
      if (t[n] == null)
        l == null || l.forEach((a) => {
          const [r, s] = a;
          r === i && (e.removeEventListener(i, s), l.delete(a));
        });
      else if (!l || ![...l].some((a) => a[0] === i && a[1] === t[n])) {
        e.addEventListener(i, t[n]);
        const a = l || /* @__PURE__ */ new Set();
        a.add([i, t[n]]), lo.has(e) || lo.set(e, a);
      }
    } else
      t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n]);
  });
}
function X7(e, t) {
  Object.keys(t).forEach((n) => {
    if (mu(n)) {
      const i = K9(n), l = lo.get(e);
      l == null || l.forEach((a) => {
        const [r, s] = a;
        r === i && (e.removeEventListener(i, s), l.delete(a));
      });
    } else
      e.removeAttribute(n);
  });
}
const aa = 2.4, f2 = 0.2126729, h2 = 0.7151522, m2 = 0.072175, N7 = 0.55, q7 = 0.58, Y7 = 0.57, F7 = 0.62, Ls = 0.03, g2 = 1.45, W7 = 5e-4, U7 = 1.25, G7 = 1.25, v2 = 0.078, p2 = 12.82051282051282, Ms = 0.06, O2 = 1e-3;
function y2(e, t) {
  const n = (e.r / 255) ** aa, i = (e.g / 255) ** aa, l = (e.b / 255) ** aa, a = (t.r / 255) ** aa, r = (t.g / 255) ** aa, s = (t.b / 255) ** aa;
  let o = n * f2 + i * h2 + l * m2, u = a * f2 + r * h2 + s * m2;
  if (o <= Ls && (o += (Ls - o) ** g2), u <= Ls && (u += (Ls - u) ** g2), Math.abs(u - o) < W7) return 0;
  let c;
  if (u > o) {
    const d = (u ** N7 - o ** q7) * U7;
    c = d < O2 ? 0 : d < v2 ? d - d * p2 * Ms : d - Ms;
  } else {
    const d = (u ** F7 - o ** Y7) * G7;
    c = d > -O2 ? 0 : d > -v2 ? d - d * p2 * Ms : d + Ms;
  }
  return c * 100;
}
function qn(e) {
  du(`Vuetify: ${e}`);
}
function Po(e) {
  du(`Vuetify error: ${e}`);
}
function K7(e, t) {
  t = Array.isArray(t) ? t.slice(0, -1).map((n) => `'${n}'`).join(", ") + ` or '${t.at(-1)}'` : `'${t}'`, du(`[Vuetify UPGRADE] '${e}' is deprecated, use ${t} instead.`);
}
const $o = 0.20689655172413793, J7 = (e) => e > $o ** 3 ? Math.cbrt(e) : e / (3 * $o ** 2) + 4 / 29, ep = (e) => e > $o ? e ** 3 : 3 * $o ** 2 * (e - 4 / 29);
function ig(e) {
  const t = J7, n = t(e[1]);
  return [116 * n - 16, 500 * (t(e[0] / 0.95047) - n), 200 * (n - t(e[2] / 1.08883))];
}
function lg(e) {
  const t = ep, n = (e[0] + 16) / 116;
  return [t(n + e[1] / 500) * 0.95047, t(n), t(n - e[2] / 200) * 1.08883];
}
const tp = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]], np = (e) => e <= 31308e-7 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - 0.055, ip = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], lp = (e) => e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
function ag(e) {
  const t = Array(3), n = np, i = tp;
  for (let l = 0; l < 3; ++l)
    t[l] = Math.round(Ot(n(i[l][0] * e[0] + i[l][1] * e[1] + i[l][2] * e[2])) * 255);
  return {
    r: t[0],
    g: t[1],
    b: t[2]
  };
}
function cf(e) {
  let {
    r: t,
    g: n,
    b: i
  } = e;
  const l = [0, 0, 0], a = lp, r = ip;
  t = a(t / 255), n = a(n / 255), i = a(i / 255);
  for (let s = 0; s < 3; ++s)
    l[s] = r[s][0] * t + r[s][1] * n + r[s][2] * i;
  return l;
}
function r1(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e);
}
function ap(e) {
  return r1(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e);
}
const b2 = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, rp = {
  rgb: (e, t, n, i) => ({
    r: e,
    g: t,
    b: n,
    a: i
  }),
  rgba: (e, t, n, i) => ({
    r: e,
    g: t,
    b: n,
    a: i
  }),
  hsl: (e, t, n, i) => C2({
    h: e,
    s: t,
    l: n,
    a: i
  }),
  hsla: (e, t, n, i) => C2({
    h: e,
    s: t,
    l: n,
    a: i
  }),
  hsv: (e, t, n, i) => Pi({
    h: e,
    s: t,
    v: n,
    a: i
  }),
  hsva: (e, t, n, i) => Pi({
    h: e,
    s: t,
    v: n,
    a: i
  })
};
function Mn(e) {
  if (typeof e == "number")
    return (isNaN(e) || e < 0 || e > 16777215) && qn(`'${e}' is not a valid hex color`), {
      r: (e & 16711680) >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  if (typeof e == "string" && b2.test(e)) {
    const {
      groups: t
    } = e.match(b2), {
      fn: n,
      values: i
    } = t, l = i.split(/,\s*/).map((a) => a.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(a) / 100 : parseFloat(a));
    return rp[n](...l);
  } else if (typeof e == "string") {
    let t = e.startsWith("#") ? e.slice(1) : e;
    [3, 4].includes(t.length) ? t = t.split("").map((i) => i + i).join("") : [6, 8].includes(t.length) || qn(`'${e}' is not a valid hex(a) color`);
    const n = parseInt(t, 16);
    return (isNaN(n) || n < 0 || n > 4294967295) && qn(`'${e}' is not a valid hex(a) color`), cg(t);
  } else if (typeof e == "object") {
    if (bl(e, ["r", "g", "b"]))
      return e;
    if (bl(e, ["h", "s", "l"]))
      return Pi(df(e));
    if (bl(e, ["h", "s", "v"]))
      return Pi(e);
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function Pi(e) {
  const {
    h: t,
    s: n,
    v: i,
    a: l
  } = e, a = (s) => {
    const o = (s + t / 60) % 6;
    return i - i * n * Math.max(Math.min(o, 4 - o, 1), 0);
  }, r = [a(5), a(3), a(1)].map((s) => Math.round(s * 255));
  return {
    r: r[0],
    g: r[1],
    b: r[2],
    a: l
  };
}
function C2(e) {
  return Pi(df(e));
}
function vu(e) {
  if (!e) return {
    h: 0,
    s: 1,
    v: 1,
    a: 1
  };
  const t = e.r / 255, n = e.g / 255, i = e.b / 255, l = Math.max(t, n, i), a = Math.min(t, n, i);
  let r = 0;
  l !== a && (l === t ? r = 60 * (0 + (n - i) / (l - a)) : l === n ? r = 60 * (2 + (i - t) / (l - a)) : l === i && (r = 60 * (4 + (t - n) / (l - a)))), r < 0 && (r = r + 360);
  const s = l === 0 ? 0 : (l - a) / l, o = [r, s, l];
  return {
    h: o[0],
    s: o[1],
    v: o[2],
    a: e.a
  };
}
function rg(e) {
  const {
    h: t,
    s: n,
    v: i,
    a: l
  } = e, a = i - i * n / 2, r = a === 1 || a === 0 ? 0 : (i - a) / Math.min(a, 1 - a);
  return {
    h: t,
    s: r,
    l: a,
    a: l
  };
}
function df(e) {
  const {
    h: t,
    s: n,
    l: i,
    a: l
  } = e, a = i + n * Math.min(i, 1 - i), r = a === 0 ? 0 : 2 - 2 * i / a;
  return {
    h: t,
    s: r,
    v: a,
    a: l
  };
}
function sg(e) {
  let {
    r: t,
    g: n,
    b: i,
    a: l
  } = e;
  return l === void 0 ? `rgb(${t}, ${n}, ${i})` : `rgba(${t}, ${n}, ${i}, ${l})`;
}
function og(e) {
  return sg(Pi(e));
}
function Ts(e) {
  const t = Math.round(e).toString(16);
  return ("00".substr(0, 2 - t.length) + t).toUpperCase();
}
function ug(e) {
  let {
    r: t,
    g: n,
    b: i,
    a: l
  } = e;
  return `#${[Ts(t), Ts(n), Ts(i), l !== void 0 ? Ts(Math.round(l * 255)) : ""].join("")}`;
}
function cg(e) {
  e = sp(e);
  let [t, n, i, l] = I7(e, 2).map((a) => parseInt(a, 16));
  return l = l === void 0 ? l : l / 255, {
    r: t,
    g: n,
    b: i,
    a: l
  };
}
function dg(e) {
  const t = cg(e);
  return vu(t);
}
function fg(e) {
  return ug(Pi(e));
}
function sp(e) {
  return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map((t) => t + t).join("")), e.length !== 6 && (e = a2(a2(e, 6), 8, "F")), e;
}
function op(e, t) {
  const n = ig(cf(e));
  return n[0] = n[0] + t * 10, ag(lg(n));
}
function up(e, t) {
  const n = ig(cf(e));
  return n[0] = n[0] - t * 10, ag(lg(n));
}
function s1(e) {
  const t = Mn(e);
  return cf(t)[1];
}
function cp(e, t) {
  const n = s1(e), i = s1(t), l = Math.max(n, i), a = Math.min(n, i);
  return (l + 0.05) / (a + 0.05);
}
function hg(e) {
  const t = Math.abs(y2(Mn(0), Mn(e)));
  return Math.abs(y2(Mn(16777215), Mn(e))) > Math.min(t, 50) ? "#fff" : "#000";
}
function B(e, t) {
  return (n) => Object.keys(e).reduce((i, l) => {
    const r = typeof e[l] == "object" && e[l] != null && !Array.isArray(e[l]) ? e[l] : {
      type: e[l]
    };
    return n && l in n ? i[l] = {
      ...r,
      default: n[l]
    } : i[l] = r, t && !i[l].source && (i[l].source = t), i;
  }, {});
}
const ue = B({
  class: [String, Array, Object],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component");
function mt(e, t) {
  const n = o7();
  if (!n)
    throw new Error(`[Vuetify] ${e} must be called from inside a setup function`);
  return n;
}
function pi() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const t = mt(e).type;
  return xl((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name));
}
let mg = 0, ao = /* @__PURE__ */ new WeakMap();
function Bt() {
  const e = mt("getUid");
  if (ao.has(e)) return ao.get(e);
  {
    const t = mg++;
    return ao.set(e, t), t;
  }
}
Bt.reset = () => {
  mg = 0, ao = /* @__PURE__ */ new WeakMap();
};
function dp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mt("injectSelf");
  const {
    provides: n
  } = t;
  if (n && e in n)
    return n[e];
}
const $a = Symbol.for("vuetify:defaults");
function fp(e) {
  return z(e);
}
function ff() {
  const e = Be($a);
  if (!e) throw new Error("[Vuetify] Could not find defaults instance");
  return e;
}
function ht(e, t) {
  const n = ff(), i = z(e), l = C(() => {
    if (Me(t == null ? void 0 : t.disabled)) return n.value;
    const r = Me(t == null ? void 0 : t.scoped), s = Me(t == null ? void 0 : t.reset), o = Me(t == null ? void 0 : t.root);
    if (i.value == null && !(r || s || o)) return n.value;
    let u = Jt(i.value, {
      prev: n.value
    });
    if (r) return u;
    if (s || o) {
      const c = Number(s || 1 / 0);
      for (let d = 0; d <= c && !(!u || !("prev" in u)); d++)
        u = u.prev;
      return u && typeof o == "string" && o in u && (u = Jt(Jt(u, {
        prev: u
      }), u[o])), u;
    }
    return u.prev ? Jt(u.prev, u) : u;
  });
  return lt($a, l), l;
}
function hp(e, t) {
  var n, i;
  return typeof ((n = e.props) == null ? void 0 : n[t]) < "u" || typeof ((i = e.props) == null ? void 0 : i[xl(t)]) < "u";
}
function mp() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ff();
  const i = mt("useDefaults");
  if (t = t ?? i.type.name ?? i.type.__name, !t)
    throw new Error("[Vuetify] Could not determine component name");
  const l = C(() => {
    var o;
    return (o = n.value) == null ? void 0 : o[e._as ?? t];
  }), a = new Proxy(e, {
    get(o, u) {
      var d, f, h, g, v, p, O;
      const c = Reflect.get(o, u);
      return u === "class" || u === "style" ? [(d = l.value) == null ? void 0 : d[u], c].filter((b) => b != null) : typeof u == "string" && !hp(i.vnode, u) ? ((f = l.value) == null ? void 0 : f[u]) !== void 0 ? (h = l.value) == null ? void 0 : h[u] : ((v = (g = n.value) == null ? void 0 : g.global) == null ? void 0 : v[u]) !== void 0 ? (O = (p = n.value) == null ? void 0 : p.global) == null ? void 0 : O[u] : c : c;
    }
  }), r = ie();
  ft(() => {
    if (l.value) {
      const o = Object.entries(l.value).filter((u) => {
        let [c] = u;
        return c.startsWith(c[0].toUpperCase());
      });
      r.value = o.length ? Object.fromEntries(o) : void 0;
    } else
      r.value = void 0;
  });
  function s() {
    const o = dp($a, i);
    lt($a, C(() => r.value ? Jt((o == null ? void 0 : o.value) ?? {}, r.value) : o == null ? void 0 : o.value));
  }
  return {
    props: a,
    provideSubDefaults: s
  };
}
function $n(e) {
  if (e._setup = e._setup ?? e.setup, !e.name)
    return qn("The component is missing an explicit name, unable to generate default prop value"), e;
  if (e._setup) {
    e.props = B(e.props ?? {}, e.name)();
    const t = Object.keys(e.props).filter((n) => n !== "class" && n !== "style");
    e.filterProps = function(i) {
      return rf(i, t);
    }, e.props._as = String, e.setup = function(i, l) {
      const a = ff();
      if (!a.value) return e._setup(i, l);
      const {
        props: r,
        provideSubDefaults: s
      } = mp(i, i._as ?? e.name, a), o = e._setup(r, l);
      return s(), o;
    };
  }
  return e;
}
function X() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (t) => (e ? $n : E9)(t);
}
function gp(e, t) {
  return t.props = e, t;
}
function Oi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", n = arguments.length > 2 ? arguments[2] : void 0;
  return X()({
    name: n ?? Xa(z9(e.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: t
      },
      ...ue()
    },
    setup(i, l) {
      let {
        slots: a
      } = l;
      return () => {
        var r;
        return A(i.tag, {
          class: [e, i.class],
          style: i.style
        }, (r = a.default) == null ? void 0 : r.call(a));
      };
    }
  });
}
function gg(e) {
  if (typeof e.getRootNode != "function") {
    for (; e.parentNode; ) e = e.parentNode;
    return e !== document ? null : document;
  }
  const t = e.getRootNode();
  return t !== document && t.getRootNode({
    composed: !0
  }) !== document ? null : t;
}
const Vr = "cubic-bezier(0.4, 0, 0.2, 1)", vp = "cubic-bezier(0.0, 0, 0.2, 1)", pp = "cubic-bezier(0.4, 0, 1, 1)";
function S2(e, t, n) {
  return Object.keys(e).filter((i) => mu(i) && i.endsWith(t)).reduce((i, l) => (i[l.slice(0, -t.length)] = (a) => e[l](a, n(a)), i), {});
}
function hf(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  for (; e; ) {
    if (t ? Op(e) : mf(e)) return e;
    e = e.parentElement;
  }
  return document.scrollingElement;
}
function Vo(e, t) {
  const n = [];
  if (t && e && !t.contains(e)) return n;
  for (; e && (mf(e) && n.push(e), e !== t); )
    e = e.parentElement;
  return n;
}
function mf(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
  const t = window.getComputedStyle(e);
  return t.overflowY === "scroll" || t.overflowY === "auto" && e.scrollHeight > e.clientHeight;
}
function Op(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
  const t = window.getComputedStyle(e);
  return ["scroll", "auto"].includes(t.overflowY);
}
function yp(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === "fixed")
      return !0;
    e = e.offsetParent;
  }
  return !1;
}
function F(e) {
  const t = mt("useRender");
  t.render = e;
}
function pe(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d, l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d;
  const a = mt("useProxiedModel"), r = z(e[t] !== void 0 ? e[t] : n), s = xl(t), u = s !== t ? C(() => {
    var d, f, h, g;
    return e[t], !!(((d = a.vnode.props) != null && d.hasOwnProperty(t) || (f = a.vnode.props) != null && f.hasOwnProperty(s)) && ((h = a.vnode.props) != null && h.hasOwnProperty(`onUpdate:${t}`) || (g = a.vnode.props) != null && g.hasOwnProperty(`onUpdate:${s}`)));
  }) : C(() => {
    var d, f;
    return e[t], !!((d = a.vnode.props) != null && d.hasOwnProperty(t) && ((f = a.vnode.props) != null && f.hasOwnProperty(`onUpdate:${t}`)));
  });
  un(() => !u.value, () => {
    ee(() => e[t], (d) => {
      r.value = d;
    });
  });
  const c = C({
    get() {
      const d = e[t];
      return i(u.value ? d : r.value);
    },
    set(d) {
      const f = l(d), h = nt(u.value ? e[t] : r.value);
      h === f || i(h) === d || (r.value = f, a == null || a.emit(`update:${t}`, f));
    }
  });
  return Object.defineProperty(c, "externalValue", {
    get: () => u.value ? e[t] : r.value
  }), c;
}
const bp = {
  badge: "Badge",
  open: "Open",
  close: "Close",
  dismiss: "Dismiss",
  confirmEdit: {
    ok: "OK",
    cancel: "Cancel"
  },
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    }
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more",
    today: "Today"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM",
    title: "Select Time"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  stepper: {
    next: "Next",
    prev: "Previous"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "Loading...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  }
}, w2 = "$vuetify.", k2 = (e, t) => e.replace(/\{(\d+)\}/g, (n, i) => String(t[+i])), vg = (e, t, n) => function(i) {
  for (var l = arguments.length, a = new Array(l > 1 ? l - 1 : 0), r = 1; r < l; r++)
    a[r - 1] = arguments[r];
  if (!i.startsWith(w2))
    return k2(i, a);
  const s = i.replace(w2, ""), o = e.value && n.value[e.value], u = t.value && n.value[t.value];
  let c = Ml(o, s, null);
  return c || (qn(`Translation key "${i}" not found in "${e.value}", trying fallback locale`), c = Ml(u, s, null)), c || (Po(`Translation key "${i}" not found in fallback`), c = i), typeof c != "string" && (Po(`Translation key "${i}" has a non-string value`), c = i), k2(c, a);
};
function pg(e, t) {
  return (n, i) => new Intl.NumberFormat([e.value, t.value], i).format(n);
}
function mc(e, t, n) {
  const i = pe(e, t, e[t] ?? n.value);
  return i.value = e[t] ?? n.value, ee(n, (l) => {
    e[t] == null && (i.value = n.value);
  }), i;
}
function Og(e) {
  return (t) => {
    const n = mc(t, "locale", e.current), i = mc(t, "fallback", e.fallback), l = mc(t, "messages", e.messages);
    return {
      name: "vuetify",
      current: n,
      fallback: i,
      messages: l,
      t: vg(n, i, l),
      n: pg(n, i),
      provide: Og({
        current: n,
        fallback: i,
        messages: l
      })
    };
  };
}
function Cp(e) {
  const t = ie((e == null ? void 0 : e.locale) ?? "en"), n = ie((e == null ? void 0 : e.fallback) ?? "en"), i = z({
    en: bp,
    ...e == null ? void 0 : e.messages
  });
  return {
    name: "vuetify",
    current: t,
    fallback: n,
    messages: i,
    t: vg(t, n, i),
    n: pg(t, n),
    provide: Og({
      current: t,
      fallback: n,
      messages: i
    })
  };
}
const Va = Symbol.for("vuetify:locale");
function Sp(e) {
  return e.name != null;
}
function wp(e) {
  const t = e != null && e.adapter && Sp(e == null ? void 0 : e.adapter) ? e == null ? void 0 : e.adapter : Cp(e), n = Pp(t, e);
  return {
    ...t,
    ...n
  };
}
function pt() {
  const e = Be(Va);
  if (!e) throw new Error("[Vuetify] Could not find injected locale instance");
  return e;
}
function kp(e) {
  const t = Be(Va);
  if (!t) throw new Error("[Vuetify] Could not find injected locale instance");
  const n = t.provide(e), i = $p(n, t.rtl, e), l = {
    ...n,
    ...i
  };
  return lt(Va, l), l;
}
function xp() {
  return {
    af: !1,
    ar: !0,
    bg: !1,
    ca: !1,
    ckb: !1,
    cs: !1,
    de: !1,
    el: !1,
    en: !1,
    es: !1,
    et: !1,
    fa: !0,
    fi: !1,
    fr: !1,
    hr: !1,
    hu: !1,
    he: !0,
    id: !1,
    it: !1,
    ja: !1,
    km: !1,
    ko: !1,
    lv: !1,
    lt: !1,
    nl: !1,
    no: !1,
    pl: !1,
    pt: !1,
    ro: !1,
    ru: !1,
    sk: !1,
    sl: !1,
    srCyrl: !1,
    srLatn: !1,
    sv: !1,
    th: !1,
    tr: !1,
    az: !1,
    uk: !1,
    vi: !1,
    zhHans: !1,
    zhHant: !1
  };
}
function Pp(e, t) {
  const n = z((t == null ? void 0 : t.rtl) ?? xp()), i = C(() => n.value[e.current.value] ?? !1);
  return {
    isRtl: i,
    rtl: n,
    rtlClasses: C(() => `v-locale--is-${i.value ? "rtl" : "ltr"}`)
  };
}
function $p(e, t, n) {
  const i = C(() => n.rtl ?? t.value[e.current.value] ?? !1);
  return {
    isRtl: i,
    rtl: t,
    rtlClasses: C(() => `v-locale--is-${i.value ? "rtl" : "ltr"}`)
  };
}
function Qt() {
  const e = Be(Va);
  if (!e) throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: e.isRtl,
    rtlClasses: e.rtlClasses
  };
}
const pu = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  "GB-alt-variant": 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0
};
function Vp(e, t, n) {
  const i = [];
  let l = [];
  const a = yg(e), r = bg(e), s = n ?? pu[t.slice(-2).toUpperCase()] ?? 0, o = (a.getDay() - s + 7) % 7, u = (r.getDay() - s + 7) % 7;
  for (let c = 0; c < o; c++) {
    const d = new Date(a);
    d.setDate(d.getDate() - (o - c)), l.push(d);
  }
  for (let c = 1; c <= r.getDate(); c++) {
    const d = new Date(e.getFullYear(), e.getMonth(), c);
    l.push(d), l.length === 7 && (i.push(l), l = []);
  }
  for (let c = 1; c < 7 - u; c++) {
    const d = new Date(r);
    d.setDate(d.getDate() + c), l.push(d);
  }
  return l.length > 0 && i.push(l), i;
}
function Qp(e, t, n) {
  const i = n ?? pu[t.slice(-2).toUpperCase()] ?? 0, l = new Date(e);
  for (; l.getDay() !== i; )
    l.setDate(l.getDate() - 1);
  return l;
}
function Lp(e, t) {
  const n = new Date(e), i = ((pu[t.slice(-2).toUpperCase()] ?? 0) + 6) % 7;
  for (; n.getDay() !== i; )
    n.setDate(n.getDate() + 1);
  return n;
}
function yg(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1);
}
function bg(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 0);
}
function Mp(e) {
  const t = e.split("-").map(Number);
  return new Date(t[0], t[1] - 1, t[2]);
}
const Tp = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
function Cg(e) {
  if (e == null) return /* @__PURE__ */ new Date();
  if (e instanceof Date) return e;
  if (typeof e == "string") {
    let t;
    if (Tp.test(e))
      return Mp(e);
    if (t = Date.parse(e), !isNaN(t)) return new Date(t);
  }
  return null;
}
const x2 = new Date(2e3, 0, 2);
function _p(e, t) {
  const n = t ?? pu[e.slice(-2).toUpperCase()] ?? 0;
  return si(7).map((i) => {
    const l = new Date(x2);
    return l.setDate(x2.getDate() + n + i), new Intl.DateTimeFormat(e, {
      weekday: "narrow"
    }).format(l);
  });
}
function Ap(e, t, n, i) {
  const l = Cg(e) ?? /* @__PURE__ */ new Date(), a = i == null ? void 0 : i[t];
  if (typeof a == "function")
    return a(l, t, n);
  let r = {};
  switch (t) {
    case "fullDate":
      r = {
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "fullDateWithWeekday":
      r = {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "normalDate":
      const s = l.getDate(), o = new Intl.DateTimeFormat(n, {
        month: "long"
      }).format(l);
      return `${s} ${o}`;
    case "normalDateWithWeekday":
      r = {
        weekday: "short",
        day: "numeric",
        month: "short"
      };
      break;
    case "shortDate":
      r = {
        month: "short",
        day: "numeric"
      };
      break;
    case "year":
      r = {
        year: "numeric"
      };
      break;
    case "month":
      r = {
        month: "long"
      };
      break;
    case "monthShort":
      r = {
        month: "short"
      };
      break;
    case "monthAndYear":
      r = {
        month: "long",
        year: "numeric"
      };
      break;
    case "monthAndDate":
      r = {
        month: "long",
        day: "numeric"
      };
      break;
    case "weekday":
      r = {
        weekday: "long"
      };
      break;
    case "weekdayShort":
      r = {
        weekday: "short"
      };
      break;
    case "dayOfMonth":
      return new Intl.NumberFormat(n).format(l.getDate());
    case "hours12h":
      r = {
        hour: "numeric",
        hour12: !0
      };
      break;
    case "hours24h":
      r = {
        hour: "numeric",
        hour12: !1
      };
      break;
    case "minutes":
      r = {
        minute: "numeric"
      };
      break;
    case "seconds":
      r = {
        second: "numeric"
      };
      break;
    case "fullTime":
      r = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullTime12h":
      r = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullTime24h":
      r = {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "fullDateTime":
      r = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime12h":
      r = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime24h":
      r = {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDate":
      r = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      };
      break;
    case "keyboardDateTime":
      r = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDateTime12h":
      r = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !0
      };
      break;
    case "keyboardDateTime24h":
      r = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        hour12: !1
      };
      break;
    default:
      r = a ?? {
        timeZone: "UTC",
        timeZoneName: "short"
      };
  }
  return new Intl.DateTimeFormat(n, r).format(l);
}
function Rp(e, t) {
  const n = e.toJsDate(t), i = n.getFullYear(), l = r2(String(n.getMonth() + 1), 2, "0"), a = r2(String(n.getDate()), 2, "0");
  return `${i}-${l}-${a}`;
}
function Zp(e) {
  const [t, n, i] = e.split("-").map(Number);
  return new Date(t, n - 1, i);
}
function Ip(e, t) {
  const n = new Date(e);
  return n.setMinutes(n.getMinutes() + t), n;
}
function Dp(e, t) {
  const n = new Date(e);
  return n.setHours(n.getHours() + t), n;
}
function Bp(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t), n;
}
function Ep(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t * 7), n;
}
function zp(e, t) {
  const n = new Date(e);
  return n.setDate(1), n.setMonth(n.getMonth() + t), n;
}
function Hp(e) {
  return e.getFullYear();
}
function jp(e) {
  return e.getMonth();
}
function Xp(e) {
  return e.getDate();
}
function Np(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 1);
}
function qp(e) {
  return new Date(e.getFullYear(), e.getMonth() - 1, 1);
}
function Yp(e) {
  return e.getHours();
}
function Fp(e) {
  return e.getMinutes();
}
function Wp(e) {
  return new Date(e.getFullYear(), 0, 1);
}
function Up(e) {
  return new Date(e.getFullYear(), 11, 31);
}
function Gp(e, t) {
  return Qo(e, t[0]) && eO(e, t[1]);
}
function Kp(e) {
  const t = new Date(e);
  return t instanceof Date && !isNaN(t.getTime());
}
function Qo(e, t) {
  return e.getTime() > t.getTime();
}
function Jp(e, t) {
  return Qo(o1(e), o1(t));
}
function eO(e, t) {
  return e.getTime() < t.getTime();
}
function P2(e, t) {
  return e.getTime() === t.getTime();
}
function tO(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function nO(e, t) {
  return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function iO(e, t) {
  return e.getFullYear() === t.getFullYear();
}
function lO(e, t, n) {
  const i = new Date(e), l = new Date(t);
  switch (n) {
    case "years":
      return i.getFullYear() - l.getFullYear();
    case "quarters":
      return Math.floor((i.getMonth() - l.getMonth() + (i.getFullYear() - l.getFullYear()) * 12) / 4);
    case "months":
      return i.getMonth() - l.getMonth() + (i.getFullYear() - l.getFullYear()) * 12;
    case "weeks":
      return Math.floor((i.getTime() - l.getTime()) / (1e3 * 60 * 60 * 24 * 7));
    case "days":
      return Math.floor((i.getTime() - l.getTime()) / (1e3 * 60 * 60 * 24));
    case "hours":
      return Math.floor((i.getTime() - l.getTime()) / (1e3 * 60 * 60));
    case "minutes":
      return Math.floor((i.getTime() - l.getTime()) / (1e3 * 60));
    case "seconds":
      return Math.floor((i.getTime() - l.getTime()) / 1e3);
    default:
      return i.getTime() - l.getTime();
  }
}
function aO(e, t) {
  const n = new Date(e);
  return n.setHours(t), n;
}
function rO(e, t) {
  const n = new Date(e);
  return n.setMinutes(t), n;
}
function sO(e, t) {
  const n = new Date(e);
  return n.setMonth(t), n;
}
function oO(e, t) {
  const n = new Date(e);
  return n.setDate(t), n;
}
function uO(e, t) {
  const n = new Date(e);
  return n.setFullYear(t), n;
}
function o1(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0);
}
function cO(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999);
}
class dO {
  constructor(t) {
    this.locale = t.locale, this.formats = t.formats;
  }
  date(t) {
    return Cg(t);
  }
  toJsDate(t) {
    return t;
  }
  toISO(t) {
    return Rp(this, t);
  }
  parseISO(t) {
    return Zp(t);
  }
  addMinutes(t, n) {
    return Ip(t, n);
  }
  addHours(t, n) {
    return Dp(t, n);
  }
  addDays(t, n) {
    return Bp(t, n);
  }
  addWeeks(t, n) {
    return Ep(t, n);
  }
  addMonths(t, n) {
    return zp(t, n);
  }
  getWeekArray(t, n) {
    return Vp(t, this.locale, n ? Number(n) : void 0);
  }
  startOfWeek(t, n) {
    return Qp(t, this.locale, n ? Number(n) : void 0);
  }
  endOfWeek(t) {
    return Lp(t, this.locale);
  }
  startOfMonth(t) {
    return yg(t);
  }
  endOfMonth(t) {
    return bg(t);
  }
  format(t, n) {
    return Ap(t, n, this.locale, this.formats);
  }
  isEqual(t, n) {
    return P2(t, n);
  }
  isValid(t) {
    return Kp(t);
  }
  isWithinRange(t, n) {
    return Gp(t, n);
  }
  isAfter(t, n) {
    return Qo(t, n);
  }
  isAfterDay(t, n) {
    return Jp(t, n);
  }
  isBefore(t, n) {
    return !Qo(t, n) && !P2(t, n);
  }
  isSameDay(t, n) {
    return tO(t, n);
  }
  isSameMonth(t, n) {
    return nO(t, n);
  }
  isSameYear(t, n) {
    return iO(t, n);
  }
  setMinutes(t, n) {
    return rO(t, n);
  }
  setHours(t, n) {
    return aO(t, n);
  }
  setMonth(t, n) {
    return sO(t, n);
  }
  setDate(t, n) {
    return oO(t, n);
  }
  setYear(t, n) {
    return uO(t, n);
  }
  getDiff(t, n, i) {
    return lO(t, n, i);
  }
  getWeekdays(t) {
    return _p(this.locale, t ? Number(t) : void 0);
  }
  getYear(t) {
    return Hp(t);
  }
  getMonth(t) {
    return jp(t);
  }
  getDate(t) {
    return Xp(t);
  }
  getNextMonth(t) {
    return Np(t);
  }
  getPreviousMonth(t) {
    return qp(t);
  }
  getHours(t) {
    return Yp(t);
  }
  getMinutes(t) {
    return Fp(t);
  }
  startOfDay(t) {
    return o1(t);
  }
  endOfDay(t) {
    return cO(t);
  }
  startOfYear(t) {
    return Wp(t);
  }
  endOfYear(t) {
    return Up(t);
  }
}
const Sg = Symbol.for("vuetify:date-options"), $2 = Symbol.for("vuetify:date-adapter");
function fO(e, t) {
  const n = Jt({
    adapter: dO,
    locale: {
      af: "af-ZA",
      // ar: '', # not the same value for all variants
      bg: "bg-BG",
      ca: "ca-ES",
      ckb: "",
      cs: "cs-CZ",
      de: "de-DE",
      el: "el-GR",
      en: "en-US",
      // es: '', # not the same value for all variants
      et: "et-EE",
      fa: "fa-IR",
      fi: "fi-FI",
      // fr: '', #not the same value for all variants
      hr: "hr-HR",
      hu: "hu-HU",
      he: "he-IL",
      id: "id-ID",
      it: "it-IT",
      ja: "ja-JP",
      ko: "ko-KR",
      lv: "lv-LV",
      lt: "lt-LT",
      nl: "nl-NL",
      no: "no-NO",
      pl: "pl-PL",
      pt: "pt-PT",
      ro: "ro-RO",
      ru: "ru-RU",
      sk: "sk-SK",
      sl: "sl-SI",
      srCyrl: "sr-SP",
      srLatn: "sr-SP",
      sv: "sv-SE",
      th: "th-TH",
      tr: "tr-TR",
      az: "az-AZ",
      uk: "uk-UA",
      vi: "vi-VN",
      zhHans: "zh-CN",
      zhHant: "zh-TW"
    }
  }, e);
  return {
    options: n,
    instance: wg(n, t)
  };
}
function wg(e, t) {
  const n = Xt(typeof e.adapter == "function" ? new e.adapter({
    locale: e.locale[t.current.value] ?? t.current.value,
    formats: e.formats
  }) : e.adapter);
  return ee(t.current, (i) => {
    n.locale = e.locale[i] ?? i ?? n.locale;
  }), n;
}
function ls() {
  const e = Be(Sg);
  if (!e) throw new Error("[Vuetify] Could not find injected date options");
  const t = pt();
  return wg(e, t);
}
function hO(e, t) {
  const n = e.toJsDate(t);
  let i = n.getFullYear(), l = new Date(i, 0, 1);
  if (n < l)
    i = i - 1, l = new Date(i, 0, 1);
  else {
    const s = new Date(i + 1, 0, 1);
    n >= s && (i = i + 1, l = s);
  }
  const a = Math.abs(n.getTime() - l.getTime()), r = Math.ceil(a / (1e3 * 60 * 60 * 24));
  return Math.floor(r / 7) + 1;
}
const Ou = ["sm", "md", "lg", "xl", "xxl"], u1 = Symbol.for("vuetify:display"), V2 = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
}, mO = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : V2;
  return Jt(V2, e);
};
function Q2(e) {
  return qe && !e ? window.innerWidth : typeof e == "object" && e.clientWidth || 0;
}
function L2(e) {
  return qe && !e ? window.innerHeight : typeof e == "object" && e.clientHeight || 0;
}
function M2(e) {
  const t = qe && !e ? window.navigator.userAgent : "ssr";
  function n(g) {
    return !!t.match(g);
  }
  const i = n(/android/i), l = n(/iphone|ipad|ipod/i), a = n(/cordova/i), r = n(/electron/i), s = n(/chrome/i), o = n(/edge/i), u = n(/firefox/i), c = n(/opera/i), d = n(/win/i), f = n(/mac/i), h = n(/linux/i);
  return {
    android: i,
    ios: l,
    cordova: a,
    electron: r,
    chrome: s,
    edge: o,
    firefox: u,
    opera: c,
    win: d,
    mac: f,
    linux: h,
    touch: L7,
    ssr: t === "ssr"
  };
}
function gO(e, t) {
  const {
    thresholds: n,
    mobileBreakpoint: i
  } = mO(e), l = ie(L2(t)), a = ie(M2(t)), r = Xt({}), s = ie(Q2(t));
  function o() {
    l.value = L2(), s.value = Q2();
  }
  function u() {
    o(), a.value = M2();
  }
  return ft(() => {
    const c = s.value < n.sm, d = s.value < n.md && !c, f = s.value < n.lg && !(d || c), h = s.value < n.xl && !(f || d || c), g = s.value < n.xxl && !(h || f || d || c), v = s.value >= n.xxl, p = c ? "xs" : d ? "sm" : f ? "md" : h ? "lg" : g ? "xl" : "xxl", O = typeof i == "number" ? i : n[i], b = s.value < O;
    r.xs = c, r.sm = d, r.md = f, r.lg = h, r.xl = g, r.xxl = v, r.smAndUp = !c, r.mdAndUp = !(c || d), r.lgAndUp = !(c || d || f), r.xlAndUp = !(c || d || f || h), r.smAndDown = !(f || h || g || v), r.mdAndDown = !(h || g || v), r.lgAndDown = !(g || v), r.xlAndDown = !v, r.name = p, r.height = l.value, r.width = s.value, r.mobile = b, r.mobileBreakpoint = i, r.platform = a.value, r.thresholds = n;
  }), qe && window.addEventListener("resize", o, {
    passive: !0
  }), {
    ...Nl(r),
    update: u,
    ssr: !!t
  };
}
const ql = B({
  mobile: {
    type: Boolean,
    default: !1
  },
  mobileBreakpoint: [Number, String]
}, "display");
function Dn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  const n = Be(u1);
  if (!n) throw new Error("Could not find Vuetify display injection");
  const i = C(() => {
    if (e.mobile != null) return e.mobile;
    if (!e.mobileBreakpoint) return n.mobile.value;
    const a = typeof e.mobileBreakpoint == "number" ? e.mobileBreakpoint : n.thresholds.value[e.mobileBreakpoint];
    return n.width.value < a;
  }), l = C(() => t ? {
    [`${t}--mobile`]: i.value
  } : {});
  return {
    ...n,
    displayClasses: l,
    mobile: i
  };
}
const kg = Symbol.for("vuetify:goto");
function xg() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: "easeInOutCubic",
    patterns: {
      linear: (e) => e,
      easeInQuad: (e) => e ** 2,
      easeOutQuad: (e) => e * (2 - e),
      easeInOutQuad: (e) => e < 0.5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e,
      easeInCubic: (e) => e ** 3,
      easeOutCubic: (e) => --e ** 3 + 1,
      easeInOutCubic: (e) => e < 0.5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
      easeInQuart: (e) => e ** 4,
      easeOutQuart: (e) => 1 - --e ** 4,
      easeInOutQuart: (e) => e < 0.5 ? 8 * e ** 4 : 1 - 8 * --e ** 4,
      easeInQuint: (e) => e ** 5,
      easeOutQuint: (e) => 1 + --e ** 5,
      easeInOutQuint: (e) => e < 0.5 ? 16 * e ** 5 : 1 + 16 * --e ** 5
    }
  };
}
function vO(e) {
  return gf(e) ?? (document.scrollingElement || document.body);
}
function gf(e) {
  return typeof e == "string" ? document.querySelector(e) : af(e);
}
function gc(e, t, n) {
  if (typeof e == "number") return t && n ? -e : e;
  let i = gf(e), l = 0;
  for (; i; )
    l += t ? i.offsetLeft : i.offsetTop, i = i.offsetParent;
  return l;
}
function pO(e, t) {
  return {
    rtl: t.isRtl,
    options: Jt(xg(), e)
  };
}
async function T2(e, t, n, i) {
  const l = n ? "scrollLeft" : "scrollTop", a = Jt((i == null ? void 0 : i.options) ?? xg(), t), r = i == null ? void 0 : i.rtl.value, s = (typeof e == "number" ? e : gf(e)) ?? 0, o = a.container === "parent" && s instanceof HTMLElement ? s.parentElement : vO(a.container), u = typeof a.easing == "function" ? a.easing : a.patterns[a.easing];
  if (!u) throw new TypeError(`Easing function "${a.easing}" not found.`);
  let c;
  if (typeof s == "number")
    c = gc(s, n, r);
  else if (c = gc(s, n, r) - gc(o, n, r), a.layout) {
    const g = window.getComputedStyle(s).getPropertyValue("--v-layout-top");
    g && (c -= parseInt(g, 10));
  }
  c += a.offset, c = yO(o, c, !!r, !!n);
  const d = o[l] ?? 0;
  if (c === d) return Promise.resolve(c);
  const f = performance.now();
  return new Promise((h) => requestAnimationFrame(function g(v) {
    const O = (v - f) / a.duration, b = Math.floor(d + (c - d) * u(Ot(O, 0, 1)));
    if (o[l] = b, O >= 1 && Math.abs(b - o[l]) < 10)
      return h(c);
    if (O > 2)
      return qn("Scroll target is not reachable"), h(o[l]);
    requestAnimationFrame(g);
  }));
}
function OO() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = Be(kg), {
    isRtl: n
  } = Qt();
  if (!t) throw new Error("[Vuetify] Could not find injected goto instance");
  const i = {
    ...t,
    // can be set via VLocaleProvider
    rtl: C(() => t.rtl.value || n.value)
  };
  async function l(a, r) {
    return T2(a, Jt(e, r), !1, i);
  }
  return l.horizontal = async (a, r) => T2(a, Jt(e, r), !0, i), l;
}
function yO(e, t, n, i) {
  const {
    scrollWidth: l,
    scrollHeight: a
  } = e, [r, s] = e === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [e.offsetWidth, e.offsetHeight];
  let o, u;
  return i ? n ? (o = -(l - r), u = 0) : (o = 0, u = l - r) : (o = 0, u = a + -s), Math.max(Math.min(t, u), o);
}
const Pg = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  // delete (e.g. v-chip close)
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  // for carousel
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus",
  calendar: "mdi-calendar",
  treeviewCollapse: "mdi-menu-down",
  treeviewExpand: "mdi-menu-right",
  eyeDropper: "mdi-eyedropper"
}, $g = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: (e) => A(pf, {
    ...e,
    class: "mdi"
  })
}, Se = [String, Function, Object, Array], c1 = Symbol.for("vuetify:icons"), yu = B({
  icon: {
    type: Se
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: !0
  }
}, "icon"), d1 = X()({
  name: "VComponentIcon",
  props: yu(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      const i = e.icon;
      return m(e.tag, null, {
        default: () => {
          var l;
          return [e.icon ? m(i, null, null) : (l = n.default) == null ? void 0 : l.call(n)];
        }
      });
    };
  }
}), vf = $n({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: yu(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => m(e.tag, q(n, {
      style: null
    }), {
      default: () => [m("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [Array.isArray(e.icon) ? e.icon.map((i) => Array.isArray(i) ? m("path", {
        d: i[0],
        "fill-opacity": i[1]
      }, null) : m("path", {
        d: i
      }, null)) : m("path", {
        d: e.icon
      }, null)])]
    });
  }
}), bO = $n({
  name: "VLigatureIcon",
  props: yu(),
  setup(e) {
    return () => m(e.tag, null, {
      default: () => [e.icon]
    });
  }
}), pf = $n({
  name: "VClassIcon",
  props: yu(),
  setup(e) {
    return () => m(e.tag, {
      class: e.icon
    }, null);
  }
});
function CO() {
  return {
    svg: {
      component: vf
    },
    class: {
      component: pf
    }
  };
}
function SO(e) {
  const t = CO(), n = (e == null ? void 0 : e.defaultSet) ?? "mdi";
  return n === "mdi" && !t.mdi && (t.mdi = $g), Jt({
    defaultSet: n,
    sets: t,
    aliases: {
      ...Pg,
      /* eslint-disable max-len */
      vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
      "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
      "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", 0.6]]
      /* eslint-enable max-len */
    }
  }, e);
}
const wO = (e) => {
  const t = Be(c1);
  if (!t) throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: C(() => {
      var o;
      const i = Me(e);
      if (!i) return {
        component: d1
      };
      let l = i;
      if (typeof l == "string" && (l = l.trim(), l.startsWith("$") && (l = (o = t.aliases) == null ? void 0 : o[l.slice(1)])), l || qn(`Could not find aliased icon "${i}"`), Array.isArray(l))
        return {
          component: vf,
          icon: l
        };
      if (typeof l != "string")
        return {
          component: d1,
          icon: l
        };
      const a = Object.keys(t.sets).find((u) => typeof l == "string" && l.startsWith(`${u}:`)), r = a ? l.slice(a.length + 1) : l;
      return {
        component: t.sets[a ?? t.defaultSet].component,
        icon: r
      };
    })
  };
}, Qr = Symbol.for("vuetify:theme"), Ie = B({
  theme: String
}, "theme");
function _2() {
  return {
    defaultTheme: "light",
    variations: {
      colors: [],
      lighten: 0,
      darken: 0
    },
    themes: {
      light: {
        dark: !1,
        colors: {
          background: "#FFFFFF",
          surface: "#FFFFFF",
          "surface-bright": "#FFFFFF",
          "surface-light": "#EEEEEE",
          "surface-variant": "#424242",
          "on-surface-variant": "#EEEEEE",
          primary: "#1867C0",
          "primary-darken-1": "#1F5592",
          secondary: "#48A9A6",
          "secondary-darken-1": "#018786",
          error: "#B00020",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#000000",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 0.87,
          "medium-emphasis-opacity": 0.6,
          "disabled-opacity": 0.38,
          "idle-opacity": 0.04,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.12,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#F5F5F5",
          "theme-on-code": "#000000"
        }
      },
      dark: {
        dark: !0,
        colors: {
          background: "#121212",
          surface: "#212121",
          "surface-bright": "#ccbfd6",
          "surface-light": "#424242",
          "surface-variant": "#a3a3a3",
          "on-surface-variant": "#424242",
          primary: "#2196F3",
          "primary-darken-1": "#277CC1",
          secondary: "#54B6B2",
          "secondary-darken-1": "#48A9A6",
          error: "#CF6679",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#FFFFFF",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 1,
          "medium-emphasis-opacity": 0.7,
          "disabled-opacity": 0.5,
          "idle-opacity": 0.1,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.16,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#343434",
          "theme-on-code": "#CCCCCC"
        }
      }
    }
  };
}
function kO() {
  var i, l;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _2();
  const t = _2();
  if (!e) return {
    ...t,
    isDisabled: !0
  };
  const n = {};
  for (const [a, r] of Object.entries(e.themes ?? {})) {
    const s = r.dark || a === "dark" ? (i = t.themes) == null ? void 0 : i.dark : (l = t.themes) == null ? void 0 : l.light;
    n[a] = Jt(s, r);
  }
  return Jt(t, {
    ...e,
    themes: n
  });
}
function xO(e) {
  const t = kO(e), n = z(t.defaultTheme), i = z(t.themes), l = C(() => {
    const c = {};
    for (const [d, f] of Object.entries(i.value)) {
      const h = c[d] = {
        ...f,
        colors: {
          ...f.colors
        }
      };
      if (t.variations)
        for (const g of t.variations.colors) {
          const v = h.colors[g];
          if (v)
            for (const p of ["lighten", "darken"]) {
              const O = p === "lighten" ? op : up;
              for (const b of si(t.variations[p], 1))
                h.colors[`${g}-${p}-${b}`] = ug(O(Mn(v), b));
            }
        }
      for (const g of Object.keys(h.colors)) {
        if (/^on-[a-z]/.test(g) || h.colors[`on-${g}`]) continue;
        const v = `on-${g}`, p = Mn(h.colors[g]);
        h.colors[v] = hg(p);
      }
    }
    return c;
  }), a = C(() => l.value[n.value]), r = C(() => {
    var g;
    const c = [];
    (g = a.value) != null && g.dark && gl(c, ":root", ["color-scheme: dark"]), gl(c, ":root", A2(a.value));
    for (const [v, p] of Object.entries(l.value))
      gl(c, `.v-theme--${v}`, [`color-scheme: ${p.dark ? "dark" : "normal"}`, ...A2(p)]);
    const d = [], f = [], h = new Set(Object.values(l.value).flatMap((v) => Object.keys(v.colors)));
    for (const v of h)
      /^on-[a-z]/.test(v) ? gl(f, `.${v}`, [`color: rgb(var(--v-theme-${v})) !important`]) : (gl(d, `.bg-${v}`, [`--v-theme-overlay-multiplier: var(--v-theme-${v}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${v})) !important`, `color: rgb(var(--v-theme-on-${v})) !important`]), gl(f, `.text-${v}`, [`color: rgb(var(--v-theme-${v})) !important`]), gl(f, `.border-${v}`, [`--v-border-color: var(--v-theme-${v})`]));
    return c.push(...d, ...f), c.map((v, p) => p === 0 ? v : `    ${v}`).join("");
  });
  function s() {
    return {
      style: [{
        children: r.value,
        id: "vuetify-theme-stylesheet",
        nonce: t.cspNonce || !1
      }]
    };
  }
  function o(c) {
    if (t.isDisabled) return;
    const d = c._context.provides.usehead;
    if (d)
      if (d.push) {
        const f = d.push(s);
        qe && ee(r, () => {
          f.patch(s);
        });
      } else
        qe ? (d.addHeadObjs(C(s)), ft(() => d.updateDOM())) : d.addHeadObjs(s());
    else {
      let h = function() {
        if (typeof document < "u" && !f) {
          const g = document.createElement("style");
          g.type = "text/css", g.id = "vuetify-theme-stylesheet", t.cspNonce && g.setAttribute("nonce", t.cspNonce), f = g, document.head.appendChild(f);
        }
        f && (f.innerHTML = r.value);
      }, f = qe ? document.getElementById("vuetify-theme-stylesheet") : null;
      qe ? ee(r, h, {
        immediate: !0
      }) : h();
    }
  }
  const u = C(() => t.isDisabled ? void 0 : `v-theme--${n.value}`);
  return {
    install: o,
    isDisabled: t.isDisabled,
    name: n,
    themes: i,
    current: a,
    computedThemes: l,
    themeClasses: u,
    styles: r,
    global: {
      name: n,
      current: a
    }
  };
}
function Xe(e) {
  mt("provideTheme");
  const t = Be(Qr, null);
  if (!t) throw new Error("Could not find Vuetify theme injection");
  const n = C(() => e.theme ?? t.name.value), i = C(() => t.themes.value[n.value]), l = C(() => t.isDisabled ? void 0 : `v-theme--${n.value}`), a = {
    ...t,
    name: n,
    current: i,
    themeClasses: l
  };
  return lt(Qr, a), a;
}
function Vg() {
  mt("useTheme");
  const e = Be(Qr, null);
  if (!e) throw new Error("Could not find Vuetify theme injection");
  return e;
}
function gl(e, t, n) {
  e.push(`${t} {
`, ...n.map((i) => `  ${i};
`), `}
`);
}
function A2(e) {
  const t = e.dark ? 2 : 1, n = e.dark ? 1 : 2, i = [];
  for (const [l, a] of Object.entries(e.colors)) {
    const r = Mn(a);
    i.push(`--v-theme-${l}: ${r.r},${r.g},${r.b}`), l.startsWith("on-") || i.push(`--v-theme-${l}-overlay-multiplier: ${s1(a) > 0.18 ? t : n}`);
  }
  for (const [l, a] of Object.entries(e.variables)) {
    const r = typeof a == "string" && a.startsWith("#") ? Mn(a) : void 0, s = r ? `${r.r}, ${r.g}, ${r.b}` : void 0;
    i.push(`--v-${l}: ${s ?? a}`);
  }
  return i;
}
function Yn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const n = ko(), i = z();
  if (qe) {
    const l = new ResizeObserver((a) => {
      e == null || e(a, l), a.length && (t === "content" ? i.value = a[0].contentRect : i.value = a[0].target.getBoundingClientRect());
    });
    Wt(() => {
      l.disconnect();
    }), ee(() => n.el, (a, r) => {
      r && (l.unobserve(r), i.value = void 0), a && l.observe(a);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef: n,
    contentRect: Kd(i)
  };
}
const Lr = Symbol.for("vuetify:layout"), Qg = Symbol.for("vuetify:layout-item"), R2 = 1e3, Lg = B({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout"), Yl = B({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function Mg() {
  const e = Be(Lr);
  if (!e) throw new Error("[Vuetify] Could not find injected layout");
  return {
    getLayoutItem: e.getLayoutItem,
    mainRect: e.mainRect,
    mainStyles: e.mainStyles
  };
}
function Fl(e) {
  const t = Be(Lr);
  if (!t) throw new Error("[Vuetify] Could not find injected layout");
  const n = e.id ?? `layout-item-${Bt()}`, i = mt("useLayoutItem");
  lt(Qg, {
    id: n
  });
  const l = ie(!1);
  H9(() => l.value = !0), u7(() => l.value = !1);
  const {
    layoutItemStyles: a,
    layoutItemScrimStyles: r
  } = t.register(i, {
    ...e,
    active: C(() => l.value ? !1 : e.active.value),
    id: n
  });
  return Wt(() => t.unregister(n)), {
    layoutItemStyles: a,
    layoutRect: t.layoutRect,
    layoutItemScrimStyles: r
  };
}
const PO = (e, t, n, i) => {
  let l = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const a = [{
    id: "",
    layer: {
      ...l
    }
  }];
  for (const r of e) {
    const s = t.get(r), o = n.get(r), u = i.get(r);
    if (!s || !o || !u) continue;
    const c = {
      ...l,
      [s.value]: parseInt(l[s.value], 10) + (u.value ? parseInt(o.value, 10) : 0)
    };
    a.push({
      id: r,
      layer: c
    }), l = c;
  }
  return a;
};
function Tg(e) {
  const t = Be(Lr, null), n = C(() => t ? t.rootZIndex.value - 100 : R2), i = z([]), l = Xt(/* @__PURE__ */ new Map()), a = Xt(/* @__PURE__ */ new Map()), r = Xt(/* @__PURE__ */ new Map()), s = Xt(/* @__PURE__ */ new Map()), o = Xt(/* @__PURE__ */ new Map()), {
    resizeRef: u,
    contentRect: c
  } = Yn(), d = C(() => {
    const Q = /* @__PURE__ */ new Map(), M = e.overlaps ?? [];
    for (const w of M.filter((y) => y.includes(":"))) {
      const [y, L] = w.split(":");
      if (!i.value.includes(y) || !i.value.includes(L)) continue;
      const k = l.get(y), S = l.get(L), P = a.get(y), T = a.get(L);
      !k || !S || !P || !T || (Q.set(L, {
        position: k.value,
        amount: parseInt(P.value, 10)
      }), Q.set(y, {
        position: S.value,
        amount: -parseInt(T.value, 10)
      }));
    }
    return Q;
  }), f = C(() => {
    const Q = [...new Set([...r.values()].map((w) => w.value))].sort((w, y) => w - y), M = [];
    for (const w of Q) {
      const y = i.value.filter((L) => {
        var k;
        return ((k = r.get(L)) == null ? void 0 : k.value) === w;
      });
      M.push(...y);
    }
    return PO(M, l, a, s);
  }), h = C(() => !Array.from(o.values()).some((Q) => Q.value)), g = C(() => f.value[f.value.length - 1].layer), v = C(() => ({
    "--v-layout-left": se(g.value.left),
    "--v-layout-right": se(g.value.right),
    "--v-layout-top": se(g.value.top),
    "--v-layout-bottom": se(g.value.bottom),
    ...h.value ? void 0 : {
      transition: "none"
    }
  })), p = C(() => f.value.slice(1).map((Q, M) => {
    let {
      id: w
    } = Q;
    const {
      layer: y
    } = f.value[M], L = a.get(w), k = l.get(w);
    return {
      id: w,
      ...y,
      size: Number(L.value),
      position: k.value
    };
  })), O = (Q) => p.value.find((M) => M.id === Q), b = mt("createLayout"), V = ie(!1);
  it(() => {
    V.value = !0;
  }), lt(Lr, {
    register: (Q, M) => {
      let {
        id: w,
        order: y,
        position: L,
        layoutSize: k,
        elementSize: S,
        active: P,
        disableTransitions: T,
        absolute: _
      } = M;
      r.set(w, y), l.set(w, L), a.set(w, k), s.set(w, P), T && o.set(w, T);
      const N = ha(Qg, b == null ? void 0 : b.vnode).indexOf(Q);
      N > -1 ? i.value.splice(N, 0, w) : i.value.push(w);
      const K = C(() => p.value.findIndex((Y) => Y.id === w)), E = C(() => n.value + f.value.length * 2 - K.value * 2), I = C(() => {
        const Y = L.value === "left" || L.value === "right", ce = L.value === "right", de = L.value === "bottom", ye = S.value ?? k.value, U = ye === 0 ? "%" : "px", ge = {
          [L.value]: 0,
          zIndex: E.value,
          transform: `translate${Y ? "X" : "Y"}(${(P.value ? 0 : -(ye === 0 ? 100 : ye)) * (ce || de ? -1 : 1)}${U})`,
          position: _.value || n.value !== R2 ? "absolute" : "fixed",
          ...h.value ? void 0 : {
            transition: "none"
          }
        };
        if (!V.value) return ge;
        const be = p.value[K.value];
        if (!be) throw new Error(`[Vuetify] Could not find layout item "${w}"`);
        const De = d.value.get(w);
        return De && (be[De.position] += De.amount), {
          ...ge,
          height: Y ? `calc(100% - ${be.top}px - ${be.bottom}px)` : S.value ? `${S.value}px` : void 0,
          left: ce ? void 0 : `${be.left}px`,
          right: ce ? `${be.right}px` : void 0,
          top: L.value !== "bottom" ? `${be.top}px` : void 0,
          bottom: L.value !== "top" ? `${be.bottom}px` : void 0,
          width: Y ? S.value ? `${S.value}px` : void 0 : `calc(100% - ${be.left}px - ${be.right}px)`
        };
      }), Z = C(() => ({
        zIndex: E.value - 1
      }));
      return {
        layoutItemStyles: I,
        layoutItemScrimStyles: Z,
        zIndex: E
      };
    },
    unregister: (Q) => {
      r.delete(Q), l.delete(Q), a.delete(Q), s.delete(Q), o.delete(Q), i.value = i.value.filter((M) => M !== Q);
    },
    mainRect: g,
    mainStyles: v,
    getLayoutItem: O,
    items: p,
    layoutRect: c,
    rootZIndex: n
  });
  const $ = C(() => ["v-layout", {
    "v-layout--full-height": e.fullHeight
  }]), x = C(() => ({
    zIndex: t ? n.value : void 0,
    position: t ? "relative" : void 0,
    overflow: t ? "hidden" : void 0
  }));
  return {
    layoutClasses: $,
    layoutStyles: x,
    getLayoutItem: O,
    items: p,
    layoutRect: c,
    layoutRef: u
  };
}
function _g() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint: t,
    ...n
  } = e, i = Jt(t, n), {
    aliases: l = {},
    components: a = {},
    directives: r = {}
  } = i, s = fp(i.defaults), o = gO(i.display, i.ssr), u = xO(i.theme), c = SO(i.icons), d = wp(i.locale), f = fO(i.date, d), h = pO(i.goTo, d);
  return {
    install: (v) => {
      for (const p in r)
        v.directive(p, r[p]);
      for (const p in a)
        v.component(p, a[p]);
      for (const p in l)
        v.component(p, $n({
          ...l[p],
          name: p,
          aliasName: l[p].name
        }));
      if (u.install(v), v.provide($a, s), v.provide(u1, o), v.provide(Qr, u), v.provide(c1, c), v.provide(Va, d), v.provide(Sg, f.options), v.provide($2, f.instance), v.provide(kg, h), qe && i.ssr)
        if (v.$nuxt)
          v.$nuxt.hook("app:suspense:resolve", () => {
            o.update();
          });
        else {
          const {
            mount: p
          } = v;
          v.mount = function() {
            const O = p(...arguments);
            return He(() => o.update()), v.mount = p, O;
          };
        }
      Bt.reset(), v.mixin({
        computed: {
          $vuetify() {
            return Xt({
              defaults: ra.call(this, $a),
              display: ra.call(this, u1),
              theme: ra.call(this, Qr),
              icons: ra.call(this, c1),
              locale: ra.call(this, Va),
              date: ra.call(this, $2)
            });
          }
        }
      });
    },
    defaults: s,
    display: o,
    theme: u,
    icons: c,
    locale: d,
    date: f,
    goTo: h
  };
}
const $O = "3.7.1";
_g.version = $O;
function ra(e) {
  var i, l;
  const t = this.$, n = ((i = t.parent) == null ? void 0 : i.provides) ?? ((l = t.vnode.appContext) == null ? void 0 : l.provides);
  if (n && e in n)
    return n[e];
}
function VO() {
  return !0;
}
function Ag(e, t, n) {
  if (!e || Rg(e, n) === !1) return !1;
  const i = gg(t);
  if (typeof ShadowRoot < "u" && i instanceof ShadowRoot && i.host === e.target) return !1;
  const l = (typeof n.value == "object" && n.value.include || (() => []))();
  return l.push(t), !l.some((a) => a == null ? void 0 : a.contains(e.target));
}
function Rg(e, t) {
  return (typeof t.value == "object" && t.value.closeConditional || VO)(e);
}
function QO(e, t, n) {
  const i = typeof n.value == "function" ? n.value : n.value.handler;
  e.shadowTarget = e.target, t._clickOutside.lastMousedownWasOutside && Ag(e, t, n) && setTimeout(() => {
    Rg(e, n) && i && i(e);
  }, 0);
}
function Z2(e, t) {
  const n = gg(e);
  t(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && t(n);
}
const Zg = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(e, t) {
    const n = (l) => QO(l, e, t), i = (l) => {
      e._clickOutside.lastMousedownWasOutside = Ag(l, e, t);
    };
    Z2(e, (l) => {
      l.addEventListener("click", n, !0), l.addEventListener("mousedown", i, !0);
    }), e._clickOutside || (e._clickOutside = {
      lastMousedownWasOutside: !1
    }), e._clickOutside[t.instance.$.uid] = {
      onClick: n,
      onMousedown: i
    };
  },
  beforeUnmount(e, t) {
    e._clickOutside && (Z2(e, (n) => {
      var a;
      if (!n || !((a = e._clickOutside) != null && a[t.instance.$.uid])) return;
      const {
        onClick: i,
        onMousedown: l
      } = e._clickOutside[t.instance.$.uid];
      n.removeEventListener("click", i, !0), n.removeEventListener("mousedown", l, !0);
    }), delete e._clickOutside[t.instance.$.uid]);
  }
};
function LO(e, t) {
  if (!nf) return;
  const n = t.modifiers || {}, i = t.value, {
    handler: l,
    options: a
  } = typeof i == "object" ? i : {
    handler: i,
    options: {}
  }, r = new IntersectionObserver(function() {
    var d;
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], o = arguments.length > 1 ? arguments[1] : void 0;
    const u = (d = e._observe) == null ? void 0 : d[t.instance.$.uid];
    if (!u) return;
    const c = s.some((f) => f.isIntersecting);
    l && (!n.quiet || u.init) && (!n.once || c || u.init) && l(c, s, o), c && n.once ? Ig(e, t) : u.init = !0;
  }, a);
  e._observe = Object(e._observe), e._observe[t.instance.$.uid] = {
    init: !1,
    observer: r
  }, r.observe(e);
}
function Ig(e, t) {
  var i;
  const n = (i = e._observe) == null ? void 0 : i[t.instance.$.uid];
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid]);
}
const as = {
  mounted: LO,
  unmounted: Ig
};
function MO(e, t) {
  const n = t.modifiers || {}, i = t.value, {
    once: l,
    immediate: a,
    ...r
  } = n, s = !Object.keys(r).length, {
    handler: o,
    options: u
  } = typeof i == "object" ? i : {
    handler: i,
    options: {
      attributes: (r == null ? void 0 : r.attr) ?? s,
      characterData: (r == null ? void 0 : r.char) ?? s,
      childList: (r == null ? void 0 : r.child) ?? s,
      subtree: (r == null ? void 0 : r.sub) ?? s
    }
  }, c = new MutationObserver(function() {
    let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], f = arguments.length > 1 ? arguments[1] : void 0;
    o == null || o(d, f), l && Dg(e, t);
  });
  a && (o == null || o([], c)), e._mutate = Object(e._mutate), e._mutate[t.instance.$.uid] = {
    observer: c
  }, c.observe(e, u);
}
function Dg(e, t) {
  var n;
  (n = e._mutate) != null && n[t.instance.$.uid] && (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid]);
}
const TO = {
  mounted: MO,
  unmounted: Dg
};
function _O(e, t) {
  var l, a;
  const n = t.value, i = {
    passive: !((l = t.modifiers) != null && l.active)
  };
  window.addEventListener("resize", n, i), e._onResize = Object(e._onResize), e._onResize[t.instance.$.uid] = {
    handler: n,
    options: i
  }, (a = t.modifiers) != null && a.quiet || n();
}
function AO(e, t) {
  var l;
  if (!((l = e._onResize) != null && l[t.instance.$.uid])) return;
  const {
    handler: n,
    options: i
  } = e._onResize[t.instance.$.uid];
  window.removeEventListener("resize", n, i), delete e._onResize[t.instance.$.uid];
}
const RO = {
  mounted: _O,
  unmounted: AO
}, f1 = Symbol("rippleStop"), ZO = 80;
function I2(e, t) {
  e.style.transform = t, e.style.webkitTransform = t;
}
function h1(e) {
  return e.constructor.name === "TouchEvent";
}
function Bg(e) {
  return e.constructor.name === "KeyboardEvent";
}
const IO = function(e, t) {
  var d;
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = 0, l = 0;
  if (!Bg(e)) {
    const f = t.getBoundingClientRect(), h = h1(e) ? e.touches[e.touches.length - 1] : e;
    i = h.clientX - f.left, l = h.clientY - f.top;
  }
  let a = 0, r = 0.3;
  (d = t._ripple) != null && d.circle ? (r = 0.15, a = t.clientWidth / 2, a = n.center ? a : a + Math.sqrt((i - a) ** 2 + (l - a) ** 2) / 4) : a = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
  const s = `${(t.clientWidth - a * 2) / 2}px`, o = `${(t.clientHeight - a * 2) / 2}px`, u = n.center ? s : `${i - a}px`, c = n.center ? o : `${l - a}px`;
  return {
    radius: a,
    scale: r,
    x: u,
    y: c,
    centerX: s,
    centerY: o
  };
}, Lo = {
  /* eslint-disable max-statements */
  show(e, t) {
    var h;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!((h = t == null ? void 0 : t._ripple) != null && h.enabled))
      return;
    const i = document.createElement("span"), l = document.createElement("span");
    i.appendChild(l), i.className = "v-ripple__container", n.class && (i.className += ` ${n.class}`);
    const {
      radius: a,
      scale: r,
      x: s,
      y: o,
      centerX: u,
      centerY: c
    } = IO(e, t, n), d = `${a * 2}px`;
    l.className = "v-ripple__animation", l.style.width = d, l.style.height = d, t.appendChild(i);
    const f = window.getComputedStyle(t);
    f && f.position === "static" && (t.style.position = "relative", t.dataset.previousPosition = "static"), l.classList.add("v-ripple__animation--enter"), l.classList.add("v-ripple__animation--visible"), I2(l, `translate(${s}, ${o}) scale3d(${r},${r},${r})`), l.dataset.activated = String(performance.now()), setTimeout(() => {
      l.classList.remove("v-ripple__animation--enter"), l.classList.add("v-ripple__animation--in"), I2(l, `translate(${u}, ${c}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(e) {
    var a;
    if (!((a = e == null ? void 0 : e._ripple) != null && a.enabled)) return;
    const t = e.getElementsByClassName("v-ripple__animation");
    if (t.length === 0) return;
    const n = t[t.length - 1];
    if (n.dataset.isHiding) return;
    n.dataset.isHiding = "true";
    const i = performance.now() - Number(n.dataset.activated), l = Math.max(250 - i, 0);
    setTimeout(() => {
      n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => {
        var s;
        e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), ((s = n.parentNode) == null ? void 0 : s.parentNode) === e && e.removeChild(n.parentNode);
      }, 300);
    }, l);
  }
};
function Eg(e) {
  return typeof e > "u" || !!e;
}
function Mr(e) {
  const t = {}, n = e.currentTarget;
  if (!(!(n != null && n._ripple) || n._ripple.touched || e[f1])) {
    if (e[f1] = !0, h1(e))
      n._ripple.touched = !0, n._ripple.isTouch = !0;
    else if (n._ripple.isTouch) return;
    if (t.center = n._ripple.centered || Bg(e), n._ripple.class && (t.class = n._ripple.class), h1(e)) {
      if (n._ripple.showTimerCommit) return;
      n._ripple.showTimerCommit = () => {
        Lo.show(e, n, t);
      }, n._ripple.showTimer = window.setTimeout(() => {
        var i;
        (i = n == null ? void 0 : n._ripple) != null && i.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null);
      }, ZO);
    } else
      Lo.show(e, n, t);
  }
}
function D2(e) {
  e[f1] = !0;
}
function wn(e) {
  const t = e.currentTarget;
  if (t != null && t._ripple) {
    if (window.clearTimeout(t._ripple.showTimer), e.type === "touchend" && t._ripple.showTimerCommit) {
      t._ripple.showTimerCommit(), t._ripple.showTimerCommit = null, t._ripple.showTimer = window.setTimeout(() => {
        wn(e);
      });
      return;
    }
    window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1);
    }), Lo.hide(t);
  }
}
function zg(e) {
  const t = e.currentTarget;
  t != null && t._ripple && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer));
}
let Tr = !1;
function Hg(e) {
  !Tr && (e.keyCode === i2.enter || e.keyCode === i2.space) && (Tr = !0, Mr(e));
}
function jg(e) {
  Tr = !1, wn(e);
}
function Xg(e) {
  Tr && (Tr = !1, wn(e));
}
function Ng(e, t, n) {
  const {
    value: i,
    modifiers: l
  } = t, a = Eg(i);
  if (a || Lo.hide(e), e._ripple = e._ripple ?? {}, e._ripple.enabled = a, e._ripple.centered = l.center, e._ripple.circle = l.circle, lf(i) && i.class && (e._ripple.class = i.class), a && !n) {
    if (l.stop) {
      e.addEventListener("touchstart", D2, {
        passive: !0
      }), e.addEventListener("mousedown", D2);
      return;
    }
    e.addEventListener("touchstart", Mr, {
      passive: !0
    }), e.addEventListener("touchend", wn, {
      passive: !0
    }), e.addEventListener("touchmove", zg, {
      passive: !0
    }), e.addEventListener("touchcancel", wn), e.addEventListener("mousedown", Mr), e.addEventListener("mouseup", wn), e.addEventListener("mouseleave", wn), e.addEventListener("keydown", Hg), e.addEventListener("keyup", jg), e.addEventListener("blur", Xg), e.addEventListener("dragstart", wn, {
      passive: !0
    });
  } else !a && n && qg(e);
}
function qg(e) {
  e.removeEventListener("mousedown", Mr), e.removeEventListener("touchstart", Mr), e.removeEventListener("touchend", wn), e.removeEventListener("touchmove", zg), e.removeEventListener("touchcancel", wn), e.removeEventListener("mouseup", wn), e.removeEventListener("mouseleave", wn), e.removeEventListener("keydown", Hg), e.removeEventListener("keyup", jg), e.removeEventListener("dragstart", wn), e.removeEventListener("blur", Xg);
}
function DO(e, t) {
  Ng(e, t, !1);
}
function BO(e) {
  delete e._ripple, qg(e);
}
function EO(e, t) {
  if (t.value === t.oldValue)
    return;
  const n = Eg(t.oldValue);
  Ng(e, t, n);
}
const Ti = {
  mounted: DO,
  unmounted: BO,
  updated: EO
};
function Yg(e, t) {
  const {
    self: n = !1
  } = t.modifiers ?? {}, i = t.value, l = typeof i == "object" && i.options || {
    passive: !0
  }, a = typeof i == "function" || "handleEvent" in i ? i : i.handler, r = n ? e : t.arg ? document.querySelector(t.arg) : window;
  r && (r.addEventListener("scroll", a, l), e._onScroll = Object(e._onScroll), e._onScroll[t.instance.$.uid] = {
    handler: a,
    options: l,
    // Don't reference self
    target: n ? void 0 : r
  });
}
function Fg(e, t) {
  var a;
  if (!((a = e._onScroll) != null && a[t.instance.$.uid])) return;
  const {
    handler: n,
    options: i,
    target: l = e
  } = e._onScroll[t.instance.$.uid];
  l.removeEventListener("scroll", n, i), delete e._onScroll[t.instance.$.uid];
}
function zO(e, t) {
  t.value !== t.oldValue && (Fg(e, t), Yg(e, t));
}
const HO = {
  mounted: Yg,
  unmounted: Fg,
  updated: zO
}, jO = (e) => {
  const {
    touchstartX: t,
    touchendX: n,
    touchstartY: i,
    touchendY: l
  } = e, a = 0.5, r = 16;
  e.offsetX = n - t, e.offsetY = l - i, Math.abs(e.offsetY) < a * Math.abs(e.offsetX) && (e.left && n < t - r && e.left(e), e.right && n > t + r && e.right(e)), Math.abs(e.offsetX) < a * Math.abs(e.offsetY) && (e.up && l < i - r && e.up(e), e.down && l > i + r && e.down(e));
};
function XO(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchstartX = n.clientX, t.touchstartY = n.clientY, (i = t.start) == null || i.call(t, {
    originalEvent: e,
    ...t
  });
}
function NO(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchendX = n.clientX, t.touchendY = n.clientY, (i = t.end) == null || i.call(t, {
    originalEvent: e,
    ...t
  }), jO(t);
}
function qO(e, t) {
  var i;
  const n = e.changedTouches[0];
  t.touchmoveX = n.clientX, t.touchmoveY = n.clientY, (i = t.move) == null || i.call(t, {
    originalEvent: e,
    ...t
  });
}
function YO() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end
  };
  return {
    touchstart: (n) => XO(n, t),
    touchend: (n) => NO(n, t),
    touchmove: (n) => qO(n, t)
  };
}
function FO(e, t) {
  var s;
  const n = t.value, i = n != null && n.parent ? e.parentElement : e, l = (n == null ? void 0 : n.options) ?? {
    passive: !0
  }, a = (s = t.instance) == null ? void 0 : s.$.uid;
  if (!i || !a) return;
  const r = YO(t.value);
  i._touchHandlers = i._touchHandlers ?? /* @__PURE__ */ Object.create(null), i._touchHandlers[a] = r, W9(r).forEach((o) => {
    i.addEventListener(o, r[o], l);
  });
}
function WO(e, t) {
  var a, r;
  const n = (a = t.value) != null && a.parent ? e.parentElement : e, i = (r = t.instance) == null ? void 0 : r.$.uid;
  if (!(n != null && n._touchHandlers) || !i) return;
  const l = n._touchHandlers[i];
  W9(l).forEach((s) => {
    n.removeEventListener(s, l[s]);
  }), delete n._touchHandlers[i];
}
const Of = {
  mounted: FO,
  unmounted: WO
};
function vc(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}
function UO(e, t) {
  return {
    x: e.x - t.x,
    y: e.y - t.y
  };
}
function B2(e, t) {
  if (e.side === "top" || e.side === "bottom") {
    const {
      side: n,
      align: i
    } = e, l = i === "left" ? 0 : i === "center" ? t.width / 2 : i === "right" ? t.width : i, a = n === "top" ? 0 : n === "bottom" ? t.height : n;
    return vc({
      x: l,
      y: a
    }, t);
  } else if (e.side === "left" || e.side === "right") {
    const {
      side: n,
      align: i
    } = e, l = n === "left" ? 0 : n === "right" ? t.width : n, a = i === "top" ? 0 : i === "center" ? t.height / 2 : i === "bottom" ? t.height : i;
    return vc({
      x: l,
      y: a
    }, t);
  }
  return vc({
    x: t.width / 2,
    y: t.height / 2
  }, t);
}
const Wg = {
  static: JO,
  // specific viewport position, usually centered
  connected: ty
  // connected to a certain element
}, GO = B({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (e) => typeof e == "function" || e in Wg
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function KO(e, t) {
  const n = z({}), i = z();
  qe && un(() => !!(t.isActive.value && e.locationStrategy), (a) => {
    var r, s;
    ee(() => e.locationStrategy, a), tn(() => {
      window.removeEventListener("resize", l), i.value = void 0;
    }), window.addEventListener("resize", l, {
      passive: !0
    }), typeof e.locationStrategy == "function" ? i.value = (r = e.locationStrategy(t, e, n)) == null ? void 0 : r.updateLocation : i.value = (s = Wg[e.locationStrategy](t, e, n)) == null ? void 0 : s.updateLocation;
  });
  function l(a) {
    var r;
    (r = i.value) == null || r.call(i, a);
  }
  return {
    contentStyles: n,
    updateLocation: i
  };
}
function JO() {
}
function ey(e, t) {
  const n = uf(e);
  return t ? n.x += parseFloat(e.style.right || 0) : n.x -= parseFloat(e.style.left || 0), n.y -= parseFloat(e.style.top || 0), n;
}
function ty(e, t, n) {
  (Array.isArray(e.target.value) || yp(e.target.value)) && Object.assign(n.value, {
    position: "fixed",
    top: 0,
    [e.isRtl.value ? "right" : "left"]: 0
  });
  const {
    preferredAnchor: l,
    preferredOrigin: a
  } = sf(() => {
    const g = l1(t.location, e.isRtl.value), v = t.origin === "overlap" ? g : t.origin === "auto" ? fc(g) : l1(t.origin, e.isRtl.value);
    return g.side === v.side && g.align === hc(v).align ? {
      preferredAnchor: u2(g),
      preferredOrigin: u2(v)
    } : {
      preferredAnchor: g,
      preferredOrigin: v
    };
  }), [r, s, o, u] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((g) => C(() => {
    const v = parseFloat(t[g]);
    return isNaN(v) ? 1 / 0 : v;
  })), c = C(() => {
    if (Array.isArray(t.offset))
      return t.offset;
    if (typeof t.offset == "string") {
      const g = t.offset.split(" ").map(parseFloat);
      return g.length < 2 && g.push(0), g;
    }
    return typeof t.offset == "number" ? [t.offset, 0] : [0, 0];
  });
  let d = !1;
  const f = new ResizeObserver(() => {
    d && h();
  });
  ee([e.target, e.contentEl], (g, v) => {
    let [p, O] = g, [b, V] = v;
    b && !Array.isArray(b) && f.unobserve(b), p && !Array.isArray(p) && f.observe(p), V && f.unobserve(V), O && f.observe(O);
  }, {
    immediate: !0
  }), tn(() => {
    f.disconnect();
  });
  function h() {
    if (d = !1, requestAnimationFrame(() => d = !0), !e.target.value || !e.contentEl.value) return;
    const g = ng(e.target.value), v = ey(e.contentEl.value, e.isRtl.value), p = Vo(e.contentEl.value), O = 12;
    p.length || (p.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (v.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), v.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
    const b = p.reduce((k, S) => {
      const P = S.getBoundingClientRect(), T = new $l({
        x: S === document.documentElement ? 0 : P.x,
        y: S === document.documentElement ? 0 : P.y,
        width: S.clientWidth,
        height: S.clientHeight
      });
      return k ? new $l({
        x: Math.max(k.left, T.left),
        y: Math.max(k.top, T.top),
        width: Math.min(k.right, T.right) - Math.max(k.left, T.left),
        height: Math.min(k.bottom, T.bottom) - Math.max(k.top, T.top)
      }) : T;
    }, void 0);
    b.x += O, b.y += O, b.width -= O * 2, b.height -= O * 2;
    let V = {
      anchor: l.value,
      origin: a.value
    };
    function $(k) {
      const S = new $l(v), P = B2(k.anchor, g), T = B2(k.origin, S);
      let {
        x: _,
        y: D
      } = UO(P, T);
      switch (k.anchor.side) {
        case "top":
          D -= c.value[0];
          break;
        case "bottom":
          D += c.value[0];
          break;
        case "left":
          _ -= c.value[0];
          break;
        case "right":
          _ += c.value[0];
          break;
      }
      switch (k.anchor.align) {
        case "top":
          D -= c.value[1];
          break;
        case "bottom":
          D += c.value[1];
          break;
        case "left":
          _ -= c.value[1];
          break;
        case "right":
          _ += c.value[1];
          break;
      }
      return S.x += _, S.y += D, S.width = Math.min(S.width, o.value), S.height = Math.min(S.height, u.value), {
        overflows: d2(S, b),
        x: _,
        y: D
      };
    }
    let x = 0, Q = 0;
    const M = {
      x: 0,
      y: 0
    }, w = {
      x: !1,
      y: !1
    };
    let y = -1;
    for (; ; ) {
      if (y++ > 10) {
        Po("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: k,
        y: S,
        overflows: P
      } = $(V);
      x += k, Q += S, v.x += k, v.y += S;
      {
        const T = c2(V.anchor), _ = P.x.before || P.x.after, D = P.y.before || P.y.after;
        let N = !1;
        if (["x", "y"].forEach((K) => {
          if (K === "x" && _ && !w.x || K === "y" && D && !w.y) {
            const E = {
              anchor: {
                ...V.anchor
              },
              origin: {
                ...V.origin
              }
            }, I = K === "x" ? T === "y" ? hc : fc : T === "y" ? fc : hc;
            E.anchor = I(E.anchor), E.origin = I(E.origin);
            const {
              overflows: Z
            } = $(E);
            (Z[K].before <= P[K].before && Z[K].after <= P[K].after || Z[K].before + Z[K].after < (P[K].before + P[K].after) / 2) && (V = E, N = w[K] = !0);
          }
        }), N) continue;
      }
      P.x.before && (x += P.x.before, v.x += P.x.before), P.x.after && (x -= P.x.after, v.x -= P.x.after), P.y.before && (Q += P.y.before, v.y += P.y.before), P.y.after && (Q -= P.y.after, v.y -= P.y.after);
      {
        const T = d2(v, b);
        M.x = b.width - T.x.before - T.x.after, M.y = b.height - T.y.before - T.y.after, x += T.x.before, v.x += T.x.before, Q += T.y.before, v.y += T.y.before;
      }
      break;
    }
    const L = c2(V.anchor);
    return Object.assign(n.value, {
      "--v-overlay-anchor-origin": `${V.anchor.side} ${V.anchor.align}`,
      transformOrigin: `${V.origin.side} ${V.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: se(pc(Q)),
      left: e.isRtl.value ? void 0 : se(pc(x)),
      right: e.isRtl.value ? se(pc(-x)) : void 0,
      minWidth: se(L === "y" ? Math.min(r.value, g.width) : r.value),
      maxWidth: se(E2(Ot(M.x, r.value === 1 / 0 ? 0 : r.value, o.value))),
      maxHeight: se(E2(Ot(M.y, s.value === 1 / 0 ? 0 : s.value, u.value)))
    }), {
      available: M,
      contentBox: v
    };
  }
  return ee(() => [l.value, a.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight], () => h()), He(() => {
    const g = h();
    if (!g) return;
    const {
      available: v,
      contentBox: p
    } = g;
    p.height > v.y && requestAnimationFrame(() => {
      h(), requestAnimationFrame(() => {
        h();
      });
    });
  }), {
    updateLocation: h
  };
}
function pc(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio;
}
function E2(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio;
}
let m1 = !0;
const Mo = [];
function ny(e) {
  !m1 || Mo.length ? (Mo.push(e), g1()) : (m1 = !1, e(), g1());
}
let z2 = -1;
function g1() {
  cancelAnimationFrame(z2), z2 = requestAnimationFrame(() => {
    const e = Mo.shift();
    e && e(), Mo.length ? g1() : m1 = !0;
  });
}
const ro = {
  none: null,
  close: ay,
  block: ry,
  reposition: sy
}, iy = B({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (e) => typeof e == "function" || e in ro
  }
}, "VOverlay-scroll-strategies");
function ly(e, t) {
  if (!qe) return;
  let n;
  ft(async () => {
    n == null || n.stop(), t.isActive.value && e.scrollStrategy && (n = Gd(), await new Promise((i) => setTimeout(i)), n.active && n.run(() => {
      var i;
      typeof e.scrollStrategy == "function" ? e.scrollStrategy(t, e, n) : (i = ro[e.scrollStrategy]) == null || i.call(ro, t, e, n);
    }));
  }), tn(() => {
    n == null || n.stop();
  });
}
function ay(e) {
  function t(n) {
    e.isActive.value = !1;
  }
  Ug(e.targetEl.value ?? e.contentEl.value, t);
}
function ry(e, t) {
  var r;
  const n = (r = e.root.value) == null ? void 0 : r.offsetParent, i = [.../* @__PURE__ */ new Set([...Vo(e.targetEl.value, t.contained ? n : void 0), ...Vo(e.contentEl.value, t.contained ? n : void 0)])].filter((s) => !s.classList.contains("v-overlay-scroll-blocked")), l = window.innerWidth - document.documentElement.offsetWidth, a = ((s) => mf(s) && s)(n || document.documentElement);
  a && e.root.value.classList.add("v-overlay--scroll-blocked"), i.forEach((s, o) => {
    s.style.setProperty("--v-body-scroll-x", se(-s.scrollLeft)), s.style.setProperty("--v-body-scroll-y", se(-s.scrollTop)), s !== document.documentElement && s.style.setProperty("--v-scrollbar-offset", se(l)), s.classList.add("v-overlay-scroll-blocked");
  }), tn(() => {
    i.forEach((s, o) => {
      const u = parseFloat(s.style.getPropertyValue("--v-body-scroll-x")), c = parseFloat(s.style.getPropertyValue("--v-body-scroll-y")), d = s.style.scrollBehavior;
      s.style.scrollBehavior = "auto", s.style.removeProperty("--v-body-scroll-x"), s.style.removeProperty("--v-body-scroll-y"), s.style.removeProperty("--v-scrollbar-offset"), s.classList.remove("v-overlay-scroll-blocked"), s.scrollLeft = -u, s.scrollTop = -c, s.style.scrollBehavior = d;
    }), a && e.root.value.classList.remove("v-overlay--scroll-blocked");
  });
}
function sy(e, t, n) {
  let i = !1, l = -1, a = -1;
  function r(s) {
    ny(() => {
      var c, d;
      const o = performance.now();
      (d = (c = e.updateLocation).value) == null || d.call(c, s), i = (performance.now() - o) / (1e3 / 60) > 2;
    });
  }
  a = (typeof requestIdleCallback > "u" ? (s) => s() : requestIdleCallback)(() => {
    n.run(() => {
      Ug(e.targetEl.value ?? e.contentEl.value, (s) => {
        i ? (cancelAnimationFrame(l), l = requestAnimationFrame(() => {
          l = requestAnimationFrame(() => {
            r(s);
          });
        })) : r(s);
      });
    });
  }), tn(() => {
    typeof cancelIdleCallback < "u" && cancelIdleCallback(a), cancelAnimationFrame(l);
  });
}
function Ug(e, t) {
  const n = [document, ...Vo(e)];
  n.forEach((i) => {
    i.addEventListener("scroll", t, {
      passive: !0
    });
  }), tn(() => {
    n.forEach((i) => {
      i.removeEventListener("scroll", t);
    });
  });
}
const v1 = Symbol.for("vuetify:v-menu"), yf = B({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function bf(e, t) {
  let n = () => {
  };
  function i(r) {
    n == null || n();
    const s = Number(r ? e.openDelay : e.closeDelay);
    return new Promise((o) => {
      n = E7(s, () => {
        t == null || t(r), o(r);
      });
    });
  }
  function l() {
    return i(!0);
  }
  function a() {
    return i(!1);
  }
  return {
    clearDelay: n,
    runOpenDelay: l,
    runCloseDelay: a
  };
}
const oy = B({
  target: [String, Object],
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...yf()
}, "VOverlay-activator");
function uy(e, t) {
  let {
    isActive: n,
    isTop: i,
    contentEl: l
  } = t;
  const a = mt("useActivator"), r = z();
  let s = !1, o = !1, u = !0;
  const c = C(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover), d = C(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !c.value), {
    runOpenDelay: f,
    runCloseDelay: h
  } = bf(e, (w) => {
    w === (e.openOnHover && s || c.value && o) && !(e.openOnHover && n.value && !i.value) && (n.value !== w && (u = !0), n.value = w);
  }), g = z(), v = {
    onClick: (w) => {
      w.stopPropagation(), r.value = w.currentTarget || w.target, n.value || (g.value = [w.clientX, w.clientY]), n.value = !n.value;
    },
    onMouseenter: (w) => {
      var y;
      (y = w.sourceCapabilities) != null && y.firesTouchEvents || (s = !0, r.value = w.currentTarget || w.target, f());
    },
    onMouseleave: (w) => {
      s = !1, h();
    },
    onFocus: (w) => {
      Pa(w.target, ":focus-visible") !== !1 && (o = !0, w.stopPropagation(), r.value = w.currentTarget || w.target, f());
    },
    onBlur: (w) => {
      o = !1, w.stopPropagation(), h();
    }
  }, p = C(() => {
    const w = {};
    return d.value && (w.onClick = v.onClick), e.openOnHover && (w.onMouseenter = v.onMouseenter, w.onMouseleave = v.onMouseleave), c.value && (w.onFocus = v.onFocus, w.onBlur = v.onBlur), w;
  }), O = C(() => {
    const w = {};
    if (e.openOnHover && (w.onMouseenter = () => {
      s = !0, f();
    }, w.onMouseleave = () => {
      s = !1, h();
    }), c.value && (w.onFocusin = () => {
      o = !0, f();
    }, w.onFocusout = () => {
      o = !1, h();
    }), e.closeOnContentClick) {
      const y = Be(v1, null);
      w.onClick = () => {
        n.value = !1, y == null || y.closeParents();
      };
    }
    return w;
  }), b = C(() => {
    const w = {};
    return e.openOnHover && (w.onMouseenter = () => {
      u && (s = !0, u = !1, f());
    }, w.onMouseleave = () => {
      s = !1, h();
    }), w;
  });
  ee(i, (w) => {
    var y;
    w && (e.openOnHover && !s && (!c.value || !o) || c.value && !o && (!e.openOnHover || !s)) && !((y = l.value) != null && y.contains(document.activeElement)) && (n.value = !1);
  }), ee(n, (w) => {
    w || setTimeout(() => {
      g.value = void 0;
    });
  }, {
    flush: "post"
  });
  const V = ko();
  ft(() => {
    V.value && He(() => {
      r.value = V.el;
    });
  });
  const $ = ko(), x = C(() => e.target === "cursor" && g.value ? g.value : $.value ? $.el : Gg(e.target, a) || r.value), Q = C(() => Array.isArray(x.value) ? void 0 : x.value);
  let M;
  return ee(() => !!e.activator, (w) => {
    w && qe ? (M = Gd(), M.run(() => {
      cy(e, a, {
        activatorEl: r,
        activatorEvents: p
      });
    })) : M && M.stop();
  }, {
    flush: "post",
    immediate: !0
  }), tn(() => {
    M == null || M.stop();
  }), {
    activatorEl: r,
    activatorRef: V,
    target: x,
    targetEl: Q,
    targetRef: $,
    activatorEvents: p,
    contentEvents: O,
    scrimEvents: b
  };
}
function cy(e, t, n) {
  let {
    activatorEl: i,
    activatorEvents: l
  } = n;
  ee(() => e.activator, (o, u) => {
    if (u && o !== u) {
      const c = s(u);
      c && r(c);
    }
    o && He(() => a());
  }, {
    immediate: !0
  }), ee(() => e.activatorProps, () => {
    a();
  }), tn(() => {
    r();
  });
  function a() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : s(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    o && j7(o, q(l.value, u));
  }
  function r() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : s(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    o && X7(o, q(l.value, u));
  }
  function s() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator;
    const u = Gg(o, t);
    return i.value = (u == null ? void 0 : u.nodeType) === Node.ELEMENT_NODE ? u : void 0, i.value;
  }
}
function Gg(e, t) {
  var i, l;
  if (!e) return;
  let n;
  if (e === "parent") {
    let a = (l = (i = t == null ? void 0 : t.proxy) == null ? void 0 : i.$el) == null ? void 0 : l.parentNode;
    for (; a != null && a.hasAttribute("data-no-activator"); )
      a = a.parentNode;
    n = a;
  } else typeof e == "string" ? n = document.querySelector(e) : "$el" in e ? n = e.$el : n = e;
  return n;
}
function Cf(e) {
  return sf(() => {
    const t = [], n = {};
    if (e.value.background)
      if (r1(e.value.background)) {
        if (n.backgroundColor = e.value.background, !e.value.text && ap(e.value.background)) {
          const i = Mn(e.value.background);
          if (i.a == null || i.a === 1) {
            const l = hg(i);
            n.color = l, n.caretColor = l;
          }
        }
      } else
        t.push(`bg-${e.value.background}`);
    return e.value.text && (r1(e.value.text) ? (n.color = e.value.text, n.caretColor = e.value.text) : t.push(`text-${e.value.text}`)), {
      colorClasses: t,
      colorStyles: n
    };
  });
}
function Yt(e, t) {
  const n = C(() => ({
    text: xa(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: i,
    colorStyles: l
  } = Cf(n);
  return {
    textColorClasses: i,
    textColorStyles: l
  };
}
function Fe(e, t) {
  const n = C(() => ({
    background: xa(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: i,
    colorStyles: l
  } = Cf(n);
  return {
    backgroundColorClasses: i,
    backgroundColorStyles: l
  };
}
const wt = B({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function kt(e) {
  return {
    dimensionStyles: C(() => {
      const n = {}, i = se(e.height), l = se(e.maxHeight), a = se(e.maxWidth), r = se(e.minHeight), s = se(e.minWidth), o = se(e.width);
      return i != null && (n.height = i), l != null && (n.maxHeight = l), a != null && (n.maxWidth = a), r != null && (n.minHeight = r), s != null && (n.minWidth = s), o != null && (n.width = o), n;
    })
  };
}
function Kg() {
  if (!qe) return ie(!1);
  const {
    ssr: e
  } = Dn();
  if (e) {
    const t = ie(!1);
    return it(() => {
      t.value = !0;
    }), t;
  } else
    return ie(!0);
}
const Sf = B({
  eager: Boolean
}, "lazy");
function wf(e, t) {
  const n = ie(!1), i = C(() => n.value || e.eager || t.value);
  ee(t, () => n.value = !0);
  function l() {
    e.eager || (n.value = !1);
  }
  return {
    isBooted: n,
    hasContent: i,
    onAfterLeave: l
  };
}
function dy() {
  const e = mt("useRoute");
  return C(() => {
    var t;
    return (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$route;
  });
}
function Jg() {
  var e, t;
  return (t = (e = mt("useRouter")) == null ? void 0 : e.proxy) == null ? void 0 : t.$router;
}
function rs(e, t) {
  var u, c;
  const n = j9("RouterLink"), i = C(() => !!(e.href || e.to)), l = C(() => (i == null ? void 0 : i.value) || o2(t, "click") || o2(e, "click"));
  if (typeof n == "string" || !("useLink" in n))
    return {
      isLink: i,
      isClickable: l,
      href: H(e, "href")
    };
  const a = C(() => ({
    ...e,
    to: H(() => e.to || "")
  })), r = n.useLink(a.value), s = C(() => e.to ? r : void 0), o = dy();
  return {
    isLink: i,
    isClickable: l,
    route: (u = s.value) == null ? void 0 : u.route,
    navigate: (c = s.value) == null ? void 0 : c.navigate,
    isActive: C(() => {
      var d, f, h;
      return s.value ? e.exact ? o.value ? ((h = s.value.isExactActive) == null ? void 0 : h.value) && vi(s.value.route.value.query, o.value.query) : ((f = s.value.isExactActive) == null ? void 0 : f.value) ?? !1 : ((d = s.value.isActive) == null ? void 0 : d.value) ?? !1 : !1;
    }),
    href: C(() => {
      var d;
      return e.to ? (d = s.value) == null ? void 0 : d.route.value.href : e.href;
    })
  };
}
const ss = B({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let Oc = !1;
function fy(e, t) {
  let n = !1, i, l;
  qe && (He(() => {
    window.addEventListener("popstate", a), i = e == null ? void 0 : e.beforeEach((r, s, o) => {
      Oc ? n ? t(o) : o() : setTimeout(() => n ? t(o) : o()), Oc = !0;
    }), l = e == null ? void 0 : e.afterEach(() => {
      Oc = !1;
    });
  }), tn(() => {
    window.removeEventListener("popstate", a), i == null || i(), l == null || l();
  }));
  function a(r) {
    var s;
    (s = r.state) != null && s.replaced || (n = !0, setTimeout(() => n = !1));
  }
}
function Wl() {
  const t = mt("useScopeId").vnode.scopeId;
  return {
    scopeId: t ? {
      [t]: ""
    } : void 0
  };
}
const H2 = Symbol.for("vuetify:stack"), ir = Xt([]);
function hy(e, t, n) {
  const i = mt("useStack"), l = !n, a = Be(H2, void 0), r = Xt({
    activeChildren: /* @__PURE__ */ new Set()
  });
  lt(H2, r);
  const s = ie(+t.value);
  un(e, () => {
    var d;
    const c = (d = ir.at(-1)) == null ? void 0 : d[1];
    s.value = c ? c + 10 : +t.value, l && ir.push([i.uid, s.value]), a == null || a.activeChildren.add(i.uid), tn(() => {
      if (l) {
        const f = nt(ir).findIndex((h) => h[0] === i.uid);
        ir.splice(f, 1);
      }
      a == null || a.activeChildren.delete(i.uid);
    });
  });
  const o = ie(!0);
  l && ft(() => {
    var d;
    const c = ((d = ir.at(-1)) == null ? void 0 : d[0]) === i.uid;
    setTimeout(() => o.value = c);
  });
  const u = C(() => !r.activeChildren.size);
  return {
    globalTop: Kd(o),
    localTop: u,
    stackStyles: C(() => ({
      zIndex: s.value
    }))
  };
}
function my(e) {
  return {
    teleportTarget: C(() => {
      const n = e();
      if (n === !0 || !qe) return;
      const i = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n;
      if (i == null) {
        du(`Unable to locate target ${n}`);
        return;
      }
      let l = [...i.children].find((a) => a.matches(".v-overlay-container"));
      return l || (l = document.createElement("div"), l.className = "v-overlay-container", i.appendChild(l)), l;
    })
  };
}
const Gn = B({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (e) => e !== !0
  }
}, "transition"), en = (e, t) => {
  let {
    slots: n
  } = t;
  const {
    transition: i,
    disabled: l,
    group: a,
    ...r
  } = e, {
    component: s = a ? Jd : Ui,
    ...o
  } = typeof i == "object" ? i : {};
  return A(s, q(typeof i == "string" ? {
    name: l ? "" : i
  } : o, typeof i == "string" ? {} : Object.fromEntries(Object.entries({
    disabled: l,
    group: a
  }).filter((u) => {
    let [c, d] = u;
    return d !== void 0;
  })), r), n);
};
function gy(e) {
  const {
    modelValue: t,
    color: n,
    ...i
  } = e;
  return m(Ui, {
    name: "fade-transition",
    appear: !0
  }, {
    default: () => [e.modelValue && m("div", q({
      class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
      style: e.color.backgroundColorStyles.value
    }, i), null)]
  });
}
const os = B({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: !0
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  opacity: [Number, String],
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...oy(),
  ...ue(),
  ...wt(),
  ...Sf(),
  ...GO(),
  ...iy(),
  ...Ie(),
  ...Gn()
}, "VOverlay"), Fn = X()({
  name: "VOverlay",
  directives: {
    ClickOutside: Zg
  },
  inheritAttrs: !1,
  props: {
    _disableGlobalStack: Boolean,
    ...os()
  },
  emits: {
    "click:outside": (e) => !0,
    "update:modelValue": (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: i,
      emit: l
    } = t;
    const a = mt("VOverlay"), r = z(), s = z(), o = z(), u = pe(e, "modelValue"), c = C({
      get: () => u.value,
      set: (U) => {
        U && e.disabled || (u.value = U);
      }
    }), {
      themeClasses: d
    } = Xe(e), {
      rtlClasses: f,
      isRtl: h
    } = Qt(), {
      hasContent: g,
      onAfterLeave: v
    } = wf(e, c), p = Fe(C(() => typeof e.scrim == "string" ? e.scrim : null)), {
      globalTop: O,
      localTop: b,
      stackStyles: V
    } = hy(c, H(e, "zIndex"), e._disableGlobalStack), {
      activatorEl: $,
      activatorRef: x,
      target: Q,
      targetEl: M,
      targetRef: w,
      activatorEvents: y,
      contentEvents: L,
      scrimEvents: k
    } = uy(e, {
      isActive: c,
      isTop: b,
      contentEl: o
    }), {
      teleportTarget: S
    } = my(() => {
      var be, De, Ye;
      const U = e.attach || e.contained;
      if (U) return U;
      const ge = ((be = $ == null ? void 0 : $.value) == null ? void 0 : be.getRootNode()) || ((Ye = (De = a.proxy) == null ? void 0 : De.$el) == null ? void 0 : Ye.getRootNode());
      return ge instanceof ShadowRoot ? ge : !1;
    }), {
      dimensionStyles: P
    } = kt(e), T = Kg(), {
      scopeId: _
    } = Wl();
    ee(() => e.disabled, (U) => {
      U && (c.value = !1);
    });
    const {
      contentStyles: D,
      updateLocation: N
    } = KO(e, {
      isRtl: h,
      contentEl: o,
      target: Q,
      isActive: c
    });
    ly(e, {
      root: r,
      contentEl: o,
      targetEl: M,
      isActive: c,
      updateLocation: N
    });
    function K(U) {
      l("click:outside", U), e.persistent ? ce() : c.value = !1;
    }
    function E(U) {
      return c.value && O.value && // If using scrim, only close if clicking on it rather than anything opened on top
      (!e.scrim || U.target === s.value || U instanceof MouseEvent && U.shadowTarget === s.value);
    }
    qe && ee(c, (U) => {
      U ? window.addEventListener("keydown", I) : window.removeEventListener("keydown", I);
    }, {
      immediate: !0
    }), Wt(() => {
      qe && window.removeEventListener("keydown", I);
    });
    function I(U) {
      var ge, be;
      U.key === "Escape" && O.value && (e.persistent ? ce() : (c.value = !1, (ge = o.value) != null && ge.contains(document.activeElement) && ((be = $.value) == null || be.focus())));
    }
    const Z = Jg();
    un(() => e.closeOnBack, () => {
      fy(Z, (U) => {
        O.value && c.value ? (U(!1), e.persistent ? ce() : c.value = !1) : U();
      });
    });
    const Y = z();
    ee(() => c.value && (e.absolute || e.contained) && S.value == null, (U) => {
      if (U) {
        const ge = hf(r.value);
        ge && ge !== document.scrollingElement && (Y.value = ge.scrollTop);
      }
    });
    function ce() {
      e.noClickAnimation || o.value && Cl(o.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: Vr
      });
    }
    function de() {
      l("afterEnter");
    }
    function ye() {
      v(), l("afterLeave");
    }
    return F(() => {
      var U;
      return m(le, null, [(U = n.activator) == null ? void 0 : U.call(n, {
        isActive: c.value,
        targetRef: w,
        props: q({
          ref: x
        }, y.value, e.activatorProps)
      }), T.value && g.value && m(fu, {
        disabled: !S.value,
        to: S.value
      }, {
        default: () => [m("div", q({
          class: ["v-overlay", {
            "v-overlay--absolute": e.absolute || e.contained,
            "v-overlay--active": c.value,
            "v-overlay--contained": e.contained
          }, d.value, f.value, e.class],
          style: [V.value, {
            "--v-overlay-opacity": e.opacity,
            top: se(Y.value)
          }, e.style],
          ref: r
        }, _, i), [m(gy, q({
          color: p,
          modelValue: c.value && !!e.scrim,
          ref: s
        }, k.value), null), m(en, {
          appear: !0,
          persisted: !0,
          transition: e.transition,
          target: Q.value,
          onAfterEnter: de,
          onAfterLeave: ye
        }, {
          default: () => {
            var ge;
            return [Je(m("div", q({
              ref: o,
              class: ["v-overlay__content", e.contentClass],
              style: [P.value, D.value]
            }, L.value, e.contentProps), [(ge = n.default) == null ? void 0 : ge.call(n, {
              isActive: c
            })]), [[xn, c.value], [Pn("click-outside"), {
              handler: K,
              closeConditional: E,
              include: () => [$.value]
            }]])];
          }
        })])]
      })]);
    }), {
      activatorEl: $,
      scrimEl: s,
      target: Q,
      animateClick: ce,
      contentEl: o,
      globalTop: O,
      localTop: b,
      updateLocation: N
    };
  }
}), yc = Symbol("Forwarded refs");
function bc(e, t) {
  let n = e;
  for (; n; ) {
    const i = Reflect.getOwnPropertyDescriptor(n, t);
    if (i) return i;
    n = Object.getPrototypeOf(n);
  }
}
function Bn(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return e[yc] = n, new Proxy(e, {
    get(l, a) {
      if (Reflect.has(l, a))
        return Reflect.get(l, a);
      if (!(typeof a == "symbol" || a.startsWith("$") || a.startsWith("__"))) {
        for (const r of n)
          if (r.value && Reflect.has(r.value, a)) {
            const s = Reflect.get(r.value, a);
            return typeof s == "function" ? s.bind(r.value) : s;
          }
      }
    },
    has(l, a) {
      if (Reflect.has(l, a))
        return !0;
      if (typeof a == "symbol" || a.startsWith("$") || a.startsWith("__")) return !1;
      for (const r of n)
        if (r.value && Reflect.has(r.value, a))
          return !0;
      return !1;
    },
    set(l, a, r) {
      if (Reflect.has(l, a))
        return Reflect.set(l, a, r);
      if (typeof a == "symbol" || a.startsWith("$") || a.startsWith("__")) return !1;
      for (const s of n)
        if (s.value && Reflect.has(s.value, a))
          return Reflect.set(s.value, a, r);
      return !1;
    },
    getOwnPropertyDescriptor(l, a) {
      var s;
      const r = Reflect.getOwnPropertyDescriptor(l, a);
      if (r) return r;
      if (!(typeof a == "symbol" || a.startsWith("$") || a.startsWith("__"))) {
        for (const o of n) {
          if (!o.value) continue;
          const u = bc(o.value, a) ?? ("_" in o.value ? bc((s = o.value._) == null ? void 0 : s.setupState, a) : void 0);
          if (u) return u;
        }
        for (const o of n) {
          const u = o.value && o.value[yc];
          if (!u) continue;
          const c = u.slice();
          for (; c.length; ) {
            const d = c.shift(), f = bc(d.value, a);
            if (f) return f;
            const h = d.value && d.value[yc];
            h && c.push(...h);
          }
        }
      }
    }
  });
}
const vy = B({
  id: String,
  text: String,
  ...St(os({
    closeOnBack: !1,
    location: "end",
    locationStrategy: "connected",
    eager: !0,
    minWidth: 0,
    offset: 10,
    openOnClick: !1,
    openOnHover: !0,
    origin: "auto",
    scrim: !1,
    scrollStrategy: "reposition",
    transition: !1
  }), ["absolute", "persistent"])
}, "VTooltip"), e4 = X()({
  name: "VTooltip",
  props: vy(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), {
      scopeId: l
    } = Wl(), a = Bt(), r = C(() => e.id || `v-tooltip-${a}`), s = z(), o = C(() => e.location.split(" ").length > 1 ? e.location : e.location + " center"), u = C(() => e.origin === "auto" || e.origin === "overlap" || e.origin.split(" ").length > 1 || e.location.split(" ").length > 1 ? e.origin : e.origin + " center"), c = C(() => e.transition ? e.transition : i.value ? "scale-transition" : "fade-transition"), d = C(() => q({
      "aria-describedby": r.value
    }, e.activatorProps));
    return F(() => {
      const f = Fn.filterProps(e);
      return m(Fn, q({
        ref: s,
        class: ["v-tooltip", e.class],
        style: e.style,
        id: r.value
      }, f, {
        modelValue: i.value,
        "onUpdate:modelValue": (h) => i.value = h,
        transition: c.value,
        absolute: !0,
        location: o.value,
        origin: u.value,
        persistent: !0,
        role: "tooltip",
        activatorProps: d.value,
        _disableGlobalStack: !0
      }, l), {
        activator: n.activator,
        default: function() {
          var p;
          for (var h = arguments.length, g = new Array(h), v = 0; v < h; v++)
            g[v] = arguments[v];
          return ((p = n.default) == null ? void 0 : p.call(n, ...g)) ?? e.text;
        }
      });
    }), Bn({}, s);
  }
});
function py(e, t) {
  const n = typeof e == "string" ? ae(e) : e, i = Oy(n, t);
  return {
    mounted: i,
    updated: i,
    unmounted(l) {
      X9(null, l);
    }
  };
}
function Oy(e, t) {
  return function(n, i, l) {
    var d, f, h;
    const a = typeof t == "function" ? t(i) : t, r = ((d = i.value) == null ? void 0 : d.text) ?? i.value ?? (a == null ? void 0 : a.text), s = lf(i.value) ? i.value : {}, o = () => r ?? n.innerHTML, u = (l.ctx === i.instance.$ ? (f = yy(l, i.instance.$)) == null ? void 0 : f.provides : (h = l.ctx) == null ? void 0 : h.provides) ?? i.instance.$.provides, c = A(e, q(a, s), o);
    c.appContext = Object.assign(/* @__PURE__ */ Object.create(null), i.instance.$.appContext, {
      provides: u
    }), X9(c, n);
  };
}
function yy(e, t) {
  const n = /* @__PURE__ */ new Set(), i = (a) => {
    var r, s;
    for (const o of a) {
      if (!o) continue;
      if (o === e)
        return !0;
      n.add(o);
      let u;
      if (o.suspense ? u = i([o.ssContent]) : Array.isArray(o.children) ? u = i(o.children) : (r = o.component) != null && r.vnode && (u = i([(s = o.component) == null ? void 0 : s.subTree])), u)
        return u;
      n.delete(o);
    }
    return !1;
  };
  if (!i([t.subTree]))
    throw new Error("Could not find original vnode");
  const l = Array.from(n).reverse();
  for (const a of l)
    if (a.component)
      return a.component;
  return t;
}
const by = py(e4, (e) => {
  var t;
  return {
    activator: "parent",
    location: ((t = e.arg) == null ? void 0 : t.replace("-", " ")) ?? "top",
    text: typeof e.value == "boolean" ? void 0 : e.value
  };
}), Cy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClickOutside: Zg,
  Intersect: as,
  Mutate: TO,
  Resize: RO,
  Ripple: Ti,
  Scroll: HO,
  Tooltip: by,
  Touch: Of
}, Symbol.toStringTag, { value: "Module" })), Sy = B({
  ...ue(),
  ...Lg({
    fullHeight: !0
  }),
  ...Ie()
}, "VApp"), wy = X()({
  name: "VApp",
  props: Sy(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Xe(e), {
      layoutClasses: l,
      getLayoutItem: a,
      items: r,
      layoutRef: s
    } = Tg(e), {
      rtlClasses: o
    } = Qt();
    return F(() => {
      var u;
      return m("div", {
        ref: s,
        class: ["v-application", i.themeClasses.value, l.value, o.value, e.class],
        style: [e.style]
      }, [m("div", {
        class: "v-application__wrap"
      }, [(u = n.default) == null ? void 0 : u.call(n)])]);
    }), {
      getLayoutItem: a,
      items: r,
      theme: i
    };
  }
}), Ve = B({
  tag: {
    type: String,
    default: "div"
  }
}, "tag"), t4 = B({
  text: String,
  ...ue(),
  ...Ve()
}, "VToolbarTitle"), kf = X()({
  name: "VToolbarTitle",
  props: t4(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => {
      const i = !!(n.default || n.text || e.text);
      return m(e.tag, {
        class: ["v-toolbar-title", e.class],
        style: e.style
      }, {
        default: () => {
          var l;
          return [i && m("div", {
            class: "v-toolbar-title__placeholder"
          }, [n.text ? n.text() : e.text, (l = n.default) == null ? void 0 : l.call(n)])];
        }
      });
    }), {};
  }
}), ky = B({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function Vn(e, t, n) {
  return X()({
    name: e,
    props: ky({
      mode: n,
      origin: t
    }),
    setup(i, l) {
      let {
        slots: a
      } = l;
      const r = {
        onBeforeEnter(s) {
          i.origin && (s.style.transformOrigin = i.origin);
        },
        onLeave(s) {
          if (i.leaveAbsolute) {
            const {
              offsetTop: o,
              offsetLeft: u,
              offsetWidth: c,
              offsetHeight: d
            } = s;
            s._transitionInitialStyles = {
              position: s.style.position,
              top: s.style.top,
              left: s.style.left,
              width: s.style.width,
              height: s.style.height
            }, s.style.position = "absolute", s.style.top = `${o}px`, s.style.left = `${u}px`, s.style.width = `${c}px`, s.style.height = `${d}px`;
          }
          i.hideOnLeave && s.style.setProperty("display", "none", "important");
        },
        onAfterLeave(s) {
          if (i.leaveAbsolute && (s != null && s._transitionInitialStyles)) {
            const {
              position: o,
              top: u,
              left: c,
              width: d,
              height: f
            } = s._transitionInitialStyles;
            delete s._transitionInitialStyles, s.style.position = o || "", s.style.top = u || "", s.style.left = c || "", s.style.width = d || "", s.style.height = f || "";
          }
        }
      };
      return () => {
        const s = i.group ? Jd : Ui;
        return A(s, {
          name: i.disabled ? "" : e,
          css: !i.disabled,
          ...i.group ? void 0 : {
            mode: i.mode
          },
          ...i.disabled ? {} : r
        }, a.default);
      };
    }
  });
}
function n4(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return X()({
    name: e,
    props: {
      mode: {
        type: String,
        default: n
      },
      disabled: Boolean,
      group: Boolean
    },
    setup(i, l) {
      let {
        slots: a
      } = l;
      const r = i.group ? Jd : Ui;
      return () => A(r, {
        name: i.disabled ? "" : e,
        css: !i.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...i.disabled ? {} : t
      }, a.default);
    }
  });
}
function i4() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", i = z9(`offset-${n}`);
  return {
    onBeforeEnter(r) {
      r._parent = r.parentNode, r._initialStyle = {
        transition: r.style.transition,
        overflow: r.style.overflow,
        [n]: r.style[n]
      };
    },
    onEnter(r) {
      const s = r._initialStyle;
      r.style.setProperty("transition", "none", "important"), r.style.overflow = "hidden";
      const o = `${r[i]}px`;
      r.style[n] = "0", r.offsetHeight, r.style.transition = s.transition, e && r._parent && r._parent.classList.add(e), requestAnimationFrame(() => {
        r.style[n] = o;
      });
    },
    onAfterEnter: a,
    onEnterCancelled: a,
    onLeave(r) {
      r._initialStyle = {
        transition: "",
        overflow: r.style.overflow,
        [n]: r.style[n]
      }, r.style.overflow = "hidden", r.style[n] = `${r[i]}px`, r.offsetHeight, requestAnimationFrame(() => r.style[n] = "0");
    },
    onAfterLeave: l,
    onLeaveCancelled: l
  };
  function l(r) {
    e && r._parent && r._parent.classList.remove(e), a(r);
  }
  function a(r) {
    const s = r._initialStyle[n];
    r.style.overflow = r._initialStyle.overflow, s != null && (r.style[n] = s), delete r._initialStyle;
  }
}
const xy = B({
  target: [Object, Array]
}, "v-dialog-transition"), bu = X()({
  name: "VDialogTransition",
  props: xy(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = {
      onBeforeEnter(l) {
        l.style.pointerEvents = "none", l.style.visibility = "hidden";
      },
      async onEnter(l, a) {
        var f;
        await new Promise((h) => requestAnimationFrame(h)), await new Promise((h) => requestAnimationFrame(h)), l.style.visibility = "";
        const {
          x: r,
          y: s,
          sx: o,
          sy: u,
          speed: c
        } = X2(e.target, l), d = Cl(l, [{
          transform: `translate(${r}px, ${s}px) scale(${o}, ${u})`,
          opacity: 0
        }, {}], {
          duration: 225 * c,
          easing: vp
        });
        (f = j2(l)) == null || f.forEach((h) => {
          Cl(h, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * c,
            easing: Vr
          });
        }), d.finished.then(() => a());
      },
      onAfterEnter(l) {
        l.style.removeProperty("pointer-events");
      },
      onBeforeLeave(l) {
        l.style.pointerEvents = "none";
      },
      async onLeave(l, a) {
        var f;
        await new Promise((h) => requestAnimationFrame(h));
        const {
          x: r,
          y: s,
          sx: o,
          sy: u,
          speed: c
        } = X2(e.target, l);
        Cl(l, [{}, {
          transform: `translate(${r}px, ${s}px) scale(${o}, ${u})`,
          opacity: 0
        }], {
          duration: 125 * c,
          easing: pp
        }).finished.then(() => a()), (f = j2(l)) == null || f.forEach((h) => {
          Cl(h, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * c,
            easing: Vr
          });
        });
      },
      onAfterLeave(l) {
        l.style.removeProperty("pointer-events");
      }
    };
    return () => e.target ? m(Ui, q({
      name: "dialog-transition"
    }, i, {
      css: !1
    }), n) : m(Ui, {
      name: "dialog-transition"
    }, n);
  }
});
function j2(e) {
  var n;
  const t = (n = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : n.children;
  return t && [...t];
}
function X2(e, t) {
  const n = ng(e), i = uf(t), [l, a] = getComputedStyle(t).transformOrigin.split(" ").map((O) => parseFloat(O)), [r, s] = getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let o = n.left + n.width / 2;
  r === "left" || s === "left" ? o -= n.width / 2 : (r === "right" || s === "right") && (o += n.width / 2);
  let u = n.top + n.height / 2;
  r === "top" || s === "top" ? u -= n.height / 2 : (r === "bottom" || s === "bottom") && (u += n.height / 2);
  const c = n.width / i.width, d = n.height / i.height, f = Math.max(1, c, d), h = c / f || 0, g = d / f || 0, v = i.width * i.height / (window.innerWidth * window.innerHeight), p = v > 0.12 ? Math.min(1.5, (v - 0.12) * 10 + 1) : 1;
  return {
    x: o - (l + i.left),
    y: u - (a + i.top),
    sx: h,
    sy: g,
    speed: p
  };
}
const Py = Vn("fab-transition", "center center", "out-in"), $y = Vn("dialog-bottom-transition"), Vy = Vn("dialog-top-transition"), _r = Vn("fade-transition"), xf = Vn("scale-transition"), Qy = Vn("scroll-x-transition"), Ly = Vn("scroll-x-reverse-transition"), My = Vn("scroll-y-transition"), Ty = Vn("scroll-y-reverse-transition"), _y = Vn("slide-x-transition"), Ay = Vn("slide-x-reverse-transition"), Pf = Vn("slide-y-transition"), Ry = Vn("slide-y-reverse-transition"), Cu = n4("expand-transition", i4()), $f = n4("expand-x-transition", i4("", !0)), Zy = B({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider"), Te = X(!1)({
  name: "VDefaultsProvider",
  props: Zy(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      defaults: i,
      disabled: l,
      reset: a,
      root: r,
      scoped: s
    } = Nl(e);
    return ht(i, {
      reset: a,
      root: r,
      scoped: s,
      disabled: l
    }), () => {
      var o;
      return (o = n.default) == null ? void 0 : o.call(n);
    };
  }
});
function Iy(e) {
  return {
    aspectStyles: C(() => {
      const t = Number(e.aspectRatio);
      return t ? {
        paddingBottom: String(1 / t * 100) + "%"
      } : void 0;
    })
  };
}
const l4 = B({
  aspectRatio: [String, Number],
  contentClass: null,
  inline: Boolean,
  ...ue(),
  ...wt()
}, "VResponsive"), p1 = X()({
  name: "VResponsive",
  props: l4(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      aspectStyles: i
    } = Iy(e), {
      dimensionStyles: l
    } = kt(e);
    return F(() => {
      var a;
      return m("div", {
        class: ["v-responsive", {
          "v-responsive--inline": e.inline
        }, e.class],
        style: [l.value, e.style]
      }, [m("div", {
        class: "v-responsive__sizer",
        style: i.value
      }, null), (a = n.additional) == null ? void 0 : a.call(n), n.default && m("div", {
        class: ["v-responsive__content", e.contentClass]
      }, [n.default()])]);
    }), {};
  }
}), at = B({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  },
  tile: Boolean
}, "rounded");
function gt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  return {
    roundedClasses: C(() => {
      const i = xa(e) ? e.value : e.rounded, l = xa(e) ? e.value : e.tile, a = [];
      if (i === !0 || i === "")
        a.push(`${t}--rounded`);
      else if (typeof i == "string" || i === 0)
        for (const r of String(i).split(" "))
          a.push(`rounded-${r}`);
      else (l || i === !1) && a.push("rounded-0");
      return a;
    })
  };
}
const a4 = B({
  absolute: Boolean,
  alt: String,
  cover: Boolean,
  color: String,
  draggable: {
    type: [Boolean, String],
    default: void 0
  },
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  crossorigin: String,
  referrerpolicy: String,
  srcset: String,
  position: String,
  ...l4(),
  ...ue(),
  ...at(),
  ...Gn()
}, "VImg"), $i = X()({
  name: "VImg",
  directives: {
    intersect: as
  },
  props: a4(),
  emits: {
    loadstart: (e) => !0,
    load: (e) => !0,
    error: (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      backgroundColorClasses: l,
      backgroundColorStyles: a
    } = Fe(H(e, "color")), {
      roundedClasses: r
    } = gt(e), s = mt("VImg"), o = ie(""), u = z(), c = ie(e.eager ? "loading" : "idle"), d = ie(), f = ie(), h = C(() => e.src && typeof e.src == "object" ? {
      src: e.src.src,
      srcset: e.srcset || e.src.srcset,
      lazySrc: e.lazySrc || e.src.lazySrc,
      aspect: Number(e.aspectRatio || e.src.aspect || 0)
    } : {
      src: e.src,
      srcset: e.srcset,
      lazySrc: e.lazySrc,
      aspect: Number(e.aspectRatio || 0)
    }), g = C(() => h.value.aspect || d.value / f.value || 0);
    ee(() => e.src, () => {
      v(c.value !== "idle");
    }), ee(g, (S, P) => {
      !S && P && u.value && $(u.value);
    }), N9(() => v());
    function v(S) {
      if (!(e.eager && S) && !(nf && !S && !e.eager)) {
        if (c.value = "loading", h.value.lazySrc) {
          const P = new Image();
          P.src = h.value.lazySrc, $(P, null);
        }
        h.value.src && He(() => {
          var P;
          n("loadstart", ((P = u.value) == null ? void 0 : P.currentSrc) || h.value.src), setTimeout(() => {
            var T;
            if (!s.isUnmounted)
              if ((T = u.value) != null && T.complete) {
                if (u.value.naturalWidth || O(), c.value === "error") return;
                g.value || $(u.value, null), c.value === "loading" && p();
              } else
                g.value || $(u.value), b();
          });
        });
      }
    }
    function p() {
      var S;
      s.isUnmounted || (b(), $(u.value), c.value = "loaded", n("load", ((S = u.value) == null ? void 0 : S.currentSrc) || h.value.src));
    }
    function O() {
      var S;
      s.isUnmounted || (c.value = "error", n("error", ((S = u.value) == null ? void 0 : S.currentSrc) || h.value.src));
    }
    function b() {
      const S = u.value;
      S && (o.value = S.currentSrc || S.src);
    }
    let V = -1;
    Wt(() => {
      clearTimeout(V);
    });
    function $(S) {
      let P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const T = () => {
        if (clearTimeout(V), s.isUnmounted) return;
        const {
          naturalHeight: _,
          naturalWidth: D
        } = S;
        _ || D ? (d.value = D, f.value = _) : !S.complete && c.value === "loading" && P != null ? V = window.setTimeout(T, P) : (S.currentSrc.endsWith(".svg") || S.currentSrc.startsWith("data:image/svg+xml")) && (d.value = 1, f.value = 1);
      };
      T();
    }
    const x = C(() => ({
      "v-img__img--cover": e.cover,
      "v-img__img--contain": !e.cover
    })), Q = () => {
      var T;
      if (!h.value.src || c.value === "idle") return null;
      const S = m("img", {
        class: ["v-img__img", x.value],
        style: {
          objectPosition: e.position
        },
        src: h.value.src,
        srcset: h.value.srcset,
        alt: e.alt,
        crossorigin: e.crossorigin,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable,
        sizes: e.sizes,
        ref: u,
        onLoad: p,
        onError: O
      }, null), P = (T = i.sources) == null ? void 0 : T.call(i);
      return m(en, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => [Je(P ? m("picture", {
          class: "v-img__picture"
        }, [P, S]) : S, [[xn, c.value === "loaded"]])]
      });
    }, M = () => m(en, {
      transition: e.transition
    }, {
      default: () => [h.value.lazySrc && c.value !== "loaded" && m("img", {
        class: ["v-img__img", "v-img__img--preload", x.value],
        style: {
          objectPosition: e.position
        },
        src: h.value.lazySrc,
        alt: e.alt,
        crossorigin: e.crossorigin,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable
      }, null)]
    }), w = () => i.placeholder ? m(en, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [(c.value === "loading" || c.value === "error" && !i.error) && m("div", {
        class: "v-img__placeholder"
      }, [i.placeholder()])]
    }) : null, y = () => i.error ? m(en, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [c.value === "error" && m("div", {
        class: "v-img__error"
      }, [i.error()])]
    }) : null, L = () => e.gradient ? m("div", {
      class: "v-img__gradient",
      style: {
        backgroundImage: `linear-gradient(${e.gradient})`
      }
    }, null) : null, k = ie(!1);
    {
      const S = ee(g, (P) => {
        P && (requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            k.value = !0;
          });
        }), S());
      });
    }
    return F(() => {
      const S = p1.filterProps(e);
      return Je(m(p1, q({
        class: ["v-img", {
          "v-img--absolute": e.absolute,
          "v-img--booting": !k.value
        }, l.value, r.value, e.class],
        style: [{
          width: se(e.width === "auto" ? d.value : e.width)
        }, a.value, e.style]
      }, S, {
        aspectRatio: g.value,
        "aria-label": e.alt,
        role: e.alt ? "img" : void 0
      }), {
        additional: () => m(le, null, [m(Q, null, null), m(M, null, null), m(L, null, null), m(w, null, null), m(y, null, null)]),
        default: i.default
      }), [[Pn("intersect"), {
        handler: v,
        options: e.options
      }, null, {
        once: !0
      }]]);
    }), {
      currentSrc: o,
      image: u,
      state: c,
      naturalWidth: d,
      naturalHeight: f
    };
  }
}), yn = B({
  border: [Boolean, Number, String]
}, "border");
function Qn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  return {
    borderClasses: C(() => {
      const i = xa(e) ? e.value : e.border, l = [];
      if (i === !0 || i === "")
        l.push(`${t}--border`);
      else if (typeof i == "string" || i === 0)
        for (const a of String(i).split(" "))
          l.push(`border-${a}`);
      return l;
    })
  };
}
const Lt = B({
  elevation: {
    type: [Number, String],
    validator(e) {
      const t = parseInt(e);
      return !isNaN(t) && t >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      t <= 24;
    }
  }
}, "elevation");
function Et(e) {
  return {
    elevationClasses: C(() => {
      const n = xa(e) ? e.value : e.elevation, i = [];
      return n == null || i.push(`elevation-${n}`), i;
    })
  };
}
const Dy = [null, "prominent", "default", "comfortable", "compact"], r4 = B({
  absolute: Boolean,
  collapse: Boolean,
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (e) => Dy.includes(e)
  },
  extended: Boolean,
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...yn(),
  ...ue(),
  ...Lt(),
  ...at(),
  ...Ve({
    tag: "header"
  }),
  ...Ie()
}, "VToolbar"), O1 = X()({
  name: "VToolbar",
  props: r4(),
  setup(e, t) {
    var h;
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = Fe(H(e, "color")), {
      borderClasses: a
    } = Qn(e), {
      elevationClasses: r
    } = Et(e), {
      roundedClasses: s
    } = gt(e), {
      themeClasses: o
    } = Xe(e), {
      rtlClasses: u
    } = Qt(), c = ie(!!(e.extended || (h = n.extension) != null && h.call(n))), d = C(() => parseInt(Number(e.height) + (e.density === "prominent" ? Number(e.height) : 0) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0), 10)), f = C(() => c.value ? parseInt(Number(e.extensionHeight) + (e.density === "prominent" ? Number(e.extensionHeight) : 0) - (e.density === "comfortable" ? 4 : 0) - (e.density === "compact" ? 8 : 0), 10) : 0);
    return ht({
      VBtn: {
        variant: "text"
      }
    }), F(() => {
      var O;
      const g = !!(e.title || n.title), v = !!(n.image || e.image), p = (O = n.extension) == null ? void 0 : O.call(n);
      return c.value = !!(e.extended || p), m(e.tag, {
        class: ["v-toolbar", {
          "v-toolbar--absolute": e.absolute,
          "v-toolbar--collapse": e.collapse,
          "v-toolbar--flat": e.flat,
          "v-toolbar--floating": e.floating,
          [`v-toolbar--density-${e.density}`]: !0
        }, i.value, a.value, r.value, s.value, o.value, u.value, e.class],
        style: [l.value, e.style]
      }, {
        default: () => [v && m("div", {
          key: "image",
          class: "v-toolbar__image"
        }, [n.image ? m(Te, {
          key: "image-defaults",
          disabled: !e.image,
          defaults: {
            VImg: {
              cover: !0,
              src: e.image
            }
          }
        }, n.image) : m($i, {
          key: "image-img",
          cover: !0,
          src: e.image
        }, null)]), m(Te, {
          defaults: {
            VTabs: {
              height: se(d.value)
            }
          }
        }, {
          default: () => {
            var b, V, $;
            return [m("div", {
              class: "v-toolbar__content",
              style: {
                height: se(d.value)
              }
            }, [n.prepend && m("div", {
              class: "v-toolbar__prepend"
            }, [(b = n.prepend) == null ? void 0 : b.call(n)]), g && m(kf, {
              key: "title",
              text: e.title
            }, {
              text: n.title
            }), (V = n.default) == null ? void 0 : V.call(n), n.append && m("div", {
              class: "v-toolbar__append"
            }, [($ = n.append) == null ? void 0 : $.call(n)])])];
          }
        }), m(Te, {
          defaults: {
            VTabs: {
              height: se(f.value)
            }
          }
        }, {
          default: () => [m(Cu, null, {
            default: () => [c.value && m("div", {
              class: "v-toolbar__extension",
              style: {
                height: se(f.value)
              }
            }, [p])]
          })]
        })]
      });
    }), {
      contentHeight: d,
      extensionHeight: f
    };
  }
}), By = B({
  scrollTarget: {
    type: String
  },
  scrollThreshold: {
    type: [String, Number],
    default: 300
  }
}, "scroll");
function Ey(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    canScroll: n
  } = t;
  let i = 0, l = 0;
  const a = z(null), r = ie(0), s = ie(0), o = ie(0), u = ie(!1), c = ie(!1), d = C(() => Number(e.scrollThreshold)), f = C(() => Ot((d.value - r.value) / d.value || 0)), h = () => {
    const g = a.value;
    if (!g || n && !n.value) return;
    i = r.value, r.value = "window" in g ? g.pageYOffset : g.scrollTop;
    const v = g instanceof Window ? document.documentElement.scrollHeight : g.scrollHeight;
    if (l !== v) {
      l = v;
      return;
    }
    c.value = r.value < i, o.value = Math.abs(r.value - d.value);
  };
  return ee(c, () => {
    s.value = s.value || r.value;
  }), ee(u, () => {
    s.value = 0;
  }), it(() => {
    ee(() => e.scrollTarget, (g) => {
      var p;
      const v = g ? document.querySelector(g) : window;
      if (!v) {
        qn(`Unable to locate element with identifier ${g}`);
        return;
      }
      v !== a.value && ((p = a.value) == null || p.removeEventListener("scroll", h), a.value = v, a.value.addEventListener("scroll", h, {
        passive: !0
      }));
    }, {
      immediate: !0
    });
  }), Wt(() => {
    var g;
    (g = a.value) == null || g.removeEventListener("scroll", h);
  }), n && ee(n, h, {
    immediate: !0
  }), {
    scrollThreshold: d,
    currentScroll: r,
    currentThreshold: o,
    isScrollActive: u,
    scrollRatio: f,
    // required only for testing
    // probably can be removed
    // later (2 chars chlng)
    isScrollingUp: c,
    savedScroll: s
  };
}
function Ul() {
  const e = ie(!1);
  return it(() => {
    window.requestAnimationFrame(() => {
      e.value = !0;
    });
  }), {
    ssrBootStyles: C(() => e.value ? void 0 : {
      transition: "none !important"
    }),
    isBooted: Kd(e)
  };
}
const zy = B({
  scrollBehavior: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  location: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ...r4(),
  ...Yl(),
  ...By(),
  height: {
    type: [Number, String],
    default: 64
  }
}, "VAppBar"), Hy = X()({
  name: "VAppBar",
  props: zy(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = z(), l = pe(e, "modelValue"), a = C(() => {
      var V;
      const b = new Set(((V = e.scrollBehavior) == null ? void 0 : V.split(" ")) ?? []);
      return {
        hide: b.has("hide"),
        fullyHide: b.has("fully-hide"),
        inverted: b.has("inverted"),
        collapse: b.has("collapse"),
        elevate: b.has("elevate"),
        fadeImage: b.has("fade-image")
        // shrink: behavior.has('shrink'),
      };
    }), r = C(() => {
      const b = a.value;
      return b.hide || b.fullyHide || b.inverted || b.collapse || b.elevate || b.fadeImage || // behavior.shrink ||
      !l.value;
    }), {
      currentScroll: s,
      scrollThreshold: o,
      isScrollingUp: u,
      scrollRatio: c
    } = Ey(e, {
      canScroll: r
    }), d = C(() => a.value.hide || a.value.fullyHide), f = C(() => e.collapse || a.value.collapse && (a.value.inverted ? c.value > 0 : c.value === 0)), h = C(() => e.flat || a.value.fullyHide && !l.value || a.value.elevate && (a.value.inverted ? s.value > 0 : s.value === 0)), g = C(() => a.value.fadeImage ? a.value.inverted ? 1 - c.value : c.value : void 0), v = C(() => {
      var $, x;
      if (a.value.hide && a.value.inverted) return 0;
      const b = (($ = i.value) == null ? void 0 : $.contentHeight) ?? 0, V = ((x = i.value) == null ? void 0 : x.extensionHeight) ?? 0;
      return d.value ? s.value < o.value || a.value.fullyHide ? b + V : b : b + V;
    });
    un(C(() => !!e.scrollBehavior), () => {
      ft(() => {
        d.value ? a.value.inverted ? l.value = s.value > o.value : l.value = u.value || s.value < o.value : l.value = !0;
      });
    });
    const {
      ssrBootStyles: p
    } = Ul(), {
      layoutItemStyles: O
    } = Fl({
      id: e.name,
      order: C(() => parseInt(e.order, 10)),
      position: H(e, "location"),
      layoutSize: v,
      elementSize: ie(void 0),
      active: l,
      absolute: H(e, "absolute")
    });
    return F(() => {
      const b = O1.filterProps(e);
      return m(O1, q({
        ref: i,
        class: ["v-app-bar", {
          "v-app-bar--bottom": e.location === "bottom"
        }, e.class],
        style: [{
          ...O.value,
          "--v-toolbar-image-opacity": g.value,
          height: void 0,
          ...p.value
        }, e.style]
      }, b, {
        collapse: f.value,
        flat: h.value
      }), n);
    }), {};
  }
}), jy = [null, "default", "comfortable", "compact"], Zt = B({
  density: {
    type: String,
    default: "default",
    validator: (e) => jy.includes(e)
  }
}, "density");
function nn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  return {
    densityClasses: C(() => `${t}--density-${e.density}`)
  };
}
const Xy = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function ol(e, t) {
  return m(le, null, [e && m("span", {
    key: "overlay",
    class: `${t}__overlay`
  }, null), m("span", {
    key: "underlay",
    class: `${t}__underlay`
  }, null)]);
}
const En = B({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (e) => Xy.includes(e)
  }
}, "variant");
function Gl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  const n = C(() => {
    const {
      variant: a
    } = Me(e);
    return `${t}--variant-${a}`;
  }), {
    colorClasses: i,
    colorStyles: l
  } = Cf(C(() => {
    const {
      variant: a,
      color: r
    } = Me(e);
    return {
      [["elevated", "flat"].includes(a) ? "background" : "text"]: r
    };
  }));
  return {
    colorClasses: i,
    colorStyles: l,
    variantClasses: n
  };
}
const s4 = B({
  baseColor: String,
  divided: Boolean,
  ...yn(),
  ...ue(),
  ...Zt(),
  ...Lt(),
  ...at(),
  ...Ve(),
  ...Ie(),
  ...En()
}, "VBtnGroup"), y1 = X()({
  name: "VBtnGroup",
  props: s4(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e), {
      densityClasses: l
    } = nn(e), {
      borderClasses: a
    } = Qn(e), {
      elevationClasses: r
    } = Et(e), {
      roundedClasses: s
    } = gt(e);
    ht({
      VBtn: {
        height: "auto",
        baseColor: H(e, "baseColor"),
        color: H(e, "color"),
        density: H(e, "density"),
        flat: !0,
        variant: H(e, "variant")
      }
    }), F(() => m(e.tag, {
      class: ["v-btn-group", {
        "v-btn-group--divided": e.divided
      }, i.value, a.value, l.value, r.value, s.value, e.class],
      style: e.style
    }, n));
  }
}), Kl = B({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group"), Jl = B({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function ea(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const i = mt("useGroupItem");
  if (!i)
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  const l = Bt();
  lt(Symbol.for(`${t.description}:id`), l);
  const a = Be(t, null);
  if (!a) {
    if (!n) return a;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`);
  }
  const r = H(e, "value"), s = C(() => !!(a.disabled.value || e.disabled));
  a.register({
    id: l,
    value: r,
    disabled: s
  }, i), Wt(() => {
    a.unregister(l);
  });
  const o = C(() => a.isSelected(l)), u = C(() => a.items.value[0].id === l), c = C(() => a.items.value[a.items.value.length - 1].id === l), d = C(() => o.value && [a.selectedClass.value, e.selectedClass]);
  return ee(o, (f) => {
    i.emit("group:selected", {
      value: f
    });
  }, {
    flush: "sync"
  }), {
    id: l,
    isSelected: o,
    isFirst: u,
    isLast: c,
    toggle: () => a.select(l, !o.value),
    select: (f) => a.select(l, f),
    selectedClass: d,
    value: r,
    disabled: s,
    group: a
  };
}
function ul(e, t) {
  let n = !1;
  const i = Xt([]), l = pe(e, "modelValue", [], (f) => f == null ? [] : o4(i, ut(f)), (f) => {
    const h = qy(i, f);
    return e.multiple ? h : h[0];
  }), a = mt("useGroup");
  function r(f, h) {
    const g = f, v = Symbol.for(`${t.description}:id`), O = ha(v, a == null ? void 0 : a.vnode).indexOf(h);
    Me(g.value) == null && (g.value = O, g.useIndexAsValue = !0), O > -1 ? i.splice(O, 0, g) : i.push(g);
  }
  function s(f) {
    if (n) return;
    o();
    const h = i.findIndex((g) => g.id === f);
    i.splice(h, 1);
  }
  function o() {
    const f = i.find((h) => !h.disabled);
    f && e.mandatory === "force" && !l.value.length && (l.value = [f.id]);
  }
  it(() => {
    o();
  }), Wt(() => {
    n = !0;
  }), c7(() => {
    for (let f = 0; f < i.length; f++)
      i[f].useIndexAsValue && (i[f].value = f);
  });
  function u(f, h) {
    const g = i.find((v) => v.id === f);
    if (!(h && (g != null && g.disabled)))
      if (e.multiple) {
        const v = l.value.slice(), p = v.findIndex((b) => b === f), O = ~p;
        if (h = h ?? !O, O && e.mandatory && v.length <= 1 || !O && e.max != null && v.length + 1 > e.max) return;
        p < 0 && h ? v.push(f) : p >= 0 && !h && v.splice(p, 1), l.value = v;
      } else {
        const v = l.value.includes(f);
        if (e.mandatory && v) return;
        l.value = h ?? !v ? [f] : [];
      }
  }
  function c(f) {
    if (e.multiple && qn('This method is not supported when using "multiple" prop'), l.value.length) {
      const h = l.value[0], g = i.findIndex((O) => O.id === h);
      let v = (g + f) % i.length, p = i[v];
      for (; p.disabled && v !== g; )
        v = (v + f) % i.length, p = i[v];
      if (p.disabled) return;
      l.value = [i[v].id];
    } else {
      const h = i.find((g) => !g.disabled);
      h && (l.value = [h.id]);
    }
  }
  const d = {
    register: r,
    unregister: s,
    selected: l,
    select: u,
    disabled: H(e, "disabled"),
    prev: () => c(i.length - 1),
    next: () => c(1),
    isSelected: (f) => l.value.includes(f),
    selectedClass: C(() => e.selectedClass),
    items: C(() => i),
    getItemIndex: (f) => Ny(i, f)
  };
  return lt(t, d), d;
}
function Ny(e, t) {
  const n = o4(e, [t]);
  return n.length ? e.findIndex((i) => i.id === n[0]) : -1;
}
function o4(e, t) {
  const n = [];
  return t.forEach((i) => {
    const l = e.find((r) => vi(i, r.value)), a = e[i];
    (l == null ? void 0 : l.value) != null ? n.push(l.id) : a != null && n.push(a.id);
  }), n;
}
function qy(e, t) {
  const n = [];
  return t.forEach((i) => {
    const l = e.findIndex((a) => a.id === i);
    if (~l) {
      const a = e[l];
      n.push(a.value != null ? a.value : l);
    }
  }), n;
}
const Vf = Symbol.for("vuetify:v-btn-toggle"), Yy = B({
  ...s4(),
  ...Kl()
}, "VBtnToggle"), Fy = X()({
  name: "VBtnToggle",
  props: Yy(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: i,
      next: l,
      prev: a,
      select: r,
      selected: s
    } = ul(e, Vf);
    return F(() => {
      const o = y1.filterProps(e);
      return m(y1, q({
        class: ["v-btn-toggle", e.class]
      }, o, {
        style: e.style
      }), {
        default: () => {
          var u;
          return [(u = n.default) == null ? void 0 : u.call(n, {
            isSelected: i,
            next: l,
            prev: a,
            select: r,
            selected: s
          })];
        }
      });
    }), {
      next: l,
      prev: a,
      select: r
    };
  }
}), Wy = ["x-small", "small", "default", "large", "x-large"], yi = B({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function Na(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  return sf(() => {
    let n, i;
    return wo(Wy, e.size) ? n = `${t}--size-${e.size}` : e.size && (i = {
      width: se(e.size),
      height: se(e.size)
    }), {
      sizeClasses: n,
      sizeStyles: i
    };
  });
}
const Uy = B({
  color: String,
  disabled: Boolean,
  start: Boolean,
  end: Boolean,
  icon: Se,
  ...ue(),
  ...yi(),
  ...Ve({
    tag: "i"
  }),
  ...Ie()
}, "VIcon"), ze = X()({
  name: "VIcon",
  props: Uy(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const l = z(), {
      themeClasses: a
    } = Xe(e), {
      iconData: r
    } = wO(C(() => l.value || e.icon)), {
      sizeClasses: s
    } = Na(e), {
      textColorClasses: o,
      textColorStyles: u
    } = Yt(H(e, "color"));
    return F(() => {
      var f, h;
      const c = (f = i.default) == null ? void 0 : f.call(i);
      c && (l.value = (h = G9(c).filter((g) => g.type === d7 && g.children && typeof g.children == "string")[0]) == null ? void 0 : h.children);
      const d = !!(n.onClick || n.onClickOnce);
      return m(r.value.component, {
        tag: e.tag,
        icon: r.value.icon,
        class: ["v-icon", "notranslate", a.value, s.value, o.value, {
          "v-icon--clickable": d,
          "v-icon--disabled": e.disabled,
          "v-icon--start": e.start,
          "v-icon--end": e.end
        }, e.class],
        style: [s.value ? void 0 : {
          fontSize: se(e.size),
          height: se(e.size),
          width: se(e.size)
        }, u.value, e.style],
        role: d ? "button" : void 0,
        "aria-hidden": !d,
        tabindex: d ? e.disabled ? -1 : 0 : void 0
      }, {
        default: () => [c]
      });
    }), {};
  }
});
function Su(e, t) {
  const n = z(), i = ie(!1);
  if (nf) {
    const l = new IntersectionObserver((a) => {
      i.value = !!a.find((r) => r.isIntersecting);
    }, t);
    Wt(() => {
      l.disconnect();
    }), ee(n, (a, r) => {
      r && (l.unobserve(r), i.value = !1), a && l.observe(a);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: n,
    isIntersecting: i
  };
}
const Gy = B({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...ue(),
  ...yi(),
  ...Ve({
    tag: "div"
  }),
  ...Ie()
}, "VProgressCircular"), Qa = X()({
  name: "VProgressCircular",
  props: Gy(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = 20, l = 2 * Math.PI * i, a = z(), {
      themeClasses: r
    } = Xe(e), {
      sizeClasses: s,
      sizeStyles: o
    } = Na(e), {
      textColorClasses: u,
      textColorStyles: c
    } = Yt(H(e, "color")), {
      textColorClasses: d,
      textColorStyles: f
    } = Yt(H(e, "bgColor")), {
      intersectionRef: h,
      isIntersecting: g
    } = Su(), {
      resizeRef: v,
      contentRect: p
    } = Yn(), O = C(() => Math.max(0, Math.min(100, parseFloat(e.modelValue)))), b = C(() => Number(e.width)), V = C(() => o.value ? Number(e.size) : p.value ? p.value.width : Math.max(b.value, 32)), $ = C(() => i / (1 - b.value / V.value) * 2), x = C(() => b.value / V.value * $.value), Q = C(() => se((100 - O.value) / 100 * l));
    return ft(() => {
      h.value = a.value, v.value = a.value;
    }), F(() => m(e.tag, {
      ref: a,
      class: ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!e.indeterminate,
        "v-progress-circular--visible": g.value,
        "v-progress-circular--disable-shrink": e.indeterminate === "disable-shrink"
      }, r.value, s.value, u.value, e.class],
      style: [o.value, c.value, e.style],
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": e.indeterminate ? void 0 : O.value
    }, {
      default: () => [m("svg", {
        style: {
          transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))`
        },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${$.value} ${$.value}`
      }, [m("circle", {
        class: ["v-progress-circular__underlay", d.value],
        style: f.value,
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: i,
        "stroke-width": x.value,
        "stroke-dasharray": l,
        "stroke-dashoffset": 0
      }, null), m("circle", {
        class: "v-progress-circular__overlay",
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: i,
        "stroke-width": x.value,
        "stroke-dasharray": l,
        "stroke-dashoffset": Q.value
      }, null)]), n.default && m("div", {
        class: "v-progress-circular__content"
      }, [n.default({
        value: O.value
      })])]
    })), {};
  }
}), N2 = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, _i = B({
  location: String
}, "location");
function ta(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: i
  } = Qt();
  return {
    locationStyles: C(() => {
      if (!e.location) return {};
      const {
        side: a,
        align: r
      } = l1(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, i.value);
      function s(u) {
        return n ? n(u) : 0;
      }
      const o = {};
      return a !== "center" && (t ? o[N2[a]] = `calc(100% - ${s(a)}px)` : o[a] = 0), r !== "center" ? t ? o[N2[r]] = `calc(100% - ${s(r)}px)` : o[r] = 0 : (a === "center" ? o.top = o.left = "50%" : o[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[a]] = "50%", o.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[a]), o;
    })
  };
}
const Ky = B({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: !0
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  bufferColor: String,
  bufferOpacity: [Number, String],
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  opacity: [Number, String],
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...ue(),
  ..._i({
    location: "top"
  }),
  ...at(),
  ...Ve(),
  ...Ie()
}, "VProgressLinear"), wu = X()({
  name: "VProgressLinear",
  props: Ky(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    var k;
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), {
      isRtl: l,
      rtlClasses: a
    } = Qt(), {
      themeClasses: r
    } = Xe(e), {
      locationStyles: s
    } = ta(e), {
      textColorClasses: o,
      textColorStyles: u
    } = Yt(e, "color"), {
      backgroundColorClasses: c,
      backgroundColorStyles: d
    } = Fe(C(() => e.bgColor || e.color)), {
      backgroundColorClasses: f,
      backgroundColorStyles: h
    } = Fe(C(() => e.bufferColor || e.bgColor || e.color)), {
      backgroundColorClasses: g,
      backgroundColorStyles: v
    } = Fe(e, "color"), {
      roundedClasses: p
    } = gt(e), {
      intersectionRef: O,
      isIntersecting: b
    } = Su(), V = C(() => parseFloat(e.max)), $ = C(() => parseFloat(e.height)), x = C(() => Ot(parseFloat(e.bufferValue) / V.value * 100, 0, 100)), Q = C(() => Ot(parseFloat(i.value) / V.value * 100, 0, 100)), M = C(() => l.value !== e.reverse), w = C(() => e.indeterminate ? "fade-transition" : "slide-x-transition"), y = qe && ((k = window.matchMedia) == null ? void 0 : k.call(window, "(forced-colors: active)").matches);
    function L(S) {
      if (!O.value) return;
      const {
        left: P,
        right: T,
        width: _
      } = O.value.getBoundingClientRect(), D = M.value ? _ - S.clientX + (T - _) : S.clientX - P;
      i.value = Math.round(D / _ * V.value);
    }
    return F(() => m(e.tag, {
      ref: O,
      class: ["v-progress-linear", {
        "v-progress-linear--absolute": e.absolute,
        "v-progress-linear--active": e.active && b.value,
        "v-progress-linear--reverse": M.value,
        "v-progress-linear--rounded": e.rounded,
        "v-progress-linear--rounded-bar": e.roundedBar,
        "v-progress-linear--striped": e.striped
      }, p.value, r.value, a.value, e.class],
      style: [{
        bottom: e.location === "bottom" ? 0 : void 0,
        top: e.location === "top" ? 0 : void 0,
        height: e.active ? se($.value) : 0,
        "--v-progress-linear-height": se($.value),
        ...e.absolute ? s.value : {}
      }, e.style],
      role: "progressbar",
      "aria-hidden": e.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      "aria-valuenow": e.indeterminate ? void 0 : Q.value,
      onClick: e.clickable && L
    }, {
      default: () => [e.stream && m("div", {
        key: "stream",
        class: ["v-progress-linear__stream", o.value],
        style: {
          ...u.value,
          [M.value ? "left" : "right"]: se(-$.value),
          borderTop: `${se($.value / 2)} dotted`,
          opacity: parseFloat(e.bufferOpacity),
          top: `calc(50% - ${se($.value / 4)})`,
          width: se(100 - x.value, "%"),
          "--v-progress-linear-stream-to": se($.value * (M.value ? 1 : -1))
        }
      }, null), m("div", {
        class: ["v-progress-linear__background", y ? void 0 : c.value],
        style: [d.value, {
          opacity: parseFloat(e.bgOpacity),
          width: e.stream ? 0 : void 0
        }]
      }, null), m("div", {
        class: ["v-progress-linear__buffer", y ? void 0 : f.value],
        style: [h.value, {
          opacity: parseFloat(e.bufferOpacity),
          width: se(x.value, "%")
        }]
      }, null), m(Ui, {
        name: w.value
      }, {
        default: () => [e.indeterminate ? m("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((S) => m("div", {
          key: S,
          class: ["v-progress-linear__indeterminate", S, y ? void 0 : g.value],
          style: v.value
        }, null))]) : m("div", {
          class: ["v-progress-linear__determinate", y ? void 0 : g.value],
          style: [v.value, {
            width: se(Q.value, "%")
          }]
        }, null)]
      }), n.default && m("div", {
        class: "v-progress-linear__content"
      }, [n.default({
        value: Q.value,
        buffer: x.value
      })])]
    })), {};
  }
}), ku = B({
  loading: [Boolean, String]
}, "loader");
function us(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  return {
    loaderClasses: C(() => ({
      [`${t}--loading`]: e.loading
    }))
  };
}
function cs(e, t) {
  var i;
  let {
    slots: n
  } = t;
  return m("div", {
    class: `${e.name}__loader`
  }, [((i = n.default) == null ? void 0 : i.call(n, {
    color: e.color,
    isActive: e.active
  })) || m(wu, {
    absolute: e.absolute,
    active: e.active,
    color: e.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const Jy = ["static", "relative", "fixed", "absolute", "sticky"], qa = B({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (e) => Jy.includes(e)
    )
  }
}, "position");
function Ya(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  return {
    positionClasses: C(() => e.position ? `${t}--${e.position}` : void 0)
  };
}
function eb(e, t) {
  ee(() => {
    var n;
    return (n = e.isActive) == null ? void 0 : n.value;
  }, (n) => {
    e.isLink.value && n && t && He(() => {
      t(!0);
    });
  }, {
    immediate: !0
  });
}
const xu = B({
  active: {
    type: Boolean,
    default: void 0
  },
  activeColor: String,
  baseColor: String,
  symbol: {
    type: null,
    default: Vf
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: Se,
  appendIcon: Se,
  block: Boolean,
  readonly: Boolean,
  slim: Boolean,
  stacked: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: String,
  ...yn(),
  ...ue(),
  ...Zt(),
  ...wt(),
  ...Lt(),
  ...Jl(),
  ...ku(),
  ..._i(),
  ...qa(),
  ...at(),
  ...ss(),
  ...yi(),
  ...Ve({
    tag: "button"
  }),
  ...Ie(),
  ...En({
    variant: "elevated"
  })
}, "VBtn"), je = X()({
  name: "VBtn",
  props: xu(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: l
    } = Xe(e), {
      borderClasses: a
    } = Qn(e), {
      densityClasses: r
    } = nn(e), {
      dimensionStyles: s
    } = kt(e), {
      elevationClasses: o
    } = Et(e), {
      loaderClasses: u
    } = us(e), {
      locationStyles: c
    } = ta(e), {
      positionClasses: d
    } = Ya(e), {
      roundedClasses: f
    } = gt(e), {
      sizeClasses: h,
      sizeStyles: g
    } = Na(e), v = ea(e, e.symbol, !1), p = rs(e, n), O = C(() => {
      var k;
      return e.active !== void 0 ? e.active : p.isLink.value ? (k = p.isActive) == null ? void 0 : k.value : v == null ? void 0 : v.isSelected.value;
    }), b = C(() => O.value ? e.activeColor ?? e.color : e.color), V = C(() => {
      var S, P;
      return {
        color: (v == null ? void 0 : v.isSelected.value) && (!p.isLink.value || ((S = p.isActive) == null ? void 0 : S.value)) || !v || ((P = p.isActive) == null ? void 0 : P.value) ? b.value ?? e.baseColor : e.baseColor,
        variant: e.variant
      };
    }), {
      colorClasses: $,
      colorStyles: x,
      variantClasses: Q
    } = Gl(V), M = C(() => (v == null ? void 0 : v.disabled.value) || e.disabled), w = C(() => e.variant === "elevated" && !(e.disabled || e.flat || e.border)), y = C(() => {
      if (!(e.value === void 0 || typeof e.value == "symbol"))
        return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value;
    });
    function L(k) {
      var S;
      M.value || p.isLink.value && (k.metaKey || k.ctrlKey || k.shiftKey || k.button !== 0 || n.target === "_blank") || ((S = p.navigate) == null || S.call(p, k), v == null || v.toggle());
    }
    return eb(p, v == null ? void 0 : v.select), F(() => {
      const k = p.isLink.value ? "a" : e.tag, S = !!(e.prependIcon || i.prepend), P = !!(e.appendIcon || i.append), T = !!(e.icon && e.icon !== !0);
      return Je(m(k, {
        type: k === "a" ? void 0 : "button",
        class: ["v-btn", v == null ? void 0 : v.selectedClass.value, {
          "v-btn--active": O.value,
          "v-btn--block": e.block,
          "v-btn--disabled": M.value,
          "v-btn--elevated": w.value,
          "v-btn--flat": e.flat,
          "v-btn--icon": !!e.icon,
          "v-btn--loading": e.loading,
          "v-btn--readonly": e.readonly,
          "v-btn--slim": e.slim,
          "v-btn--stacked": e.stacked
        }, l.value, a.value, $.value, r.value, o.value, u.value, d.value, f.value, h.value, Q.value, e.class],
        style: [x.value, s.value, c.value, g.value, e.style],
        "aria-busy": e.loading ? !0 : void 0,
        disabled: M.value || void 0,
        href: p.href.value,
        tabindex: e.loading || e.readonly ? -1 : void 0,
        onClick: L,
        value: y.value
      }, {
        default: () => {
          var _;
          return [ol(!0, "v-btn"), !e.icon && S && m("span", {
            key: "prepend",
            class: "v-btn__prepend"
          }, [i.prepend ? m(Te, {
            key: "prepend-defaults",
            disabled: !e.prependIcon,
            defaults: {
              VIcon: {
                icon: e.prependIcon
              }
            }
          }, i.prepend) : m(ze, {
            key: "prepend-icon",
            icon: e.prependIcon
          }, null)]), m("span", {
            class: "v-btn__content",
            "data-no-activator": ""
          }, [!i.default && T ? m(ze, {
            key: "content-icon",
            icon: e.icon
          }, null) : m(Te, {
            key: "content-defaults",
            disabled: !T,
            defaults: {
              VIcon: {
                icon: e.icon
              }
            }
          }, {
            default: () => {
              var D;
              return [((D = i.default) == null ? void 0 : D.call(i)) ?? e.text];
            }
          })]), !e.icon && P && m("span", {
            key: "append",
            class: "v-btn__append"
          }, [i.append ? m(Te, {
            key: "append-defaults",
            disabled: !e.appendIcon,
            defaults: {
              VIcon: {
                icon: e.appendIcon
              }
            }
          }, i.append) : m(ze, {
            key: "append-icon",
            icon: e.appendIcon
          }, null)]), !!e.loading && m("span", {
            key: "loader",
            class: "v-btn__loader"
          }, [((_ = i.loader) == null ? void 0 : _.call(i)) ?? m(Qa, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            width: "2"
          }, null)])];
        }
      }), [[Ti, !M.value && e.ripple, "", {
        center: !!e.icon
      }]]);
    }), {
      group: v
    };
  }
}), tb = B({
  ...xu({
    icon: "$menu",
    variant: "text"
  })
}, "VAppBarNavIcon"), nb = X()({
  name: "VAppBarNavIcon",
  props: tb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => m(je, q(e, {
      class: ["v-app-bar-nav-icon"]
    }), n)), {};
  }
}), ib = X()({
  name: "VAppBarTitle",
  props: t4(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => m(kf, q(e, {
      class: "v-app-bar-title"
    }), n)), {};
  }
}), u4 = Oi("v-alert-title"), lb = ["success", "info", "warning", "error"], ab = B({
  border: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["top", "end", "bottom", "start"].includes(e)
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: Se,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (e) => lb.includes(e)
  },
  ...ue(),
  ...Zt(),
  ...wt(),
  ...Lt(),
  ..._i(),
  ...qa(),
  ...at(),
  ...Ve(),
  ...Ie(),
  ...En({
    variant: "flat"
  })
}, "VAlert"), rb = X()({
  name: "VAlert",
  props: ab(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const l = pe(e, "modelValue"), a = C(() => {
      if (e.icon !== !1)
        return e.type ? e.icon ?? `$${e.type}` : e.icon;
    }), r = C(() => ({
      color: e.color ?? e.type,
      variant: e.variant
    })), {
      themeClasses: s
    } = Xe(e), {
      colorClasses: o,
      colorStyles: u,
      variantClasses: c
    } = Gl(r), {
      densityClasses: d
    } = nn(e), {
      dimensionStyles: f
    } = kt(e), {
      elevationClasses: h
    } = Et(e), {
      locationStyles: g
    } = ta(e), {
      positionClasses: v
    } = Ya(e), {
      roundedClasses: p
    } = gt(e), {
      textColorClasses: O,
      textColorStyles: b
    } = Yt(H(e, "borderColor")), {
      t: V
    } = pt(), $ = C(() => ({
      "aria-label": V(e.closeLabel),
      onClick(x) {
        l.value = !1, n("click:close", x);
      }
    }));
    return () => {
      const x = !!(i.prepend || a.value), Q = !!(i.title || e.title), M = !!(i.close || e.closable);
      return l.value && m(e.tag, {
        class: ["v-alert", e.border && {
          "v-alert--border": !!e.border,
          [`v-alert--border-${e.border === !0 ? "start" : e.border}`]: !0
        }, {
          "v-alert--prominent": e.prominent
        }, s.value, o.value, d.value, h.value, v.value, p.value, c.value, e.class],
        style: [u.value, f.value, g.value, e.style],
        role: "alert"
      }, {
        default: () => {
          var w, y;
          return [ol(!1, "v-alert"), e.border && m("div", {
            key: "border",
            class: ["v-alert__border", O.value],
            style: b.value
          }, null), x && m("div", {
            key: "prepend",
            class: "v-alert__prepend"
          }, [i.prepend ? m(Te, {
            key: "prepend-defaults",
            disabled: !a.value,
            defaults: {
              VIcon: {
                density: e.density,
                icon: a.value,
                size: e.prominent ? 44 : 28
              }
            }
          }, i.prepend) : m(ze, {
            key: "prepend-icon",
            density: e.density,
            icon: a.value,
            size: e.prominent ? 44 : 28
          }, null)]), m("div", {
            class: "v-alert__content"
          }, [Q && m(u4, {
            key: "title"
          }, {
            default: () => {
              var L;
              return [((L = i.title) == null ? void 0 : L.call(i)) ?? e.title];
            }
          }), ((w = i.text) == null ? void 0 : w.call(i)) ?? e.text, (y = i.default) == null ? void 0 : y.call(i)]), i.append && m("div", {
            key: "append",
            class: "v-alert__append"
          }, [i.append()]), M && m("div", {
            key: "close",
            class: "v-alert__close"
          }, [i.close ? m(Te, {
            key: "close-defaults",
            defaults: {
              VBtn: {
                icon: e.closeIcon,
                size: "x-small",
                variant: "text"
              }
            }
          }, {
            default: () => {
              var L;
              return [(L = i.close) == null ? void 0 : L.call(i, {
                props: $.value
              })];
            }
          }) : m(je, q({
            key: "close-btn",
            icon: e.closeIcon,
            size: "x-small",
            variant: "text"
          }, $.value), null)])];
        }
      });
    };
  }
}), sb = B({
  start: Boolean,
  end: Boolean,
  icon: Se,
  image: String,
  text: String,
  ...yn(),
  ...ue(),
  ...Zt(),
  ...at(),
  ...yi(),
  ...Ve(),
  ...Ie(),
  ...En({
    variant: "flat"
  })
}, "VAvatar"), An = X()({
  name: "VAvatar",
  props: sb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e), {
      borderClasses: l
    } = Qn(e), {
      colorClasses: a,
      colorStyles: r,
      variantClasses: s
    } = Gl(e), {
      densityClasses: o
    } = nn(e), {
      roundedClasses: u
    } = gt(e), {
      sizeClasses: c,
      sizeStyles: d
    } = Na(e);
    return F(() => m(e.tag, {
      class: ["v-avatar", {
        "v-avatar--start": e.start,
        "v-avatar--end": e.end
      }, i.value, l.value, a.value, o.value, u.value, c.value, s.value, e.class],
      style: [r.value, d.value, e.style]
    }, {
      default: () => [n.default ? m(Te, {
        key: "content-defaults",
        defaults: {
          VImg: {
            cover: !0,
            src: e.image
          },
          VIcon: {
            icon: e.icon
          }
        }
      }, {
        default: () => [n.default()]
      }) : e.image ? m($i, {
        key: "image",
        src: e.image,
        alt: "",
        cover: !0
      }, null) : e.icon ? m(ze, {
        key: "icon",
        icon: e.icon
      }, null) : e.text, ol(!1, "v-avatar")]
    })), {};
  }
}), ob = B({
  text: String,
  onClick: Dt(),
  ...ue(),
  ...Ie()
}, "VLabel"), Fa = X()({
  name: "VLabel",
  props: ob(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => {
      var i;
      return m("label", {
        class: ["v-label", {
          "v-label--clickable": !!e.onClick
        }, e.class],
        style: e.style,
        onClick: e.onClick
      }, [e.text, (i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), c4 = Symbol.for("vuetify:selection-control-group"), Qf = B({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: Se,
  trueIcon: Se,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: {
    type: Boolean,
    default: null
  },
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: vi
  },
  ...ue(),
  ...Zt(),
  ...Ie()
}, "SelectionControlGroup"), ub = B({
  ...Qf({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup"), d4 = X()({
  name: "VSelectionControlGroup",
  props: ub(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), l = Bt(), a = C(() => e.id || `v-selection-control-group-${l}`), r = C(() => e.name || a.value), s = /* @__PURE__ */ new Set();
    return lt(c4, {
      modelValue: i,
      forceUpdate: () => {
        s.forEach((o) => o());
      },
      onForceUpdate: (o) => {
        s.add(o), tn(() => {
          s.delete(o);
        });
      }
    }), ht({
      [e.defaultsTarget]: {
        color: H(e, "color"),
        disabled: H(e, "disabled"),
        density: H(e, "density"),
        error: H(e, "error"),
        inline: H(e, "inline"),
        modelValue: i,
        multiple: C(() => !!e.multiple || e.multiple == null && Array.isArray(i.value)),
        name: r,
        falseIcon: H(e, "falseIcon"),
        trueIcon: H(e, "trueIcon"),
        readonly: H(e, "readonly"),
        ripple: H(e, "ripple"),
        type: H(e, "type"),
        valueComparator: H(e, "valueComparator")
      }
    }), F(() => {
      var o;
      return m("div", {
        class: ["v-selection-control-group", {
          "v-selection-control-group--inline": e.inline
        }, e.class],
        style: e.style,
        role: e.type === "radio" ? "radiogroup" : void 0
      }, [(o = n.default) == null ? void 0 : o.call(n)]);
    }), {};
  }
}), Pu = B({
  label: String,
  baseColor: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...ue(),
  ...Qf()
}, "VSelectionControl");
function cb(e) {
  const t = Be(c4, void 0), {
    densityClasses: n
  } = nn(e), i = pe(e, "modelValue"), l = C(() => e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0), a = C(() => e.falseValue !== void 0 ? e.falseValue : !1), r = C(() => !!e.multiple || e.multiple == null && Array.isArray(i.value)), s = C({
    get() {
      const h = t ? t.modelValue.value : i.value;
      return r.value ? ut(h).some((g) => e.valueComparator(g, l.value)) : e.valueComparator(h, l.value);
    },
    set(h) {
      if (e.readonly) return;
      const g = h ? l.value : a.value;
      let v = g;
      r.value && (v = h ? [...ut(i.value), g] : ut(i.value).filter((p) => !e.valueComparator(p, l.value))), t ? t.modelValue.value = v : i.value = v;
    }
  }), {
    textColorClasses: o,
    textColorStyles: u
  } = Yt(C(() => {
    if (!(e.error || e.disabled))
      return s.value ? e.color : e.baseColor;
  })), {
    backgroundColorClasses: c,
    backgroundColorStyles: d
  } = Fe(C(() => s.value && !e.error && !e.disabled ? e.color : e.baseColor)), f = C(() => s.value ? e.trueIcon : e.falseIcon);
  return {
    group: t,
    densityClasses: n,
    trueValue: l,
    falseValue: a,
    model: s,
    textColorClasses: o,
    textColorStyles: u,
    backgroundColorClasses: c,
    backgroundColorStyles: d,
    icon: f
  };
}
const Ki = X()({
  name: "VSelectionControl",
  directives: {
    Ripple: Ti
  },
  inheritAttrs: !1,
  props: Pu(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      group: l,
      densityClasses: a,
      icon: r,
      model: s,
      textColorClasses: o,
      textColorStyles: u,
      backgroundColorClasses: c,
      backgroundColorStyles: d,
      trueValue: f
    } = cb(e), h = Bt(), g = ie(!1), v = ie(!1), p = z(), O = C(() => e.id || `input-${h}`), b = C(() => !e.disabled && !e.readonly);
    l == null || l.onForceUpdate(() => {
      p.value && (p.value.checked = s.value);
    });
    function V(M) {
      b.value && (g.value = !0, Pa(M.target, ":focus-visible") !== !1 && (v.value = !0));
    }
    function $() {
      g.value = !1, v.value = !1;
    }
    function x(M) {
      M.stopPropagation();
    }
    function Q(M) {
      if (!b.value) {
        p.value && (p.value.checked = s.value);
        return;
      }
      e.readonly && l && He(() => l.forceUpdate()), s.value = M.target.checked;
    }
    return F(() => {
      var k, S;
      const M = i.label ? i.label({
        label: e.label,
        props: {
          for: O.value
        }
      }) : e.label, [w, y] = sl(n), L = m("input", q({
        ref: p,
        checked: s.value,
        disabled: !!e.disabled,
        id: O.value,
        onBlur: $,
        onFocus: V,
        onInput: Q,
        "aria-disabled": !!e.disabled,
        "aria-label": e.label,
        type: e.type,
        value: f.value,
        name: e.name,
        "aria-checked": e.type === "checkbox" ? s.value : void 0
      }, y), null);
      return m("div", q({
        class: ["v-selection-control", {
          "v-selection-control--dirty": s.value,
          "v-selection-control--disabled": e.disabled,
          "v-selection-control--error": e.error,
          "v-selection-control--focused": g.value,
          "v-selection-control--focus-visible": v.value,
          "v-selection-control--inline": e.inline
        }, a.value, e.class]
      }, w, {
        style: e.style
      }), [m("div", {
        class: ["v-selection-control__wrapper", o.value],
        style: u.value
      }, [(k = i.default) == null ? void 0 : k.call(i, {
        backgroundColorClasses: c,
        backgroundColorStyles: d
      }), Je(m("div", {
        class: ["v-selection-control__input"]
      }, [((S = i.input) == null ? void 0 : S.call(i, {
        model: s,
        textColorClasses: o,
        textColorStyles: u,
        backgroundColorClasses: c,
        backgroundColorStyles: d,
        inputNode: L,
        icon: r.value,
        props: {
          onFocus: V,
          onBlur: $,
          id: O.value
        }
      })) ?? m(le, null, [r.value && m(ze, {
        key: "icon",
        icon: r.value
      }, null), L])]), [[Pn("ripple"), e.ripple && [!e.disabled && !e.readonly, null, ["center", "circle"]]]])]), M && m(Fa, {
        for: O.value,
        onClick: x
      }, {
        default: () => [M]
      })]);
    }), {
      isFocused: g,
      input: p
    };
  }
}), f4 = B({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: Se,
    default: "$checkboxIndeterminate"
  },
  ...Pu({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn"), Vi = X()({
  name: "VCheckboxBtn",
  props: f4(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "indeterminate"), l = pe(e, "modelValue");
    function a(o) {
      i.value && (i.value = !1);
    }
    const r = C(() => i.value ? e.indeterminateIcon : e.falseIcon), s = C(() => i.value ? e.indeterminateIcon : e.trueIcon);
    return F(() => {
      const o = St(Ki.filterProps(e), ["modelValue"]);
      return m(Ki, q(o, {
        modelValue: l.value,
        "onUpdate:modelValue": [(u) => l.value = u, a],
        class: ["v-checkbox-btn", e.class],
        style: e.style,
        type: "checkbox",
        falseIcon: r.value,
        trueIcon: s.value,
        "aria-checked": i.value ? "mixed" : void 0
      }), n);
    }), {};
  }
});
function h4(e) {
  const {
    t
  } = pt();
  function n(i) {
    let {
      name: l
    } = i;
    const a = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[l], r = e[`onClick:${l}`], s = r && a ? t(`$vuetify.input.${a}`, e.label ?? "") : void 0;
    return m(ze, {
      icon: e[`${l}Icon`],
      "aria-label": s,
      onClick: r
    }, null);
  }
  return {
    InputIcon: n
  };
}
const db = B({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...ue(),
  ...Gn({
    transition: {
      component: Pf,
      leaveAbsolute: !0,
      group: !0
    }
  })
}, "VMessages"), m4 = X()({
  name: "VMessages",
  props: db(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = C(() => ut(e.messages)), {
      textColorClasses: l,
      textColorStyles: a
    } = Yt(C(() => e.color));
    return F(() => m(en, {
      transition: e.transition,
      tag: "div",
      class: ["v-messages", l.value, e.class],
      style: [a.value, e.style],
      role: "alert",
      "aria-live": "polite"
    }, {
      default: () => [e.active && i.value.map((r, s) => m("div", {
        class: "v-messages__message",
        key: `${s}-${i.value}`
      }, [n.message ? n.message({
        message: r
      }) : r]))]
    })), {};
  }
}), ds = B({
  focused: Boolean,
  "onUpdate:focused": Dt()
}, "focus");
function Ai(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi();
  const n = pe(e, "focused"), i = C(() => ({
    [`${t}--focused`]: n.value
  }));
  function l() {
    n.value = !0;
  }
  function a() {
    n.value = !1;
  }
  return {
    focusClasses: i,
    isFocused: n,
    focus: l,
    blur: a
  };
}
const g4 = Symbol.for("vuetify:form"), fb = B({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function hb(e) {
  const t = pe(e, "modelValue"), n = C(() => e.disabled), i = C(() => e.readonly), l = ie(!1), a = z([]), r = z([]);
  async function s() {
    const c = [];
    let d = !0;
    r.value = [], l.value = !0;
    for (const f of a.value) {
      const h = await f.validate();
      if (h.length > 0 && (d = !1, c.push({
        id: f.id,
        errorMessages: h
      })), !d && e.fastFail) break;
    }
    return r.value = c, l.value = !1, {
      valid: d,
      errors: r.value
    };
  }
  function o() {
    a.value.forEach((c) => c.reset());
  }
  function u() {
    a.value.forEach((c) => c.resetValidation());
  }
  return ee(a, () => {
    let c = 0, d = 0;
    const f = [];
    for (const h of a.value)
      h.isValid === !1 ? (d++, f.push({
        id: h.id,
        errorMessages: h.errorMessages
      })) : h.isValid === !0 && c++;
    r.value = f, t.value = d > 0 ? !1 : c === a.value.length ? !0 : null;
  }, {
    deep: !0,
    flush: "post"
  }), lt(g4, {
    register: (c) => {
      let {
        id: d,
        vm: f,
        validate: h,
        reset: g,
        resetValidation: v
      } = c;
      a.value.some((p) => p.id === d) && qn(`Duplicate input name "${d}"`), a.value.push({
        id: d,
        validate: h,
        reset: g,
        resetValidation: v,
        vm: f7(f),
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (c) => {
      a.value = a.value.filter((d) => d.id !== c);
    },
    update: (c, d, f) => {
      const h = a.value.find((g) => g.id === c);
      h && (h.isValid = d, h.errorMessages = f);
    },
    isDisabled: n,
    isReadonly: i,
    isValidating: l,
    isValid: t,
    items: a,
    validateOn: H(e, "validateOn")
  }), {
    errors: r,
    isDisabled: n,
    isReadonly: i,
    isValidating: l,
    isValid: t,
    items: a,
    validate: s,
    reset: o,
    resetValidation: u
  };
}
function $u() {
  return Be(g4, null);
}
const v4 = B({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...ds()
}, "validation");
function p4(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pi(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Bt();
  const i = pe(e, "modelValue"), l = C(() => e.validationValue === void 0 ? i.value : e.validationValue), a = $u(), r = z([]), s = ie(!0), o = C(() => !!(ut(i.value === "" ? null : i.value).length || ut(l.value === "" ? null : l.value).length)), u = C(() => !!(e.disabled ?? (a == null ? void 0 : a.isDisabled.value))), c = C(() => !!(e.readonly ?? (a == null ? void 0 : a.isReadonly.value))), d = C(() => {
    var x;
    return (x = e.errorMessages) != null && x.length ? ut(e.errorMessages).concat(r.value).slice(0, Math.max(0, +e.maxErrors)) : r.value;
  }), f = C(() => {
    let x = (e.validateOn ?? (a == null ? void 0 : a.validateOn.value)) || "input";
    x === "lazy" && (x = "input lazy"), x === "eager" && (x = "input eager");
    const Q = new Set((x == null ? void 0 : x.split(" ")) ?? []);
    return {
      input: Q.has("input"),
      blur: Q.has("blur") || Q.has("input") || Q.has("invalid-input"),
      invalidInput: Q.has("invalid-input"),
      lazy: Q.has("lazy"),
      eager: Q.has("eager")
    };
  }), h = C(() => {
    var x;
    return e.error || (x = e.errorMessages) != null && x.length ? !1 : e.rules.length ? s.value ? r.value.length || f.value.lazy ? null : !0 : !r.value.length : !0;
  }), g = ie(!1), v = C(() => ({
    [`${t}--error`]: h.value === !1,
    [`${t}--dirty`]: o.value,
    [`${t}--disabled`]: u.value,
    [`${t}--readonly`]: c.value
  })), p = mt("validation"), O = C(() => e.name ?? Me(n));
  N9(() => {
    a == null || a.register({
      id: O.value,
      vm: p,
      validate: $,
      reset: b,
      resetValidation: V
    });
  }), Wt(() => {
    a == null || a.unregister(O.value);
  }), it(async () => {
    f.value.lazy || await $(!f.value.eager), a == null || a.update(O.value, h.value, d.value);
  }), un(() => f.value.input || f.value.invalidInput && h.value === !1, () => {
    ee(l, () => {
      if (l.value != null)
        $();
      else if (e.focused) {
        const x = ee(() => e.focused, (Q) => {
          Q || $(), x();
        });
      }
    });
  }), un(() => f.value.blur, () => {
    ee(() => e.focused, (x) => {
      x || $();
    });
  }), ee([h, d], () => {
    a == null || a.update(O.value, h.value, d.value);
  });
  async function b() {
    i.value = null, await He(), await V();
  }
  async function V() {
    s.value = !0, f.value.lazy ? r.value = [] : await $(!f.value.eager);
  }
  async function $() {
    let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const Q = [];
    g.value = !0;
    for (const M of e.rules) {
      if (Q.length >= +(e.maxErrors ?? 1))
        break;
      const y = await (typeof M == "function" ? M : () => M)(l.value);
      if (y !== !0) {
        if (y !== !1 && typeof y != "string") {
          console.warn(`${y} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        Q.push(y || "");
      }
    }
    return r.value = Q, g.value = !1, s.value = x, r.value;
  }
  return {
    errorMessages: d,
    isDirty: o,
    isDisabled: u,
    isReadonly: c,
    isPristine: s,
    isValid: h,
    isValidating: g,
    reset: b,
    resetValidation: V,
    validate: $,
    validationClasses: v
  };
}
const Ri = B({
  id: String,
  appendIcon: Se,
  centerAffix: {
    type: Boolean,
    default: !0
  },
  prependIcon: Se,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["horizontal", "vertical"].includes(e)
  },
  "onClick:prepend": Dt(),
  "onClick:append": Dt(),
  ...ue(),
  ...Zt(),
  ...hu(wt(), ["maxWidth", "minWidth", "width"]),
  ...Ie(),
  ...v4()
}, "VInput"), Ft = X()({
  name: "VInput",
  props: {
    ...Ri()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i,
      emit: l
    } = t;
    const {
      densityClasses: a
    } = nn(e), {
      dimensionStyles: r
    } = kt(e), {
      themeClasses: s
    } = Xe(e), {
      rtlClasses: o
    } = Qt(), {
      InputIcon: u
    } = h4(e), c = Bt(), d = C(() => e.id || `input-${c}`), f = C(() => `${d.value}-messages`), {
      errorMessages: h,
      isDirty: g,
      isDisabled: v,
      isReadonly: p,
      isPristine: O,
      isValid: b,
      isValidating: V,
      reset: $,
      resetValidation: x,
      validate: Q,
      validationClasses: M
    } = p4(e, "v-input", d), w = C(() => ({
      id: d,
      messagesId: f,
      isDirty: g,
      isDisabled: v,
      isReadonly: p,
      isPristine: O,
      isValid: b,
      isValidating: V,
      reset: $,
      resetValidation: x,
      validate: Q
    })), y = C(() => {
      var L;
      return (L = e.errorMessages) != null && L.length || !O.value && h.value.length ? h.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages;
    });
    return F(() => {
      var T, _, D, N;
      const L = !!(i.prepend || e.prependIcon), k = !!(i.append || e.appendIcon), S = y.value.length > 0, P = !e.hideDetails || e.hideDetails === "auto" && (S || !!i.details);
      return m("div", {
        class: ["v-input", `v-input--${e.direction}`, {
          "v-input--center-affix": e.centerAffix,
          "v-input--hide-spin-buttons": e.hideSpinButtons
        }, a.value, s.value, o.value, M.value, e.class],
        style: [r.value, e.style]
      }, [L && m("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [(T = i.prepend) == null ? void 0 : T.call(i, w.value), e.prependIcon && m(u, {
        key: "prepend-icon",
        name: "prepend"
      }, null)]), i.default && m("div", {
        class: "v-input__control"
      }, [(_ = i.default) == null ? void 0 : _.call(i, w.value)]), k && m("div", {
        key: "append",
        class: "v-input__append"
      }, [e.appendIcon && m(u, {
        key: "append-icon",
        name: "append"
      }, null), (D = i.append) == null ? void 0 : D.call(i, w.value)]), P && m("div", {
        class: "v-input__details"
      }, [m(m4, {
        id: f.value,
        active: S,
        messages: y.value
      }, {
        message: i.message
      }), (N = i.details) == null ? void 0 : N.call(i, w.value)])]);
    }), {
      reset: $,
      resetValidation: x,
      validate: Q,
      isValid: b,
      errorMessages: h
    };
  }
}), mb = B({
  ...Ri(),
  ...St(f4(), ["inline"])
}, "VCheckbox"), gb = X()({
  name: "VCheckbox",
  inheritAttrs: !1,
  props: mb(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:focused": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const l = pe(e, "modelValue"), {
      isFocused: a,
      focus: r,
      blur: s
    } = Ai(e), o = Bt(), u = C(() => e.id || `checkbox-${o}`);
    return F(() => {
      const [c, d] = sl(n), f = Ft.filterProps(e), h = Vi.filterProps(e);
      return m(Ft, q({
        class: ["v-checkbox", e.class]
      }, c, f, {
        modelValue: l.value,
        "onUpdate:modelValue": (g) => l.value = g,
        id: u.value,
        focused: a.value,
        style: e.style
      }), {
        ...i,
        default: (g) => {
          let {
            id: v,
            messagesId: p,
            isDisabled: O,
            isReadonly: b,
            isValid: V
          } = g;
          return m(Vi, q(h, {
            id: v.value,
            "aria-describedby": p.value,
            disabled: O.value,
            readonly: b.value
          }, d, {
            error: V.value === !1,
            modelValue: l.value,
            "onUpdate:modelValue": ($) => l.value = $,
            onFocus: r,
            onBlur: s
          }), i);
        }
      });
    }), {};
  }
});
function vb(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isRtl: i,
    isHorizontal: l
  } = e;
  const a = Ar(l, n), r = O4(l, i, n), s = Ar(l, t), o = y4(l, t), u = s * 0.4;
  return r > o ? o - u : r + a < o + s ? o - a + s + u : r;
}
function pb(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isHorizontal: i
  } = e;
  const l = Ar(i, n), a = y4(i, t), r = Ar(i, t);
  return a - l / 2 + r / 2;
}
function q2(e, t) {
  const n = e ? "scrollWidth" : "scrollHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function Ob(e, t) {
  const n = e ? "clientWidth" : "clientHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function O4(e, t, n) {
  if (!n)
    return 0;
  const {
    scrollLeft: i,
    offsetWidth: l,
    scrollWidth: a
  } = n;
  return e ? t ? a - l + i : i : n.scrollTop;
}
function Ar(e, t) {
  const n = e ? "offsetWidth" : "offsetHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function y4(e, t) {
  const n = e ? "offsetLeft" : "offsetTop";
  return (t == null ? void 0 : t[n]) || 0;
}
const b4 = Symbol.for("vuetify:v-slide-group"), Lf = B({
  centerActive: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: b4
  },
  nextIcon: {
    type: Se,
    default: "$next"
  },
  prevIcon: {
    type: Se,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["always", "desktop", "mobile"].includes(e)
  },
  ...ue(),
  ...ql({
    mobile: null
  }),
  ...Ve(),
  ...Kl({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup"), Rr = X()({
  name: "VSlideGroup",
  props: Lf(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isRtl: i
    } = Qt(), {
      displayClasses: l,
      mobile: a
    } = Dn(e), r = ul(e, e.symbol), s = ie(!1), o = ie(0), u = ie(0), c = ie(0), d = C(() => e.direction === "horizontal"), {
      resizeRef: f,
      contentRect: h
    } = Yn(), {
      resizeRef: g,
      contentRect: v
    } = Yn(), p = OO(), O = C(() => ({
      container: f.el,
      duration: 200,
      easing: "easeOutQuart"
    })), b = C(() => r.selected.value.length ? r.items.value.findIndex((I) => I.id === r.selected.value[0]) : -1), V = C(() => r.selected.value.length ? r.items.value.findIndex((I) => I.id === r.selected.value[r.selected.value.length - 1]) : -1);
    if (qe) {
      let I = -1;
      ee(() => [r.selected.value, h.value, v.value, d.value], () => {
        cancelAnimationFrame(I), I = requestAnimationFrame(() => {
          if (h.value && v.value) {
            const Z = d.value ? "width" : "height";
            u.value = h.value[Z], c.value = v.value[Z], s.value = u.value + 1 < c.value;
          }
          if (b.value >= 0 && g.el) {
            const Z = g.el.children[V.value];
            x(Z, e.centerActive);
          }
        });
      });
    }
    const $ = ie(!1);
    function x(I, Z) {
      let Y = 0;
      Z ? Y = pb({
        containerElement: f.el,
        isHorizontal: d.value,
        selectedElement: I
      }) : Y = vb({
        containerElement: f.el,
        isHorizontal: d.value,
        isRtl: i.value,
        selectedElement: I
      }), Q(Y);
    }
    function Q(I) {
      if (!qe || !f.el) return;
      const Z = Ar(d.value, f.el), Y = O4(d.value, i.value, f.el);
      if (!(q2(d.value, f.el) <= Z || // Prevent scrolling by only a couple of pixels, which doesn't look smooth
      Math.abs(I - Y) < 16)) {
        if (d.value && i.value && f.el) {
          const {
            scrollWidth: de,
            offsetWidth: ye
          } = f.el;
          I = de - ye - I;
        }
        d.value ? p.horizontal(I, O.value) : p(I, O.value);
      }
    }
    function M(I) {
      const {
        scrollTop: Z,
        scrollLeft: Y
      } = I.target;
      o.value = d.value ? Y : Z;
    }
    function w(I) {
      if ($.value = !0, !(!s.value || !g.el)) {
        for (const Z of I.composedPath())
          for (const Y of g.el.children)
            if (Y === Z) {
              x(Y);
              return;
            }
      }
    }
    function y(I) {
      $.value = !1;
    }
    let L = !1;
    function k(I) {
      var Z;
      !L && !$.value && !(I.relatedTarget && ((Z = g.el) != null && Z.contains(I.relatedTarget))) && T(), L = !1;
    }
    function S() {
      L = !0;
    }
    function P(I) {
      if (!g.el) return;
      function Z(Y) {
        I.preventDefault(), T(Y);
      }
      d.value ? I.key === "ArrowRight" ? Z(i.value ? "prev" : "next") : I.key === "ArrowLeft" && Z(i.value ? "next" : "prev") : I.key === "ArrowDown" ? Z("next") : I.key === "ArrowUp" && Z("prev"), I.key === "Home" ? Z("first") : I.key === "End" && Z("last");
    }
    function T(I) {
      var Y, ce;
      if (!g.el) return;
      let Z;
      if (!I)
        Z = $r(g.el)[0];
      else if (I === "next") {
        if (Z = (Y = g.el.querySelector(":focus")) == null ? void 0 : Y.nextElementSibling, !Z) return T("first");
      } else if (I === "prev") {
        if (Z = (ce = g.el.querySelector(":focus")) == null ? void 0 : ce.previousElementSibling, !Z) return T("last");
      } else I === "first" ? Z = g.el.firstElementChild : I === "last" && (Z = g.el.lastElementChild);
      Z && Z.focus({
        preventScroll: !0
      });
    }
    function _(I) {
      const Z = d.value && i.value ? -1 : 1, Y = (I === "prev" ? -Z : Z) * u.value;
      let ce = o.value + Y;
      if (d.value && i.value && f.el) {
        const {
          scrollWidth: de,
          offsetWidth: ye
        } = f.el;
        ce += de - ye;
      }
      Q(ce);
    }
    const D = C(() => ({
      next: r.next,
      prev: r.prev,
      select: r.select,
      isSelected: r.isSelected
    })), N = C(() => {
      switch (e.showArrows) {
        case "always":
          return !0;
        case "desktop":
          return !a.value;
        case !0:
          return s.value || Math.abs(o.value) > 0;
        case "mobile":
          return a.value || s.value || Math.abs(o.value) > 0;
        default:
          return !a.value && (s.value || Math.abs(o.value) > 0);
      }
    }), K = C(() => Math.abs(o.value) > 1), E = C(() => {
      if (!f.value) return !1;
      const I = q2(d.value, f.el), Z = Ob(d.value, f.el);
      return I - Z - Math.abs(o.value) > 1;
    });
    return F(() => m(e.tag, {
      class: ["v-slide-group", {
        "v-slide-group--vertical": !d.value,
        "v-slide-group--has-affixes": N.value,
        "v-slide-group--is-overflowing": s.value
      }, l.value, e.class],
      style: e.style,
      tabindex: $.value || r.selected.value.length ? -1 : 0,
      onFocus: k
    }, {
      default: () => {
        var I, Z, Y;
        return [N.value && m("div", {
          key: "prev",
          class: ["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !K.value
          }],
          onMousedown: S,
          onClick: () => K.value && _("prev")
        }, [((I = n.prev) == null ? void 0 : I.call(n, D.value)) ?? m(_r, null, {
          default: () => [m(ze, {
            icon: i.value ? e.nextIcon : e.prevIcon
          }, null)]
        })]), m("div", {
          key: "container",
          ref: f,
          class: "v-slide-group__container",
          onScroll: M
        }, [m("div", {
          ref: g,
          class: "v-slide-group__content",
          onFocusin: w,
          onFocusout: y,
          onKeydown: P
        }, [(Z = n.default) == null ? void 0 : Z.call(n, D.value)])]), N.value && m("div", {
          key: "next",
          class: ["v-slide-group__next", {
            "v-slide-group__next--disabled": !E.value
          }],
          onMousedown: S,
          onClick: () => E.value && _("next")
        }, [((Y = n.next) == null ? void 0 : Y.call(n, D.value)) ?? m(_r, null, {
          default: () => [m(ze, {
            icon: i.value ? e.prevIcon : e.nextIcon
          }, null)]
        })])];
      }
    })), {
      selected: r.selected,
      scrollTo: _,
      scrollOffset: o,
      focus: T,
      hasPrev: K,
      hasNext: E
    };
  }
}), C4 = Symbol.for("vuetify:v-chip-group"), yb = B({
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: vi
  },
  ...Lf(),
  ...ue(),
  ...Kl({
    selectedClass: "v-chip--selected"
  }),
  ...Ve(),
  ...Ie(),
  ...En({
    variant: "tonal"
  })
}, "VChipGroup"), bb = X()({
  name: "VChipGroup",
  props: yb(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e), {
      isSelected: l,
      select: a,
      next: r,
      prev: s,
      selected: o
    } = ul(e, C4);
    return ht({
      VChip: {
        color: H(e, "color"),
        disabled: H(e, "disabled"),
        filter: H(e, "filter"),
        variant: H(e, "variant")
      }
    }), F(() => {
      const u = Rr.filterProps(e);
      return m(Rr, q(u, {
        class: ["v-chip-group", {
          "v-chip-group--column": e.column
        }, i.value, e.class],
        style: e.style
      }), {
        default: () => {
          var c;
          return [(c = n.default) == null ? void 0 : c.call(n, {
            isSelected: l,
            select: a,
            next: r,
            prev: s,
            selected: o.value
          })];
        }
      });
    }), {};
  }
}), Cb = B({
  activeClass: String,
  appendAvatar: String,
  appendIcon: Se,
  closable: Boolean,
  closeIcon: {
    type: Se,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: String,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: Se,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  onClick: Dt(),
  onClickOnce: Dt(),
  ...yn(),
  ...ue(),
  ...Zt(),
  ...Lt(),
  ...Jl(),
  ...at(),
  ...ss(),
  ...yi(),
  ...Ve({
    tag: "span"
  }),
  ...Ie(),
  ...En({
    variant: "tonal"
  })
}, "VChip"), Wa = X()({
  name: "VChip",
  directives: {
    Ripple: Ti
  },
  props: Cb(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0,
    "group:selected": (e) => !0,
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: l
    } = t;
    const {
      t: a
    } = pt(), {
      borderClasses: r
    } = Qn(e), {
      colorClasses: s,
      colorStyles: o,
      variantClasses: u
    } = Gl(e), {
      densityClasses: c
    } = nn(e), {
      elevationClasses: d
    } = Et(e), {
      roundedClasses: f
    } = gt(e), {
      sizeClasses: h
    } = Na(e), {
      themeClasses: g
    } = Xe(e), v = pe(e, "modelValue"), p = ea(e, C4, !1), O = rs(e, n), b = C(() => e.link !== !1 && O.isLink.value), V = C(() => !e.disabled && e.link !== !1 && (!!p || e.link || O.isClickable.value)), $ = C(() => ({
      "aria-label": a(e.closeLabel),
      onClick(M) {
        M.preventDefault(), M.stopPropagation(), v.value = !1, i("click:close", M);
      }
    }));
    function x(M) {
      var w;
      i("click", M), V.value && ((w = O.navigate) == null || w.call(O, M), p == null || p.toggle());
    }
    function Q(M) {
      (M.key === "Enter" || M.key === " ") && (M.preventDefault(), x(M));
    }
    return () => {
      const M = O.isLink.value ? "a" : e.tag, w = !!(e.appendIcon || e.appendAvatar), y = !!(w || l.append), L = !!(l.close || e.closable), k = !!(l.filter || e.filter) && p, S = !!(e.prependIcon || e.prependAvatar), P = !!(S || l.prepend), T = !p || p.isSelected.value;
      return v.value && Je(m(M, {
        class: ["v-chip", {
          "v-chip--disabled": e.disabled,
          "v-chip--label": e.label,
          "v-chip--link": V.value,
          "v-chip--filter": k,
          "v-chip--pill": e.pill
        }, g.value, r.value, T ? s.value : void 0, c.value, d.value, f.value, h.value, u.value, p == null ? void 0 : p.selectedClass.value, e.class],
        style: [T ? o.value : void 0, e.style],
        disabled: e.disabled || void 0,
        draggable: e.draggable,
        href: O.href.value,
        tabindex: V.value ? 0 : void 0,
        onClick: x,
        onKeydown: V.value && !b.value && Q
      }, {
        default: () => {
          var _;
          return [ol(V.value, "v-chip"), k && m($f, {
            key: "filter"
          }, {
            default: () => [Je(m("div", {
              class: "v-chip__filter"
            }, [l.filter ? m(Te, {
              key: "filter-defaults",
              disabled: !e.filterIcon,
              defaults: {
                VIcon: {
                  icon: e.filterIcon
                }
              }
            }, l.filter) : m(ze, {
              key: "filter-icon",
              icon: e.filterIcon
            }, null)]), [[xn, p.isSelected.value]])]
          }), P && m("div", {
            key: "prepend",
            class: "v-chip__prepend"
          }, [l.prepend ? m(Te, {
            key: "prepend-defaults",
            disabled: !S,
            defaults: {
              VAvatar: {
                image: e.prependAvatar,
                start: !0
              },
              VIcon: {
                icon: e.prependIcon,
                start: !0
              }
            }
          }, l.prepend) : m(le, null, [e.prependIcon && m(ze, {
            key: "prepend-icon",
            icon: e.prependIcon,
            start: !0
          }, null), e.prependAvatar && m(An, {
            key: "prepend-avatar",
            image: e.prependAvatar,
            start: !0
          }, null)])]), m("div", {
            class: "v-chip__content",
            "data-no-activator": ""
          }, [((_ = l.default) == null ? void 0 : _.call(l, {
            isSelected: p == null ? void 0 : p.isSelected.value,
            selectedClass: p == null ? void 0 : p.selectedClass.value,
            select: p == null ? void 0 : p.select,
            toggle: p == null ? void 0 : p.toggle,
            value: p == null ? void 0 : p.value.value,
            disabled: e.disabled
          })) ?? e.text]), y && m("div", {
            key: "append",
            class: "v-chip__append"
          }, [l.append ? m(Te, {
            key: "append-defaults",
            disabled: !w,
            defaults: {
              VAvatar: {
                end: !0,
                image: e.appendAvatar
              },
              VIcon: {
                end: !0,
                icon: e.appendIcon
              }
            }
          }, l.append) : m(le, null, [e.appendIcon && m(ze, {
            key: "append-icon",
            end: !0,
            icon: e.appendIcon
          }, null), e.appendAvatar && m(An, {
            key: "append-avatar",
            end: !0,
            image: e.appendAvatar
          }, null)])]), L && m("button", q({
            key: "close",
            class: "v-chip__close",
            type: "button"
          }, $.value), [l.close ? m(Te, {
            key: "close-defaults",
            defaults: {
              VIcon: {
                icon: e.closeIcon,
                size: "x-small"
              }
            }
          }, l.close) : m(ze, {
            key: "close-icon",
            icon: e.closeIcon,
            size: "x-small"
          }, null)])];
        }
      }), [[Pn("ripple"), V.value && e.ripple, null]]);
    };
  }
}), b1 = Symbol.for("vuetify:list");
function S4() {
  const e = Be(b1, {
    hasPrepend: ie(!1),
    updateHasPrepend: () => null
  }), t = {
    hasPrepend: ie(!1),
    updateHasPrepend: (n) => {
      n && (t.hasPrepend.value = n);
    }
  };
  return lt(b1, t), e;
}
function w4() {
  return Be(b1, null);
}
const Mf = (e) => {
  const t = {
    activate: (n) => {
      let {
        id: i,
        value: l,
        activated: a
      } = n;
      return i = nt(i), e && !l && a.size === 1 && a.has(i) || (l ? a.add(i) : a.delete(i)), a;
    },
    in: (n, i, l) => {
      let a = /* @__PURE__ */ new Set();
      if (n != null)
        for (const r of ut(n))
          a = t.activate({
            id: r,
            value: !0,
            activated: new Set(a),
            children: i,
            parents: l
          });
      return a;
    },
    out: (n) => Array.from(n)
  };
  return t;
}, k4 = (e) => {
  const t = Mf(e);
  return {
    activate: (i) => {
      let {
        activated: l,
        id: a,
        ...r
      } = i;
      a = nt(a);
      const s = l.has(a) ? /* @__PURE__ */ new Set([a]) : /* @__PURE__ */ new Set();
      return t.activate({
        ...r,
        id: a,
        activated: s
      });
    },
    in: (i, l, a) => {
      let r = /* @__PURE__ */ new Set();
      if (i != null) {
        const s = ut(i);
        s.length && (r = t.in(s.slice(0, 1), l, a));
      }
      return r;
    },
    out: (i, l, a) => t.out(i, l, a)
  };
}, Sb = (e) => {
  const t = Mf(e);
  return {
    activate: (i) => {
      let {
        id: l,
        activated: a,
        children: r,
        ...s
      } = i;
      return l = nt(l), r.has(l) ? a : t.activate({
        id: l,
        activated: a,
        children: r,
        ...s
      });
    },
    in: t.in,
    out: t.out
  };
}, wb = (e) => {
  const t = k4(e);
  return {
    activate: (i) => {
      let {
        id: l,
        activated: a,
        children: r,
        ...s
      } = i;
      return l = nt(l), r.has(l) ? a : t.activate({
        id: l,
        activated: a,
        children: r,
        ...s
      });
    },
    in: t.in,
    out: t.out
  };
}, kb = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: l
    } = e;
    if (n) {
      const a = /* @__PURE__ */ new Set();
      a.add(t);
      let r = l.get(t);
      for (; r != null; )
        a.add(r), r = l.get(r);
      return a;
    } else
      return i.delete(t), i;
  },
  select: () => null
}, x4 = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: l
    } = e;
    if (n) {
      let a = nt(l.get(t));
      for (i.add(t); a != null && a !== t; )
        i.add(a), a = nt(l.get(a));
      return i;
    } else
      i.delete(t);
    return i;
  },
  select: () => null
}, xb = {
  open: x4.open,
  select: (e) => {
    let {
      id: t,
      value: n,
      opened: i,
      parents: l
    } = e;
    if (!n) return i;
    const a = [];
    let r = l.get(t);
    for (; r != null; )
      a.push(r), r = l.get(r);
    return new Set(a);
  }
}, Tf = (e) => {
  const t = {
    select: (n) => {
      let {
        id: i,
        value: l,
        selected: a
      } = n;
      if (i = nt(i), e && !l) {
        const r = Array.from(a.entries()).reduce((s, o) => {
          let [u, c] = o;
          return c === "on" && s.push(u), s;
        }, []);
        if (r.length === 1 && r[0] === i) return a;
      }
      return a.set(i, l ? "on" : "off"), a;
    },
    in: (n, i, l) => {
      let a = /* @__PURE__ */ new Map();
      for (const r of n || [])
        a = t.select({
          id: r,
          value: !0,
          selected: new Map(a),
          children: i,
          parents: l
        });
      return a;
    },
    out: (n) => {
      const i = [];
      for (const [l, a] of n.entries())
        a === "on" && i.push(l);
      return i;
    }
  };
  return t;
}, P4 = (e) => {
  const t = Tf(e);
  return {
    select: (i) => {
      let {
        selected: l,
        id: a,
        ...r
      } = i;
      a = nt(a);
      const s = l.has(a) ? /* @__PURE__ */ new Map([[a, l.get(a)]]) : /* @__PURE__ */ new Map();
      return t.select({
        ...r,
        id: a,
        selected: s
      });
    },
    in: (i, l, a) => {
      let r = /* @__PURE__ */ new Map();
      return i != null && i.length && (r = t.in(i.slice(0, 1), l, a)), r;
    },
    out: (i, l, a) => t.out(i, l, a)
  };
}, Pb = (e) => {
  const t = Tf(e);
  return {
    select: (i) => {
      let {
        id: l,
        selected: a,
        children: r,
        ...s
      } = i;
      return l = nt(l), r.has(l) ? a : t.select({
        id: l,
        selected: a,
        children: r,
        ...s
      });
    },
    in: t.in,
    out: t.out
  };
}, $b = (e) => {
  const t = P4(e);
  return {
    select: (i) => {
      let {
        id: l,
        selected: a,
        children: r,
        ...s
      } = i;
      return l = nt(l), r.has(l) ? a : t.select({
        id: l,
        selected: a,
        children: r,
        ...s
      });
    },
    in: t.in,
    out: t.out
  };
}, Vb = (e) => {
  const t = {
    select: (n) => {
      let {
        id: i,
        value: l,
        selected: a,
        children: r,
        parents: s
      } = n;
      i = nt(i);
      const o = new Map(a), u = [i];
      for (; u.length; ) {
        const d = u.shift();
        a.set(nt(d), l ? "on" : "off"), r.has(d) && u.push(...r.get(d));
      }
      let c = nt(s.get(i));
      for (; c; ) {
        const d = r.get(c), f = d.every((g) => a.get(nt(g)) === "on"), h = d.every((g) => !a.has(nt(g)) || a.get(nt(g)) === "off");
        a.set(c, f ? "on" : h ? "off" : "indeterminate"), c = nt(s.get(c));
      }
      return e && !l && Array.from(a.entries()).reduce((f, h) => {
        let [g, v] = h;
        return v === "on" && f.push(g), f;
      }, []).length === 0 ? o : a;
    },
    in: (n, i, l) => {
      let a = /* @__PURE__ */ new Map();
      for (const r of n || [])
        a = t.select({
          id: r,
          value: !0,
          selected: new Map(a),
          children: i,
          parents: l
        });
      return a;
    },
    out: (n, i) => {
      const l = [];
      for (const [a, r] of n.entries())
        r === "on" && !i.has(a) && l.push(a);
      return l;
    }
  };
  return t;
}, Zr = Symbol.for("vuetify:nested"), $4 = {
  id: ie(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: z(/* @__PURE__ */ new Map()),
    children: z(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    activate: () => null,
    select: () => null,
    activatable: z(!1),
    selectable: z(!1),
    opened: z(/* @__PURE__ */ new Set()),
    activated: z(/* @__PURE__ */ new Set()),
    selected: z(/* @__PURE__ */ new Map()),
    selectedValues: z([])
  }
}, Qb = B({
  activatable: Boolean,
  selectable: Boolean,
  activeStrategy: [String, Function, Object],
  selectStrategy: [String, Function, Object],
  openStrategy: [String, Object],
  opened: null,
  activated: null,
  selected: null,
  mandatory: Boolean
}, "nested"), Lb = (e) => {
  let t = !1;
  const n = z(/* @__PURE__ */ new Map()), i = z(/* @__PURE__ */ new Map()), l = pe(e, "opened", e.opened, (h) => new Set(nt(h)), (h) => [...h.values()]), a = C(() => {
    if (typeof e.activeStrategy == "object") return e.activeStrategy;
    if (typeof e.activeStrategy == "function") return e.activeStrategy(e.mandatory);
    switch (e.activeStrategy) {
      case "leaf":
        return Sb(e.mandatory);
      case "single-leaf":
        return wb(e.mandatory);
      case "independent":
        return Mf(e.mandatory);
      case "single-independent":
      default:
        return k4(e.mandatory);
    }
  }), r = C(() => {
    if (typeof e.selectStrategy == "object") return e.selectStrategy;
    if (typeof e.selectStrategy == "function") return e.selectStrategy(e.mandatory);
    switch (e.selectStrategy) {
      case "single-leaf":
        return $b(e.mandatory);
      case "leaf":
        return Pb(e.mandatory);
      case "independent":
        return Tf(e.mandatory);
      case "single-independent":
        return P4(e.mandatory);
      case "classic":
      default:
        return Vb(e.mandatory);
    }
  }), s = C(() => {
    if (typeof e.openStrategy == "object") return e.openStrategy;
    switch (e.openStrategy) {
      case "list":
        return xb;
      case "single":
        return kb;
      case "multiple":
      default:
        return x4;
    }
  }), o = pe(e, "activated", e.activated, (h) => a.value.in(h, n.value, i.value), (h) => a.value.out(h, n.value, i.value)), u = pe(e, "selected", e.selected, (h) => r.value.in(h, n.value, i.value), (h) => r.value.out(h, n.value, i.value));
  Wt(() => {
    t = !0;
  });
  function c(h) {
    const g = [];
    let v = h;
    for (; v != null; )
      g.unshift(v), v = i.value.get(v);
    return g;
  }
  const d = mt("nested"), f = {
    id: ie(),
    root: {
      opened: l,
      activatable: H(e, "activatable"),
      selectable: H(e, "selectable"),
      activated: o,
      selected: u,
      selectedValues: C(() => {
        const h = [];
        for (const [g, v] of u.value.entries())
          v === "on" && h.push(g);
        return h;
      }),
      register: (h, g, v) => {
        g && h !== g && i.value.set(h, g), v && n.value.set(h, []), g != null && n.value.set(g, [...n.value.get(g) || [], h]);
      },
      unregister: (h) => {
        if (t) return;
        n.value.delete(h);
        const g = i.value.get(h);
        if (g) {
          const v = n.value.get(g) ?? [];
          n.value.set(g, v.filter((p) => p !== h));
        }
        i.value.delete(h);
      },
      open: (h, g, v) => {
        d.emit("click:open", {
          id: h,
          value: g,
          path: c(h),
          event: v
        });
        const p = s.value.open({
          id: h,
          value: g,
          opened: new Set(l.value),
          children: n.value,
          parents: i.value,
          event: v
        });
        p && (l.value = p);
      },
      openOnSelect: (h, g, v) => {
        const p = s.value.select({
          id: h,
          value: g,
          selected: new Map(u.value),
          opened: new Set(l.value),
          children: n.value,
          parents: i.value,
          event: v
        });
        p && (l.value = p);
      },
      select: (h, g, v) => {
        d.emit("click:select", {
          id: h,
          value: g,
          path: c(h),
          event: v
        });
        const p = r.value.select({
          id: h,
          value: g,
          selected: new Map(u.value),
          children: n.value,
          parents: i.value,
          event: v
        });
        p && (u.value = p), f.root.openOnSelect(h, g, v);
      },
      activate: (h, g, v) => {
        if (!e.activatable)
          return f.root.select(h, !0, v);
        d.emit("click:activate", {
          id: h,
          value: g,
          path: c(h),
          event: v
        });
        const p = a.value.activate({
          id: h,
          value: g,
          activated: new Set(o.value),
          children: n.value,
          parents: i.value,
          event: v
        });
        p && (o.value = p);
      },
      children: n,
      parents: i
    }
  };
  return lt(Zr, f), f.root;
}, V4 = (e, t) => {
  const n = Be(Zr, $4), i = Symbol(Bt()), l = C(() => e.value !== void 0 ? e.value : i), a = {
    ...n,
    id: l,
    open: (r, s) => n.root.open(nt(l.value), r, s),
    openOnSelect: (r, s) => n.root.openOnSelect(l.value, r, s),
    isOpen: C(() => n.root.opened.value.has(nt(l.value))),
    parent: C(() => n.root.parents.value.get(l.value)),
    activate: (r, s) => n.root.activate(l.value, r, s),
    isActivated: C(() => n.root.activated.value.has(nt(l.value))),
    select: (r, s) => n.root.select(l.value, r, s),
    isSelected: C(() => n.root.selected.value.get(nt(l.value)) === "on"),
    isIndeterminate: C(() => n.root.selected.value.get(l.value) === "indeterminate"),
    isLeaf: C(() => !n.root.children.value.get(l.value)),
    isGroupActivator: n.isGroupActivator
  };
  return !n.isGroupActivator && n.root.register(l.value, n.id.value, t), Wt(() => {
    !n.isGroupActivator && n.root.unregister(l.value);
  }), t && lt(Zr, a), a;
}, Mb = () => {
  const e = Be(Zr, $4);
  lt(Zr, {
    ...e,
    isGroupActivator: !0
  });
}, Tb = $n({
  name: "VListGroupActivator",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Mb(), () => {
      var i;
      return (i = n.default) == null ? void 0 : i.call(n);
    };
  }
}), _b = B({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: Se,
    default: "$collapse"
  },
  expandIcon: {
    type: Se,
    default: "$expand"
  },
  prependIcon: Se,
  appendIcon: Se,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...ue(),
  ...Ve()
}, "VListGroup"), C1 = X()({
  name: "VListGroup",
  props: _b(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isOpen: i,
      open: l,
      id: a
    } = V4(H(e, "value"), !0), r = C(() => `v-list-group--id-${String(a.value)}`), s = w4(), {
      isBooted: o
    } = Ul();
    function u(h) {
      h.stopPropagation(), l(!i.value, h);
    }
    const c = C(() => ({
      onClick: u,
      class: "v-list-group__header",
      id: r.value
    })), d = C(() => i.value ? e.collapseIcon : e.expandIcon), f = C(() => ({
      VListItem: {
        active: i.value,
        activeColor: e.activeColor,
        baseColor: e.baseColor,
        color: e.color,
        prependIcon: e.prependIcon || e.subgroup && d.value,
        appendIcon: e.appendIcon || !e.subgroup && d.value,
        title: e.title,
        value: e.value
      }
    }));
    return F(() => m(e.tag, {
      class: ["v-list-group", {
        "v-list-group--prepend": s == null ? void 0 : s.hasPrepend.value,
        "v-list-group--fluid": e.fluid,
        "v-list-group--subgroup": e.subgroup,
        "v-list-group--open": i.value
      }, e.class],
      style: e.style
    }, {
      default: () => [n.activator && m(Te, {
        defaults: f.value
      }, {
        default: () => [m(Tb, null, {
          default: () => [n.activator({
            props: c.value,
            isOpen: i.value
          })]
        })]
      }), m(en, {
        transition: {
          component: Cu
        },
        disabled: !o.value
      }, {
        default: () => {
          var h;
          return [Je(m("div", {
            class: "v-list-group__items",
            role: "group",
            "aria-labelledby": r.value
          }, [(h = n.default) == null ? void 0 : h.call(n)]), [[xn, i.value]])];
        }
      })]
    })), {
      isOpen: i
    };
  }
}), Ab = B({
  opacity: [Number, String],
  ...ue(),
  ...Ve()
}, "VListItemSubtitle"), Q4 = X()({
  name: "VListItemSubtitle",
  props: Ab(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => m(e.tag, {
      class: ["v-list-item-subtitle", e.class],
      style: [{
        "--v-list-item-subtitle-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), L4 = Oi("v-list-item-title"), Rb = B({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: Se,
  baseColor: String,
  disabled: Boolean,
  lines: [Boolean, String],
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: Se,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  slim: Boolean,
  subtitle: [String, Number],
  title: [String, Number],
  value: null,
  onClick: Dt(),
  onClickOnce: Dt(),
  ...yn(),
  ...ue(),
  ...Zt(),
  ...wt(),
  ...Lt(),
  ...at(),
  ...ss(),
  ...Ve(),
  ...Ie(),
  ...En({
    variant: "text"
  })
}, "VListItem"), Qi = X()({
  name: "VListItem",
  directives: {
    Ripple: Ti
  },
  props: Rb(),
  emits: {
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i,
      emit: l
    } = t;
    const a = rs(e, n), r = C(() => e.value === void 0 ? a.href.value : e.value), {
      activate: s,
      isActivated: o,
      select: u,
      isOpen: c,
      isSelected: d,
      isIndeterminate: f,
      isGroupActivator: h,
      root: g,
      parent: v,
      openOnSelect: p
    } = V4(r, !1), O = w4(), b = C(() => {
      var Z;
      return e.active !== !1 && (e.active || ((Z = a.isActive) == null ? void 0 : Z.value) || (g.activatable.value ? o.value : d.value));
    }), V = C(() => e.link !== !1 && a.isLink.value), $ = C(() => !e.disabled && e.link !== !1 && (e.link || a.isClickable.value || !!O && (g.selectable.value || g.activatable.value || e.value != null))), x = C(() => e.rounded || e.nav), Q = C(() => e.color ?? e.activeColor), M = C(() => ({
      color: b.value ? Q.value ?? e.baseColor : e.baseColor,
      variant: e.variant
    }));
    ee(() => {
      var Z;
      return (Z = a.isActive) == null ? void 0 : Z.value;
    }, (Z) => {
      Z && v.value != null && g.open(v.value, !0), Z && p(Z);
    }, {
      immediate: !0
    });
    const {
      themeClasses: w
    } = Xe(e), {
      borderClasses: y
    } = Qn(e), {
      colorClasses: L,
      colorStyles: k,
      variantClasses: S
    } = Gl(M), {
      densityClasses: P
    } = nn(e), {
      dimensionStyles: T
    } = kt(e), {
      elevationClasses: _
    } = Et(e), {
      roundedClasses: D
    } = gt(x), N = C(() => e.lines ? `v-list-item--${e.lines}-line` : void 0), K = C(() => ({
      isActive: b.value,
      select: u,
      isOpen: c.value,
      isSelected: d.value,
      isIndeterminate: f.value
    }));
    function E(Z) {
      var Y;
      l("click", Z), $.value && ((Y = a.navigate) == null || Y.call(a, Z), !h && (g.activatable.value ? s(!o.value, Z) : (g.selectable.value || e.value != null) && u(!d.value, Z)));
    }
    function I(Z) {
      (Z.key === "Enter" || Z.key === " ") && (Z.preventDefault(), Z.target.dispatchEvent(new MouseEvent("click", Z)));
    }
    return F(() => {
      const Z = V.value ? "a" : e.tag, Y = i.title || e.title != null, ce = i.subtitle || e.subtitle != null, de = !!(e.appendAvatar || e.appendIcon), ye = !!(de || i.append), U = !!(e.prependAvatar || e.prependIcon), ge = !!(U || i.prepend);
      return O == null || O.updateHasPrepend(ge), e.activeColor && K7("active-color", ["color", "base-color"]), Je(m(Z, {
        class: ["v-list-item", {
          "v-list-item--active": b.value,
          "v-list-item--disabled": e.disabled,
          "v-list-item--link": $.value,
          "v-list-item--nav": e.nav,
          "v-list-item--prepend": !ge && (O == null ? void 0 : O.hasPrepend.value),
          "v-list-item--slim": e.slim,
          [`${e.activeClass}`]: e.activeClass && b.value
        }, w.value, y.value, L.value, P.value, _.value, N.value, D.value, S.value, e.class],
        style: [k.value, T.value, e.style],
        href: a.href.value,
        tabindex: $.value ? O ? -2 : 0 : void 0,
        onClick: E,
        onKeydown: $.value && !V.value && I
      }, {
        default: () => {
          var be;
          return [ol($.value || b.value, "v-list-item"), ge && m("div", {
            key: "prepend",
            class: "v-list-item__prepend"
          }, [i.prepend ? m(Te, {
            key: "prepend-defaults",
            disabled: !U,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.prependAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.prependIcon
              },
              VListItemAction: {
                start: !0
              }
            }
          }, {
            default: () => {
              var De;
              return [(De = i.prepend) == null ? void 0 : De.call(i, K.value)];
            }
          }) : m(le, null, [e.prependAvatar && m(An, {
            key: "prepend-avatar",
            density: e.density,
            image: e.prependAvatar
          }, null), e.prependIcon && m(ze, {
            key: "prepend-icon",
            density: e.density,
            icon: e.prependIcon
          }, null)]), m("div", {
            class: "v-list-item__spacer"
          }, null)]), m("div", {
            class: "v-list-item__content",
            "data-no-activator": ""
          }, [Y && m(L4, {
            key: "title"
          }, {
            default: () => {
              var De;
              return [((De = i.title) == null ? void 0 : De.call(i, {
                title: e.title
              })) ?? e.title];
            }
          }), ce && m(Q4, {
            key: "subtitle"
          }, {
            default: () => {
              var De;
              return [((De = i.subtitle) == null ? void 0 : De.call(i, {
                subtitle: e.subtitle
              })) ?? e.subtitle];
            }
          }), (be = i.default) == null ? void 0 : be.call(i, K.value)]), ye && m("div", {
            key: "append",
            class: "v-list-item__append"
          }, [i.append ? m(Te, {
            key: "append-defaults",
            disabled: !de,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.appendAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.appendIcon
              },
              VListItemAction: {
                end: !0
              }
            }
          }, {
            default: () => {
              var De;
              return [(De = i.append) == null ? void 0 : De.call(i, K.value)];
            }
          }) : m(le, null, [e.appendIcon && m(ze, {
            key: "append-icon",
            density: e.density,
            icon: e.appendIcon
          }, null), e.appendAvatar && m(An, {
            key: "append-avatar",
            density: e.density,
            image: e.appendAvatar
          }, null)]), m("div", {
            class: "v-list-item__spacer"
          }, null)])];
        }
      }), [[Pn("ripple"), $.value && e.ripple]]);
    }), {
      activate: s,
      isActivated: o,
      isGroupActivator: h,
      isSelected: d,
      list: O,
      select: u
    };
  }
}), Zb = B({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...ue(),
  ...Ve()
}, "VListSubheader"), M4 = X()({
  name: "VListSubheader",
  props: Zb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: i,
      textColorStyles: l
    } = Yt(H(e, "color"));
    return F(() => {
      const a = !!(n.default || e.title);
      return m(e.tag, {
        class: ["v-list-subheader", {
          "v-list-subheader--inset": e.inset,
          "v-list-subheader--sticky": e.sticky
        }, i.value, e.class],
        style: [{
          textColorStyles: l
        }, e.style]
      }, {
        default: () => {
          var r;
          return [a && m("div", {
            class: "v-list-subheader__text"
          }, [((r = n.default) == null ? void 0 : r.call(n)) ?? e.title])];
        }
      });
    }), {};
  }
}), Ib = B({
  color: String,
  inset: Boolean,
  length: [Number, String],
  opacity: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...ue(),
  ...Ie()
}, "VDivider"), fs = X()({
  name: "VDivider",
  props: Ib(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: l
    } = Xe(e), {
      textColorClasses: a,
      textColorStyles: r
    } = Yt(H(e, "color")), s = C(() => {
      const o = {};
      return e.length && (o[e.vertical ? "height" : "width"] = se(e.length)), e.thickness && (o[e.vertical ? "borderRightWidth" : "borderTopWidth"] = se(e.thickness)), o;
    });
    return F(() => {
      const o = m("hr", {
        class: [{
          "v-divider": !0,
          "v-divider--inset": e.inset,
          "v-divider--vertical": e.vertical
        }, l.value, a.value, e.class],
        style: [s.value, r.value, {
          "--v-border-opacity": e.opacity
        }, e.style],
        "aria-orientation": !n.role || n.role === "separator" ? e.vertical ? "vertical" : "horizontal" : void 0,
        role: `${n.role || "separator"}`
      }, null);
      return i.default ? m("div", {
        class: ["v-divider__wrapper", {
          "v-divider__wrapper--vertical": e.vertical,
          "v-divider__wrapper--inset": e.inset
        }]
      }, [o, m("div", {
        class: "v-divider__content"
      }, [i.default()]), o]) : o;
    }), {};
  }
}), Db = B({
  items: Array,
  returnObject: Boolean
}, "VListChildren"), T4 = X()({
  name: "VListChildren",
  props: Db(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return S4(), () => {
      var i, l;
      return ((i = n.default) == null ? void 0 : i.call(n)) ?? ((l = e.items) == null ? void 0 : l.map((a) => {
        var f, h;
        let {
          children: r,
          props: s,
          type: o,
          raw: u
        } = a;
        if (o === "divider")
          return ((f = n.divider) == null ? void 0 : f.call(n, {
            props: s
          })) ?? m(fs, s, null);
        if (o === "subheader")
          return ((h = n.subheader) == null ? void 0 : h.call(n, {
            props: s
          })) ?? m(M4, s, null);
        const c = {
          subtitle: n.subtitle ? (g) => {
            var v;
            return (v = n.subtitle) == null ? void 0 : v.call(n, {
              ...g,
              item: u
            });
          } : void 0,
          prepend: n.prepend ? (g) => {
            var v;
            return (v = n.prepend) == null ? void 0 : v.call(n, {
              ...g,
              item: u
            });
          } : void 0,
          append: n.append ? (g) => {
            var v;
            return (v = n.append) == null ? void 0 : v.call(n, {
              ...g,
              item: u
            });
          } : void 0,
          title: n.title ? (g) => {
            var v;
            return (v = n.title) == null ? void 0 : v.call(n, {
              ...g,
              item: u
            });
          } : void 0
        }, d = C1.filterProps(s);
        return r ? m(C1, q({
          value: s == null ? void 0 : s.value
        }, d), {
          activator: (g) => {
            let {
              props: v
            } = g;
            const p = {
              ...s,
              ...v,
              value: e.returnObject ? u : s.value
            };
            return n.header ? n.header({
              props: p
            }) : m(Qi, p, c);
          },
          default: () => m(T4, {
            items: r,
            returnObject: e.returnObject
          }, n)
        }) : n.item ? n.item({
          props: s
        }) : m(Qi, q(s, {
          value: e.returnObject ? u : s.value
        }), c);
      }));
    };
  }
}), _4 = B({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean,
  valueComparator: {
    type: Function,
    default: vi
  }
}, "list-items");
function Hi(e, t) {
  const n = Pt(t, e.itemTitle, t), i = Pt(t, e.itemValue, n), l = Pt(t, e.itemChildren), a = e.itemProps === !0 ? typeof t == "object" && t != null && !Array.isArray(t) ? "children" in t ? St(t, ["children"]) : t : void 0 : Pt(t, e.itemProps), r = {
    title: n,
    value: i,
    ...a
  };
  return {
    title: String(r.title ?? ""),
    value: r.value,
    props: r,
    children: Array.isArray(l) ? A4(e, l) : void 0,
    raw: t
  };
}
function A4(e, t) {
  const n = [];
  for (const i of t)
    n.push(Hi(e, i));
  return n;
}
function _f(e) {
  const t = C(() => A4(e, e.items)), n = C(() => t.value.some((a) => a.value === null));
  function i(a) {
    return n.value || (a = a.filter((r) => r !== null)), a.map((r) => e.returnObject && typeof r == "string" ? Hi(e, r) : t.value.find((s) => e.valueComparator(r, s.value)) || Hi(e, r));
  }
  function l(a) {
    return e.returnObject ? a.map((r) => {
      let {
        raw: s
      } = r;
      return s;
    }) : a.map((r) => {
      let {
        value: s
      } = r;
      return s;
    });
  }
  return {
    items: t,
    transformIn: i,
    transformOut: l
  };
}
function Bb(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean";
}
function Eb(e, t) {
  const n = Pt(t, e.itemType, "item"), i = Bb(t) ? t : Pt(t, e.itemTitle), l = Pt(t, e.itemValue, void 0), a = Pt(t, e.itemChildren), r = e.itemProps === !0 ? St(t, ["children"]) : Pt(t, e.itemProps), s = {
    title: i,
    value: l,
    ...r
  };
  return {
    type: n,
    title: s.title,
    value: s.value,
    props: s,
    children: n === "item" && a ? R4(e, a) : void 0,
    raw: t
  };
}
function R4(e, t) {
  const n = [];
  for (const i of t)
    n.push(Eb(e, i));
  return n;
}
function zb(e) {
  return {
    items: C(() => R4(e, e.items))
  };
}
const Hb = B({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  expandIcon: String,
  collapseIcon: String,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  slim: Boolean,
  nav: Boolean,
  "onClick:open": Dt(),
  "onClick:select": Dt(),
  "onUpdate:opened": Dt(),
  ...Qb({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...yn(),
  ...ue(),
  ...Zt(),
  ...wt(),
  ...Lt(),
  itemType: {
    type: String,
    default: "type"
  },
  ..._4(),
  ...at(),
  ...Ve(),
  ...Ie(),
  ...En({
    variant: "text"
  })
}, "VList"), Vu = X()({
  name: "VList",
  props: Hb(),
  emits: {
    "update:selected": (e) => !0,
    "update:activated": (e) => !0,
    "update:opened": (e) => !0,
    "click:open": (e) => !0,
    "click:activate": (e) => !0,
    "click:select": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: i
    } = zb(e), {
      themeClasses: l
    } = Xe(e), {
      backgroundColorClasses: a,
      backgroundColorStyles: r
    } = Fe(H(e, "bgColor")), {
      borderClasses: s
    } = Qn(e), {
      densityClasses: o
    } = nn(e), {
      dimensionStyles: u
    } = kt(e), {
      elevationClasses: c
    } = Et(e), {
      roundedClasses: d
    } = gt(e), {
      children: f,
      open: h,
      parents: g,
      select: v
    } = Lb(e), p = C(() => e.lines ? `v-list--${e.lines}-line` : void 0), O = H(e, "activeColor"), b = H(e, "baseColor"), V = H(e, "color");
    S4(), ht({
      VListGroup: {
        activeColor: O,
        baseColor: b,
        color: V,
        expandIcon: H(e, "expandIcon"),
        collapseIcon: H(e, "collapseIcon")
      },
      VListItem: {
        activeClass: H(e, "activeClass"),
        activeColor: O,
        baseColor: b,
        color: V,
        density: H(e, "density"),
        disabled: H(e, "disabled"),
        lines: H(e, "lines"),
        nav: H(e, "nav"),
        slim: H(e, "slim"),
        variant: H(e, "variant")
      }
    });
    const $ = ie(!1), x = z();
    function Q(S) {
      $.value = !0;
    }
    function M(S) {
      $.value = !1;
    }
    function w(S) {
      var P;
      !$.value && !(S.relatedTarget && ((P = x.value) != null && P.contains(S.relatedTarget))) && k();
    }
    function y(S) {
      const P = S.target;
      if (!(!x.value || ["INPUT", "TEXTAREA"].includes(P.tagName))) {
        if (S.key === "ArrowDown")
          k("next");
        else if (S.key === "ArrowUp")
          k("prev");
        else if (S.key === "Home")
          k("first");
        else if (S.key === "End")
          k("last");
        else
          return;
        S.preventDefault();
      }
    }
    function L(S) {
      $.value = !0;
    }
    function k(S) {
      if (x.value)
        return Pl(x.value, S);
    }
    return F(() => m(e.tag, {
      ref: x,
      class: ["v-list", {
        "v-list--disabled": e.disabled,
        "v-list--nav": e.nav,
        "v-list--slim": e.slim
      }, l.value, a.value, s.value, o.value, c.value, p.value, d.value, e.class],
      style: [r.value, u.value, e.style],
      tabindex: e.disabled || $.value ? -1 : 0,
      role: "listbox",
      "aria-activedescendant": void 0,
      onFocusin: Q,
      onFocusout: M,
      onFocus: w,
      onKeydown: y,
      onMousedown: L
    }, {
      default: () => [m(T4, {
        items: i.value,
        returnObject: e.returnObject
      }, n)]
    })), {
      open: h,
      select: v,
      focus: k,
      children: f,
      parents: g
    };
  }
}), jb = Oi("v-list-img"), Xb = B({
  start: Boolean,
  end: Boolean,
  ...ue(),
  ...Ve()
}, "VListItemAction"), Nb = X()({
  name: "VListItemAction",
  props: Xb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => m(e.tag, {
      class: ["v-list-item-action", {
        "v-list-item-action--start": e.start,
        "v-list-item-action--end": e.end
      }, e.class],
      style: e.style
    }, n)), {};
  }
}), qb = B({
  start: Boolean,
  end: Boolean,
  ...ue(),
  ...Ve()
}, "VListItemMedia"), Yb = X()({
  name: "VListItemMedia",
  props: qb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => m(e.tag, {
      class: ["v-list-item-media", {
        "v-list-item-media--start": e.start,
        "v-list-item-media--end": e.end
      }, e.class],
      style: e.style
    }, n)), {};
  }
}), Z4 = B({
  // TODO
  // disableKeys: Boolean,
  id: String,
  submenu: Boolean,
  ...St(os({
    closeDelay: 250,
    closeOnContentClick: !0,
    locationStrategy: "connected",
    location: void 0,
    openDelay: 300,
    scrim: !1,
    scrollStrategy: "reposition",
    transition: {
      component: bu
    }
  }), ["absolute"])
}, "VMenu"), La = X()({
  name: "VMenu",
  props: Z4(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), {
      scopeId: l
    } = Wl(), {
      isRtl: a
    } = Qt(), r = Bt(), s = C(() => e.id || `v-menu-${r}`), o = z(), u = Be(v1, null), c = ie(/* @__PURE__ */ new Set());
    lt(v1, {
      register() {
        c.value.add(r);
      },
      unregister() {
        c.value.delete(r);
      },
      closeParents(p) {
        setTimeout(() => {
          var O;
          !c.value.size && !e.persistent && (p == null || (O = o.value) != null && O.contentEl && !z7(p, o.value.contentEl)) && (i.value = !1, u == null || u.closeParents());
        }, 40);
      }
    }), Wt(() => u == null ? void 0 : u.unregister()), H9(() => i.value = !1);
    async function d(p) {
      var V, $, x;
      const O = p.relatedTarget, b = p.target;
      await He(), i.value && O !== b && ((V = o.value) != null && V.contentEl) && // We're the topmost menu
      (($ = o.value) != null && $.globalTop) && // It isn't the document or the menu body
      ![document, o.value.contentEl].includes(b) && // It isn't inside the menu body
      !o.value.contentEl.contains(b) && ((x = $r(o.value.contentEl)[0]) == null || x.focus());
    }
    ee(i, (p) => {
      p ? (u == null || u.register(), document.addEventListener("focusin", d, {
        once: !0
      })) : (u == null || u.unregister(), document.removeEventListener("focusin", d));
    });
    function f(p) {
      u == null || u.closeParents(p);
    }
    function h(p) {
      var O, b, V, $, x;
      if (!e.disabled)
        if (p.key === "Tab" || p.key === "Enter" && !e.closeOnContentClick) {
          if (p.key === "Enter" && (p.target instanceof HTMLTextAreaElement || p.target instanceof HTMLInputElement && p.target.closest("form"))) return;
          p.key === "Enter" && p.preventDefault(), J9($r((O = o.value) == null ? void 0 : O.contentEl, !1), p.shiftKey ? "prev" : "next", (M) => M.tabIndex >= 0) || (i.value = !1, (V = (b = o.value) == null ? void 0 : b.activatorEl) == null || V.focus());
        } else e.submenu && p.key === (a.value ? "ArrowRight" : "ArrowLeft") && (i.value = !1, (x = ($ = o.value) == null ? void 0 : $.activatorEl) == null || x.focus());
    }
    function g(p) {
      var b;
      if (e.disabled) return;
      const O = (b = o.value) == null ? void 0 : b.contentEl;
      O && i.value ? p.key === "ArrowDown" ? (p.preventDefault(), p.stopImmediatePropagation(), Pl(O, "next")) : p.key === "ArrowUp" ? (p.preventDefault(), p.stopImmediatePropagation(), Pl(O, "prev")) : e.submenu && (p.key === (a.value ? "ArrowRight" : "ArrowLeft") ? i.value = !1 : p.key === (a.value ? "ArrowLeft" : "ArrowRight") && (p.preventDefault(), Pl(O, "first"))) : (e.submenu ? p.key === (a.value ? "ArrowLeft" : "ArrowRight") : ["ArrowDown", "ArrowUp"].includes(p.key)) && (i.value = !0, p.preventDefault(), setTimeout(() => setTimeout(() => g(p))));
    }
    const v = C(() => q({
      "aria-haspopup": "menu",
      "aria-expanded": String(i.value),
      "aria-owns": s.value,
      onKeydown: g
    }, e.activatorProps));
    return F(() => {
      const p = Fn.filterProps(e);
      return m(Fn, q({
        ref: o,
        id: s.value,
        class: ["v-menu", e.class],
        style: e.style
      }, p, {
        modelValue: i.value,
        "onUpdate:modelValue": (O) => i.value = O,
        absolute: !0,
        activatorProps: v.value,
        location: e.location ?? (e.submenu ? "end" : "bottom"),
        "onClick:outside": f,
        onKeydown: h
      }, l), {
        activator: n.activator,
        default: function() {
          for (var O = arguments.length, b = new Array(O), V = 0; V < O; V++)
            b[V] = arguments[V];
          return m(Te, {
            root: "VMenu"
          }, {
            default: () => {
              var $;
              return [($ = n.default) == null ? void 0 : $.call(n, ...b)];
            }
          });
        }
      });
    }), Bn({
      id: s,
      openChildren: c
    }, o);
  }
}), Fb = B({
  active: Boolean,
  disabled: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...ue(),
  ...Gn({
    transition: {
      component: Pf
    }
  })
}, "VCounter"), Qu = X()({
  name: "VCounter",
  functional: !0,
  props: Fb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = C(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
    return F(() => m(en, {
      transition: e.transition
    }, {
      default: () => [Je(m("div", {
        class: ["v-counter", {
          "text-error": e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max)
        }, e.class],
        style: e.style
      }, [n.default ? n.default({
        counter: i.value,
        max: e.max,
        value: e.value
      }) : i.value]), [[xn, e.active]])]
    })), {};
  }
}), Wb = B({
  floating: Boolean,
  ...ue()
}, "VFieldLabel"), fr = X()({
  name: "VFieldLabel",
  props: Wb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => m(Fa, {
      class: ["v-field-label", {
        "v-field-label--floating": e.floating
      }, e.class],
      style: e.style,
      "aria-hidden": e.floating || void 0
    }, n)), {};
  }
}), Ub = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], hs = B({
  appendInnerIcon: Se,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: Se,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  flat: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: Se,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (e) => Ub.includes(e)
  },
  "onClick:clear": Dt(),
  "onClick:appendInner": Dt(),
  "onClick:prependInner": Dt(),
  ...ue(),
  ...ku(),
  ...at(),
  ...Ie()
}, "VField"), Ua = X()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    ...ds(),
    ...hs()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: l
    } = t;
    const {
      themeClasses: a
    } = Xe(e), {
      loaderClasses: r
    } = us(e), {
      focusClasses: s,
      isFocused: o,
      focus: u,
      blur: c
    } = Ai(e), {
      InputIcon: d
    } = h4(e), {
      roundedClasses: f
    } = gt(e), {
      rtlClasses: h
    } = Qt(), g = C(() => e.dirty || e.active), v = C(() => !e.singleLine && !!(e.label || l.label)), p = Bt(), O = C(() => e.id || `input-${p}`), b = C(() => `${O.value}-messages`), V = z(), $ = z(), x = z(), Q = C(() => ["plain", "underlined"].includes(e.variant)), {
      backgroundColorClasses: M,
      backgroundColorStyles: w
    } = Fe(H(e, "bgColor")), {
      textColorClasses: y,
      textColorStyles: L
    } = Yt(C(() => e.error || e.disabled ? void 0 : g.value && o.value ? e.color : e.baseColor));
    ee(g, (T) => {
      if (v.value) {
        const _ = V.value.$el, D = $.value.$el;
        requestAnimationFrame(() => {
          const N = uf(_), K = D.getBoundingClientRect(), E = K.x - N.x, I = K.y - N.y - (N.height / 2 - K.height / 2), Z = K.width / 0.75, Y = Math.abs(Z - N.width) > 1 ? {
            maxWidth: se(Z)
          } : void 0, ce = getComputedStyle(_), de = getComputedStyle(D), ye = parseFloat(ce.transitionDuration) * 1e3 || 150, U = parseFloat(de.getPropertyValue("--v-field-label-scale")), ge = de.getPropertyValue("color");
          _.style.visibility = "visible", D.style.visibility = "hidden", Cl(_, {
            transform: `translate(${E}px, ${I}px) scale(${U})`,
            color: ge,
            ...Y
          }, {
            duration: ye,
            easing: Vr,
            direction: T ? "normal" : "reverse"
          }).finished.then(() => {
            _.style.removeProperty("visibility"), D.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const k = C(() => ({
      isActive: g,
      isFocused: o,
      controlRef: x,
      blur: c,
      focus: u
    }));
    function S(T) {
      T.target !== document.activeElement && T.preventDefault();
    }
    function P(T) {
      var _;
      T.key !== "Enter" && T.key !== " " || (T.preventDefault(), T.stopPropagation(), (_ = e["onClick:clear"]) == null || _.call(e, new MouseEvent("click")));
    }
    return F(() => {
      var E, I, Z;
      const T = e.variant === "outlined", _ = !!(l["prepend-inner"] || e.prependInnerIcon), D = !!(e.clearable || l.clear), N = !!(l["append-inner"] || e.appendInnerIcon || D), K = () => l.label ? l.label({
        ...k.value,
        label: e.label,
        props: {
          for: O.value
        }
      }) : e.label;
      return m("div", q({
        class: ["v-field", {
          "v-field--active": g.value,
          "v-field--appended": N,
          "v-field--center-affix": e.centerAffix ?? !Q.value,
          "v-field--disabled": e.disabled,
          "v-field--dirty": e.dirty,
          "v-field--error": e.error,
          "v-field--flat": e.flat,
          "v-field--has-background": !!e.bgColor,
          "v-field--persistent-clear": e.persistentClear,
          "v-field--prepended": _,
          "v-field--reverse": e.reverse,
          "v-field--single-line": e.singleLine,
          "v-field--no-label": !K(),
          [`v-field--variant-${e.variant}`]: !0
        }, a.value, M.value, s.value, r.value, f.value, h.value, e.class],
        style: [w.value, e.style],
        onClick: S
      }, n), [m("div", {
        class: "v-field__overlay"
      }, null), m(cs, {
        name: "v-field",
        active: !!e.loading,
        color: e.error ? "error" : typeof e.loading == "string" ? e.loading : e.color
      }, {
        default: l.loader
      }), _ && m("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [e.prependInnerIcon && m(d, {
        key: "prepend-icon",
        name: "prependInner"
      }, null), (E = l["prepend-inner"]) == null ? void 0 : E.call(l, k.value)]), m("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && v.value && m(fr, {
        key: "floating-label",
        ref: $,
        class: [y.value],
        floating: !0,
        for: O.value,
        style: L.value
      }, {
        default: () => [K()]
      }), m(fr, {
        ref: V,
        for: O.value
      }, {
        default: () => [K()]
      }), (I = l.default) == null ? void 0 : I.call(l, {
        ...k.value,
        props: {
          id: O.value,
          class: "v-field__input",
          "aria-describedby": b.value
        },
        focus: u,
        blur: c
      })]), D && m($f, {
        key: "clear"
      }, {
        default: () => [Je(m("div", {
          class: "v-field__clearable",
          onMousedown: (Y) => {
            Y.preventDefault(), Y.stopPropagation();
          }
        }, [m(Te, {
          defaults: {
            VIcon: {
              icon: e.clearIcon
            }
          }
        }, {
          default: () => [l.clear ? l.clear({
            ...k.value,
            props: {
              onKeydown: P,
              onFocus: u,
              onBlur: c,
              onClick: e["onClick:clear"]
            }
          }) : m(d, {
            name: "clear",
            onKeydown: P,
            onFocus: u,
            onBlur: c
          }, null)]
        })]), [[xn, e.dirty]])]
      }), N && m("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [(Z = l["append-inner"]) == null ? void 0 : Z.call(l, k.value), e.appendInnerIcon && m(d, {
        key: "append-icon",
        name: "appendInner"
      }, null)]), m("div", {
        class: ["v-field__outline", y.value],
        style: L.value
      }, [T && m(le, null, [m("div", {
        class: "v-field__outline__start"
      }, null), v.value && m("div", {
        class: "v-field__outline__notch"
      }, [m(fr, {
        ref: $,
        floating: !0,
        for: O.value
      }, {
        default: () => [K()]
      })]), m("div", {
        class: "v-field__outline__end"
      }, null)]), Q.value && v.value && m(fr, {
        ref: $,
        floating: !0,
        for: O.value
      }, {
        default: () => [K()]
      })])]);
    }), {
      controlRef: x
    };
  }
});
function Af(e) {
  const t = Object.keys(Ua.props).filter((n) => !mu(n) && n !== "class" && n !== "style");
  return rf(e, t);
}
const Gb = ["color", "file", "time", "date", "datetime-local", "week", "month"], Lu = B({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...Ri(),
  ...hs()
}, "VTextField"), Tl = X()({
  name: "VTextField",
  directives: {
    Intersect: as
  },
  inheritAttrs: !1,
  props: Lu(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: l
    } = t;
    const a = pe(e, "modelValue"), {
      isFocused: r,
      focus: s,
      blur: o
    } = Ai(e), u = C(() => typeof e.counterValue == "function" ? e.counterValue(a.value) : typeof e.counterValue == "number" ? e.counterValue : (a.value ?? "").toString().length), c = C(() => {
      if (n.maxlength) return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    }), d = C(() => ["plain", "underlined"].includes(e.variant));
    function f(Q, M) {
      var w, y;
      !e.autofocus || !Q || (y = (w = M[0].target) == null ? void 0 : w.focus) == null || y.call(w);
    }
    const h = z(), g = z(), v = z(), p = C(() => Gb.includes(e.type) || e.persistentPlaceholder || r.value || e.active);
    function O() {
      var Q;
      v.value !== document.activeElement && ((Q = v.value) == null || Q.focus()), r.value || s();
    }
    function b(Q) {
      i("mousedown:control", Q), Q.target !== v.value && (O(), Q.preventDefault());
    }
    function V(Q) {
      O(), i("click:control", Q);
    }
    function $(Q) {
      Q.stopPropagation(), O(), He(() => {
        a.value = null, of(e["onClick:clear"], Q);
      });
    }
    function x(Q) {
      var w;
      const M = Q.target;
      if (a.value = M.value, (w = e.modelModifiers) != null && w.trim && ["text", "search", "password", "tel", "url"].includes(e.type)) {
        const y = [M.selectionStart, M.selectionEnd];
        He(() => {
          M.selectionStart = y[0], M.selectionEnd = y[1];
        });
      }
    }
    return F(() => {
      const Q = !!(l.counter || e.counter !== !1 && e.counter != null), M = !!(Q || l.details), [w, y] = sl(n), {
        modelValue: L,
        ...k
      } = Ft.filterProps(e), S = Af(e);
      return m(Ft, q({
        ref: h,
        modelValue: a.value,
        "onUpdate:modelValue": (P) => a.value = P,
        class: ["v-text-field", {
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-input--plain-underlined": d.value
        }, e.class],
        style: e.style
      }, w, k, {
        centerAffix: !d.value,
        focused: r.value
      }), {
        ...l,
        default: (P) => {
          let {
            id: T,
            isDisabled: _,
            isDirty: D,
            isReadonly: N,
            isValid: K
          } = P;
          return m(Ua, q({
            ref: g,
            onMousedown: b,
            onClick: V,
            "onClick:clear": $,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"],
            role: e.role
          }, S, {
            id: T.value,
            active: p.value || D.value,
            dirty: D.value || e.dirty,
            disabled: _.value,
            focused: r.value,
            error: K.value === !1
          }), {
            ...l,
            default: (E) => {
              let {
                props: {
                  class: I,
                  ...Z
                }
              } = E;
              const Y = Je(m("input", q({
                ref: v,
                value: a.value,
                onInput: x,
                autofocus: e.autofocus,
                readonly: N.value,
                disabled: _.value,
                name: e.name,
                placeholder: e.placeholder,
                size: 1,
                type: e.type,
                onFocus: O,
                onBlur: o
              }, Z, y), null), [[Pn("intersect"), {
                handler: f
              }, null, {
                once: !0
              }]]);
              return m(le, null, [e.prefix && m("span", {
                class: "v-text-field__prefix"
              }, [m("span", {
                class: "v-text-field__prefix__text"
              }, [e.prefix])]), l.default ? m("div", {
                class: I,
                "data-no-activator": ""
              }, [l.default(), Y]) : h7(Y, {
                class: I
              }), e.suffix && m("span", {
                class: "v-text-field__suffix"
              }, [m("span", {
                class: "v-text-field__suffix__text"
              }, [e.suffix])])]);
            }
          });
        },
        details: M ? (P) => {
          var T;
          return m(le, null, [(T = l.details) == null ? void 0 : T.call(l, P), Q && m(le, null, [m("span", null, null), m(Qu, {
            active: e.persistentCounter || r.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, l.counter)])]);
        } : void 0
      });
    }), Bn({}, h, g, v);
  }
}), Kb = B({
  renderless: Boolean,
  ...ue()
}, "VVirtualScrollItem"), I4 = X()({
  name: "VVirtualScrollItem",
  inheritAttrs: !1,
  props: Kb(),
  emits: {
    "update:height": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: l
    } = t;
    const {
      resizeRef: a,
      contentRect: r
    } = Yn(void 0, "border");
    ee(() => {
      var s;
      return (s = r.value) == null ? void 0 : s.height;
    }, (s) => {
      s != null && i("update:height", s);
    }), F(() => {
      var s, o;
      return e.renderless ? m(le, null, [(s = l.default) == null ? void 0 : s.call(l, {
        itemRef: a
      })]) : m("div", q({
        ref: a,
        class: ["v-virtual-scroll__item", e.class],
        style: e.style
      }, n), [(o = l.default) == null ? void 0 : o.call(l)]);
    });
  }
}), Jb = -1, eC = 1, Cc = 100, D4 = B({
  itemHeight: {
    type: [Number, String],
    default: null
  },
  height: [Number, String]
}, "virtual");
function B4(e, t) {
  const n = Dn(), i = ie(0);
  ft(() => {
    i.value = parseFloat(e.itemHeight || 0);
  });
  const l = ie(0), a = ie(Math.ceil(
    // Assume 16px items filling the entire screen height if
    // not provided. This is probably incorrect but it minimises
    // the chance of ending up with empty space at the bottom.
    // The default value is set here to avoid poisoning getSize()
    (parseInt(e.height) || n.height.value) / (i.value || 16)
  ) || 1), r = ie(0), s = ie(0), o = z(), u = z();
  let c = 0;
  const {
    resizeRef: d,
    contentRect: f
  } = Yn();
  ft(() => {
    d.value = o.value;
  });
  const h = C(() => {
    var E;
    return o.value === document.documentElement ? n.height.value : ((E = f.value) == null ? void 0 : E.height) || parseInt(e.height) || 0;
  }), g = C(() => !!(o.value && u.value && h.value && i.value));
  let v = Array.from({
    length: t.value.length
  }), p = Array.from({
    length: t.value.length
  });
  const O = ie(0);
  let b = -1;
  function V(E) {
    return v[E] || i.value;
  }
  const $ = Z7(() => {
    const E = performance.now();
    p[0] = 0;
    const I = t.value.length;
    for (let Z = 1; Z <= I - 1; Z++)
      p[Z] = (p[Z - 1] || 0) + V(Z - 1);
    O.value = Math.max(O.value, performance.now() - E);
  }, O), x = ee(g, (E) => {
    E && (x(), c = u.value.offsetTop, $.immediate(), _(), ~b && He(() => {
      qe && window.requestAnimationFrame(() => {
        N(b), b = -1;
      });
    }));
  });
  tn(() => {
    $.clear();
  });
  function Q(E, I) {
    const Z = v[E], Y = i.value;
    i.value = Y ? Math.min(i.value, I) : I, (Z !== I || Y !== i.value) && (v[E] = I, $());
  }
  function M(E) {
    return E = Ot(E, 0, t.value.length - 1), p[E] || 0;
  }
  function w(E) {
    return tC(p, E);
  }
  let y = 0, L = 0, k = 0;
  ee(h, (E, I) => {
    I && (_(), E < I && requestAnimationFrame(() => {
      L = 0, _();
    }));
  });
  function S() {
    if (!o.value || !u.value) return;
    const E = o.value.scrollTop, I = performance.now();
    I - k > 500 ? (L = Math.sign(E - y), c = u.value.offsetTop) : L = E - y, y = E, k = I, _();
  }
  function P() {
    !o.value || !u.value || (L = 0, k = 0, _());
  }
  let T = -1;
  function _() {
    cancelAnimationFrame(T), T = requestAnimationFrame(D);
  }
  function D() {
    if (!o.value || !h.value) return;
    const E = y - c, I = Math.sign(L), Z = Math.max(0, E - Cc), Y = Ot(w(Z), 0, t.value.length), ce = E + h.value + Cc, de = Ot(w(ce) + 1, Y + 1, t.value.length);
    if (
      // Only update the side we're scrolling towards,
      // the other side will be updated incidentally
      (I !== Jb || Y < l.value) && (I !== eC || de > a.value)
    ) {
      const ye = M(l.value) - M(Y), U = M(de) - M(a.value);
      Math.max(ye, U) > Cc ? (l.value = Y, a.value = de) : (Y <= 0 && (l.value = Y), de >= t.value.length && (a.value = de));
    }
    r.value = M(l.value), s.value = M(t.value.length) - M(a.value);
  }
  function N(E) {
    const I = M(E);
    !o.value || E && !I ? b = E : o.value.scrollTop = I;
  }
  const K = C(() => t.value.slice(l.value, a.value).map((E, I) => ({
    raw: E,
    index: I + l.value
  })));
  return ee(t, () => {
    v = Array.from({
      length: t.value.length
    }), p = Array.from({
      length: t.value.length
    }), $.immediate(), _();
  }, {
    deep: !0
  }), {
    calculateVisibleItems: _,
    containerRef: o,
    markerRef: u,
    computedItems: K,
    paddingTop: r,
    paddingBottom: s,
    scrollToIndex: N,
    handleScroll: S,
    handleScrollend: P,
    handleItemResize: Q
  };
}
function tC(e, t) {
  let n = e.length - 1, i = 0, l = 0, a = null, r = -1;
  if (e[n] < t)
    return n;
  for (; i <= n; )
    if (l = i + n >> 1, a = e[l], a > t)
      n = l - 1;
    else if (a < t)
      r = l, i = l + 1;
    else return a === t ? l : i;
  return r;
}
const nC = B({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...D4(),
  ...ue(),
  ...wt()
}, "VVirtualScroll"), Mu = X()({
  name: "VVirtualScroll",
  props: nC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = mt("VVirtualScroll"), {
      dimensionStyles: l
    } = kt(e), {
      calculateVisibleItems: a,
      containerRef: r,
      markerRef: s,
      handleScroll: o,
      handleScrollend: u,
      handleItemResize: c,
      scrollToIndex: d,
      paddingTop: f,
      paddingBottom: h,
      computedItems: g
    } = B4(e, H(e, "items"));
    return un(() => e.renderless, () => {
      function v() {
        var b, V;
        const O = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? "addEventListener" : "removeEventListener";
        r.value === document.documentElement ? (document[O]("scroll", o, {
          passive: !0
        }), document[O]("scrollend", u)) : ((b = r.value) == null || b[O]("scroll", o, {
          passive: !0
        }), (V = r.value) == null || V[O]("scrollend", u));
      }
      it(() => {
        r.value = hf(i.vnode.el, !0), v(!0);
      }), tn(v);
    }), F(() => {
      const v = g.value.map((p) => m(I4, {
        key: p.index,
        renderless: e.renderless,
        "onUpdate:height": (O) => c(p.index, O)
      }, {
        default: (O) => {
          var b;
          return (b = n.default) == null ? void 0 : b.call(n, {
            item: p.raw,
            index: p.index,
            ...O
          });
        }
      }));
      return e.renderless ? m(le, null, [m("div", {
        ref: s,
        class: "v-virtual-scroll__spacer",
        style: {
          paddingTop: se(f.value)
        }
      }, null), v, m("div", {
        class: "v-virtual-scroll__spacer",
        style: {
          paddingBottom: se(h.value)
        }
      }, null)]) : m("div", {
        ref: r,
        class: ["v-virtual-scroll", e.class],
        onScrollPassive: o,
        onScrollend: u,
        style: [l.value, e.style]
      }, [m("div", {
        ref: s,
        class: "v-virtual-scroll__container",
        style: {
          paddingTop: se(f.value),
          paddingBottom: se(h.value)
        }
      }, [v])]);
    }), {
      calculateVisibleItems: a,
      scrollToIndex: d
    };
  }
});
function Rf(e, t) {
  const n = ie(!1);
  let i;
  function l(s) {
    cancelAnimationFrame(i), n.value = !0, i = requestAnimationFrame(() => {
      i = requestAnimationFrame(() => {
        n.value = !1;
      });
    });
  }
  async function a() {
    await new Promise((s) => requestAnimationFrame(s)), await new Promise((s) => requestAnimationFrame(s)), await new Promise((s) => requestAnimationFrame(s)), await new Promise((s) => {
      if (n.value) {
        const o = ee(n, () => {
          o(), s();
        });
      } else s();
    });
  }
  async function r(s) {
    var c, d;
    if (s.key === "Tab" && ((c = t.value) == null || c.focus()), !["PageDown", "PageUp", "Home", "End"].includes(s.key)) return;
    const o = (d = e.value) == null ? void 0 : d.$el;
    if (!o) return;
    (s.key === "Home" || s.key === "End") && o.scrollTo({
      top: s.key === "Home" ? 0 : o.scrollHeight,
      behavior: "smooth"
    }), await a();
    const u = o.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (s.key === "PageDown" || s.key === "Home") {
      const f = o.getBoundingClientRect().top;
      for (const h of u)
        if (h.getBoundingClientRect().top >= f) {
          h.focus();
          break;
        }
    } else {
      const f = o.getBoundingClientRect().bottom;
      for (const h of [...u].reverse())
        if (h.getBoundingClientRect().bottom <= f) {
          h.focus();
          break;
        }
    }
  }
  return {
    onScrollPassive: l,
    onKeydown: r
  };
}
const Zf = B({
  chips: Boolean,
  closableChips: Boolean,
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  },
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  listProps: {
    type: Object
  },
  menu: Boolean,
  menuIcon: {
    type: Se,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  ..._4({
    itemChildren: !1
  })
}, "Select"), iC = B({
  ...Zf(),
  ...St(Lu({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Gn({
    transition: {
      component: bu
    }
  })
}, "VSelect"), If = X()({
  name: "VSelect",
  props: iC(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = pt(), l = z(), a = z(), r = z(), s = pe(e, "menu"), o = C({
      get: () => s.value,
      set: (E) => {
        var I;
        s.value && !E && ((I = a.value) != null && I.openChildren.size) || (s.value = E);
      }
    }), {
      items: u,
      transformIn: c,
      transformOut: d
    } = _f(e), f = pe(e, "modelValue", [], (E) => c(E === null ? [null] : ut(E)), (E) => {
      const I = d(E);
      return e.multiple ? I : I[0] ?? null;
    }), h = C(() => typeof e.counterValue == "function" ? e.counterValue(f.value) : typeof e.counterValue == "number" ? e.counterValue : f.value.length), g = $u(), v = C(() => f.value.map((E) => E.value)), p = ie(!1), O = C(() => o.value ? e.closeText : e.openText);
    let b = "", V;
    const $ = C(() => e.hideSelected ? u.value.filter((E) => !f.value.some((I) => e.valueComparator(I, E))) : u.value), x = C(() => e.hideNoData && !$.value.length || e.readonly || (g == null ? void 0 : g.isReadonly.value)), Q = C(() => {
      var E;
      return {
        ...e.menuProps,
        activatorProps: {
          ...((E = e.menuProps) == null ? void 0 : E.activatorProps) || {},
          "aria-haspopup": "listbox"
          // Set aria-haspopup to 'listbox'
        }
      };
    }), M = z(), w = Rf(M, l);
    function y(E) {
      e.openOnClear && (o.value = !0);
    }
    function L() {
      x.value || (o.value = !o.value);
    }
    function k(E) {
      xo(E) && S(E);
    }
    function S(E) {
      var ce, de;
      if (!E.key || e.readonly || g != null && g.isReadonly.value) return;
      ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(E.key) && E.preventDefault(), ["Enter", "ArrowDown", " "].includes(E.key) && (o.value = !0), ["Escape", "Tab"].includes(E.key) && (o.value = !1), E.key === "Home" ? (ce = M.value) == null || ce.focus("first") : E.key === "End" && ((de = M.value) == null || de.focus("last"));
      const I = 1e3;
      if (e.multiple || !xo(E)) return;
      const Z = performance.now();
      Z - V > I && (b = ""), b += E.key.toLowerCase(), V = Z;
      const Y = u.value.find((ye) => ye.title.toLowerCase().startsWith(b));
      if (Y !== void 0) {
        f.value = [Y];
        const ye = $.value.indexOf(Y);
        qe && window.requestAnimationFrame(() => {
          var U;
          ye >= 0 && ((U = r.value) == null || U.scrollToIndex(ye));
        });
      }
    }
    function P(E) {
      let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!E.props.disabled)
        if (e.multiple) {
          const Z = f.value.findIndex((ce) => e.valueComparator(ce.value, E.value)), Y = I ?? !~Z;
          if (~Z) {
            const ce = Y ? [...f.value, E] : [...f.value];
            ce.splice(Z, 1), f.value = ce;
          } else Y && (f.value = [...f.value, E]);
        } else {
          const Z = I !== !1;
          f.value = Z ? [E] : [], He(() => {
            o.value = !1;
          });
        }
    }
    function T(E) {
      var I;
      (I = M.value) != null && I.$el.contains(E.relatedTarget) || (o.value = !1);
    }
    function _() {
      var E;
      e.eager && ((E = r.value) == null || E.calculateVisibleItems());
    }
    function D() {
      var E;
      p.value && ((E = l.value) == null || E.focus());
    }
    function N(E) {
      p.value = !0;
    }
    function K(E) {
      if (E == null) f.value = [];
      else if (Pa(l.value, ":autofill") || Pa(l.value, ":-webkit-autofill")) {
        const I = u.value.find((Z) => Z.title === E);
        I && P(I);
      } else l.value && (l.value.value = "");
    }
    return ee(o, () => {
      if (!e.hideSelected && o.value && f.value.length) {
        const E = $.value.findIndex((I) => f.value.some((Z) => e.valueComparator(Z.value, I.value)));
        qe && window.requestAnimationFrame(() => {
          var I;
          E >= 0 && ((I = r.value) == null || I.scrollToIndex(E));
        });
      }
    }), ee(() => e.items, (E, I) => {
      o.value || p.value && !I.length && E.length && (o.value = !0);
    }), F(() => {
      const E = !!(e.chips || n.chip), I = !!(!e.hideNoData || $.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), Z = f.value.length > 0, Y = Tl.filterProps(e), ce = Z || !p.value && e.label && !e.persistentPlaceholder ? void 0 : e.placeholder;
      return m(Tl, q({
        ref: l
      }, Y, {
        modelValue: f.value.map((de) => de.props.value).join(", "),
        "onUpdate:modelValue": K,
        focused: p.value,
        "onUpdate:focused": (de) => p.value = de,
        validationValue: f.externalValue,
        counterValue: h.value,
        dirty: Z,
        class: ["v-select", {
          "v-select--active-menu": o.value,
          "v-select--chips": !!e.chips,
          [`v-select--${e.multiple ? "multiple" : "single"}`]: !0,
          "v-select--selected": f.value.length,
          "v-select--selection-slot": !!n.selection
        }, e.class],
        style: e.style,
        inputmode: "none",
        placeholder: ce,
        "onClick:clear": y,
        "onMousedown:control": L,
        onBlur: T,
        onKeydown: S,
        "aria-label": i(O.value),
        title: i(O.value)
      }), {
        ...n,
        default: () => m(le, null, [m(La, q({
          ref: a,
          modelValue: o.value,
          "onUpdate:modelValue": (de) => o.value = de,
          activator: "parent",
          contentClass: "v-select__content",
          disabled: x.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: _,
          onAfterLeave: D
        }, Q.value), {
          default: () => [I && m(Vu, q({
            ref: M,
            selected: v.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (de) => de.preventDefault(),
            onKeydown: k,
            onFocusin: N,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, w, e.listProps), {
            default: () => {
              var de, ye, U;
              return [(de = n["prepend-item"]) == null ? void 0 : de.call(n), !$.value.length && !e.hideNoData && (((ye = n["no-data"]) == null ? void 0 : ye.call(n)) ?? m(Qi, {
                title: i(e.noDataText)
              }, null)), m(Mu, {
                ref: r,
                renderless: !0,
                items: $.value
              }, {
                default: (ge) => {
                  var Qe;
                  let {
                    item: be,
                    index: De,
                    itemRef: Ye
                  } = ge;
                  const re = q(be.props, {
                    ref: Ye,
                    key: De,
                    onClick: () => P(be, null)
                  });
                  return ((Qe = n.item) == null ? void 0 : Qe.call(n, {
                    item: be,
                    index: De,
                    props: re
                  })) ?? m(Qi, q(re, {
                    role: "option"
                  }), {
                    prepend: (te) => {
                      let {
                        isSelected: oe
                      } = te;
                      return m(le, null, [e.multiple && !e.hideSelected ? m(Vi, {
                        key: be.value,
                        modelValue: oe,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, be.props.prependAvatar && m(An, {
                        image: be.props.prependAvatar
                      }, null), be.props.prependIcon && m(ze, {
                        icon: be.props.prependIcon
                      }, null)]);
                    }
                  });
                }
              }), (U = n["append-item"]) == null ? void 0 : U.call(n)];
            }
          })]
        }), f.value.map((de, ye) => {
          function U(Ye) {
            Ye.stopPropagation(), Ye.preventDefault(), P(de, !1);
          }
          const ge = {
            "onClick:close": U,
            onKeydown(Ye) {
              Ye.key !== "Enter" && Ye.key !== " " || (Ye.preventDefault(), Ye.stopPropagation(), U(Ye));
            },
            onMousedown(Ye) {
              Ye.preventDefault(), Ye.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, be = E ? !!n.chip : !!n.selection, De = be ? gu(E ? n.chip({
            item: de,
            index: ye,
            props: ge
          }) : n.selection({
            item: de,
            index: ye
          })) : void 0;
          if (!(be && !De))
            return m("div", {
              key: de.value,
              class: "v-select__selection"
            }, [E ? n.chip ? m(Te, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: de.title
                }
              }
            }, {
              default: () => [De]
            }) : m(Wa, q({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: de.title,
              disabled: de.props.disabled
            }, ge), null) : De ?? m("span", {
              class: "v-select__selection-text"
            }, [de.title, e.multiple && ye < f.value.length - 1 && m("span", {
              class: "v-select__selection-comma"
            }, [ke(",")])])]);
        })]),
        "append-inner": function() {
          var ge;
          for (var de = arguments.length, ye = new Array(de), U = 0; U < de; U++)
            ye[U] = arguments[U];
          return m(le, null, [(ge = n["append-inner"]) == null ? void 0 : ge.call(n, ...ye), e.menuIcon ? m(ze, {
            class: "v-select__menu-icon",
            icon: e.menuIcon
          }, null) : void 0]);
        }
      });
    }), Bn({
      isFocused: p,
      menu: o,
      select: P
    }, l);
  }
}), lC = (e, t, n) => e == null || t == null ? -1 : e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase()), ms = B({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function aC(e, t, n) {
  var s;
  const i = [], l = (n == null ? void 0 : n.default) ?? lC, a = n != null && n.filterKeys ? ut(n.filterKeys) : !1, r = Object.keys((n == null ? void 0 : n.customKeyFilter) ?? {}).length;
  if (!(e != null && e.length)) return i;
  e: for (let o = 0; o < e.length; o++) {
    const [u, c = u] = ut(e[o]), d = {}, f = {};
    let h = -1;
    if ((t || r > 0) && !(n != null && n.noFilter)) {
      if (typeof u == "object") {
        const p = a || Object.keys(c);
        for (const O of p) {
          const b = Pt(c, O), V = (s = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : s[O];
          if (h = V ? V(b, t, u) : l(b, t, u), h !== -1 && h !== !1)
            V ? d[O] = h : f[O] = h;
          else if ((n == null ? void 0 : n.filterMode) === "every")
            continue e;
        }
      } else
        h = l(u, t, u), h !== -1 && h !== !1 && (f.title = h);
      const g = Object.keys(f).length, v = Object.keys(d).length;
      if (!g && !v || (n == null ? void 0 : n.filterMode) === "union" && v !== r && !g || (n == null ? void 0 : n.filterMode) === "intersection" && (v !== r || !g)) continue;
    }
    i.push({
      index: o,
      matches: {
        ...f,
        ...d
      }
    });
  }
  return i;
}
function gs(e, t, n, i) {
  const l = z([]), a = z(/* @__PURE__ */ new Map()), r = C(() => i != null && i.transform ? Me(t).map((o) => [o, i.transform(o)]) : Me(t));
  ft(() => {
    const o = typeof n == "function" ? n() : Me(n), u = typeof o != "string" && typeof o != "number" ? "" : String(o), c = aC(r.value, u, {
      customKeyFilter: {
        ...e.customKeyFilter,
        ...Me(i == null ? void 0 : i.customKeyFilter)
      },
      default: e.customFilter,
      filterKeys: e.filterKeys,
      filterMode: e.filterMode,
      noFilter: e.noFilter
    }), d = Me(t), f = [], h = /* @__PURE__ */ new Map();
    c.forEach((g) => {
      let {
        index: v,
        matches: p
      } = g;
      const O = d[v];
      f.push(O), h.set(O.value, p);
    }), l.value = f, a.value = h;
  });
  function s(o) {
    return a.value.get(o.value);
  }
  return {
    filteredItems: l,
    filteredMatches: a,
    getMatches: s
  };
}
function rC(e, t, n) {
  if (t == null) return e;
  if (Array.isArray(t)) throw new Error("Multiple matches is not implemented");
  return typeof t == "number" && ~t ? m(le, null, [m("span", {
    class: "v-autocomplete__unmask"
  }, [e.substr(0, t)]), m("span", {
    class: "v-autocomplete__mask"
  }, [e.substr(t, n)]), m("span", {
    class: "v-autocomplete__unmask"
  }, [e.substr(t + n)])]) : e;
}
const sC = B({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...ms({
    filterKeys: ["title"]
  }),
  ...Zf(),
  ...St(Lu({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Gn({
    transition: !1
  })
}, "VAutocomplete"), oC = X()({
  name: "VAutocomplete",
  props: sC(),
  emits: {
    "update:focused": (e) => !0,
    "update:search": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = pt(), l = z(), a = ie(!1), r = ie(!0), s = ie(!1), o = z(), u = z(), c = pe(e, "menu"), d = C({
      get: () => c.value,
      set: (re) => {
        var Qe;
        c.value && !re && ((Qe = o.value) != null && Qe.openChildren.size) || (c.value = re);
      }
    }), f = ie(-1), h = C(() => {
      var re;
      return (re = l.value) == null ? void 0 : re.color;
    }), g = C(() => d.value ? e.closeText : e.openText), {
      items: v,
      transformIn: p,
      transformOut: O
    } = _f(e), {
      textColorClasses: b,
      textColorStyles: V
    } = Yt(h), $ = pe(e, "search", ""), x = pe(e, "modelValue", [], (re) => p(re === null ? [null] : ut(re)), (re) => {
      const Qe = O(re);
      return e.multiple ? Qe : Qe[0] ?? null;
    }), Q = C(() => typeof e.counterValue == "function" ? e.counterValue(x.value) : typeof e.counterValue == "number" ? e.counterValue : x.value.length), M = $u(), {
      filteredItems: w,
      getMatches: y
    } = gs(e, v, () => r.value ? "" : $.value), L = C(() => e.hideSelected ? w.value.filter((re) => !x.value.some((Qe) => Qe.value === re.value)) : w.value), k = C(() => !!(e.chips || n.chip)), S = C(() => k.value || !!n.selection), P = C(() => x.value.map((re) => re.props.value)), T = C(() => {
      var Qe;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && $.value === ((Qe = L.value[0]) == null ? void 0 : Qe.title)) && L.value.length > 0 && !r.value && !s.value;
    }), _ = C(() => e.hideNoData && !L.value.length || e.readonly || (M == null ? void 0 : M.isReadonly.value)), D = z(), N = Rf(D, l);
    function K(re) {
      e.openOnClear && (d.value = !0), $.value = "";
    }
    function E() {
      _.value || (d.value = !0);
    }
    function I(re) {
      _.value || (a.value && (re.preventDefault(), re.stopPropagation()), d.value = !d.value);
    }
    function Z(re) {
      var Qe;
      xo(re) && ((Qe = l.value) == null || Qe.focus());
    }
    function Y(re) {
      var oe, Pe, we;
      if (e.readonly || M != null && M.isReadonly.value) return;
      const Qe = l.value.selectionStart, te = x.value.length;
      if ((f.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(re.key)) && re.preventDefault(), ["Enter", "ArrowDown"].includes(re.key) && (d.value = !0), ["Escape"].includes(re.key) && (d.value = !1), T.value && ["Enter", "Tab"].includes(re.key) && !x.value.some(($e) => {
        let {
          value: We
        } = $e;
        return We === L.value[0].value;
      }) && Ye(L.value[0]), re.key === "ArrowDown" && T.value && ((oe = D.value) == null || oe.focus("next")), ["Backspace", "Delete"].includes(re.key)) {
        if (!e.multiple && S.value && x.value.length > 0 && !$.value) return Ye(x.value[0], !1);
        if (~f.value) {
          const $e = f.value;
          Ye(x.value[f.value], !1), f.value = $e >= te - 1 ? te - 2 : $e;
        } else re.key === "Backspace" && !$.value && (f.value = te - 1);
      }
      if (e.multiple) {
        if (re.key === "ArrowLeft") {
          if (f.value < 0 && Qe > 0) return;
          const $e = f.value > -1 ? f.value - 1 : te - 1;
          x.value[$e] ? f.value = $e : (f.value = -1, l.value.setSelectionRange((Pe = $.value) == null ? void 0 : Pe.length, (we = $.value) == null ? void 0 : we.length));
        }
        if (re.key === "ArrowRight") {
          if (f.value < 0) return;
          const $e = f.value + 1;
          x.value[$e] ? f.value = $e : (f.value = -1, l.value.setSelectionRange(0, 0));
        }
      }
    }
    function ce(re) {
      if (Pa(l.value, ":autofill") || Pa(l.value, ":-webkit-autofill")) {
        const Qe = v.value.find((te) => te.title === re.target.value);
        Qe && Ye(Qe);
      }
    }
    function de() {
      var re;
      e.eager && ((re = u.value) == null || re.calculateVisibleItems());
    }
    function ye() {
      var re;
      a.value && (r.value = !0, (re = l.value) == null || re.focus());
    }
    function U(re) {
      a.value = !0, setTimeout(() => {
        s.value = !0;
      });
    }
    function ge(re) {
      s.value = !1;
    }
    function be(re) {
      (re == null || re === "" && !e.multiple && !S.value) && (x.value = []);
    }
    const De = ie(!1);
    function Ye(re) {
      let Qe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!re || re.props.disabled))
        if (e.multiple) {
          const te = x.value.findIndex((Pe) => e.valueComparator(Pe.value, re.value)), oe = Qe ?? !~te;
          if (~te) {
            const Pe = oe ? [...x.value, re] : [...x.value];
            Pe.splice(te, 1), x.value = Pe;
          } else oe && (x.value = [...x.value, re]);
          e.clearOnSelect && ($.value = "");
        } else {
          const te = Qe !== !1;
          x.value = te ? [re] : [], $.value = te && !S.value ? re.title : "", He(() => {
            d.value = !1, r.value = !0;
          });
        }
    }
    return ee(a, (re, Qe) => {
      var te;
      re !== Qe && (re ? (De.value = !0, $.value = e.multiple || S.value ? "" : String(((te = x.value.at(-1)) == null ? void 0 : te.props.title) ?? ""), r.value = !0, He(() => De.value = !1)) : (!e.multiple && $.value == null && (x.value = []), d.value = !1, x.value.some((oe) => {
        let {
          title: Pe
        } = oe;
        return Pe === $.value;
      }) || ($.value = ""), f.value = -1));
    }), ee($, (re) => {
      !a.value || De.value || (re && (d.value = !0), r.value = !re);
    }), ee(d, () => {
      if (!e.hideSelected && d.value && x.value.length) {
        const re = L.value.findIndex((Qe) => x.value.some((te) => Qe.value === te.value));
        qe && window.requestAnimationFrame(() => {
          var Qe;
          re >= 0 && ((Qe = u.value) == null || Qe.scrollToIndex(re));
        });
      }
    }), ee(() => e.items, (re, Qe) => {
      d.value || a.value && !Qe.length && re.length && (d.value = !0);
    }), F(() => {
      const re = !!(!e.hideNoData || L.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), Qe = x.value.length > 0, te = Tl.filterProps(e);
      return m(Tl, q({
        ref: l
      }, te, {
        modelValue: $.value,
        "onUpdate:modelValue": [(oe) => $.value = oe, be],
        focused: a.value,
        "onUpdate:focused": (oe) => a.value = oe,
        validationValue: x.externalValue,
        counterValue: Q.value,
        dirty: Qe,
        onChange: ce,
        class: ["v-autocomplete", `v-autocomplete--${e.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": d.value,
          "v-autocomplete--chips": !!e.chips,
          "v-autocomplete--selection-slot": !!S.value,
          "v-autocomplete--selecting-index": f.value > -1
        }, e.class],
        style: e.style,
        readonly: e.readonly,
        placeholder: Qe ? void 0 : e.placeholder,
        "onClick:clear": K,
        "onMousedown:control": E,
        onKeydown: Y
      }), {
        ...n,
        default: () => m(le, null, [m(La, q({
          ref: o,
          modelValue: d.value,
          "onUpdate:modelValue": (oe) => d.value = oe,
          activator: "parent",
          contentClass: "v-autocomplete__content",
          disabled: _.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: de,
          onAfterLeave: ye
        }, e.menuProps), {
          default: () => [re && m(Vu, q({
            ref: D,
            selected: P.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (oe) => oe.preventDefault(),
            onKeydown: Z,
            onFocusin: U,
            onFocusout: ge,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, N, e.listProps), {
            default: () => {
              var oe, Pe, we;
              return [(oe = n["prepend-item"]) == null ? void 0 : oe.call(n), !L.value.length && !e.hideNoData && (((Pe = n["no-data"]) == null ? void 0 : Pe.call(n)) ?? m(Qi, {
                title: i(e.noDataText)
              }, null)), m(Mu, {
                ref: u,
                renderless: !0,
                items: L.value
              }, {
                default: ($e) => {
                  var Ut;
                  let {
                    item: We,
                    index: an,
                    itemRef: Ue
                  } = $e;
                  const ei = q(We.props, {
                    ref: Ue,
                    key: an,
                    active: T.value && an === 0 ? !0 : void 0,
                    onClick: () => Ye(We, null)
                  });
                  return ((Ut = n.item) == null ? void 0 : Ut.call(n, {
                    item: We,
                    index: an,
                    props: ei
                  })) ?? m(Qi, q(ei, {
                    role: "option"
                  }), {
                    prepend: (fl) => {
                      let {
                        isSelected: hl
                      } = fl;
                      return m(le, null, [e.multiple && !e.hideSelected ? m(Vi, {
                        key: We.value,
                        modelValue: hl,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, We.props.prependAvatar && m(An, {
                        image: We.props.prependAvatar
                      }, null), We.props.prependIcon && m(ze, {
                        icon: We.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var fl, hl;
                      return r.value ? We.title : rC(We.title, (fl = y(We)) == null ? void 0 : fl.title, ((hl = $.value) == null ? void 0 : hl.length) ?? 0);
                    }
                  });
                }
              }), (we = n["append-item"]) == null ? void 0 : we.call(n)];
            }
          })]
        }), x.value.map((oe, Pe) => {
          function we(Ue) {
            Ue.stopPropagation(), Ue.preventDefault(), Ye(oe, !1);
          }
          const $e = {
            "onClick:close": we,
            onKeydown(Ue) {
              Ue.key !== "Enter" && Ue.key !== " " || (Ue.preventDefault(), Ue.stopPropagation(), we(Ue));
            },
            onMousedown(Ue) {
              Ue.preventDefault(), Ue.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, We = k.value ? !!n.chip : !!n.selection, an = We ? gu(k.value ? n.chip({
            item: oe,
            index: Pe,
            props: $e
          }) : n.selection({
            item: oe,
            index: Pe
          })) : void 0;
          if (!(We && !an))
            return m("div", {
              key: oe.value,
              class: ["v-autocomplete__selection", Pe === f.value && ["v-autocomplete__selection--selected", b.value]],
              style: Pe === f.value ? V.value : {}
            }, [k.value ? n.chip ? m(Te, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: oe.title
                }
              }
            }, {
              default: () => [an]
            }) : m(Wa, q({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: oe.title,
              disabled: oe.props.disabled
            }, $e), null) : an ?? m("span", {
              class: "v-autocomplete__selection-text"
            }, [oe.title, e.multiple && Pe < x.value.length - 1 && m("span", {
              class: "v-autocomplete__selection-comma"
            }, [ke(",")])])]);
        })]),
        "append-inner": function() {
          var $e;
          for (var oe = arguments.length, Pe = new Array(oe), we = 0; we < oe; we++)
            Pe[we] = arguments[we];
          return m(le, null, [($e = n["append-inner"]) == null ? void 0 : $e.call(n, ...Pe), e.menuIcon ? m(ze, {
            class: "v-autocomplete__menu-icon",
            icon: e.menuIcon,
            onMousedown: I,
            onClick: eg,
            "aria-label": i(g.value),
            title: i(g.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Bn({
      isFocused: a,
      isPristine: r,
      menu: d,
      search: $,
      filteredItems: w,
      select: Ye
    }, l);
  }
}), uC = B({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: Se,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: !0
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...ue(),
  ..._i({
    location: "top end"
  }),
  ...at(),
  ...Ve(),
  ...Ie(),
  ...Gn({
    transition: "scale-rotate-transition"
  })
}, "VBadge"), cC = X()({
  name: "VBadge",
  inheritAttrs: !1,
  props: uC(),
  setup(e, t) {
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: i
    } = Fe(H(e, "color")), {
      roundedClasses: l
    } = gt(e), {
      t: a
    } = pt(), {
      textColorClasses: r,
      textColorStyles: s
    } = Yt(H(e, "textColor")), {
      themeClasses: o
    } = Vg(), {
      locationStyles: u
    } = ta(e, !0, (c) => (e.floating ? e.dot ? 2 : 4 : e.dot ? 8 : 12) + (["top", "bottom"].includes(c) ? +(e.offsetY ?? 0) : ["left", "right"].includes(c) ? +(e.offsetX ?? 0) : 0));
    return F(() => {
      const c = Number(e.content), d = !e.max || isNaN(c) ? e.content : c <= +e.max ? c : `${e.max}+`, [f, h] = i1(t.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return m(e.tag, q({
        class: ["v-badge", {
          "v-badge--bordered": e.bordered,
          "v-badge--dot": e.dot,
          "v-badge--floating": e.floating,
          "v-badge--inline": e.inline
        }, e.class]
      }, h, {
        style: e.style
      }), {
        default: () => {
          var g, v;
          return [m("div", {
            class: "v-badge__wrapper"
          }, [(v = (g = t.slots).default) == null ? void 0 : v.call(g), m(en, {
            transition: e.transition
          }, {
            default: () => {
              var p, O;
              return [Je(m("span", q({
                class: ["v-badge__badge", o.value, n.value, l.value, r.value],
                style: [i.value, s.value, e.inline ? {} : u.value],
                "aria-atomic": "true",
                "aria-label": a(e.label, c),
                "aria-live": "polite",
                role: "status"
              }, f), [e.dot ? void 0 : t.slots.badge ? (O = (p = t.slots).badge) == null ? void 0 : O.call(p) : e.icon ? m(ze, {
                icon: e.icon
              }, null) : d]), [[xn, e.modelValue]])];
            }
          })])];
        }
      });
    }), {};
  }
}), dC = B({
  color: String,
  density: String,
  ...ue()
}, "VBannerActions"), E4 = X()({
  name: "VBannerActions",
  props: dC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ht({
      VBtn: {
        color: e.color,
        density: e.density,
        slim: !0,
        variant: "text"
      }
    }), F(() => {
      var i;
      return m("div", {
        class: ["v-banner-actions", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), z4 = Oi("v-banner-text"), fC = B({
  avatar: String,
  bgColor: String,
  color: String,
  icon: Se,
  lines: String,
  stacked: Boolean,
  sticky: Boolean,
  text: String,
  ...yn(),
  ...ue(),
  ...Zt(),
  ...wt(),
  ...ql({
    mobile: null
  }),
  ...Lt(),
  ..._i(),
  ...qa(),
  ...at(),
  ...Ve(),
  ...Ie()
}, "VBanner"), hC = X()({
  name: "VBanner",
  props: fC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = Fe(e, "bgColor"), {
      borderClasses: a
    } = Qn(e), {
      densityClasses: r
    } = nn(e), {
      displayClasses: s,
      mobile: o
    } = Dn(e), {
      dimensionStyles: u
    } = kt(e), {
      elevationClasses: c
    } = Et(e), {
      locationStyles: d
    } = ta(e), {
      positionClasses: f
    } = Ya(e), {
      roundedClasses: h
    } = gt(e), {
      themeClasses: g
    } = Xe(e), v = H(e, "color"), p = H(e, "density");
    ht({
      VBannerActions: {
        color: v,
        density: p
      }
    }), F(() => {
      const O = !!(e.text || n.text), b = !!(e.avatar || e.icon), V = !!(b || n.prepend);
      return m(e.tag, {
        class: ["v-banner", {
          "v-banner--stacked": e.stacked || o.value,
          "v-banner--sticky": e.sticky,
          [`v-banner--${e.lines}-line`]: !!e.lines
        }, g.value, i.value, a.value, r.value, s.value, c.value, f.value, h.value, e.class],
        style: [l.value, u.value, d.value, e.style],
        role: "banner"
      }, {
        default: () => {
          var $;
          return [V && m("div", {
            key: "prepend",
            class: "v-banner__prepend"
          }, [n.prepend ? m(Te, {
            key: "prepend-defaults",
            disabled: !b,
            defaults: {
              VAvatar: {
                color: v.value,
                density: p.value,
                icon: e.icon,
                image: e.avatar
              }
            }
          }, n.prepend) : m(An, {
            key: "prepend-avatar",
            color: v.value,
            density: p.value,
            icon: e.icon,
            image: e.avatar
          }, null)]), m("div", {
            class: "v-banner__content"
          }, [O && m(z4, {
            key: "text"
          }, {
            default: () => {
              var x;
              return [((x = n.text) == null ? void 0 : x.call(n)) ?? e.text];
            }
          }), ($ = n.default) == null ? void 0 : $.call(n)]), n.actions && m(E4, {
            key: "actions"
          }, n.actions)];
        }
      });
    });
  }
}), mC = B({
  baseColor: String,
  bgColor: String,
  color: String,
  grow: Boolean,
  mode: {
    type: String,
    validator: (e) => !e || ["horizontal", "shift"].includes(e)
  },
  height: {
    type: [Number, String],
    default: 56
  },
  active: {
    type: Boolean,
    default: !0
  },
  ...yn(),
  ...ue(),
  ...Zt(),
  ...Lt(),
  ...at(),
  ...Yl({
    name: "bottom-navigation"
  }),
  ...Ve({
    tag: "header"
  }),
  ...Kl({
    selectedClass: "v-btn--selected"
  }),
  ...Ie()
}, "VBottomNavigation"), gC = X()({
  name: "VBottomNavigation",
  props: mC(),
  emits: {
    "update:active": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Vg(), {
      borderClasses: l
    } = Qn(e), {
      backgroundColorClasses: a,
      backgroundColorStyles: r
    } = Fe(H(e, "bgColor")), {
      densityClasses: s
    } = nn(e), {
      elevationClasses: o
    } = Et(e), {
      roundedClasses: u
    } = gt(e), {
      ssrBootStyles: c
    } = Ul(), d = C(() => Number(e.height) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0)), f = pe(e, "active", e.active), {
      layoutItemStyles: h
    } = Fl({
      id: e.name,
      order: C(() => parseInt(e.order, 10)),
      position: C(() => "bottom"),
      layoutSize: C(() => f.value ? d.value : 0),
      elementSize: d,
      active: f,
      absolute: H(e, "absolute")
    });
    return ul(e, Vf), ht({
      VBtn: {
        baseColor: H(e, "baseColor"),
        color: H(e, "color"),
        density: H(e, "density"),
        stacked: C(() => e.mode !== "horizontal"),
        variant: "text"
      }
    }, {
      scoped: !0
    }), F(() => m(e.tag, {
      class: ["v-bottom-navigation", {
        "v-bottom-navigation--active": f.value,
        "v-bottom-navigation--grow": e.grow,
        "v-bottom-navigation--shift": e.mode === "shift"
      }, i.value, a.value, l.value, s.value, o.value, u.value, e.class],
      style: [r.value, h.value, {
        height: se(d.value)
      }, c.value, e.style]
    }, {
      default: () => [n.default && m("div", {
        class: "v-bottom-navigation__content"
      }, [n.default()])]
    })), {};
  }
}), H4 = B({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: !0
  },
  scrollable: Boolean,
  ...os({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: bu
    },
    zIndex: 2400
  })
}, "VDialog"), S1 = X()({
  name: "VDialog",
  props: H4(),
  emits: {
    "update:modelValue": (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const l = pe(e, "modelValue"), {
      scopeId: a
    } = Wl(), r = z();
    function s(c) {
      var h, g;
      const d = c.relatedTarget, f = c.target;
      if (d !== f && ((h = r.value) != null && h.contentEl) && // We're the topmost dialog
      ((g = r.value) != null && g.globalTop) && // It isn't the document or the dialog body
      ![document, r.value.contentEl].includes(f) && // It isn't inside the dialog body
      !r.value.contentEl.contains(f)) {
        const v = $r(r.value.contentEl);
        if (!v.length) return;
        const p = v[0], O = v[v.length - 1];
        d === p ? O.focus() : p.focus();
      }
    }
    qe && ee(() => l.value && e.retainFocus, (c) => {
      c ? document.addEventListener("focusin", s) : document.removeEventListener("focusin", s);
    }, {
      immediate: !0
    });
    function o() {
      var c;
      n("afterEnter"), (c = r.value) != null && c.contentEl && !r.value.contentEl.contains(document.activeElement) && r.value.contentEl.focus({
        preventScroll: !0
      });
    }
    function u() {
      n("afterLeave");
    }
    return ee(l, async (c) => {
      var d;
      c || (await He(), (d = r.value.activatorEl) == null || d.focus({
        preventScroll: !0
      }));
    }), F(() => {
      const c = Fn.filterProps(e), d = q({
        "aria-haspopup": "dialog",
        "aria-expanded": String(l.value)
      }, e.activatorProps), f = q({
        tabindex: -1
      }, e.contentProps);
      return m(Fn, q({
        ref: r,
        class: ["v-dialog", {
          "v-dialog--fullscreen": e.fullscreen,
          "v-dialog--scrollable": e.scrollable
        }, e.class],
        style: e.style
      }, c, {
        modelValue: l.value,
        "onUpdate:modelValue": (h) => l.value = h,
        "aria-modal": "true",
        activatorProps: d,
        contentProps: f,
        role: "dialog",
        onAfterEnter: o,
        onAfterLeave: u
      }, a), {
        activator: i.activator,
        default: function() {
          for (var h = arguments.length, g = new Array(h), v = 0; v < h; v++)
            g[v] = arguments[v];
          return m(Te, {
            root: "VDialog"
          }, {
            default: () => {
              var p;
              return [(p = i.default) == null ? void 0 : p.call(i, ...g)];
            }
          });
        }
      });
    }), Bn({}, r);
  }
}), vC = B({
  inset: Boolean,
  ...H4({
    transition: "bottom-sheet-transition"
  })
}, "VBottomSheet"), pC = X()({
  name: "VBottomSheet",
  props: vC(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue");
    return F(() => {
      const l = S1.filterProps(e);
      return m(S1, q(l, {
        contentClass: ["v-bottom-sheet__content", e.contentClass],
        modelValue: i.value,
        "onUpdate:modelValue": (a) => i.value = a,
        class: ["v-bottom-sheet", {
          "v-bottom-sheet--inset": e.inset
        }, e.class],
        style: e.style
      }), n);
    }), {};
  }
}), OC = B({
  divider: [Number, String],
  ...ue()
}, "VBreadcrumbsDivider"), j4 = X()({
  name: "VBreadcrumbsDivider",
  props: OC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => {
      var i;
      return m("li", {
        class: ["v-breadcrumbs-divider", e.class],
        style: e.style
      }, [((i = n == null ? void 0 : n.default) == null ? void 0 : i.call(n)) ?? e.divider]);
    }), {};
  }
}), yC = B({
  active: Boolean,
  activeClass: String,
  activeColor: String,
  color: String,
  disabled: Boolean,
  title: String,
  ...ue(),
  ...ss(),
  ...Ve({
    tag: "li"
  })
}, "VBreadcrumbsItem"), X4 = X()({
  name: "VBreadcrumbsItem",
  props: yC(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    const l = rs(e, i), a = C(() => {
      var u;
      return e.active || ((u = l.isActive) == null ? void 0 : u.value);
    }), r = C(() => a.value ? e.activeColor : e.color), {
      textColorClasses: s,
      textColorStyles: o
    } = Yt(r);
    return F(() => m(e.tag, {
      class: ["v-breadcrumbs-item", {
        "v-breadcrumbs-item--active": a.value,
        "v-breadcrumbs-item--disabled": e.disabled,
        [`${e.activeClass}`]: a.value && e.activeClass
      }, s.value, e.class],
      style: [o.value, e.style],
      "aria-current": a.value ? "page" : void 0
    }, {
      default: () => {
        var u, c;
        return [l.isLink.value ? m("a", {
          class: "v-breadcrumbs-item--link",
          href: l.href.value,
          "aria-current": a.value ? "page" : void 0,
          onClick: l.navigate
        }, [((c = n.default) == null ? void 0 : c.call(n)) ?? e.title]) : ((u = n.default) == null ? void 0 : u.call(n)) ?? e.title];
      }
    })), {};
  }
}), bC = B({
  activeClass: String,
  activeColor: String,
  bgColor: String,
  color: String,
  disabled: Boolean,
  divider: {
    type: String,
    default: "/"
  },
  icon: Se,
  items: {
    type: Array,
    default: () => []
  },
  ...ue(),
  ...Zt(),
  ...at(),
  ...Ve({
    tag: "ul"
  })
}, "VBreadcrumbs"), CC = X()({
  name: "VBreadcrumbs",
  props: bC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = Fe(H(e, "bgColor")), {
      densityClasses: a
    } = nn(e), {
      roundedClasses: r
    } = gt(e);
    ht({
      VBreadcrumbsDivider: {
        divider: H(e, "divider")
      },
      VBreadcrumbsItem: {
        activeClass: H(e, "activeClass"),
        activeColor: H(e, "activeColor"),
        color: H(e, "color"),
        disabled: H(e, "disabled")
      }
    });
    const s = C(() => e.items.map((o) => typeof o == "string" ? {
      item: {
        title: o
      },
      raw: o
    } : {
      item: o,
      raw: o
    }));
    return F(() => {
      const o = !!(n.prepend || e.icon);
      return m(e.tag, {
        class: ["v-breadcrumbs", i.value, a.value, r.value, e.class],
        style: [l.value, e.style]
      }, {
        default: () => {
          var u;
          return [o && m("li", {
            key: "prepend",
            class: "v-breadcrumbs__prepend"
          }, [n.prepend ? m(Te, {
            key: "prepend-defaults",
            disabled: !e.icon,
            defaults: {
              VIcon: {
                icon: e.icon,
                start: !0
              }
            }
          }, n.prepend) : m(ze, {
            key: "prepend-icon",
            start: !0,
            icon: e.icon
          }, null)]), s.value.map((c, d, f) => {
            var v;
            let {
              item: h,
              raw: g
            } = c;
            return m(le, null, [((v = n.item) == null ? void 0 : v.call(n, {
              item: h,
              index: d
            })) ?? m(X4, q({
              key: d,
              disabled: d >= f.length - 1
            }, typeof h == "string" ? {
              title: h
            } : h), {
              default: n.title ? () => {
                var p;
                return (p = n.title) == null ? void 0 : p.call(n, {
                  item: h,
                  index: d
                });
              } : void 0
            }), d < f.length - 1 && m(j4, null, {
              default: n.divider ? () => {
                var p;
                return (p = n.divider) == null ? void 0 : p.call(n, {
                  item: g,
                  index: d
                });
              } : void 0
            })]);
          }), (u = n.default) == null ? void 0 : u.call(n)];
        }
      });
    }), {};
  }
}), N4 = X()({
  name: "VCardActions",
  props: ue(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ht({
      VBtn: {
        slim: !0,
        variant: "text"
      }
    }), F(() => {
      var i;
      return m("div", {
        class: ["v-card-actions", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), SC = B({
  opacity: [Number, String],
  ...ue(),
  ...Ve()
}, "VCardSubtitle"), q4 = X()({
  name: "VCardSubtitle",
  props: SC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => m(e.tag, {
      class: ["v-card-subtitle", e.class],
      style: [{
        "--v-card-subtitle-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), Y4 = Oi("v-card-title"), wC = B({
  appendAvatar: String,
  appendIcon: Se,
  prependAvatar: String,
  prependIcon: Se,
  subtitle: [String, Number],
  title: [String, Number],
  ...ue(),
  ...Zt()
}, "VCardItem"), F4 = X()({
  name: "VCardItem",
  props: wC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => {
      var u;
      const i = !!(e.prependAvatar || e.prependIcon), l = !!(i || n.prepend), a = !!(e.appendAvatar || e.appendIcon), r = !!(a || n.append), s = !!(e.title != null || n.title), o = !!(e.subtitle != null || n.subtitle);
      return m("div", {
        class: ["v-card-item", e.class],
        style: e.style
      }, [l && m("div", {
        key: "prepend",
        class: "v-card-item__prepend"
      }, [n.prepend ? m(Te, {
        key: "prepend-defaults",
        disabled: !i,
        defaults: {
          VAvatar: {
            density: e.density,
            image: e.prependAvatar
          },
          VIcon: {
            density: e.density,
            icon: e.prependIcon
          }
        }
      }, n.prepend) : m(le, null, [e.prependAvatar && m(An, {
        key: "prepend-avatar",
        density: e.density,
        image: e.prependAvatar
      }, null), e.prependIcon && m(ze, {
        key: "prepend-icon",
        density: e.density,
        icon: e.prependIcon
      }, null)])]), m("div", {
        class: "v-card-item__content"
      }, [s && m(Y4, {
        key: "title"
      }, {
        default: () => {
          var c;
          return [((c = n.title) == null ? void 0 : c.call(n)) ?? e.title];
        }
      }), o && m(q4, {
        key: "subtitle"
      }, {
        default: () => {
          var c;
          return [((c = n.subtitle) == null ? void 0 : c.call(n)) ?? e.subtitle];
        }
      }), (u = n.default) == null ? void 0 : u.call(n)]), r && m("div", {
        key: "append",
        class: "v-card-item__append"
      }, [n.append ? m(Te, {
        key: "append-defaults",
        disabled: !a,
        defaults: {
          VAvatar: {
            density: e.density,
            image: e.appendAvatar
          },
          VIcon: {
            density: e.density,
            icon: e.appendIcon
          }
        }
      }, n.append) : m(le, null, [e.appendIcon && m(ze, {
        key: "append-icon",
        density: e.density,
        icon: e.appendIcon
      }, null), e.appendAvatar && m(An, {
        key: "append-avatar",
        density: e.density,
        image: e.appendAvatar
      }, null)])])]);
    }), {};
  }
}), kC = B({
  opacity: [Number, String],
  ...ue(),
  ...Ve()
}, "VCardText"), W4 = X()({
  name: "VCardText",
  props: kC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => m(e.tag, {
      class: ["v-card-text", e.class],
      style: [{
        "--v-card-text-opacity": e.opacity
      }, e.style]
    }, n)), {};
  }
}), xC = B({
  appendAvatar: String,
  appendIcon: Se,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: Se,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  subtitle: [String, Number],
  text: [String, Number],
  title: [String, Number],
  ...yn(),
  ...ue(),
  ...Zt(),
  ...wt(),
  ...Lt(),
  ...ku(),
  ..._i(),
  ...qa(),
  ...at(),
  ...ss(),
  ...Ve(),
  ...Ie(),
  ...En({
    variant: "elevated"
  })
}, "VCard"), PC = X()({
  name: "VCard",
  directives: {
    Ripple: Ti
  },
  props: xC(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      themeClasses: l
    } = Xe(e), {
      borderClasses: a
    } = Qn(e), {
      colorClasses: r,
      colorStyles: s,
      variantClasses: o
    } = Gl(e), {
      densityClasses: u
    } = nn(e), {
      dimensionStyles: c
    } = kt(e), {
      elevationClasses: d
    } = Et(e), {
      loaderClasses: f
    } = us(e), {
      locationStyles: h
    } = ta(e), {
      positionClasses: g
    } = Ya(e), {
      roundedClasses: v
    } = gt(e), p = rs(e, n), O = C(() => e.link !== !1 && p.isLink.value), b = C(() => !e.disabled && e.link !== !1 && (e.link || p.isClickable.value));
    return F(() => {
      const V = O.value ? "a" : e.tag, $ = !!(i.title || e.title != null), x = !!(i.subtitle || e.subtitle != null), Q = $ || x, M = !!(i.append || e.appendAvatar || e.appendIcon), w = !!(i.prepend || e.prependAvatar || e.prependIcon), y = !!(i.image || e.image), L = Q || w || M, k = !!(i.text || e.text != null);
      return Je(m(V, {
        class: ["v-card", {
          "v-card--disabled": e.disabled,
          "v-card--flat": e.flat,
          "v-card--hover": e.hover && !(e.disabled || e.flat),
          "v-card--link": b.value
        }, l.value, a.value, r.value, u.value, d.value, f.value, g.value, v.value, o.value, e.class],
        style: [s.value, c.value, h.value, e.style],
        href: p.href.value,
        onClick: b.value && p.navigate,
        tabindex: e.disabled ? -1 : void 0
      }, {
        default: () => {
          var S;
          return [y && m("div", {
            key: "image",
            class: "v-card__image"
          }, [i.image ? m(Te, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                cover: !0,
                src: e.image
              }
            }
          }, i.image) : m($i, {
            key: "image-img",
            cover: !0,
            src: e.image
          }, null)]), m(cs, {
            name: "v-card",
            active: !!e.loading,
            color: typeof e.loading == "boolean" ? void 0 : e.loading
          }, {
            default: i.loader
          }), L && m(F4, {
            key: "item",
            prependAvatar: e.prependAvatar,
            prependIcon: e.prependIcon,
            title: e.title,
            subtitle: e.subtitle,
            appendAvatar: e.appendAvatar,
            appendIcon: e.appendIcon
          }, {
            default: i.item,
            prepend: i.prepend,
            title: i.title,
            subtitle: i.subtitle,
            append: i.append
          }), k && m(W4, {
            key: "text"
          }, {
            default: () => {
              var P;
              return [((P = i.text) == null ? void 0 : P.call(i)) ?? e.text];
            }
          }), (S = i.default) == null ? void 0 : S.call(i), i.actions && m(N4, null, {
            default: i.actions
          }), ol(b.value, "v-card")];
        }
      }), [[Pn("ripple"), b.value && e.ripple]]);
    }), {};
  }
}), U4 = Symbol.for("vuetify:v-window"), G4 = Symbol.for("vuetify:v-window-group"), Tu = B({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || e === "hover"
  },
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  ...ue(),
  ...Ve(),
  ...Ie()
}, "VWindow"), _l = X()({
  name: "VWindow",
  directives: {
    Touch: Of
  },
  props: Tu(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e), {
      isRtl: l
    } = Qt(), {
      t: a
    } = pt(), r = ul(e, G4), s = z(), o = C(() => l.value ? !e.reverse : e.reverse), u = ie(!1), c = C(() => {
      const $ = e.direction === "vertical" ? "y" : "x", Q = (o.value ? !u.value : u.value) ? "-reverse" : "";
      return `v-window-${$}${Q}-transition`;
    }), d = ie(0), f = z(void 0), h = C(() => r.items.value.findIndex(($) => r.selected.value.includes($.id)));
    ee(h, ($, x) => {
      const Q = r.items.value.length, M = Q - 1;
      Q <= 2 ? u.value = $ < x : $ === M && x === 0 ? u.value = !0 : $ === 0 && x === M ? u.value = !1 : u.value = $ < x;
    }), lt(U4, {
      transition: c,
      isReversed: u,
      transitionCount: d,
      transitionHeight: f,
      rootRef: s
    });
    const g = C(() => e.continuous || h.value !== 0), v = C(() => e.continuous || h.value !== r.items.value.length - 1);
    function p() {
      g.value && r.prev();
    }
    function O() {
      v.value && r.next();
    }
    const b = C(() => {
      const $ = [], x = {
        icon: l.value ? e.nextIcon : e.prevIcon,
        class: `v-window__${o.value ? "right" : "left"}`,
        onClick: r.prev,
        "aria-label": a("$vuetify.carousel.prev")
      };
      $.push(g.value ? n.prev ? n.prev({
        props: x
      }) : m(je, x, null) : m("div", null, null));
      const Q = {
        icon: l.value ? e.prevIcon : e.nextIcon,
        class: `v-window__${o.value ? "left" : "right"}`,
        onClick: r.next,
        "aria-label": a("$vuetify.carousel.next")
      };
      return $.push(v.value ? n.next ? n.next({
        props: Q
      }) : m(je, Q, null) : m("div", null, null)), $;
    }), V = C(() => e.touch === !1 ? e.touch : {
      ...{
        left: () => {
          o.value ? p() : O();
        },
        right: () => {
          o.value ? O() : p();
        },
        start: (x) => {
          let {
            originalEvent: Q
          } = x;
          Q.stopPropagation();
        }
      },
      ...e.touch === !0 ? {} : e.touch
    });
    return F(() => Je(m(e.tag, {
      ref: s,
      class: ["v-window", {
        "v-window--show-arrows-on-hover": e.showArrows === "hover"
      }, i.value, e.class],
      style: e.style
    }, {
      default: () => {
        var $, x;
        return [m("div", {
          class: "v-window__container",
          style: {
            height: f.value
          }
        }, [($ = n.default) == null ? void 0 : $.call(n, {
          group: r
        }), e.showArrows !== !1 && m("div", {
          class: "v-window__controls"
        }, [b.value])]), (x = n.additional) == null ? void 0 : x.call(n, {
          group: r
        })];
      }
    }), [[Pn("touch"), V.value]])), {
      group: r
    };
  }
}), $C = B({
  color: String,
  cycle: Boolean,
  delimiterIcon: {
    type: Se,
    default: "$delimiter"
  },
  height: {
    type: [Number, String],
    default: 500
  },
  hideDelimiters: Boolean,
  hideDelimiterBackground: Boolean,
  interval: {
    type: [Number, String],
    default: 6e3,
    validator: (e) => Number(e) > 0
  },
  progress: [Boolean, String],
  verticalDelimiters: [Boolean, String],
  ...Tu({
    continuous: !0,
    mandatory: "force",
    showArrows: !0
  })
}, "VCarousel"), VC = X()({
  name: "VCarousel",
  props: $C(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), {
      t: l
    } = pt(), a = z();
    let r = -1;
    ee(i, o), ee(() => e.interval, o), ee(() => e.cycle, (u) => {
      u ? o() : window.clearTimeout(r);
    }), it(s);
    function s() {
      !e.cycle || !a.value || (r = window.setTimeout(a.value.group.next, +e.interval > 0 ? +e.interval : 6e3));
    }
    function o() {
      window.clearTimeout(r), window.requestAnimationFrame(s);
    }
    return F(() => {
      const u = _l.filterProps(e);
      return m(_l, q({
        ref: a
      }, u, {
        modelValue: i.value,
        "onUpdate:modelValue": (c) => i.value = c,
        class: ["v-carousel", {
          "v-carousel--hide-delimiter-background": e.hideDelimiterBackground,
          "v-carousel--vertical-delimiters": e.verticalDelimiters
        }, e.class],
        style: [{
          height: se(e.height)
        }, e.style]
      }), {
        default: n.default,
        additional: (c) => {
          let {
            group: d
          } = c;
          return m(le, null, [!e.hideDelimiters && m("div", {
            class: "v-carousel__controls",
            style: {
              left: e.verticalDelimiters === "left" && e.verticalDelimiters ? 0 : "auto",
              right: e.verticalDelimiters === "right" ? 0 : "auto"
            }
          }, [d.items.value.length > 0 && m(Te, {
            defaults: {
              VBtn: {
                color: e.color,
                icon: e.delimiterIcon,
                size: "x-small",
                variant: "text"
              }
            },
            scoped: !0
          }, {
            default: () => [d.items.value.map((f, h) => {
              const g = {
                id: `carousel-item-${f.id}`,
                "aria-label": l("$vuetify.carousel.ariaLabel.delimiter", h + 1, d.items.value.length),
                class: ["v-carousel__controls__item", d.isSelected(f.id) && "v-btn--active"],
                onClick: () => d.select(f.id, !0)
              };
              return n.item ? n.item({
                props: g,
                item: f
              }) : m(je, q(f, g), null);
            })]
          })]), e.progress && m(wu, {
            class: "v-carousel__progress",
            color: typeof e.progress == "string" ? e.progress : void 0,
            modelValue: (d.getItemIndex(i.value) + 1) / d.items.value.length * 100
          }, null)]);
        },
        prev: n.prev,
        next: n.next
      });
    }), {};
  }
}), _u = B({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...ue(),
  ...Jl(),
  ...Sf()
}, "VWindowItem"), Al = X()({
  name: "VWindowItem",
  directives: {
    Touch: Of
  },
  props: _u(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Be(U4), l = ea(e, G4), {
      isBooted: a
    } = Ul();
    if (!i || !l) throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const r = ie(!1), s = C(() => a.value && (i.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1));
    function o() {
      !r.value || !i || (r.value = !1, i.transitionCount.value > 0 && (i.transitionCount.value -= 1, i.transitionCount.value === 0 && (i.transitionHeight.value = void 0)));
    }
    function u() {
      var g;
      r.value || !i || (r.value = !0, i.transitionCount.value === 0 && (i.transitionHeight.value = se((g = i.rootRef.value) == null ? void 0 : g.clientHeight)), i.transitionCount.value += 1);
    }
    function c() {
      o();
    }
    function d(g) {
      r.value && He(() => {
        !s.value || !r.value || !i || (i.transitionHeight.value = se(g.clientHeight));
      });
    }
    const f = C(() => {
      const g = i.isReversed.value ? e.reverseTransition : e.transition;
      return s.value ? {
        name: typeof g != "string" ? i.transition.value : g,
        onBeforeEnter: u,
        onAfterEnter: o,
        onEnterCancelled: c,
        onBeforeLeave: u,
        onAfterLeave: o,
        onLeaveCancelled: c,
        onEnter: d
      } : !1;
    }), {
      hasContent: h
    } = wf(e, l.isSelected);
    return F(() => m(en, {
      transition: f.value,
      disabled: !a.value
    }, {
      default: () => {
        var g;
        return [Je(m("div", {
          class: ["v-window-item", l.selectedClass.value, e.class],
          style: e.style
        }, [h.value && ((g = n.default) == null ? void 0 : g.call(n))]), [[xn, l.isSelected.value]])];
      }
    })), {
      groupItem: l
    };
  }
}), QC = B({
  ...a4(),
  ..._u()
}, "VCarouselItem"), LC = X()({
  name: "VCarouselItem",
  inheritAttrs: !1,
  props: QC(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    F(() => {
      const l = $i.filterProps(e), a = Al.filterProps(e);
      return m(Al, q({
        class: ["v-carousel-item", e.class]
      }, a), {
        default: () => [m($i, q(i, l), n)]
      });
    });
  }
}), MC = Oi("v-code"), TC = B({
  color: {
    type: Object
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  height: {
    type: [Number, String],
    default: 150
  },
  width: {
    type: [Number, String],
    default: 300
  },
  ...ue()
}, "VColorPickerCanvas"), _C = $n({
  name: "VColorPickerCanvas",
  props: TC(),
  emits: {
    "update:color": (e) => !0,
    "update:position": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = ie(!1), l = z(), a = ie(parseFloat(e.width)), r = ie(parseFloat(e.height)), s = z({
      x: 0,
      y: 0
    }), o = C({
      get: () => s.value,
      set(p) {
        var V, $;
        if (!l.value) return;
        const {
          x: O,
          y: b
        } = p;
        s.value = p, n("update:color", {
          h: ((V = e.color) == null ? void 0 : V.h) ?? 0,
          s: Ot(O, 0, a.value) / a.value,
          v: 1 - Ot(b, 0, r.value) / r.value,
          a: (($ = e.color) == null ? void 0 : $.a) ?? 1
        });
      }
    }), u = C(() => {
      const {
        x: p,
        y: O
      } = o.value, b = parseInt(e.dotSize, 10) / 2;
      return {
        width: se(e.dotSize),
        height: se(e.dotSize),
        transform: `translate(${se(p - b)}, ${se(O - b)})`
      };
    }), {
      resizeRef: c
    } = Yn((p) => {
      var V;
      if (!((V = c.el) != null && V.offsetParent)) return;
      const {
        width: O,
        height: b
      } = p[0].contentRect;
      a.value = O, r.value = b;
    });
    function d(p, O, b) {
      const {
        left: V,
        top: $,
        width: x,
        height: Q
      } = b;
      o.value = {
        x: Ot(p - V, 0, x),
        y: Ot(O - $, 0, Q)
      };
    }
    function f(p) {
      p.type === "mousedown" && p.preventDefault(), !e.disabled && (h(p), window.addEventListener("mousemove", h), window.addEventListener("mouseup", g), window.addEventListener("touchmove", h), window.addEventListener("touchend", g));
    }
    function h(p) {
      if (e.disabled || !l.value) return;
      i.value = !0;
      const O = B7(p);
      d(O.clientX, O.clientY, l.value.getBoundingClientRect());
    }
    function g() {
      window.removeEventListener("mousemove", h), window.removeEventListener("mouseup", g), window.removeEventListener("touchmove", h), window.removeEventListener("touchend", g);
    }
    function v() {
      var $;
      if (!l.value) return;
      const p = l.value, O = p.getContext("2d");
      if (!O) return;
      const b = O.createLinearGradient(0, 0, p.width, 0);
      b.addColorStop(0, "hsla(0, 0%, 100%, 1)"), b.addColorStop(1, `hsla(${(($ = e.color) == null ? void 0 : $.h) ?? 0}, 100%, 50%, 1)`), O.fillStyle = b, O.fillRect(0, 0, p.width, p.height);
      const V = O.createLinearGradient(0, 0, 0, p.height);
      V.addColorStop(0, "hsla(0, 0%, 0%, 0)"), V.addColorStop(1, "hsla(0, 0%, 0%, 1)"), O.fillStyle = V, O.fillRect(0, 0, p.width, p.height);
    }
    return ee(() => {
      var p;
      return (p = e.color) == null ? void 0 : p.h;
    }, v, {
      immediate: !0
    }), ee(() => [a.value, r.value], (p, O) => {
      v(), s.value = {
        x: o.value.x * p[0] / O[0],
        y: o.value.y * p[1] / O[1]
      };
    }, {
      flush: "post"
    }), ee(() => e.color, () => {
      if (i.value) {
        i.value = !1;
        return;
      }
      s.value = e.color ? {
        x: e.color.s * a.value,
        y: (1 - e.color.v) * r.value
      } : {
        x: 0,
        y: 0
      };
    }, {
      deep: !0,
      immediate: !0
    }), it(() => v()), F(() => m("div", {
      ref: c,
      class: ["v-color-picker-canvas", e.class],
      style: e.style,
      onMousedown: f,
      onTouchstartPassive: f
    }, [m("canvas", {
      ref: l,
      width: a.value,
      height: r.value
    }, null), e.color && m("div", {
      class: ["v-color-picker-canvas__dot", {
        "v-color-picker-canvas__dot--disabled": e.disabled
      }],
      style: u.value
    }, null)])), {};
  }
});
function AC(e, t) {
  if (t) {
    const {
      a: n,
      ...i
    } = e;
    return i;
  }
  return e;
}
function RC(e, t) {
  if (t == null || typeof t == "string") {
    const n = fg(e);
    return e.a === 1 ? n.slice(0, 7) : n;
  }
  if (typeof t == "object") {
    let n;
    return bl(t, ["r", "g", "b"]) ? n = Pi(e) : bl(t, ["h", "s", "l"]) ? n = rg(e) : bl(t, ["h", "s", "v"]) && (n = e), AC(n, !bl(t, ["a"]) && e.a === 1);
  }
  return e;
}
const ma = {
  h: 0,
  s: 0,
  v: 0,
  a: 1
}, w1 = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "R",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.r),
    getColor: (e, t) => ({
      ...e,
      r: Number(t)
    })
  }, {
    label: "G",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.g),
    getColor: (e, t) => ({
      ...e,
      g: Number(t)
    })
  }, {
    label: "B",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.b),
    getColor: (e, t) => ({
      ...e,
      b: Number(t)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    })
  }],
  to: Pi,
  from: vu
};
var B9;
const ZC = {
  ...w1,
  inputs: (B9 = w1.inputs) == null ? void 0 : B9.slice(0, 3)
}, k1 = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "H",
    max: 360,
    step: 1,
    getValue: (e) => Math.round(e.h),
    getColor: (e, t) => ({
      ...e,
      h: Number(t)
    })
  }, {
    label: "S",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.s * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      s: Number(t)
    })
  }, {
    label: "L",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.l * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      l: Number(t)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    })
  }],
  to: rg,
  from: df
}, IC = {
  ...k1,
  inputs: k1.inputs.slice(0, 3)
}, K4 = {
  inputProps: {
    type: "text"
  },
  inputs: [{
    label: "HEXA",
    getValue: (e) => e,
    getColor: (e, t) => t
  }],
  to: fg,
  from: dg
}, DC = {
  ...K4,
  inputs: [{
    label: "HEX",
    getValue: (e) => e.slice(0, 7),
    getColor: (e, t) => t
  }]
}, Vl = {
  rgb: ZC,
  rgba: w1,
  hsl: IC,
  hsla: k1,
  hex: DC,
  hexa: K4
}, BC = (e) => {
  let {
    label: t,
    ...n
  } = e;
  return m("div", {
    class: "v-color-picker-edit__input"
  }, [m("input", n, null), m("span", null, [t])]);
}, EC = B({
  color: Object,
  disabled: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(Vl).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(Vl),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(Vl).includes(t))
  },
  ...ue()
}, "VColorPickerEdit"), zC = $n({
  name: "VColorPickerEdit",
  props: EC(),
  emits: {
    "update:color": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = C(() => e.modes.map((a) => ({
      ...Vl[a],
      name: a
    }))), l = C(() => {
      var s;
      const a = i.value.find((o) => o.name === e.mode);
      if (!a) return [];
      const r = e.color ? a.to(e.color) : null;
      return (s = a.inputs) == null ? void 0 : s.map((o) => {
        let {
          getValue: u,
          getColor: c,
          ...d
        } = o;
        return {
          ...a.inputProps,
          ...d,
          disabled: e.disabled,
          value: r && u(r),
          onChange: (f) => {
            const h = f.target;
            h && n("update:color", a.from(c(r ?? a.to(ma), h.value)));
          }
        };
      });
    });
    return F(() => {
      var a;
      return m("div", {
        class: ["v-color-picker-edit", e.class],
        style: e.style
      }, [(a = l.value) == null ? void 0 : a.map((r) => m(BC, r, null)), i.value.length > 1 && m(je, {
        icon: "$unfold",
        size: "x-small",
        variant: "plain",
        onClick: () => {
          const r = i.value.findIndex((s) => s.name === e.mode);
          n("update:mode", i.value[(r + 1) % i.value.length].name);
        }
      }, null)]);
    }), {};
  }
}), Df = Symbol.for("vuetify:v-slider");
function x1(e, t, n) {
  const i = n === "vertical", l = t.getBoundingClientRect(), a = "touches" in e ? e.touches[0] : e;
  return i ? a.clientY - (l.top + l.height / 2) : a.clientX - (l.left + l.width / 2);
}
function HC(e, t) {
  return "touches" in e && e.touches.length ? e.touches[0][t] : "changedTouches" in e && e.changedTouches.length ? e.changedTouches[0][t] : e[t];
}
const J4 = B({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  readonly: {
    type: Boolean,
    default: null
  },
  max: {
    type: [Number, String],
    default: 100
  },
  min: {
    type: [Number, String],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 0
  },
  thumbColor: String,
  thumbLabel: {
    type: [Boolean, String],
    default: void 0,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  thumbSize: {
    type: [Number, String],
    default: 20
  },
  showTicks: {
    type: [Boolean, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  ticks: {
    type: [Array, Object]
  },
  tickSize: {
    type: [Number, String],
    default: 2
  },
  color: String,
  trackColor: String,
  trackFillColor: String,
  trackSize: {
    type: [Number, String],
    default: 4
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  reverse: Boolean,
  ...at(),
  ...Lt({
    elevation: 2
  }),
  ripple: {
    type: Boolean,
    default: !0
  }
}, "Slider"), e5 = (e) => {
  const t = C(() => parseFloat(e.min)), n = C(() => parseFloat(e.max)), i = C(() => +e.step > 0 ? parseFloat(e.step) : 0), l = C(() => Math.max(l2(i.value), l2(t.value)));
  function a(r) {
    if (r = parseFloat(r), i.value <= 0) return r;
    const s = Ot(r, t.value, n.value), o = t.value % i.value, u = Math.round((s - o) / i.value) * i.value + o;
    return parseFloat(Math.min(u, n.value).toFixed(l.value));
  }
  return {
    min: t,
    max: n,
    step: i,
    decimals: l,
    roundValue: a
  };
}, t5 = (e) => {
  let {
    props: t,
    steps: n,
    onSliderStart: i,
    onSliderMove: l,
    onSliderEnd: a,
    getActiveThumb: r
  } = e;
  const {
    isRtl: s
  } = Qt(), o = H(t, "reverse"), u = C(() => t.direction === "vertical"), c = C(() => u.value !== o.value), {
    min: d,
    max: f,
    step: h,
    decimals: g,
    roundValue: v
  } = n, p = C(() => parseInt(t.thumbSize, 10)), O = C(() => parseInt(t.tickSize, 10)), b = C(() => parseInt(t.trackSize, 10)), V = C(() => (f.value - d.value) / h.value), $ = H(t, "disabled"), x = C(() => t.error || t.disabled ? void 0 : t.thumbColor ?? t.color), Q = C(() => t.error || t.disabled ? void 0 : t.trackColor ?? t.color), M = C(() => t.error || t.disabled ? void 0 : t.trackFillColor ?? t.color), w = ie(!1), y = ie(0), L = z(), k = z();
  function S(U) {
    var Pe;
    const ge = t.direction === "vertical", be = ge ? "top" : "left", De = ge ? "height" : "width", Ye = ge ? "clientY" : "clientX", {
      [be]: re,
      [De]: Qe
    } = (Pe = L.value) == null ? void 0 : Pe.$el.getBoundingClientRect(), te = HC(U, Ye);
    let oe = Math.min(Math.max((te - re - y.value) / Qe, 0), 1) || 0;
    return (ge ? c.value : c.value !== s.value) && (oe = 1 - oe), v(d.value + oe * (f.value - d.value));
  }
  const P = (U) => {
    a({
      value: S(U)
    }), w.value = !1, y.value = 0;
  }, T = (U) => {
    k.value = r(U), k.value && (k.value.focus(), w.value = !0, k.value.contains(U.target) ? y.value = x1(U, k.value, t.direction) : (y.value = 0, l({
      value: S(U)
    })), i({
      value: S(U)
    }));
  }, _ = {
    passive: !0,
    capture: !0
  };
  function D(U) {
    l({
      value: S(U)
    });
  }
  function N(U) {
    U.stopPropagation(), U.preventDefault(), P(U), window.removeEventListener("mousemove", D, _), window.removeEventListener("mouseup", N);
  }
  function K(U) {
    var ge;
    P(U), window.removeEventListener("touchmove", D, _), (ge = U.target) == null || ge.removeEventListener("touchend", K);
  }
  function E(U) {
    var ge;
    T(U), window.addEventListener("touchmove", D, _), (ge = U.target) == null || ge.addEventListener("touchend", K, {
      passive: !1
    });
  }
  function I(U) {
    U.preventDefault(), T(U), window.addEventListener("mousemove", D, _), window.addEventListener("mouseup", N, {
      passive: !1
    });
  }
  const Z = (U) => {
    const ge = (U - d.value) / (f.value - d.value) * 100;
    return Ot(isNaN(ge) ? 0 : ge, 0, 100);
  }, Y = H(t, "showTicks"), ce = C(() => Y.value ? t.ticks ? Array.isArray(t.ticks) ? t.ticks.map((U) => ({
    value: U,
    position: Z(U),
    label: U.toString()
  })) : Object.keys(t.ticks).map((U) => ({
    value: parseFloat(U),
    position: Z(parseFloat(U)),
    label: t.ticks[U]
  })) : V.value !== 1 / 0 ? si(V.value + 1).map((U) => {
    const ge = d.value + U * h.value;
    return {
      value: ge,
      position: Z(ge)
    };
  }) : [] : []), de = C(() => ce.value.some((U) => {
    let {
      label: ge
    } = U;
    return !!ge;
  })), ye = {
    activeThumbRef: k,
    color: H(t, "color"),
    decimals: g,
    disabled: $,
    direction: H(t, "direction"),
    elevation: H(t, "elevation"),
    hasLabels: de,
    isReversed: o,
    indexFromEnd: c,
    min: d,
    max: f,
    mousePressed: w,
    numTicks: V,
    onSliderMousedown: I,
    onSliderTouchstart: E,
    parsedTicks: ce,
    parseMouseMove: S,
    position: Z,
    readonly: H(t, "readonly"),
    rounded: H(t, "rounded"),
    roundValue: v,
    showTicks: Y,
    startOffset: y,
    step: h,
    thumbSize: p,
    thumbColor: x,
    thumbLabel: H(t, "thumbLabel"),
    ticks: H(t, "ticks"),
    tickSize: O,
    trackColor: Q,
    trackContainerRef: L,
    trackFillColor: M,
    trackSize: b,
    vertical: u
  };
  return lt(Df, ye), ye;
}, jC = B({
  focused: Boolean,
  max: {
    type: Number,
    required: !0
  },
  min: {
    type: Number,
    required: !0
  },
  modelValue: {
    type: Number,
    required: !0
  },
  position: {
    type: Number,
    required: !0
  },
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  name: String,
  ...ue()
}, "VSliderThumb"), P1 = X()({
  name: "VSliderThumb",
  directives: {
    Ripple: Ti
  },
  props: jC(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const l = Be(Df), {
      isRtl: a,
      rtlClasses: r
    } = Qt();
    if (!l) throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
    const {
      thumbColor: s,
      step: o,
      disabled: u,
      thumbSize: c,
      thumbLabel: d,
      direction: f,
      isReversed: h,
      vertical: g,
      readonly: v,
      elevation: p,
      mousePressed: O,
      decimals: b,
      indexFromEnd: V
    } = l, $ = C(() => u.value ? void 0 : p.value), {
      elevationClasses: x
    } = Et($), {
      textColorClasses: Q,
      textColorStyles: M
    } = Yt(s), {
      pageup: w,
      pagedown: y,
      end: L,
      home: k,
      left: S,
      right: P,
      down: T,
      up: _
    } = n1, D = [w, y, L, k, S, P, T, _], N = C(() => o.value ? [1, 2, 3] : [1, 5, 10]);
    function K(I, Z) {
      if (!D.includes(I.key)) return;
      I.preventDefault();
      const Y = o.value || 0.1, ce = (e.max - e.min) / Y;
      if ([S, P, T, _].includes(I.key)) {
        const ye = (g.value ? [a.value ? S : P, h.value ? T : _] : V.value !== a.value ? [S, _] : [P, _]).includes(I.key) ? 1 : -1, U = I.shiftKey ? 2 : I.ctrlKey ? 1 : 0;
        Z = Z + ye * Y * N.value[U];
      } else if (I.key === k)
        Z = e.min;
      else if (I.key === L)
        Z = e.max;
      else {
        const de = I.key === y ? 1 : -1;
        Z = Z - de * Y * (ce > 100 ? ce / 10 : 10);
      }
      return Math.max(e.min, Math.min(e.max, Z));
    }
    function E(I) {
      const Z = K(I, e.modelValue);
      Z != null && i("update:modelValue", Z);
    }
    return F(() => {
      const I = se(V.value ? 100 - e.position : e.position, "%");
      return m("div", {
        class: ["v-slider-thumb", {
          "v-slider-thumb--focused": e.focused,
          "v-slider-thumb--pressed": e.focused && O.value
        }, e.class, r.value],
        style: [{
          "--v-slider-thumb-position": I,
          "--v-slider-thumb-size": se(c.value)
        }, e.style],
        role: "slider",
        tabindex: u.value ? -1 : 0,
        "aria-label": e.name,
        "aria-valuemin": e.min,
        "aria-valuemax": e.max,
        "aria-valuenow": e.modelValue,
        "aria-readonly": !!v.value,
        "aria-orientation": f.value,
        onKeydown: v.value ? void 0 : E
      }, [m("div", {
        class: ["v-slider-thumb__surface", Q.value, x.value],
        style: {
          ...M.value
        }
      }, null), Je(m("div", {
        class: ["v-slider-thumb__ripple", Q.value],
        style: M.value
      }, null), [[Pn("ripple"), e.ripple, null, {
        circle: !0,
        center: !0
      }]]), m(xf, {
        origin: "bottom center"
      }, {
        default: () => {
          var Z;
          return [Je(m("div", {
            class: "v-slider-thumb__label-container"
          }, [m("div", {
            class: ["v-slider-thumb__label"]
          }, [m("div", null, [((Z = n["thumb-label"]) == null ? void 0 : Z.call(n, {
            modelValue: e.modelValue
          })) ?? e.modelValue.toFixed(o.value ? b.value : 1)])])]), [[xn, d.value && e.focused || d.value === "always"]])];
        }
      })]);
    }), {};
  }
}), XC = B({
  start: {
    type: Number,
    required: !0
  },
  stop: {
    type: Number,
    required: !0
  },
  ...ue()
}, "VSliderTrack"), n5 = X()({
  name: "VSliderTrack",
  props: XC(),
  emits: {},
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Be(Df);
    if (!i) throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
    const {
      color: l,
      parsedTicks: a,
      rounded: r,
      showTicks: s,
      tickSize: o,
      trackColor: u,
      trackFillColor: c,
      trackSize: d,
      vertical: f,
      min: h,
      max: g,
      indexFromEnd: v
    } = i, {
      roundedClasses: p
    } = gt(r), {
      backgroundColorClasses: O,
      backgroundColorStyles: b
    } = Fe(c), {
      backgroundColorClasses: V,
      backgroundColorStyles: $
    } = Fe(u), x = C(() => `inset-${f.value ? "block" : "inline"}-${v.value ? "end" : "start"}`), Q = C(() => f.value ? "height" : "width"), M = C(() => ({
      [x.value]: "0%",
      [Q.value]: "100%"
    })), w = C(() => e.stop - e.start), y = C(() => ({
      [x.value]: se(e.start, "%"),
      [Q.value]: se(w.value, "%")
    })), L = C(() => s.value ? (f.value ? a.value.slice().reverse() : a.value).map((S, P) => {
      var _;
      const T = S.value !== h.value && S.value !== g.value ? se(S.position, "%") : void 0;
      return m("div", {
        key: S.value,
        class: ["v-slider-track__tick", {
          "v-slider-track__tick--filled": S.position >= e.start && S.position <= e.stop,
          "v-slider-track__tick--first": S.value === h.value,
          "v-slider-track__tick--last": S.value === g.value
        }],
        style: {
          [x.value]: T
        }
      }, [(S.label || n["tick-label"]) && m("div", {
        class: "v-slider-track__tick-label"
      }, [((_ = n["tick-label"]) == null ? void 0 : _.call(n, {
        tick: S,
        index: P
      })) ?? S.label])]);
    }) : []);
    return F(() => m("div", {
      class: ["v-slider-track", p.value, e.class],
      style: [{
        "--v-slider-track-size": se(d.value),
        "--v-slider-tick-size": se(o.value)
      }, e.style]
    }, [m("div", {
      class: ["v-slider-track__background", V.value, {
        "v-slider-track__background--opacity": !!l.value || !c.value
      }],
      style: {
        ...M.value,
        ...$.value
      }
    }, null), m("div", {
      class: ["v-slider-track__fill", O.value],
      style: {
        ...y.value,
        ...b.value
      }
    }, null), s.value && m("div", {
      class: ["v-slider-track__ticks", {
        "v-slider-track__ticks--always-show": s.value === "always"
      }]
    }, [L.value])])), {};
  }
}), NC = B({
  ...ds(),
  ...J4(),
  ...Ri(),
  modelValue: {
    type: [Number, String],
    default: 0
  }
}, "VSlider"), $1 = X()({
  name: "VSlider",
  props: NC(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    start: (e) => !0,
    end: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const l = z(), {
      rtlClasses: a
    } = Qt(), r = e5(e), s = pe(e, "modelValue", void 0, (Q) => r.roundValue(Q ?? r.min.value)), {
      min: o,
      max: u,
      mousePressed: c,
      roundValue: d,
      onSliderMousedown: f,
      onSliderTouchstart: h,
      trackContainerRef: g,
      position: v,
      hasLabels: p,
      readonly: O
    } = t5({
      props: e,
      steps: r,
      onSliderStart: () => {
        i("start", s.value);
      },
      onSliderEnd: (Q) => {
        let {
          value: M
        } = Q;
        const w = d(M);
        s.value = w, i("end", w);
      },
      onSliderMove: (Q) => {
        let {
          value: M
        } = Q;
        return s.value = d(M);
      },
      getActiveThumb: () => {
        var Q;
        return (Q = l.value) == null ? void 0 : Q.$el;
      }
    }), {
      isFocused: b,
      focus: V,
      blur: $
    } = Ai(e), x = C(() => v(s.value));
    return F(() => {
      const Q = Ft.filterProps(e), M = !!(e.label || n.label || n.prepend);
      return m(Ft, q({
        class: ["v-slider", {
          "v-slider--has-labels": !!n["tick-label"] || p.value,
          "v-slider--focused": b.value,
          "v-slider--pressed": c.value,
          "v-slider--disabled": e.disabled
        }, a.value, e.class],
        style: e.style
      }, Q, {
        focused: b.value
      }), {
        ...n,
        prepend: M ? (w) => {
          var y, L;
          return m(le, null, [((y = n.label) == null ? void 0 : y.call(n, w)) ?? (e.label ? m(Fa, {
            id: w.id.value,
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (L = n.prepend) == null ? void 0 : L.call(n, w)]);
        } : void 0,
        default: (w) => {
          let {
            id: y,
            messagesId: L
          } = w;
          return m("div", {
            class: "v-slider__container",
            onMousedown: O.value ? void 0 : f,
            onTouchstartPassive: O.value ? void 0 : h
          }, [m("input", {
            id: y.value,
            name: e.name || y.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: s.value
          }, null), m(n5, {
            ref: g,
            start: 0,
            stop: x.value
          }, {
            "tick-label": n["tick-label"]
          }), m(P1, {
            ref: l,
            "aria-describedby": L.value,
            focused: b.value,
            min: o.value,
            max: u.value,
            modelValue: s.value,
            "onUpdate:modelValue": (k) => s.value = k,
            position: x.value,
            elevation: e.elevation,
            onFocus: V,
            onBlur: $,
            ripple: e.ripple,
            name: e.name
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), {};
  }
}), qC = B({
  color: {
    type: Object
  },
  disabled: Boolean,
  hideAlpha: Boolean,
  ...ue()
}, "VColorPickerPreview"), YC = $n({
  name: "VColorPickerPreview",
  props: qC(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = new AbortController();
    ef(() => i.abort());
    async function l() {
      if (!e2) return;
      const a = new window.EyeDropper();
      try {
        const r = await a.open({
          signal: i.signal
        }), s = dg(r.sRGBHex);
        n("update:color", {
          ...e.color ?? ma,
          ...s
        });
      } catch {
      }
    }
    return F(() => {
      var a, r;
      return m("div", {
        class: ["v-color-picker-preview", {
          "v-color-picker-preview--hide-alpha": e.hideAlpha
        }, e.class],
        style: e.style
      }, [e2 && m("div", {
        class: "v-color-picker-preview__eye-dropper",
        key: "eyeDropper"
      }, [m(je, {
        onClick: l,
        icon: "$eyeDropper",
        variant: "plain",
        density: "comfortable"
      }, null)]), m("div", {
        class: "v-color-picker-preview__dot"
      }, [m("div", {
        style: {
          background: og(e.color ?? ma)
        }
      }, null)]), m("div", {
        class: "v-color-picker-preview__sliders"
      }, [m($1, {
        class: "v-color-picker-preview__track v-color-picker-preview__hue",
        modelValue: (a = e.color) == null ? void 0 : a.h,
        "onUpdate:modelValue": (s) => n("update:color", {
          ...e.color ?? ma,
          h: s
        }),
        step: 0,
        min: 0,
        max: 360,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null), !e.hideAlpha && m($1, {
        class: "v-color-picker-preview__track v-color-picker-preview__alpha",
        modelValue: ((r = e.color) == null ? void 0 : r.a) ?? 1,
        "onUpdate:modelValue": (s) => n("update:color", {
          ...e.color ?? ma,
          a: s
        }),
        step: 1 / 256,
        min: 0,
        max: 1,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null)])]);
    }), {};
  }
}), FC = {
  base: "#f44336",
  lighten5: "#ffebee",
  lighten4: "#ffcdd2",
  lighten3: "#ef9a9a",
  lighten2: "#e57373",
  lighten1: "#ef5350",
  darken1: "#e53935",
  darken2: "#d32f2f",
  darken3: "#c62828",
  darken4: "#b71c1c",
  accent1: "#ff8a80",
  accent2: "#ff5252",
  accent3: "#ff1744",
  accent4: "#d50000"
}, WC = {
  base: "#e91e63",
  lighten5: "#fce4ec",
  lighten4: "#f8bbd0",
  lighten3: "#f48fb1",
  lighten2: "#f06292",
  lighten1: "#ec407a",
  darken1: "#d81b60",
  darken2: "#c2185b",
  darken3: "#ad1457",
  darken4: "#880e4f",
  accent1: "#ff80ab",
  accent2: "#ff4081",
  accent3: "#f50057",
  accent4: "#c51162"
}, UC = {
  base: "#9c27b0",
  lighten5: "#f3e5f5",
  lighten4: "#e1bee7",
  lighten3: "#ce93d8",
  lighten2: "#ba68c8",
  lighten1: "#ab47bc",
  darken1: "#8e24aa",
  darken2: "#7b1fa2",
  darken3: "#6a1b9a",
  darken4: "#4a148c",
  accent1: "#ea80fc",
  accent2: "#e040fb",
  accent3: "#d500f9",
  accent4: "#aa00ff"
}, GC = {
  base: "#673ab7",
  lighten5: "#ede7f6",
  lighten4: "#d1c4e9",
  lighten3: "#b39ddb",
  lighten2: "#9575cd",
  lighten1: "#7e57c2",
  darken1: "#5e35b1",
  darken2: "#512da8",
  darken3: "#4527a0",
  darken4: "#311b92",
  accent1: "#b388ff",
  accent2: "#7c4dff",
  accent3: "#651fff",
  accent4: "#6200ea"
}, KC = {
  base: "#3f51b5",
  lighten5: "#e8eaf6",
  lighten4: "#c5cae9",
  lighten3: "#9fa8da",
  lighten2: "#7986cb",
  lighten1: "#5c6bc0",
  darken1: "#3949ab",
  darken2: "#303f9f",
  darken3: "#283593",
  darken4: "#1a237e",
  accent1: "#8c9eff",
  accent2: "#536dfe",
  accent3: "#3d5afe",
  accent4: "#304ffe"
}, JC = {
  base: "#2196f3",
  lighten5: "#e3f2fd",
  lighten4: "#bbdefb",
  lighten3: "#90caf9",
  lighten2: "#64b5f6",
  lighten1: "#42a5f5",
  darken1: "#1e88e5",
  darken2: "#1976d2",
  darken3: "#1565c0",
  darken4: "#0d47a1",
  accent1: "#82b1ff",
  accent2: "#448aff",
  accent3: "#2979ff",
  accent4: "#2962ff"
}, eS = {
  base: "#03a9f4",
  lighten5: "#e1f5fe",
  lighten4: "#b3e5fc",
  lighten3: "#81d4fa",
  lighten2: "#4fc3f7",
  lighten1: "#29b6f6",
  darken1: "#039be5",
  darken2: "#0288d1",
  darken3: "#0277bd",
  darken4: "#01579b",
  accent1: "#80d8ff",
  accent2: "#40c4ff",
  accent3: "#00b0ff",
  accent4: "#0091ea"
}, tS = {
  base: "#00bcd4",
  lighten5: "#e0f7fa",
  lighten4: "#b2ebf2",
  lighten3: "#80deea",
  lighten2: "#4dd0e1",
  lighten1: "#26c6da",
  darken1: "#00acc1",
  darken2: "#0097a7",
  darken3: "#00838f",
  darken4: "#006064",
  accent1: "#84ffff",
  accent2: "#18ffff",
  accent3: "#00e5ff",
  accent4: "#00b8d4"
}, nS = {
  base: "#009688",
  lighten5: "#e0f2f1",
  lighten4: "#b2dfdb",
  lighten3: "#80cbc4",
  lighten2: "#4db6ac",
  lighten1: "#26a69a",
  darken1: "#00897b",
  darken2: "#00796b",
  darken3: "#00695c",
  darken4: "#004d40",
  accent1: "#a7ffeb",
  accent2: "#64ffda",
  accent3: "#1de9b6",
  accent4: "#00bfa5"
}, iS = {
  base: "#4caf50",
  lighten5: "#e8f5e9",
  lighten4: "#c8e6c9",
  lighten3: "#a5d6a7",
  lighten2: "#81c784",
  lighten1: "#66bb6a",
  darken1: "#43a047",
  darken2: "#388e3c",
  darken3: "#2e7d32",
  darken4: "#1b5e20",
  accent1: "#b9f6ca",
  accent2: "#69f0ae",
  accent3: "#00e676",
  accent4: "#00c853"
}, lS = {
  base: "#8bc34a",
  lighten5: "#f1f8e9",
  lighten4: "#dcedc8",
  lighten3: "#c5e1a5",
  lighten2: "#aed581",
  lighten1: "#9ccc65",
  darken1: "#7cb342",
  darken2: "#689f38",
  darken3: "#558b2f",
  darken4: "#33691e",
  accent1: "#ccff90",
  accent2: "#b2ff59",
  accent3: "#76ff03",
  accent4: "#64dd17"
}, aS = {
  base: "#cddc39",
  lighten5: "#f9fbe7",
  lighten4: "#f0f4c3",
  lighten3: "#e6ee9c",
  lighten2: "#dce775",
  lighten1: "#d4e157",
  darken1: "#c0ca33",
  darken2: "#afb42b",
  darken3: "#9e9d24",
  darken4: "#827717",
  accent1: "#f4ff81",
  accent2: "#eeff41",
  accent3: "#c6ff00",
  accent4: "#aeea00"
}, rS = {
  base: "#ffeb3b",
  lighten5: "#fffde7",
  lighten4: "#fff9c4",
  lighten3: "#fff59d",
  lighten2: "#fff176",
  lighten1: "#ffee58",
  darken1: "#fdd835",
  darken2: "#fbc02d",
  darken3: "#f9a825",
  darken4: "#f57f17",
  accent1: "#ffff8d",
  accent2: "#ffff00",
  accent3: "#ffea00",
  accent4: "#ffd600"
}, sS = {
  base: "#ffc107",
  lighten5: "#fff8e1",
  lighten4: "#ffecb3",
  lighten3: "#ffe082",
  lighten2: "#ffd54f",
  lighten1: "#ffca28",
  darken1: "#ffb300",
  darken2: "#ffa000",
  darken3: "#ff8f00",
  darken4: "#ff6f00",
  accent1: "#ffe57f",
  accent2: "#ffd740",
  accent3: "#ffc400",
  accent4: "#ffab00"
}, oS = {
  base: "#ff9800",
  lighten5: "#fff3e0",
  lighten4: "#ffe0b2",
  lighten3: "#ffcc80",
  lighten2: "#ffb74d",
  lighten1: "#ffa726",
  darken1: "#fb8c00",
  darken2: "#f57c00",
  darken3: "#ef6c00",
  darken4: "#e65100",
  accent1: "#ffd180",
  accent2: "#ffab40",
  accent3: "#ff9100",
  accent4: "#ff6d00"
}, uS = {
  base: "#ff5722",
  lighten5: "#fbe9e7",
  lighten4: "#ffccbc",
  lighten3: "#ffab91",
  lighten2: "#ff8a65",
  lighten1: "#ff7043",
  darken1: "#f4511e",
  darken2: "#e64a19",
  darken3: "#d84315",
  darken4: "#bf360c",
  accent1: "#ff9e80",
  accent2: "#ff6e40",
  accent3: "#ff3d00",
  accent4: "#dd2c00"
}, cS = {
  base: "#795548",
  lighten5: "#efebe9",
  lighten4: "#d7ccc8",
  lighten3: "#bcaaa4",
  lighten2: "#a1887f",
  lighten1: "#8d6e63",
  darken1: "#6d4c41",
  darken2: "#5d4037",
  darken3: "#4e342e",
  darken4: "#3e2723"
}, dS = {
  base: "#607d8b",
  lighten5: "#eceff1",
  lighten4: "#cfd8dc",
  lighten3: "#b0bec5",
  lighten2: "#90a4ae",
  lighten1: "#78909c",
  darken1: "#546e7a",
  darken2: "#455a64",
  darken3: "#37474f",
  darken4: "#263238"
}, fS = {
  base: "#9e9e9e",
  lighten5: "#fafafa",
  lighten4: "#f5f5f5",
  lighten3: "#eeeeee",
  lighten2: "#e0e0e0",
  lighten1: "#bdbdbd",
  darken1: "#757575",
  darken2: "#616161",
  darken3: "#424242",
  darken4: "#212121"
}, hS = {
  black: "#000000",
  white: "#ffffff",
  transparent: "#ffffff00"
}, mS = {
  red: FC,
  pink: WC,
  purple: UC,
  deepPurple: GC,
  indigo: KC,
  blue: JC,
  lightBlue: eS,
  cyan: tS,
  teal: nS,
  green: iS,
  lightGreen: lS,
  lime: aS,
  yellow: rS,
  amber: sS,
  orange: oS,
  deepOrange: uS,
  brown: cS,
  blueGrey: dS,
  grey: fS,
  shades: hS
}, gS = B({
  swatches: {
    type: Array,
    default: () => vS(mS)
  },
  disabled: Boolean,
  color: Object,
  maxHeight: [Number, String],
  ...ue()
}, "VColorPickerSwatches");
function vS(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return n.base ? [n.base, n.darken4, n.darken3, n.darken2, n.darken1, n.lighten1, n.lighten2, n.lighten3, n.lighten4, n.lighten5] : [n.black, n.white, n.transparent];
  });
}
const pS = $n({
  name: "VColorPickerSwatches",
  props: gS(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    return F(() => m("div", {
      class: ["v-color-picker-swatches", e.class],
      style: [{
        maxHeight: se(e.maxHeight)
      }, e.style]
    }, [m("div", null, [e.swatches.map((i) => m("div", {
      class: "v-color-picker-swatches__swatch"
    }, [i.map((l) => {
      const a = Mn(l), r = vu(a), s = sg(a);
      return m("div", {
        class: "v-color-picker-swatches__color",
        onClick: () => r && n("update:color", r)
      }, [m("div", {
        style: {
          background: s
        }
      }, [e.color && vi(e.color, r) ? m(ze, {
        size: "x-small",
        icon: "$success",
        color: cp(l, "#FFFFFF") > 2 ? "white" : "black"
      }, null) : void 0])]);
    })]))])])), {};
  }
}), Au = B({
  color: String,
  ...yn(),
  ...ue(),
  ...wt(),
  ...Lt(),
  ..._i(),
  ...qa(),
  ...at(),
  ...Ve(),
  ...Ie()
}, "VSheet"), Rl = X()({
  name: "VSheet",
  props: Au(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: a
    } = Fe(H(e, "color")), {
      borderClasses: r
    } = Qn(e), {
      dimensionStyles: s
    } = kt(e), {
      elevationClasses: o
    } = Et(e), {
      locationStyles: u
    } = ta(e), {
      positionClasses: c
    } = Ya(e), {
      roundedClasses: d
    } = gt(e);
    return F(() => m(e.tag, {
      class: ["v-sheet", i.value, l.value, r.value, o.value, c.value, d.value, e.class],
      style: [a.value, s.value, u.value, e.style]
    }, n)), {};
  }
}), OS = B({
  canvasHeight: {
    type: [String, Number],
    default: 150
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  hideCanvas: Boolean,
  hideSliders: Boolean,
  hideInputs: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(Vl).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(Vl),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(Vl).includes(t))
  },
  showSwatches: Boolean,
  swatches: Array,
  swatchesMaxHeight: {
    type: [Number, String],
    default: 150
  },
  modelValue: {
    type: [Object, String]
  },
  ...St(Au({
    width: 300
  }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
}, "VColorPicker"), yS = $n({
  name: "VColorPicker",
  props: OS(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e) {
    const t = pe(e, "mode"), n = z(null), i = pe(e, "modelValue", void 0, (o) => {
      if (o == null || o === "") return null;
      let u;
      try {
        u = vu(Mn(o));
      } catch (c) {
        return qn(c), null;
      }
      return u;
    }, (o) => o ? RC(o, e.modelValue) : null), l = C(() => i.value ? {
      ...i.value,
      h: n.value ?? i.value.h
    } : null), {
      rtlClasses: a
    } = Qt();
    let r = !0;
    ee(i, (o) => {
      if (!r) {
        r = !0;
        return;
      }
      o && (n.value = o.h);
    }, {
      immediate: !0
    });
    const s = (o) => {
      r = !1, n.value = o.h, i.value = o;
    };
    return it(() => {
      e.modes.includes(t.value) || (t.value = e.modes[0]);
    }), ht({
      VSlider: {
        color: void 0,
        trackColor: void 0,
        trackFillColor: void 0
      }
    }), F(() => {
      const o = Rl.filterProps(e);
      return m(Rl, q({
        rounded: e.rounded,
        elevation: e.elevation,
        theme: e.theme,
        class: ["v-color-picker", a.value, e.class],
        style: [{
          "--v-color-picker-color-hsv": og({
            ...l.value ?? ma,
            a: 1
          })
        }, e.style]
      }, o, {
        maxWidth: e.width
      }), {
        default: () => [!e.hideCanvas && m(_C, {
          key: "canvas",
          color: l.value,
          "onUpdate:color": s,
          disabled: e.disabled,
          dotSize: e.dotSize,
          width: e.width,
          height: e.canvasHeight
        }, null), (!e.hideSliders || !e.hideInputs) && m("div", {
          key: "controls",
          class: "v-color-picker__controls"
        }, [!e.hideSliders && m(YC, {
          key: "preview",
          color: l.value,
          "onUpdate:color": s,
          hideAlpha: !t.value.endsWith("a"),
          disabled: e.disabled
        }, null), !e.hideInputs && m(zC, {
          key: "edit",
          modes: e.modes,
          mode: t.value,
          "onUpdate:mode": (u) => t.value = u,
          color: l.value,
          "onUpdate:color": s,
          disabled: e.disabled
        }, null)]), e.showSwatches && m(pS, {
          key: "swatches",
          color: l.value,
          "onUpdate:color": s,
          maxHeight: e.swatchesMaxHeight,
          swatches: e.swatches,
          disabled: e.disabled
        }, null)]
      });
    }), {};
  }
});
function bS(e, t, n) {
  if (t == null) return e;
  if (Array.isArray(t)) throw new Error("Multiple matches is not implemented");
  return typeof t == "number" && ~t ? m(le, null, [m("span", {
    class: "v-combobox__unmask"
  }, [e.substr(0, t)]), m("span", {
    class: "v-combobox__mask"
  }, [e.substr(t, n)]), m("span", {
    class: "v-combobox__unmask"
  }, [e.substr(t + n)])]) : e;
}
const CS = B({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: {
    type: Boolean,
    default: !0
  },
  delimiters: Array,
  ...ms({
    filterKeys: ["title"]
  }),
  ...Zf({
    hideNoData: !0,
    returnObject: !0
  }),
  ...St(Lu({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Gn({
    transition: !1
  })
}, "VCombobox"), SS = X()({
  name: "VCombobox",
  props: CS(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:search": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    var Qe;
    let {
      emit: n,
      slots: i
    } = t;
    const {
      t: l
    } = pt(), a = z(), r = ie(!1), s = ie(!0), o = ie(!1), u = z(), c = z(), d = pe(e, "menu"), f = C({
      get: () => d.value,
      set: (te) => {
        var oe;
        d.value && !te && ((oe = u.value) != null && oe.openChildren.size) || (d.value = te);
      }
    }), h = ie(-1);
    let g = !1;
    const v = C(() => {
      var te;
      return (te = a.value) == null ? void 0 : te.color;
    }), p = C(() => f.value ? e.closeText : e.openText), {
      items: O,
      transformIn: b,
      transformOut: V
    } = _f(e), {
      textColorClasses: $,
      textColorStyles: x
    } = Yt(v), Q = pe(e, "modelValue", [], (te) => b(ut(te)), (te) => {
      const oe = V(te);
      return e.multiple ? oe : oe[0] ?? null;
    }), M = $u(), w = C(() => !!(e.chips || i.chip)), y = C(() => w.value || !!i.selection), L = ie(!e.multiple && !y.value ? ((Qe = Q.value[0]) == null ? void 0 : Qe.title) ?? "" : ""), k = C({
      get: () => L.value,
      set: (te) => {
        var oe;
        if (L.value = te ?? "", !e.multiple && !y.value && (Q.value = [Hi(e, te)]), te && e.multiple && ((oe = e.delimiters) != null && oe.length)) {
          const Pe = te.split(new RegExp(`(?:${e.delimiters.join("|")})+`));
          Pe.length > 1 && (Pe.forEach((we) => {
            we = we.trim(), we && be(Hi(e, we));
          }), L.value = "");
        }
        te || (h.value = -1), s.value = !te;
      }
    }), S = C(() => typeof e.counterValue == "function" ? e.counterValue(Q.value) : typeof e.counterValue == "number" ? e.counterValue : e.multiple ? Q.value.length : k.value.length);
    ee(L, (te) => {
      g ? He(() => g = !1) : r.value && !f.value && (f.value = !0), n("update:search", te);
    }), ee(Q, (te) => {
      var oe;
      !e.multiple && !y.value && (L.value = ((oe = te[0]) == null ? void 0 : oe.title) ?? "");
    });
    const {
      filteredItems: P,
      getMatches: T
    } = gs(e, O, () => s.value ? "" : k.value), _ = C(() => e.hideSelected ? P.value.filter((te) => !Q.value.some((oe) => oe.value === te.value)) : P.value), D = C(() => Q.value.map((te) => te.value)), N = C(() => {
      var oe;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && k.value === ((oe = _.value[0]) == null ? void 0 : oe.title)) && _.value.length > 0 && !s.value && !o.value;
    }), K = C(() => e.hideNoData && !_.value.length || e.readonly || (M == null ? void 0 : M.isReadonly.value)), E = z(), I = Rf(E, a);
    function Z(te) {
      g = !0, e.openOnClear && (f.value = !0);
    }
    function Y() {
      K.value || (f.value = !0);
    }
    function ce(te) {
      K.value || (r.value && (te.preventDefault(), te.stopPropagation()), f.value = !f.value);
    }
    function de(te) {
      var oe;
      xo(te) && ((oe = a.value) == null || oe.focus());
    }
    function ye(te) {
      var we;
      if (R7(te) || e.readonly || M != null && M.isReadonly.value) return;
      const oe = a.value.selectionStart, Pe = Q.value.length;
      if ((h.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(te.key)) && te.preventDefault(), ["Enter", "ArrowDown"].includes(te.key) && (f.value = !0), ["Escape"].includes(te.key) && (f.value = !1), ["Enter", "Escape", "Tab"].includes(te.key) && (N.value && ["Enter", "Tab"].includes(te.key) && !Q.value.some(($e) => {
        let {
          value: We
        } = $e;
        return We === _.value[0].value;
      }) && be(P.value[0]), s.value = !0), te.key === "ArrowDown" && N.value && ((we = E.value) == null || we.focus("next")), te.key === "Enter" && k.value && (be(Hi(e, k.value)), y.value && (L.value = "")), ["Backspace", "Delete"].includes(te.key)) {
        if (!e.multiple && y.value && Q.value.length > 0 && !k.value) return be(Q.value[0], !1);
        if (~h.value) {
          const $e = h.value;
          be(Q.value[h.value], !1), h.value = $e >= Pe - 1 ? Pe - 2 : $e;
        } else te.key === "Backspace" && !k.value && (h.value = Pe - 1);
      }
      if (e.multiple) {
        if (te.key === "ArrowLeft") {
          if (h.value < 0 && oe > 0) return;
          const $e = h.value > -1 ? h.value - 1 : Pe - 1;
          Q.value[$e] ? h.value = $e : (h.value = -1, a.value.setSelectionRange(k.value.length, k.value.length));
        }
        if (te.key === "ArrowRight") {
          if (h.value < 0) return;
          const $e = h.value + 1;
          Q.value[$e] ? h.value = $e : (h.value = -1, a.value.setSelectionRange(0, 0));
        }
      }
    }
    function U() {
      var te;
      e.eager && ((te = c.value) == null || te.calculateVisibleItems());
    }
    function ge() {
      var te;
      r.value && (s.value = !0, (te = a.value) == null || te.focus());
    }
    function be(te) {
      let oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!te || te.props.disabled))
        if (e.multiple) {
          const Pe = Q.value.findIndex(($e) => e.valueComparator($e.value, te.value)), we = oe ?? !~Pe;
          if (~Pe) {
            const $e = we ? [...Q.value, te] : [...Q.value];
            $e.splice(Pe, 1), Q.value = $e;
          } else we && (Q.value = [...Q.value, te]);
          e.clearOnSelect && (k.value = "");
        } else {
          const Pe = oe !== !1;
          Q.value = Pe ? [te] : [], L.value = Pe && !y.value ? te.title : "", He(() => {
            f.value = !1, s.value = !0;
          });
        }
    }
    function De(te) {
      r.value = !0, setTimeout(() => {
        o.value = !0;
      });
    }
    function Ye(te) {
      o.value = !1;
    }
    function re(te) {
      (te == null || te === "" && !e.multiple && !y.value) && (Q.value = []);
    }
    return ee(r, (te, oe) => {
      if (!(te || te === oe) && (h.value = -1, f.value = !1, k.value)) {
        if (e.multiple) {
          be(Hi(e, k.value));
          return;
        }
        if (!y.value) return;
        Q.value.some((Pe) => {
          let {
            title: we
          } = Pe;
          return we === k.value;
        }) ? L.value = "" : be(Hi(e, k.value));
      }
    }), ee(f, () => {
      if (!e.hideSelected && f.value && Q.value.length) {
        const te = _.value.findIndex((oe) => Q.value.some((Pe) => e.valueComparator(Pe.value, oe.value)));
        qe && window.requestAnimationFrame(() => {
          var oe;
          te >= 0 && ((oe = c.value) == null || oe.scrollToIndex(te));
        });
      }
    }), ee(() => e.items, (te, oe) => {
      f.value || r.value && !oe.length && te.length && (f.value = !0);
    }), F(() => {
      const te = !!(!e.hideNoData || _.value.length || i["prepend-item"] || i["append-item"] || i["no-data"]), oe = Q.value.length > 0, Pe = Tl.filterProps(e);
      return m(Tl, q({
        ref: a
      }, Pe, {
        modelValue: k.value,
        "onUpdate:modelValue": [(we) => k.value = we, re],
        focused: r.value,
        "onUpdate:focused": (we) => r.value = we,
        validationValue: Q.externalValue,
        counterValue: S.value,
        dirty: oe,
        class: ["v-combobox", {
          "v-combobox--active-menu": f.value,
          "v-combobox--chips": !!e.chips,
          "v-combobox--selection-slot": !!y.value,
          "v-combobox--selecting-index": h.value > -1,
          [`v-combobox--${e.multiple ? "multiple" : "single"}`]: !0
        }, e.class],
        style: e.style,
        readonly: e.readonly,
        placeholder: oe ? void 0 : e.placeholder,
        "onClick:clear": Z,
        "onMousedown:control": Y,
        onKeydown: ye
      }), {
        ...i,
        default: () => m(le, null, [m(La, q({
          ref: u,
          modelValue: f.value,
          "onUpdate:modelValue": (we) => f.value = we,
          activator: "parent",
          contentClass: "v-combobox__content",
          disabled: K.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: U,
          onAfterLeave: ge
        }, e.menuProps), {
          default: () => [te && m(Vu, q({
            ref: E,
            selected: D.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (we) => we.preventDefault(),
            onKeydown: de,
            onFocusin: De,
            onFocusout: Ye,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, I, e.listProps), {
            default: () => {
              var we, $e, We;
              return [(we = i["prepend-item"]) == null ? void 0 : we.call(i), !_.value.length && !e.hideNoData && ((($e = i["no-data"]) == null ? void 0 : $e.call(i)) ?? m(Qi, {
                title: l(e.noDataText)
              }, null)), m(Mu, {
                ref: c,
                renderless: !0,
                items: _.value
              }, {
                default: (an) => {
                  var hl;
                  let {
                    item: Ue,
                    index: ei,
                    itemRef: Ut
                  } = an;
                  const fl = q(Ue.props, {
                    ref: Ut,
                    key: ei,
                    active: N.value && ei === 0 ? !0 : void 0,
                    onClick: () => be(Ue, null)
                  });
                  return ((hl = i.item) == null ? void 0 : hl.call(i, {
                    item: Ue,
                    index: ei,
                    props: fl
                  })) ?? m(Qi, q(fl, {
                    role: "option"
                  }), {
                    prepend: (Ps) => {
                      let {
                        isSelected: $s
                      } = Ps;
                      return m(le, null, [e.multiple && !e.hideSelected ? m(Vi, {
                        key: Ue.value,
                        modelValue: $s,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, Ue.props.prependAvatar && m(An, {
                        image: Ue.props.prependAvatar
                      }, null), Ue.props.prependIcon && m(ze, {
                        icon: Ue.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var Ps, $s;
                      return s.value ? Ue.title : bS(Ue.title, (Ps = T(Ue)) == null ? void 0 : Ps.title, (($s = k.value) == null ? void 0 : $s.length) ?? 0);
                    }
                  });
                }
              }), (We = i["append-item"]) == null ? void 0 : We.call(i)];
            }
          })]
        }), Q.value.map((we, $e) => {
          function We(Ut) {
            Ut.stopPropagation(), Ut.preventDefault(), be(we, !1);
          }
          const an = {
            "onClick:close": We,
            onKeydown(Ut) {
              Ut.key !== "Enter" && Ut.key !== " " || (Ut.preventDefault(), Ut.stopPropagation(), We(Ut));
            },
            onMousedown(Ut) {
              Ut.preventDefault(), Ut.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, Ue = w.value ? !!i.chip : !!i.selection, ei = Ue ? gu(w.value ? i.chip({
            item: we,
            index: $e,
            props: an
          }) : i.selection({
            item: we,
            index: $e
          })) : void 0;
          if (!(Ue && !ei))
            return m("div", {
              key: we.value,
              class: ["v-combobox__selection", $e === h.value && ["v-combobox__selection--selected", $.value]],
              style: $e === h.value ? x.value : {}
            }, [w.value ? i.chip ? m(Te, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: we.title
                }
              }
            }, {
              default: () => [ei]
            }) : m(Wa, q({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: we.title,
              disabled: we.props.disabled
            }, an), null) : ei ?? m("span", {
              class: "v-combobox__selection-text"
            }, [we.title, e.multiple && $e < Q.value.length - 1 && m("span", {
              class: "v-combobox__selection-comma"
            }, [ke(",")])])]);
        })]),
        "append-inner": function() {
          var an;
          for (var we = arguments.length, $e = new Array(we), We = 0; We < we; We++)
            $e[We] = arguments[We];
          return m(le, null, [(an = i["append-inner"]) == null ? void 0 : an.call(i, ...$e), (!e.hideNoData || e.items.length) && e.menuIcon ? m(ze, {
            class: "v-combobox__menu-icon",
            icon: e.menuIcon,
            onMousedown: ce,
            onClick: eg,
            "aria-label": l(p.value),
            title: l(p.value),
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Bn({
      isFocused: r,
      isPristine: s,
      menu: f,
      search: k,
      selectionIndex: h,
      filteredItems: P,
      select: be
    }, a);
  }
}), wS = B({
  modelValue: null,
  color: String,
  cancelText: {
    type: String,
    default: "$vuetify.confirmEdit.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.confirmEdit.ok"
  }
}, "VConfirmEdit"), kS = X()({
  name: "VConfirmEdit",
  props: wS(),
  emits: {
    cancel: () => !0,
    save: (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const l = pe(e, "modelValue"), a = z();
    ft(() => {
      a.value = structuredClone(nt(l.value));
    });
    const {
      t: r
    } = pt(), s = C(() => vi(l.value, a.value));
    function o() {
      l.value = a.value, n("save", a.value);
    }
    function u() {
      a.value = structuredClone(nt(l.value)), n("cancel");
    }
    let c = !1;
    return F(() => {
      var f;
      const d = m(le, null, [m(je, {
        disabled: s.value,
        variant: "text",
        color: e.color,
        onClick: u,
        text: r(e.cancelText)
      }, null), m(je, {
        disabled: s.value,
        variant: "text",
        color: e.color,
        onClick: o,
        text: r(e.okText)
      }, null)]);
      return m(le, null, [(f = i.default) == null ? void 0 : f.call(i, {
        model: a,
        save: o,
        cancel: u,
        isPristine: s.value,
        get actions() {
          return c = !0, d;
        }
      }), !c && d]);
    }), {
      save: o,
      cancel: u,
      isPristine: s
    };
  }
}), i5 = B({
  expandOnClick: Boolean,
  showExpand: Boolean,
  expanded: {
    type: Array,
    default: () => []
  }
}, "DataTable-expand"), l5 = Symbol.for("vuetify:datatable:expanded");
function Ru(e) {
  const t = H(e, "expandOnClick"), n = pe(e, "expanded", e.expanded, (s) => new Set(s), (s) => [...s.values()]);
  function i(s, o) {
    const u = new Set(n.value);
    o ? u.add(s.value) : u.delete(s.value), n.value = u;
  }
  function l(s) {
    return n.value.has(s.value);
  }
  function a(s) {
    i(s, !l(s));
  }
  const r = {
    expand: i,
    expanded: n,
    expandOnClick: t,
    isExpanded: l,
    toggleExpand: a
  };
  return lt(l5, r), r;
}
function a5() {
  const e = Be(l5);
  if (!e) throw new Error("foo");
  return e;
}
const Bf = B({
  groupBy: {
    type: Array,
    default: () => []
  }
}, "DataTable-group"), r5 = Symbol.for("vuetify:data-table-group");
function Ef(e) {
  return {
    groupBy: pe(e, "groupBy")
  };
}
function Zu(e) {
  const {
    disableSort: t,
    groupBy: n,
    sortBy: i
  } = e, l = z(/* @__PURE__ */ new Set()), a = C(() => n.value.map((c) => ({
    ...c,
    order: c.order ?? !1
  })).concat(t != null && t.value ? [] : i.value));
  function r(c) {
    return l.value.has(c.id);
  }
  function s(c) {
    const d = new Set(l.value);
    r(c) ? d.delete(c.id) : d.add(c.id), l.value = d;
  }
  function o(c) {
    function d(f) {
      const h = [];
      for (const g of f.items)
        "type" in g && g.type === "group" ? h.push(...d(g)) : h.push(g);
      return h;
    }
    return d({
      type: "group",
      items: c,
      id: "dummy",
      key: "dummy",
      value: "dummy",
      depth: 0
    });
  }
  const u = {
    sortByWithGroups: a,
    toggleGroup: s,
    opened: l,
    groupBy: n,
    extractRows: o,
    isGroupOpen: r
  };
  return lt(r5, u), u;
}
function s5() {
  const e = Be(r5);
  if (!e) throw new Error("Missing group!");
  return e;
}
function xS(e, t) {
  if (!e.length) return [];
  const n = /* @__PURE__ */ new Map();
  for (const i of e) {
    const l = Ml(i.raw, t);
    n.has(l) || n.set(l, []), n.get(l).push(i);
  }
  return n;
}
function o5(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
  if (!t.length) return [];
  const l = xS(e, t[0]), a = [], r = t.slice(1);
  return l.forEach((s, o) => {
    const u = t[0], c = `${i}_${u}_${o}`;
    a.push({
      depth: n,
      id: c,
      key: u,
      value: o,
      items: r.length ? o5(s, r, n + 1, c) : s,
      type: "group"
    });
  }), a;
}
function u5(e, t) {
  const n = [];
  for (const i of e)
    "type" in i && i.type === "group" ? (i.value != null && n.push(i), (t.has(i.id) || i.value == null) && n.push(...u5(i.items, t))) : n.push(i);
  return n;
}
function Iu(e, t, n) {
  return {
    flatItems: C(() => {
      if (!t.value.length) return e.value;
      const l = o5(e.value, t.value.map((a) => a.key));
      return u5(l, n.value);
    })
  };
}
function Du(e) {
  let {
    page: t,
    itemsPerPage: n,
    sortBy: i,
    groupBy: l,
    search: a
  } = e;
  const r = mt("VDataTable"), s = C(() => ({
    page: t.value,
    itemsPerPage: n.value,
    sortBy: i.value,
    groupBy: l.value,
    search: a.value
  }));
  let o = null;
  ee(s, () => {
    vi(o, s.value) || (o && o.search !== s.value.search && (t.value = 1), r.emit("update:options", s.value), o = s.value);
  }, {
    deep: !0,
    immediate: !0
  });
}
const zf = B({
  page: {
    type: [Number, String],
    default: 1
  },
  itemsPerPage: {
    type: [Number, String],
    default: 10
  }
}, "DataTable-paginate"), c5 = Symbol.for("vuetify:data-table-pagination");
function Hf(e) {
  const t = pe(e, "page", void 0, (i) => +(i ?? 1)), n = pe(e, "itemsPerPage", void 0, (i) => +(i ?? 10));
  return {
    page: t,
    itemsPerPage: n
  };
}
function jf(e) {
  const {
    page: t,
    itemsPerPage: n,
    itemsLength: i
  } = e, l = C(() => n.value === -1 ? 0 : n.value * (t.value - 1)), a = C(() => n.value === -1 ? i.value : Math.min(i.value, l.value + n.value)), r = C(() => n.value === -1 || i.value === 0 ? 1 : Math.ceil(i.value / n.value));
  ft(() => {
    t.value > r.value && (t.value = r.value);
  });
  function s(f) {
    n.value = f, t.value = 1;
  }
  function o() {
    t.value = Ot(t.value + 1, 1, r.value);
  }
  function u() {
    t.value = Ot(t.value - 1, 1, r.value);
  }
  function c(f) {
    t.value = Ot(f, 1, r.value);
  }
  const d = {
    page: t,
    itemsPerPage: n,
    startIndex: l,
    stopIndex: a,
    pageCount: r,
    itemsLength: i,
    nextPage: o,
    prevPage: u,
    setPage: c,
    setItemsPerPage: s
  };
  return lt(c5, d), d;
}
function PS() {
  const e = Be(c5);
  if (!e) throw new Error("Missing pagination!");
  return e;
}
function d5(e) {
  const t = mt("usePaginatedItems"), {
    items: n,
    startIndex: i,
    stopIndex: l,
    itemsPerPage: a
  } = e, r = C(() => a.value <= 0 ? n.value : n.value.slice(i.value, l.value));
  return ee(r, (s) => {
    t.emit("update:currentItems", s);
  }), {
    paginatedItems: r
  };
}
const $S = {
  showSelectAll: !1,
  allSelected: () => [],
  select: (e) => {
    var i;
    let {
      items: t,
      value: n
    } = e;
    return new Set(n ? [(i = t[0]) == null ? void 0 : i.value] : []);
  },
  selectAll: (e) => {
    let {
      selected: t
    } = e;
    return t;
  }
}, f5 = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      currentPage: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: i
    } = e;
    for (const l of t)
      n ? i.add(l.value) : i.delete(l.value);
    return i;
  },
  selectAll: (e) => {
    let {
      value: t,
      currentPage: n,
      selected: i
    } = e;
    return f5.select({
      items: n,
      value: t,
      selected: i
    });
  }
}, h5 = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      allItems: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: i
    } = e;
    for (const l of t)
      n ? i.add(l.value) : i.delete(l.value);
    return i;
  },
  selectAll: (e) => {
    let {
      value: t,
      allItems: n,
      selected: i
    } = e;
    return h5.select({
      items: n,
      value: t,
      selected: i
    });
  }
}, m5 = B({
  showSelect: Boolean,
  selectStrategy: {
    type: [String, Object],
    default: "page"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  valueComparator: {
    type: Function,
    default: vi
  }
}, "DataTable-select"), g5 = Symbol.for("vuetify:data-table-selection");
function Bu(e, t) {
  let {
    allItems: n,
    currentPage: i
  } = t;
  const l = pe(e, "modelValue", e.modelValue, (O) => new Set(ut(O).map((b) => {
    var V;
    return ((V = n.value.find(($) => e.valueComparator(b, $.value))) == null ? void 0 : V.value) ?? b;
  })), (O) => [...O.values()]), a = C(() => n.value.filter((O) => O.selectable)), r = C(() => i.value.filter((O) => O.selectable)), s = C(() => {
    if (typeof e.selectStrategy == "object") return e.selectStrategy;
    switch (e.selectStrategy) {
      case "single":
        return $S;
      case "all":
        return h5;
      case "page":
      default:
        return f5;
    }
  });
  function o(O) {
    return ut(O).every((b) => l.value.has(b.value));
  }
  function u(O) {
    return ut(O).some((b) => l.value.has(b.value));
  }
  function c(O, b) {
    const V = s.value.select({
      items: O,
      value: b,
      selected: new Set(l.value)
    });
    l.value = V;
  }
  function d(O) {
    c([O], !o([O]));
  }
  function f(O) {
    const b = s.value.selectAll({
      value: O,
      allItems: a.value,
      currentPage: r.value,
      selected: new Set(l.value)
    });
    l.value = b;
  }
  const h = C(() => l.value.size > 0), g = C(() => {
    const O = s.value.allSelected({
      allItems: a.value,
      currentPage: r.value
    });
    return !!O.length && o(O);
  }), v = C(() => s.value.showSelectAll), p = {
    toggleSelect: d,
    select: c,
    selectAll: f,
    isSelected: o,
    isSomeSelected: u,
    someSelected: h,
    allSelected: g,
    showSelectAll: v
  };
  return lt(g5, p), p;
}
function Eu() {
  const e = Be(g5);
  if (!e) throw new Error("Missing selection!");
  return e;
}
const v5 = B({
  sortBy: {
    type: Array,
    default: () => []
  },
  customKeySort: Object,
  multiSort: Boolean,
  mustSort: Boolean
}, "DataTable-sort"), p5 = Symbol.for("vuetify:data-table-sort");
function zu(e) {
  const t = pe(e, "sortBy"), n = H(e, "mustSort"), i = H(e, "multiSort");
  return {
    sortBy: t,
    mustSort: n,
    multiSort: i
  };
}
function Hu(e) {
  const {
    sortBy: t,
    mustSort: n,
    multiSort: i,
    page: l
  } = e, a = (o) => {
    if (o.key == null) return;
    let u = t.value.map((d) => ({
      ...d
    })) ?? [];
    const c = u.find((d) => d.key === o.key);
    c ? c.order === "desc" ? n.value ? c.order = "asc" : u = u.filter((d) => d.key !== o.key) : c.order = "desc" : i.value ? u = [...u, {
      key: o.key,
      order: "asc"
    }] : u = [{
      key: o.key,
      order: "asc"
    }], t.value = u, l && (l.value = 1);
  };
  function r(o) {
    return !!t.value.find((u) => u.key === o.key);
  }
  const s = {
    sortBy: t,
    toggleSort: a,
    isSorted: r
  };
  return lt(p5, s), s;
}
function O5() {
  const e = Be(p5);
  if (!e) throw new Error("Missing sort!");
  return e;
}
function Xf(e, t, n, i) {
  const l = pt();
  return {
    sortedItems: C(() => {
      var r, s;
      return n.value.length ? VS(t.value, n.value, l.current.value, {
        transform: i == null ? void 0 : i.transform,
        sortFunctions: {
          ...e.customKeySort,
          ...(r = i == null ? void 0 : i.sortFunctions) == null ? void 0 : r.value
        },
        sortRawFunctions: (s = i == null ? void 0 : i.sortRawFunctions) == null ? void 0 : s.value
      }) : t.value;
    })
  };
}
function VS(e, t, n, i) {
  const l = new Intl.Collator(n, {
    sensitivity: "accent",
    usage: "sort"
  });
  return e.map((r) => [r, i != null && i.transform ? i.transform(r) : r]).sort((r, s) => {
    var o, u;
    for (let c = 0; c < t.length; c++) {
      let d = !1;
      const f = t[c].key, h = t[c].order ?? "asc";
      if (h === !1) continue;
      let g = Ml(r[1], f), v = Ml(s[1], f), p = r[0].raw, O = s[0].raw;
      if (h === "desc" && ([g, v] = [v, g], [p, O] = [O, p]), (o = i == null ? void 0 : i.sortRawFunctions) != null && o[f]) {
        const b = i.sortRawFunctions[f](p, O);
        if (b == null) continue;
        if (d = !0, b) return b;
      }
      if ((u = i == null ? void 0 : i.sortFunctions) != null && u[f]) {
        const b = i.sortFunctions[f](g, v);
        if (b == null) continue;
        if (d = !0, b) return b;
      }
      if (!d) {
        if (g instanceof Date && v instanceof Date)
          return g.getTime() - v.getTime();
        if ([g, v] = [g, v].map((b) => b != null ? b.toString().toLocaleLowerCase() : b), g !== v)
          return Qs(g) && Qs(v) ? 0 : Qs(g) ? -1 : Qs(v) ? 1 : !isNaN(g) && !isNaN(v) ? Number(g) - Number(v) : l.compare(g, v);
      }
    }
    return 0;
  }).map((r) => {
    let [s] = r;
    return s;
  });
}
const QS = B({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  returnObject: Boolean
}, "DataIterator-items");
function LS(e, t) {
  const n = e.returnObject ? t : Pt(t, e.itemValue), i = Pt(t, e.itemSelectable, !0);
  return {
    type: "item",
    value: n,
    selectable: i,
    raw: t
  };
}
function MS(e, t) {
  const n = [];
  for (const i of t)
    n.push(LS(e, i));
  return n;
}
function TS(e) {
  return {
    items: C(() => MS(e, e.items))
  };
}
const _S = B({
  search: String,
  loading: Boolean,
  ...ue(),
  ...QS(),
  ...m5(),
  ...v5(),
  ...zf({
    itemsPerPage: 5
  }),
  ...i5(),
  ...Bf(),
  ...ms(),
  ...Ve(),
  ...Gn({
    transition: {
      component: _r,
      hideOnLeave: !0
    }
  })
}, "VDataIterator"), AS = X()({
  name: "VDataIterator",
  props: _S(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "groupBy"), l = H(e, "search"), {
      items: a
    } = TS(e), {
      filteredItems: r
    } = gs(e, a, l, {
      transform: (Z) => Z.raw
    }), {
      sortBy: s,
      multiSort: o,
      mustSort: u
    } = zu(e), {
      page: c,
      itemsPerPage: d
    } = Hf(e), {
      toggleSort: f
    } = Hu({
      sortBy: s,
      multiSort: o,
      mustSort: u,
      page: c
    }), {
      sortByWithGroups: h,
      opened: g,
      extractRows: v,
      isGroupOpen: p,
      toggleGroup: O
    } = Zu({
      groupBy: i,
      sortBy: s
    }), {
      sortedItems: b
    } = Xf(e, r, h, {
      transform: (Z) => Z.raw
    }), {
      flatItems: V
    } = Iu(b, i, g), $ = C(() => V.value.length), {
      startIndex: x,
      stopIndex: Q,
      pageCount: M,
      prevPage: w,
      nextPage: y,
      setItemsPerPage: L,
      setPage: k
    } = jf({
      page: c,
      itemsPerPage: d,
      itemsLength: $
    }), {
      paginatedItems: S
    } = d5({
      items: V,
      startIndex: x,
      stopIndex: Q,
      itemsPerPage: d
    }), P = C(() => v(S.value)), {
      isSelected: T,
      select: _,
      selectAll: D,
      toggleSelect: N
    } = Bu(e, {
      allItems: a,
      currentPage: P
    }), {
      isExpanded: K,
      toggleExpand: E
    } = Ru(e);
    Du({
      page: c,
      itemsPerPage: d,
      sortBy: s,
      groupBy: i,
      search: l
    });
    const I = C(() => ({
      page: c.value,
      itemsPerPage: d.value,
      sortBy: s.value,
      pageCount: M.value,
      toggleSort: f,
      prevPage: w,
      nextPage: y,
      setPage: k,
      setItemsPerPage: L,
      isSelected: T,
      select: _,
      selectAll: D,
      toggleSelect: N,
      isExpanded: K,
      toggleExpand: E,
      isGroupOpen: p,
      toggleGroup: O,
      items: P.value,
      groupedItems: S.value
    }));
    return F(() => m(e.tag, {
      class: ["v-data-iterator", {
        "v-data-iterator--loading": e.loading
      }, e.class],
      style: e.style
    }, {
      default: () => {
        var Z, Y;
        return [(Z = n.header) == null ? void 0 : Z.call(n, I.value), m(en, {
          transition: e.transition
        }, {
          default: () => {
            var ce, de;
            return [e.loading ? m(cs, {
              key: "loader",
              name: "v-data-iterator",
              active: !0
            }, {
              default: (ye) => {
                var U;
                return (U = n.loader) == null ? void 0 : U.call(n, ye);
              }
            }) : m("div", {
              key: "items"
            }, [S.value.length ? (de = n.default) == null ? void 0 : de.call(n, I.value) : (ce = n["no-data"]) == null ? void 0 : ce.call(n)])];
          }
        }), (Y = n.footer) == null ? void 0 : Y.call(n, I.value)];
      }
    })), {};
  }
});
function RS() {
  const e = z([]);
  m7(() => e.value = []);
  function t(n, i) {
    e.value[i] = n;
  }
  return {
    refs: e,
    updateRef: t
  };
}
const ZS = B({
  activeColor: String,
  start: {
    type: [Number, String],
    default: 1
  },
  modelValue: {
    type: Number,
    default: (e) => e.start
  },
  disabled: Boolean,
  length: {
    type: [Number, String],
    default: 1,
    validator: (e) => e % 1 === 0
  },
  totalVisible: [Number, String],
  firstIcon: {
    type: Se,
    default: "$first"
  },
  prevIcon: {
    type: Se,
    default: "$prev"
  },
  nextIcon: {
    type: Se,
    default: "$next"
  },
  lastIcon: {
    type: Se,
    default: "$last"
  },
  ariaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.root"
  },
  pageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.page"
  },
  currentPageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.currentPage"
  },
  firstAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.first"
  },
  previousAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.previous"
  },
  nextAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.next"
  },
  lastAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.last"
  },
  ellipsis: {
    type: String,
    default: "..."
  },
  showFirstLastPage: Boolean,
  ...yn(),
  ...ue(),
  ...Zt(),
  ...Lt(),
  ...at(),
  ...yi(),
  ...Ve({
    tag: "nav"
  }),
  ...Ie(),
  ...En({
    variant: "text"
  })
}, "VPagination"), V1 = X()({
  name: "VPagination",
  props: ZS(),
  emits: {
    "update:modelValue": (e) => !0,
    first: (e) => !0,
    prev: (e) => !0,
    next: (e) => !0,
    last: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const l = pe(e, "modelValue"), {
      t: a,
      n: r
    } = pt(), {
      isRtl: s
    } = Qt(), {
      themeClasses: o
    } = Xe(e), {
      width: u
    } = Dn(), c = ie(-1);
    ht(void 0, {
      scoped: !0
    });
    const {
      resizeRef: d
    } = Yn((w) => {
      if (!w.length) return;
      const {
        target: y,
        contentRect: L
      } = w[0], k = y.querySelector(".v-pagination__list > *");
      if (!k) return;
      const S = L.width, P = k.offsetWidth + parseFloat(getComputedStyle(k).marginRight) * 2;
      c.value = v(S, P);
    }), f = C(() => parseInt(e.length, 10)), h = C(() => parseInt(e.start, 10)), g = C(() => e.totalVisible != null ? parseInt(e.totalVisible, 10) : c.value >= 0 ? c.value : v(u.value, 58));
    function v(w, y) {
      const L = e.showFirstLastPage ? 5 : 3;
      return Math.max(0, Math.floor(
        // Round to two decimal places to avoid floating point errors
        +((w - y * L) / y).toFixed(2)
      ));
    }
    const p = C(() => {
      if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER) return [];
      if (g.value <= 0) return [];
      if (g.value === 1) return [l.value];
      if (f.value <= g.value)
        return si(f.value, h.value);
      const w = g.value % 2 === 0, y = w ? g.value / 2 : Math.floor(g.value / 2), L = w ? y : y + 1, k = f.value - y;
      if (L - l.value >= 0)
        return [...si(Math.max(1, g.value - 1), h.value), e.ellipsis, f.value];
      if (l.value - k >= (w ? 1 : 0)) {
        const S = g.value - 1, P = f.value - S + h.value;
        return [h.value, e.ellipsis, ...si(S, P)];
      } else {
        const S = Math.max(1, g.value - 3), P = S === 1 ? l.value : l.value - Math.ceil(S / 2) + h.value;
        return [h.value, e.ellipsis, ...si(S, P), e.ellipsis, f.value];
      }
    });
    function O(w, y, L) {
      w.preventDefault(), l.value = y, L && i(L, y);
    }
    const {
      refs: b,
      updateRef: V
    } = RS();
    ht({
      VPaginationBtn: {
        color: H(e, "color"),
        border: H(e, "border"),
        density: H(e, "density"),
        size: H(e, "size"),
        variant: H(e, "variant"),
        rounded: H(e, "rounded"),
        elevation: H(e, "elevation")
      }
    });
    const $ = C(() => p.value.map((w, y) => {
      const L = (k) => V(k, y);
      if (typeof w == "string")
        return {
          isActive: !1,
          key: `ellipsis-${y}`,
          page: w,
          props: {
            ref: L,
            ellipsis: !0,
            icon: !0,
            disabled: !0
          }
        };
      {
        const k = w === l.value;
        return {
          isActive: k,
          key: w,
          page: r(w),
          props: {
            ref: L,
            ellipsis: !1,
            icon: !0,
            disabled: !!e.disabled || +e.length < 2,
            color: k ? e.activeColor : e.color,
            "aria-current": k,
            "aria-label": a(k ? e.currentPageAriaLabel : e.pageAriaLabel, w),
            onClick: (S) => O(S, w)
          }
        };
      }
    })), x = C(() => {
      const w = !!e.disabled || l.value <= h.value, y = !!e.disabled || l.value >= h.value + f.value - 1;
      return {
        first: e.showFirstLastPage ? {
          icon: s.value ? e.lastIcon : e.firstIcon,
          onClick: (L) => O(L, h.value, "first"),
          disabled: w,
          "aria-label": a(e.firstAriaLabel),
          "aria-disabled": w
        } : void 0,
        prev: {
          icon: s.value ? e.nextIcon : e.prevIcon,
          onClick: (L) => O(L, l.value - 1, "prev"),
          disabled: w,
          "aria-label": a(e.previousAriaLabel),
          "aria-disabled": w
        },
        next: {
          icon: s.value ? e.prevIcon : e.nextIcon,
          onClick: (L) => O(L, l.value + 1, "next"),
          disabled: y,
          "aria-label": a(e.nextAriaLabel),
          "aria-disabled": y
        },
        last: e.showFirstLastPage ? {
          icon: s.value ? e.firstIcon : e.lastIcon,
          onClick: (L) => O(L, h.value + f.value - 1, "last"),
          disabled: y,
          "aria-label": a(e.lastAriaLabel),
          "aria-disabled": y
        } : void 0
      };
    });
    function Q() {
      var y;
      const w = l.value - h.value;
      (y = b.value[w]) == null || y.$el.focus();
    }
    function M(w) {
      w.key === n1.left && !e.disabled && l.value > +e.start ? (l.value = l.value - 1, He(Q)) : w.key === n1.right && !e.disabled && l.value < h.value + f.value - 1 && (l.value = l.value + 1, He(Q));
    }
    return F(() => m(e.tag, {
      ref: d,
      class: ["v-pagination", o.value, e.class],
      style: e.style,
      role: "navigation",
      "aria-label": a(e.ariaLabel),
      onKeydown: M,
      "data-test": "v-pagination-root"
    }, {
      default: () => [m("ul", {
        class: "v-pagination__list"
      }, [e.showFirstLastPage && m("li", {
        key: "first",
        class: "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [n.first ? n.first(x.value.first) : m(je, q({
        _as: "VPaginationBtn"
      }, x.value.first), null)]), m("li", {
        key: "prev",
        class: "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [n.prev ? n.prev(x.value.prev) : m(je, q({
        _as: "VPaginationBtn"
      }, x.value.prev), null)]), $.value.map((w, y) => m("li", {
        key: w.key,
        class: ["v-pagination__item", {
          "v-pagination__item--is-active": w.isActive
        }],
        "data-test": "v-pagination-item"
      }, [n.item ? n.item(w) : m(je, q({
        _as: "VPaginationBtn"
      }, w.props), {
        default: () => [w.page]
      })])), m("li", {
        key: "next",
        class: "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [n.next ? n.next(x.value.next) : m(je, q({
        _as: "VPaginationBtn"
      }, x.value.next), null)]), e.showFirstLastPage && m("li", {
        key: "last",
        class: "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [n.last ? n.last(x.value.last) : m(je, q({
        _as: "VPaginationBtn"
      }, x.value.last), null)])])]
    })), {};
  }
}), Nf = B({
  prevIcon: {
    type: Se,
    default: "$prev"
  },
  nextIcon: {
    type: Se,
    default: "$next"
  },
  firstIcon: {
    type: Se,
    default: "$first"
  },
  lastIcon: {
    type: Se,
    default: "$last"
  },
  itemsPerPageText: {
    type: String,
    default: "$vuetify.dataFooter.itemsPerPageText"
  },
  pageText: {
    type: String,
    default: "$vuetify.dataFooter.pageText"
  },
  firstPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.firstPage"
  },
  prevPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.prevPage"
  },
  nextPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.nextPage"
  },
  lastPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.lastPage"
  },
  itemsPerPageOptions: {
    type: Array,
    default: () => [{
      value: 10,
      title: "10"
    }, {
      value: 25,
      title: "25"
    }, {
      value: 50,
      title: "50"
    }, {
      value: 100,
      title: "100"
    }, {
      value: -1,
      title: "$vuetify.dataFooter.itemsPerPageAll"
    }]
  },
  showCurrentPage: Boolean
}, "VDataTableFooter"), Ir = X()({
  name: "VDataTableFooter",
  props: Nf(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = pt(), {
      page: l,
      pageCount: a,
      startIndex: r,
      stopIndex: s,
      itemsLength: o,
      itemsPerPage: u,
      setItemsPerPage: c
    } = PS(), d = C(() => e.itemsPerPageOptions.map((f) => typeof f == "number" ? {
      value: f,
      title: f === -1 ? i("$vuetify.dataFooter.itemsPerPageAll") : String(f)
    } : {
      ...f,
      title: isNaN(Number(f.title)) ? i(f.title) : f.title
    }));
    return F(() => {
      var h;
      const f = V1.filterProps(e);
      return m("div", {
        class: "v-data-table-footer"
      }, [(h = n.prepend) == null ? void 0 : h.call(n), m("div", {
        class: "v-data-table-footer__items-per-page"
      }, [m("span", null, [i(e.itemsPerPageText)]), m(If, {
        items: d.value,
        modelValue: u.value,
        "onUpdate:modelValue": (g) => c(Number(g)),
        density: "compact",
        variant: "outlined",
        "hide-details": !0
      }, null)]), m("div", {
        class: "v-data-table-footer__info"
      }, [m("div", null, [i(e.pageText, o.value ? r.value + 1 : 0, s.value, o.value)])]), m("div", {
        class: "v-data-table-footer__pagination"
      }, [m(V1, q({
        modelValue: l.value,
        "onUpdate:modelValue": (g) => l.value = g,
        density: "comfortable",
        "first-aria-label": e.firstPageLabel,
        "last-aria-label": e.lastPageLabel,
        length: a.value,
        "next-aria-label": e.nextPageLabel,
        "previous-aria-label": e.prevPageLabel,
        rounded: !0,
        "show-first-last-page": !0,
        "total-visible": e.showCurrentPage ? 1 : 0,
        variant: "plain"
      }, f), null)])]);
    }), {};
  }
}), To = gp({
  align: {
    type: String,
    default: "start"
  },
  fixed: Boolean,
  fixedOffset: [Number, String],
  height: [Number, String],
  lastFixed: Boolean,
  noPadding: Boolean,
  tag: String,
  width: [Number, String],
  maxWidth: [Number, String],
  nowrap: Boolean
}, (e, t) => {
  let {
    slots: n
  } = t;
  const i = e.tag ?? "td";
  return m(i, {
    class: ["v-data-table__td", {
      "v-data-table-column--fixed": e.fixed,
      "v-data-table-column--last-fixed": e.lastFixed,
      "v-data-table-column--no-padding": e.noPadding,
      "v-data-table-column--nowrap": e.nowrap
    }, `v-data-table-column--align-${e.align}`],
    style: {
      height: se(e.height),
      width: se(e.width),
      maxWidth: se(e.maxWidth),
      left: se(e.fixedOffset || null)
    }
  }, {
    default: () => {
      var l;
      return [(l = n.default) == null ? void 0 : l.call(n)];
    }
  });
}), IS = B({
  headers: Array
}, "DataTable-header"), y5 = Symbol.for("vuetify:data-table-headers"), b5 = {
  title: "",
  sortable: !1
}, DS = {
  ...b5,
  width: 48
};
function BS() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map((n) => ({
    element: n,
    priority: 0
  }));
  return {
    enqueue: (n, i) => {
      let l = !1;
      for (let a = 0; a < t.length; a++)
        if (t[a].priority > i) {
          t.splice(a, 0, {
            element: n,
            priority: i
          }), l = !0;
          break;
        }
      l || t.push({
        element: n,
        priority: i
      });
    },
    size: () => t.length,
    count: () => {
      let n = 0;
      if (!t.length) return 0;
      const i = Math.floor(t[0].priority);
      for (let l = 0; l < t.length; l++)
        Math.floor(t[l].priority) === i && (n += 1);
      return n;
    },
    dequeue: () => t.shift()
  };
}
function Q1(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (!e.children)
    t.push(e);
  else
    for (const n of e.children)
      Q1(n, t);
  return t;
}
function C5(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
  for (const n of e)
    n.key && t.add(n.key), n.children && C5(n.children, t);
  return t;
}
function ES(e) {
  if (e.key) {
    if (e.key === "data-table-group") return b5;
    if (["data-table-expand", "data-table-select"].includes(e.key)) return DS;
  }
}
function qf(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return e.children ? Math.max(t, ...e.children.map((n) => qf(n, t + 1))) : t;
}
function zS(e) {
  let t = !1;
  function n(a) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (a)
      if (r && (a.fixed = !0), a.fixed)
        if (a.children)
          for (let s = a.children.length - 1; s >= 0; s--)
            n(a.children[s], !0);
        else
          t ? isNaN(+a.width) && Po(`Multiple fixed columns should have a static width (key: ${a.key})`) : a.lastFixed = !0, t = !0;
      else if (a.children)
        for (let s = a.children.length - 1; s >= 0; s--)
          n(a.children[s]);
      else
        t = !1;
  }
  for (let a = e.length - 1; a >= 0; a--)
    n(e[a]);
  function i(a) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!a) return r;
    if (a.children) {
      a.fixedOffset = r;
      for (const s of a.children)
        r = i(s, r);
    } else a.fixed && (a.fixedOffset = r, r += parseFloat(a.width || "0") || 0);
    return r;
  }
  let l = 0;
  for (const a of e)
    l = i(a, l);
}
function HS(e, t) {
  const n = [];
  let i = 0;
  const l = BS(e);
  for (; l.size() > 0; ) {
    let r = l.count();
    const s = [];
    let o = 1;
    for (; r > 0; ) {
      const {
        element: u,
        priority: c
      } = l.dequeue(), d = t - i - qf(u);
      if (s.push({
        ...u,
        rowspan: d ?? 1,
        colspan: u.children ? Q1(u).length : 1
      }), u.children)
        for (const f of u.children) {
          const h = c % 1 + o / Math.pow(10, i + 2);
          l.enqueue(f, i + d + h);
        }
      o += 1, r -= 1;
    }
    i += 1, n.push(s);
  }
  return {
    columns: e.map((r) => Q1(r)).flat(),
    headers: n
  };
}
function S5(e) {
  const t = [];
  for (const n of e) {
    const i = {
      ...ES(n),
      ...n
    }, l = i.key ?? (typeof i.value == "string" ? i.value : null), a = i.value ?? l ?? null, r = {
      ...i,
      key: l,
      value: a,
      sortable: i.sortable ?? (i.key != null || !!i.sort),
      children: i.children ? S5(i.children) : void 0
    };
    t.push(r);
  }
  return t;
}
function Yf(e, t) {
  const n = z([]), i = z([]), l = z({}), a = z({}), r = z({});
  ft(() => {
    var v, p, O;
    const u = (e.headers || Object.keys(e.items[0] ?? {}).map((b) => ({
      key: b,
      title: Xa(b)
    }))).slice(), c = C5(u);
    (v = t == null ? void 0 : t.groupBy) != null && v.value.length && !c.has("data-table-group") && u.unshift({
      key: "data-table-group",
      title: "Group"
    }), (p = t == null ? void 0 : t.showSelect) != null && p.value && !c.has("data-table-select") && u.unshift({
      key: "data-table-select"
    }), (O = t == null ? void 0 : t.showExpand) != null && O.value && !c.has("data-table-expand") && u.push({
      key: "data-table-expand"
    });
    const d = S5(u);
    zS(d);
    const f = Math.max(...d.map((b) => qf(b))) + 1, h = HS(d, f);
    n.value = h.headers, i.value = h.columns;
    const g = h.headers.flat(1);
    for (const b of g)
      b.key && (b.sortable && (b.sort && (l.value[b.key] = b.sort), b.sortRaw && (a.value[b.key] = b.sortRaw)), b.filter && (r.value[b.key] = b.filter));
  });
  const s = {
    headers: n,
    columns: i,
    sortFunctions: l,
    sortRawFunctions: a,
    filterFunctions: r
  };
  return lt(y5, s), s;
}
function ju() {
  const e = Be(y5);
  if (!e) throw new Error("Missing headers!");
  return e;
}
const w5 = B({
  color: String,
  sticky: Boolean,
  disableSort: Boolean,
  multiSort: Boolean,
  sortAscIcon: {
    type: Se,
    default: "$sortAsc"
  },
  sortDescIcon: {
    type: Se,
    default: "$sortDesc"
  },
  headerProps: {
    type: Object
  },
  ...ql(),
  ...ku()
}, "VDataTableHeaders"), Zl = X()({
  name: "VDataTableHeaders",
  props: w5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = pt(), {
      toggleSort: l,
      sortBy: a,
      isSorted: r
    } = O5(), {
      someSelected: s,
      allSelected: o,
      selectAll: u,
      showSelectAll: c
    } = Eu(), {
      columns: d,
      headers: f
    } = ju(), {
      loaderClasses: h
    } = us(e);
    function g(w, y) {
      if (!(!e.sticky && !w.fixed))
        return {
          position: "sticky",
          left: w.fixed ? se(w.fixedOffset) : void 0,
          top: e.sticky ? `calc(var(--v-table-header-height) * ${y})` : void 0
        };
    }
    function v(w) {
      const y = a.value.find((L) => L.key === w.key);
      return y ? y.order === "asc" ? e.sortAscIcon : e.sortDescIcon : e.sortAscIcon;
    }
    const {
      backgroundColorClasses: p,
      backgroundColorStyles: O
    } = Fe(e, "color"), {
      displayClasses: b,
      mobile: V
    } = Dn(e), $ = C(() => ({
      headers: f.value,
      columns: d.value,
      toggleSort: l,
      isSorted: r,
      sortBy: a.value,
      someSelected: s.value,
      allSelected: o.value,
      selectAll: u,
      getSortIcon: v
    })), x = C(() => ["v-data-table__th", {
      "v-data-table__th--sticky": e.sticky
    }, b.value, h.value]), Q = (w) => {
      let {
        column: y,
        x: L,
        y: k
      } = w;
      const S = y.key === "data-table-select" || y.key === "data-table-expand", P = q(e.headerProps ?? {}, y.headerProps ?? {});
      return m(To, q({
        tag: "th",
        align: y.align,
        class: [{
          "v-data-table__th--sortable": y.sortable && !e.disableSort,
          "v-data-table__th--sorted": r(y),
          "v-data-table__th--fixed": y.fixed
        }, ...x.value],
        style: {
          width: se(y.width),
          minWidth: se(y.minWidth),
          maxWidth: se(y.maxWidth),
          ...g(y, k)
        },
        colspan: y.colspan,
        rowspan: y.rowspan,
        onClick: y.sortable ? () => l(y) : void 0,
        fixed: y.fixed,
        nowrap: y.nowrap,
        lastFixed: y.lastFixed,
        noPadding: S
      }, P), {
        default: () => {
          var D;
          const T = `header.${y.key}`, _ = {
            column: y,
            selectAll: u,
            isSorted: r,
            toggleSort: l,
            sortBy: a.value,
            someSelected: s.value,
            allSelected: o.value,
            getSortIcon: v
          };
          return n[T] ? n[T](_) : y.key === "data-table-select" ? ((D = n["header.data-table-select"]) == null ? void 0 : D.call(n, _)) ?? (c.value && m(Vi, {
            modelValue: o.value,
            indeterminate: s.value && !o.value,
            "onUpdate:modelValue": u
          }, null)) : m("div", {
            class: "v-data-table-header__content"
          }, [m("span", null, [y.title]), y.sortable && !e.disableSort && m(ze, {
            key: "icon",
            class: "v-data-table-header__sort-icon",
            icon: v(y)
          }, null), e.multiSort && r(y) && m("div", {
            key: "badge",
            class: ["v-data-table-header__sort-badge", ...p.value],
            style: O.value
          }, [a.value.findIndex((N) => N.key === y.key) + 1])]);
        }
      });
    }, M = () => {
      const w = q(e.headerProps ?? {} ?? {}), y = C(() => d.value.filter((k) => (k == null ? void 0 : k.sortable) && !e.disableSort)), L = C(() => {
        if (d.value.find((S) => S.key === "data-table-select") != null)
          return o.value ? "$checkboxOn" : s.value ? "$checkboxIndeterminate" : "$checkboxOff";
      });
      return m(To, q({
        tag: "th",
        class: [...x.value],
        colspan: f.value.length + 1
      }, w), {
        default: () => [m("div", {
          class: "v-data-table-header__content"
        }, [m(If, {
          chips: !0,
          class: "v-data-table__td-sort-select",
          clearable: !0,
          density: "default",
          items: y.value,
          label: i("$vuetify.dataTable.sortBy"),
          multiple: e.multiSort,
          variant: "underlined",
          "onClick:clear": () => a.value = [],
          appendIcon: L.value,
          "onClick:append": () => u(!o.value)
        }, {
          ...n,
          chip: (k) => {
            var S;
            return m(Wa, {
              onClick: (S = k.item.raw) != null && S.sortable ? () => l(k.item.raw) : void 0,
              onMousedown: (P) => {
                P.preventDefault(), P.stopPropagation();
              }
            }, {
              default: () => [k.item.title, m(ze, {
                class: ["v-data-table__td-sort-icon", r(k.item.raw) && "v-data-table__td-sort-icon-active"],
                icon: v(k.item.raw),
                size: "small"
              }, null)]
            });
          }
        })])]
      });
    };
    F(() => V.value ? m("tr", null, [m(M, null, null)]) : m(le, null, [n.headers ? n.headers($.value) : f.value.map((w, y) => m("tr", null, [w.map((L, k) => m(Q, {
      column: L,
      x: k,
      y
    }, null))])), e.loading && m("tr", {
      class: "v-data-table-progress"
    }, [m("th", {
      colspan: d.value.length
    }, [m(cs, {
      name: "v-data-table-progress",
      absolute: !0,
      active: !0,
      color: typeof e.loading == "boolean" ? void 0 : e.loading,
      indeterminate: !0
    }, {
      default: n.loader
    })])])]));
  }
}), jS = B({
  item: {
    type: Object,
    required: !0
  }
}, "VDataTableGroupHeaderRow"), XS = X()({
  name: "VDataTableGroupHeaderRow",
  props: jS(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isGroupOpen: i,
      toggleGroup: l,
      extractRows: a
    } = s5(), {
      isSelected: r,
      isSomeSelected: s,
      select: o
    } = Eu(), {
      columns: u
    } = ju(), c = C(() => a([e.item]));
    return () => m("tr", {
      class: "v-data-table-group-header-row",
      style: {
        "--v-data-table-group-header-row-depth": e.item.depth
      }
    }, [u.value.map((d) => {
      var f, h;
      if (d.key === "data-table-group") {
        const g = i(e.item) ? "$expand" : "$next", v = () => l(e.item);
        return ((f = n["data-table-group"]) == null ? void 0 : f.call(n, {
          item: e.item,
          count: c.value.length,
          props: {
            icon: g,
            onClick: v
          }
        })) ?? m(To, {
          class: "v-data-table-group-header-row__column"
        }, {
          default: () => [m(je, {
            size: "small",
            variant: "text",
            icon: g,
            onClick: v
          }, null), m("span", null, [e.item.value]), m("span", null, [ke("("), c.value.length, ke(")")])]
        });
      }
      if (d.key === "data-table-select") {
        const g = r(c.value), v = s(c.value) && !g, p = (O) => o(c.value, O);
        return ((h = n["data-table-select"]) == null ? void 0 : h.call(n, {
          props: {
            modelValue: g,
            indeterminate: v,
            "onUpdate:modelValue": p
          }
        })) ?? m("td", null, [m(Vi, {
          modelValue: g,
          indeterminate: v,
          "onUpdate:modelValue": p
        }, null)]);
      }
      return m("td", null, null);
    })]);
  }
}), NS = B({
  index: Number,
  item: Object,
  cellProps: [Object, Function],
  onClick: Dt(),
  onContextmenu: Dt(),
  onDblclick: Dt(),
  ...ql()
}, "VDataTableRow"), Ff = X()({
  name: "VDataTableRow",
  props: NS(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      displayClasses: i,
      mobile: l
    } = Dn(e, "v-data-table__tr"), {
      isSelected: a,
      toggleSelect: r,
      someSelected: s,
      allSelected: o,
      selectAll: u
    } = Eu(), {
      isExpanded: c,
      toggleExpand: d
    } = a5(), {
      toggleSort: f,
      sortBy: h,
      isSorted: g
    } = O5(), {
      columns: v
    } = ju();
    F(() => m("tr", {
      class: ["v-data-table__tr", {
        "v-data-table__tr--clickable": !!(e.onClick || e.onContextmenu || e.onDblclick)
      }, i.value],
      onClick: e.onClick,
      onContextmenu: e.onContextmenu,
      onDblclick: e.onDblclick
    }, [e.item && v.value.map((p, O) => {
      const b = e.item, V = `item.${p.key}`, $ = `header.${p.key}`, x = {
        index: e.index,
        item: b.raw,
        internalItem: b,
        value: Ml(b.columns, p.key),
        column: p,
        isSelected: a,
        toggleSelect: r,
        isExpanded: c,
        toggleExpand: d
      }, Q = {
        column: p,
        selectAll: u,
        isSorted: g,
        toggleSort: f,
        sortBy: h.value,
        someSelected: s.value,
        allSelected: o.value,
        getSortIcon: () => ""
      }, M = typeof e.cellProps == "function" ? e.cellProps({
        index: x.index,
        item: x.item,
        internalItem: x.internalItem,
        value: x.value,
        column: p
      }) : e.cellProps, w = typeof p.cellProps == "function" ? p.cellProps({
        index: x.index,
        item: x.item,
        internalItem: x.internalItem,
        value: x.value
      }) : p.cellProps;
      return m(To, q({
        align: p.align,
        class: {
          "v-data-table__td--expanded-row": p.key === "data-table-expand",
          "v-data-table__td--select-row": p.key === "data-table-select"
        },
        fixed: p.fixed,
        fixedOffset: p.fixedOffset,
        lastFixed: p.lastFixed,
        maxWidth: l.value ? void 0 : p.maxWidth,
        noPadding: p.key === "data-table-select" || p.key === "data-table-expand",
        nowrap: p.nowrap,
        width: l.value ? void 0 : p.width
      }, M, w), {
        default: () => {
          var L, k, S, P, T;
          if (n[V] && !l.value) return (L = n[V]) == null ? void 0 : L.call(n, x);
          if (p.key === "data-table-select")
            return ((k = n["item.data-table-select"]) == null ? void 0 : k.call(n, x)) ?? m(Vi, {
              disabled: !b.selectable,
              modelValue: a([b]),
              onClick: _t(() => r(b), ["stop"])
            }, null);
          if (p.key === "data-table-expand")
            return ((S = n["item.data-table-expand"]) == null ? void 0 : S.call(n, x)) ?? m(je, {
              icon: c(b) ? "$collapse" : "$expand",
              size: "small",
              variant: "text",
              onClick: _t(() => d(b), ["stop"])
            }, null);
          const y = he(x.value);
          return l.value ? m(le, null, [m("div", {
            class: "v-data-table__td-title"
          }, [((P = n[$]) == null ? void 0 : P.call(n, Q)) ?? p.title]), m("div", {
            class: "v-data-table__td-value"
          }, [((T = n[V]) == null ? void 0 : T.call(n, x)) ?? y])]) : y;
        }
      });
    })]));
  }
}), k5 = B({
  loading: [Boolean, String],
  loadingText: {
    type: String,
    default: "$vuetify.dataIterator.loadingText"
  },
  hideNoData: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  ...ql()
}, "VDataTableRows"), Il = X()({
  name: "VDataTableRows",
  inheritAttrs: !1,
  props: k5(),
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      columns: l
    } = ju(), {
      expandOnClick: a,
      toggleExpand: r,
      isExpanded: s
    } = a5(), {
      isSelected: o,
      toggleSelect: u
    } = Eu(), {
      toggleGroup: c,
      isGroupOpen: d
    } = s5(), {
      t: f
    } = pt(), {
      mobile: h
    } = Dn(e);
    return F(() => {
      var g, v;
      return e.loading && (!e.items.length || i.loading) ? m("tr", {
        class: "v-data-table-rows-loading",
        key: "loading"
      }, [m("td", {
        colspan: l.value.length
      }, [((g = i.loading) == null ? void 0 : g.call(i)) ?? f(e.loadingText)])]) : !e.loading && !e.items.length && !e.hideNoData ? m("tr", {
        class: "v-data-table-rows-no-data",
        key: "no-data"
      }, [m("td", {
        colspan: l.value.length
      }, [((v = i["no-data"]) == null ? void 0 : v.call(i)) ?? f(e.noDataText)])]) : m(le, null, [e.items.map((p, O) => {
        var $;
        if (p.type === "group") {
          const x = {
            index: O,
            item: p,
            columns: l.value,
            isExpanded: s,
            toggleExpand: r,
            isSelected: o,
            toggleSelect: u,
            toggleGroup: c,
            isGroupOpen: d
          };
          return i["group-header"] ? i["group-header"](x) : m(XS, q({
            key: `group-header_${p.id}`,
            item: p
          }, S2(n, ":group-header", () => x)), i);
        }
        const b = {
          index: O,
          item: p.raw,
          internalItem: p,
          columns: l.value,
          isExpanded: s,
          toggleExpand: r,
          isSelected: o,
          toggleSelect: u
        }, V = {
          ...b,
          props: q({
            key: `item_${p.key ?? p.index}`,
            onClick: a.value ? () => {
              r(p);
            } : void 0,
            index: O,
            item: p,
            cellProps: e.cellProps,
            mobile: h.value
          }, S2(n, ":row", () => b), typeof e.rowProps == "function" ? e.rowProps({
            item: b.item,
            index: b.index,
            internalItem: b.internalItem
          }) : e.rowProps)
        };
        return m(le, {
          key: V.props.key
        }, [i.item ? i.item(V) : m(Ff, V.props, i), s(p) && (($ = i["expanded-row"]) == null ? void 0 : $.call(i, b))]);
      })]);
    }), {};
  }
}), x5 = B({
  fixedHeader: Boolean,
  fixedFooter: Boolean,
  height: [Number, String],
  hover: Boolean,
  ...ue(),
  ...Zt(),
  ...Ve(),
  ...Ie()
}, "VTable"), Dl = X()({
  name: "VTable",
  props: x5(),
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const {
      themeClasses: l
    } = Xe(e), {
      densityClasses: a
    } = nn(e);
    return F(() => m(e.tag, {
      class: ["v-table", {
        "v-table--fixed-height": !!e.height,
        "v-table--fixed-header": e.fixedHeader,
        "v-table--fixed-footer": e.fixedFooter,
        "v-table--has-top": !!n.top,
        "v-table--has-bottom": !!n.bottom,
        "v-table--hover": e.hover
      }, l.value, a.value, e.class],
      style: e.style
    }, {
      default: () => {
        var r, s, o;
        return [(r = n.top) == null ? void 0 : r.call(n), n.default ? m("div", {
          class: "v-table__wrapper",
          style: {
            height: se(e.height)
          }
        }, [m("table", null, [n.default()])]) : (s = n.wrapper) == null ? void 0 : s.call(n), (o = n.bottom) == null ? void 0 : o.call(n)];
      }
    })), {};
  }
}), qS = B({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  returnObject: Boolean
}, "DataTable-items");
function YS(e, t, n, i) {
  const l = e.returnObject ? t : Pt(t, e.itemValue), a = Pt(t, e.itemSelectable, !0), r = i.reduce((s, o) => (o.key != null && (s[o.key] = Pt(t, o.value)), s), {});
  return {
    type: "item",
    key: e.returnObject ? Pt(t, e.itemValue) : l,
    index: n,
    value: l,
    selectable: a,
    columns: r,
    raw: t
  };
}
function FS(e, t, n) {
  return t.map((i, l) => YS(e, i, l, n));
}
function Wf(e, t) {
  return {
    items: C(() => FS(e, e.items, t.value))
  };
}
const Uf = B({
  ...k5(),
  hideDefaultBody: Boolean,
  hideDefaultFooter: Boolean,
  hideDefaultHeader: Boolean,
  width: [String, Number],
  search: String,
  ...i5(),
  ...Bf(),
  ...IS(),
  ...qS(),
  ...m5(),
  ...v5(),
  ...w5(),
  ...x5()
}, "DataTable"), WS = B({
  ...zf(),
  ...Uf(),
  ...ms(),
  ...Nf()
}, "VDataTable"), US = X()({
  name: "VDataTable",
  props: WS(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: l
    } = Ef(e), {
      sortBy: a,
      multiSort: r,
      mustSort: s
    } = zu(e), {
      page: o,
      itemsPerPage: u
    } = Hf(e), {
      disableSort: c
    } = Nl(e), {
      columns: d,
      headers: f,
      sortFunctions: h,
      sortRawFunctions: g,
      filterFunctions: v
    } = Yf(e, {
      groupBy: l,
      showSelect: H(e, "showSelect"),
      showExpand: H(e, "showExpand")
    }), {
      items: p
    } = Wf(e, d), O = H(e, "search"), {
      filteredItems: b
    } = gs(e, p, O, {
      transform: (ge) => ge.columns,
      customKeyFilter: v
    }), {
      toggleSort: V
    } = Hu({
      sortBy: a,
      multiSort: r,
      mustSort: s,
      page: o
    }), {
      sortByWithGroups: $,
      opened: x,
      extractRows: Q,
      isGroupOpen: M,
      toggleGroup: w
    } = Zu({
      groupBy: l,
      sortBy: a,
      disableSort: c
    }), {
      sortedItems: y
    } = Xf(e, b, $, {
      transform: (ge) => ({
        ...ge.raw,
        ...ge.columns
      }),
      sortFunctions: h,
      sortRawFunctions: g
    }), {
      flatItems: L
    } = Iu(y, l, x), k = C(() => L.value.length), {
      startIndex: S,
      stopIndex: P,
      pageCount: T,
      setItemsPerPage: _
    } = jf({
      page: o,
      itemsPerPage: u,
      itemsLength: k
    }), {
      paginatedItems: D
    } = d5({
      items: L,
      startIndex: S,
      stopIndex: P,
      itemsPerPage: u
    }), N = C(() => Q(D.value)), {
      isSelected: K,
      select: E,
      selectAll: I,
      toggleSelect: Z,
      someSelected: Y,
      allSelected: ce
    } = Bu(e, {
      allItems: p,
      currentPage: N
    }), {
      isExpanded: de,
      toggleExpand: ye
    } = Ru(e);
    Du({
      page: o,
      itemsPerPage: u,
      sortBy: a,
      groupBy: l,
      search: O
    }), ht({
      VDataTableRows: {
        hideNoData: H(e, "hideNoData"),
        noDataText: H(e, "noDataText"),
        loading: H(e, "loading"),
        loadingText: H(e, "loadingText")
      }
    });
    const U = C(() => ({
      page: o.value,
      itemsPerPage: u.value,
      sortBy: a.value,
      pageCount: T.value,
      toggleSort: V,
      setItemsPerPage: _,
      someSelected: Y.value,
      allSelected: ce.value,
      isSelected: K,
      select: E,
      selectAll: I,
      toggleSelect: Z,
      isExpanded: de,
      toggleExpand: ye,
      isGroupOpen: M,
      toggleGroup: w,
      items: N.value.map((ge) => ge.raw),
      internalItems: N.value,
      groupedItems: D.value,
      columns: d.value,
      headers: f.value
    }));
    return F(() => {
      const ge = Ir.filterProps(e), be = Zl.filterProps(e), De = Il.filterProps(e), Ye = Dl.filterProps(e);
      return m(Dl, q({
        class: ["v-data-table", {
          "v-data-table--show-select": e.showSelect,
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Ye), {
        top: () => {
          var re;
          return (re = i.top) == null ? void 0 : re.call(i, U.value);
        },
        default: () => {
          var re, Qe, te, oe, Pe, we;
          return i.default ? i.default(U.value) : m(le, null, [(re = i.colgroup) == null ? void 0 : re.call(i, U.value), !e.hideDefaultHeader && m("thead", {
            key: "thead"
          }, [m(Zl, be, i)]), (Qe = i.thead) == null ? void 0 : Qe.call(i, U.value), !e.hideDefaultBody && m("tbody", null, [(te = i["body.prepend"]) == null ? void 0 : te.call(i, U.value), i.body ? i.body(U.value) : m(Il, q(n, De, {
            items: D.value
          }), i), (oe = i["body.append"]) == null ? void 0 : oe.call(i, U.value)]), (Pe = i.tbody) == null ? void 0 : Pe.call(i, U.value), (we = i.tfoot) == null ? void 0 : we.call(i, U.value)]);
        },
        bottom: () => i.bottom ? i.bottom(U.value) : !e.hideDefaultFooter && m(le, null, [m(fs, null, null), m(Ir, ge, {
          prepend: i["footer.prepend"]
        })])
      });
    }), {};
  }
}), GS = B({
  ...Uf(),
  ...Bf(),
  ...D4(),
  ...ms()
}, "VDataTableVirtual"), KS = X()({
  name: "VDataTableVirtual",
  props: GS(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: l
    } = Ef(e), {
      sortBy: a,
      multiSort: r,
      mustSort: s
    } = zu(e), {
      disableSort: o
    } = Nl(e), {
      columns: u,
      headers: c,
      filterFunctions: d,
      sortFunctions: f,
      sortRawFunctions: h
    } = Yf(e, {
      groupBy: l,
      showSelect: H(e, "showSelect"),
      showExpand: H(e, "showExpand")
    }), {
      items: g
    } = Wf(e, u), v = H(e, "search"), {
      filteredItems: p
    } = gs(e, g, v, {
      transform: (be) => be.columns,
      customKeyFilter: d
    }), {
      toggleSort: O
    } = Hu({
      sortBy: a,
      multiSort: r,
      mustSort: s
    }), {
      sortByWithGroups: b,
      opened: V,
      extractRows: $,
      isGroupOpen: x,
      toggleGroup: Q
    } = Zu({
      groupBy: l,
      sortBy: a,
      disableSort: o
    }), {
      sortedItems: M
    } = Xf(e, p, b, {
      transform: (be) => ({
        ...be.raw,
        ...be.columns
      }),
      sortFunctions: f,
      sortRawFunctions: h
    }), {
      flatItems: w
    } = Iu(M, l, V), y = C(() => $(w.value)), {
      isSelected: L,
      select: k,
      selectAll: S,
      toggleSelect: P,
      someSelected: T,
      allSelected: _
    } = Bu(e, {
      allItems: y,
      currentPage: y
    }), {
      isExpanded: D,
      toggleExpand: N
    } = Ru(e), {
      containerRef: K,
      markerRef: E,
      paddingTop: I,
      paddingBottom: Z,
      computedItems: Y,
      handleItemResize: ce,
      handleScroll: de,
      handleScrollend: ye
    } = B4(e, w), U = C(() => Y.value.map((be) => be.raw));
    Du({
      sortBy: a,
      page: ie(1),
      itemsPerPage: ie(-1),
      groupBy: l,
      search: v
    }), ht({
      VDataTableRows: {
        hideNoData: H(e, "hideNoData"),
        noDataText: H(e, "noDataText"),
        loading: H(e, "loading"),
        loadingText: H(e, "loadingText")
      }
    });
    const ge = C(() => ({
      sortBy: a.value,
      toggleSort: O,
      someSelected: T.value,
      allSelected: _.value,
      isSelected: L,
      select: k,
      selectAll: S,
      toggleSelect: P,
      isExpanded: D,
      toggleExpand: N,
      isGroupOpen: x,
      toggleGroup: Q,
      items: y.value.map((be) => be.raw),
      internalItems: y.value,
      groupedItems: w.value,
      columns: u.value,
      headers: c.value
    }));
    F(() => {
      const be = Zl.filterProps(e), De = Il.filterProps(e), Ye = Dl.filterProps(e);
      return m(Dl, q({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Ye), {
        top: () => {
          var re;
          return (re = i.top) == null ? void 0 : re.call(i, ge.value);
        },
        wrapper: () => {
          var re, Qe, te;
          return m("div", {
            ref: K,
            onScrollPassive: de,
            onScrollend: ye,
            class: "v-table__wrapper",
            style: {
              height: se(e.height)
            }
          }, [m("table", null, [(re = i.colgroup) == null ? void 0 : re.call(i, ge.value), !e.hideDefaultHeader && m("thead", {
            key: "thead"
          }, [m(Zl, q(be, {
            sticky: e.fixedHeader
          }), i)]), !e.hideDefaultBody && m("tbody", null, [m("tr", {
            ref: E,
            style: {
              height: se(I.value),
              border: 0
            }
          }, [m("td", {
            colspan: u.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)]), (Qe = i["body.prepend"]) == null ? void 0 : Qe.call(i, ge.value), m(Il, q(n, De, {
            items: U.value
          }), {
            ...i,
            item: (oe) => m(I4, {
              key: oe.internalItem.index,
              renderless: !0,
              "onUpdate:height": (Pe) => ce(oe.internalItem.index, Pe)
            }, {
              default: (Pe) => {
                var $e;
                let {
                  itemRef: we
                } = Pe;
                return (($e = i.item) == null ? void 0 : $e.call(i, {
                  ...oe,
                  itemRef: we
                })) ?? m(Ff, q(oe.props, {
                  ref: we,
                  key: oe.internalItem.index,
                  index: oe.internalItem.index
                }), i);
              }
            })
          }), (te = i["body.append"]) == null ? void 0 : te.call(i, ge.value), m("tr", {
            style: {
              height: se(Z.value),
              border: 0
            }
          }, [m("td", {
            colspan: u.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)])])])]);
        },
        bottom: () => {
          var re;
          return (re = i.bottom) == null ? void 0 : re.call(i, ge.value);
        }
      });
    });
  }
}), JS = B({
  itemsLength: {
    type: [Number, String],
    required: !0
  },
  ...zf(),
  ...Uf(),
  ...Nf()
}, "VDataTableServer"), ew = X()({
  name: "VDataTableServer",
  props: JS(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:groupBy": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const {
      groupBy: l
    } = Ef(e), {
      sortBy: a,
      multiSort: r,
      mustSort: s
    } = zu(e), {
      page: o,
      itemsPerPage: u
    } = Hf(e), {
      disableSort: c
    } = Nl(e), d = C(() => parseInt(e.itemsLength, 10)), {
      columns: f,
      headers: h
    } = Yf(e, {
      groupBy: l,
      showSelect: H(e, "showSelect"),
      showExpand: H(e, "showExpand")
    }), {
      items: g
    } = Wf(e, f), {
      toggleSort: v
    } = Hu({
      sortBy: a,
      multiSort: r,
      mustSort: s,
      page: o
    }), {
      opened: p,
      isGroupOpen: O,
      toggleGroup: b,
      extractRows: V
    } = Zu({
      groupBy: l,
      sortBy: a,
      disableSort: c
    }), {
      pageCount: $,
      setItemsPerPage: x
    } = jf({
      page: o,
      itemsPerPage: u,
      itemsLength: d
    }), {
      flatItems: Q
    } = Iu(g, l, p), {
      isSelected: M,
      select: w,
      selectAll: y,
      toggleSelect: L,
      someSelected: k,
      allSelected: S
    } = Bu(e, {
      allItems: g,
      currentPage: g
    }), {
      isExpanded: P,
      toggleExpand: T
    } = Ru(e), _ = C(() => V(g.value));
    Du({
      page: o,
      itemsPerPage: u,
      sortBy: a,
      groupBy: l,
      search: H(e, "search")
    }), lt("v-data-table", {
      toggleSort: v,
      sortBy: a
    }), ht({
      VDataTableRows: {
        hideNoData: H(e, "hideNoData"),
        noDataText: H(e, "noDataText"),
        loading: H(e, "loading"),
        loadingText: H(e, "loadingText")
      }
    });
    const D = C(() => ({
      page: o.value,
      itemsPerPage: u.value,
      sortBy: a.value,
      pageCount: $.value,
      toggleSort: v,
      setItemsPerPage: x,
      someSelected: k.value,
      allSelected: S.value,
      isSelected: M,
      select: w,
      selectAll: y,
      toggleSelect: L,
      isExpanded: P,
      toggleExpand: T,
      isGroupOpen: O,
      toggleGroup: b,
      items: _.value.map((N) => N.raw),
      internalItems: _.value,
      groupedItems: Q.value,
      columns: f.value,
      headers: h.value
    }));
    F(() => {
      const N = Ir.filterProps(e), K = Zl.filterProps(e), E = Il.filterProps(e), I = Dl.filterProps(e);
      return m(Dl, q({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, I), {
        top: () => {
          var Z;
          return (Z = i.top) == null ? void 0 : Z.call(i, D.value);
        },
        default: () => {
          var Z, Y, ce, de, ye, U;
          return i.default ? i.default(D.value) : m(le, null, [(Z = i.colgroup) == null ? void 0 : Z.call(i, D.value), !e.hideDefaultHeader && m("thead", {
            key: "thead",
            class: "v-data-table__thead",
            role: "rowgroup"
          }, [m(Zl, q(K, {
            sticky: e.fixedHeader
          }), i)]), (Y = i.thead) == null ? void 0 : Y.call(i, D.value), !e.hideDefaultBody && m("tbody", {
            class: "v-data-table__tbody",
            role: "rowgroup"
          }, [(ce = i["body.prepend"]) == null ? void 0 : ce.call(i, D.value), i.body ? i.body(D.value) : m(Il, q(n, E, {
            items: Q.value
          }), i), (de = i["body.append"]) == null ? void 0 : de.call(i, D.value)]), (ye = i.tbody) == null ? void 0 : ye.call(i, D.value), (U = i.tfoot) == null ? void 0 : U.call(i, D.value)]);
        },
        bottom: () => i.bottom ? i.bottom(D.value) : !e.hideDefaultFooter && m(le, null, [m(fs, null, null), m(Ir, N, {
          prepend: i["footer.prepend"]
        })])
      });
    });
  }
}), tw = B({
  fluid: {
    type: Boolean,
    default: !1
  },
  ...ue(),
  ...wt(),
  ...Ve()
}, "VContainer"), nw = X()({
  name: "VContainer",
  props: tw(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: i
    } = Qt(), {
      dimensionStyles: l
    } = kt(e);
    return F(() => m(e.tag, {
      class: ["v-container", {
        "v-container--fluid": e.fluid
      }, i.value, e.class],
      style: [l.value, e.style]
    }, n)), {};
  }
}), P5 = Ou.reduce((e, t) => (e[t] = {
  type: [Boolean, String, Number],
  default: !1
}, e), {}), $5 = Ou.reduce((e, t) => {
  const n = "offset" + Xa(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}), V5 = Ou.reduce((e, t) => {
  const n = "order" + Xa(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}), Y2 = {
  col: Object.keys(P5),
  offset: Object.keys($5),
  order: Object.keys(V5)
};
function iw(e, t, n) {
  let i = e;
  if (!(n == null || n === !1)) {
    if (t) {
      const l = t.replace(e, "");
      i += `-${l}`;
    }
    return e === "col" && (i = "v-" + i), e === "col" && (n === "" || n === !0) || (i += `-${n}`), i.toLowerCase();
  }
}
const lw = ["auto", "start", "end", "center", "baseline", "stretch"], aw = B({
  cols: {
    type: [Boolean, String, Number],
    default: !1
  },
  ...P5,
  offset: {
    type: [String, Number],
    default: null
  },
  ...$5,
  order: {
    type: [String, Number],
    default: null
  },
  ...V5,
  alignSelf: {
    type: String,
    default: null,
    validator: (e) => lw.includes(e)
  },
  ...ue(),
  ...Ve()
}, "VCol"), rw = X()({
  name: "VCol",
  props: aw(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = C(() => {
      const l = [];
      let a;
      for (a in Y2)
        Y2[a].forEach((s) => {
          const o = e[s], u = iw(a, s, o);
          u && l.push(u);
        });
      const r = l.some((s) => s.startsWith("v-col-"));
      return l.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !r || !e.cols,
        [`v-col-${e.cols}`]: e.cols,
        [`offset-${e.offset}`]: e.offset,
        [`order-${e.order}`]: e.order,
        [`align-self-${e.alignSelf}`]: e.alignSelf
      }), l;
    });
    return () => {
      var l;
      return A(e.tag, {
        class: [i.value, e.class],
        style: e.style
      }, (l = n.default) == null ? void 0 : l.call(n));
    };
  }
}), Gf = ["start", "end", "center"], Q5 = ["space-between", "space-around", "space-evenly"];
function Kf(e, t) {
  return Ou.reduce((n, i) => {
    const l = e + Xa(i);
    return n[l] = t(), n;
  }, {});
}
const sw = [...Gf, "baseline", "stretch"], L5 = (e) => sw.includes(e), M5 = Kf("align", () => ({
  type: String,
  default: null,
  validator: L5
})), ow = [...Gf, ...Q5], T5 = (e) => ow.includes(e), _5 = Kf("justify", () => ({
  type: String,
  default: null,
  validator: T5
})), uw = [...Gf, ...Q5, "stretch"], A5 = (e) => uw.includes(e), R5 = Kf("alignContent", () => ({
  type: String,
  default: null,
  validator: A5
})), F2 = {
  align: Object.keys(M5),
  justify: Object.keys(_5),
  alignContent: Object.keys(R5)
}, cw = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function dw(e, t, n) {
  let i = cw[e];
  if (n != null) {
    if (t) {
      const l = t.replace(e, "");
      i += `-${l}`;
    }
    return i += `-${n}`, i.toLowerCase();
  }
}
const fw = B({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: L5
  },
  ...M5,
  justify: {
    type: String,
    default: null,
    validator: T5
  },
  ..._5,
  alignContent: {
    type: String,
    default: null,
    validator: A5
  },
  ...R5,
  ...ue(),
  ...Ve()
}, "VRow"), hw = X()({
  name: "VRow",
  props: fw(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = C(() => {
      const l = [];
      let a;
      for (a in F2)
        F2[a].forEach((r) => {
          const s = e[r], o = dw(a, r, s);
          o && l.push(o);
        });
      return l.push({
        "v-row--no-gutters": e.noGutters,
        "v-row--dense": e.dense,
        [`align-${e.align}`]: e.align,
        [`justify-${e.justify}`]: e.justify,
        [`align-content-${e.alignContent}`]: e.alignContent
      }), l;
    });
    return () => {
      var l;
      return A(e.tag, {
        class: ["v-row", i.value, e.class],
        style: e.style
      }, (l = n.default) == null ? void 0 : l.call(n));
    };
  }
}), Z5 = Oi("v-spacer", "div", "VSpacer"), I5 = B({
  active: {
    type: [String, Array],
    default: void 0
  },
  disabled: {
    type: [Boolean, String, Array],
    default: !1
  },
  nextIcon: {
    type: Se,
    default: "$next"
  },
  prevIcon: {
    type: Se,
    default: "$prev"
  },
  modeIcon: {
    type: Se,
    default: "$subgroup"
  },
  text: String,
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls"), L1 = X()({
  name: "VDatePickerControls",
  props: I5(),
  emits: {
    "click:year": () => !0,
    "click:month": () => !0,
    "click:prev": () => !0,
    "click:next": () => !0,
    "click:text": () => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const i = C(() => Array.isArray(e.disabled) ? e.disabled.includes("text") : !!e.disabled), l = C(() => Array.isArray(e.disabled) ? e.disabled.includes("mode") : !!e.disabled), a = C(() => Array.isArray(e.disabled) ? e.disabled.includes("prev") : !!e.disabled), r = C(() => Array.isArray(e.disabled) ? e.disabled.includes("next") : !!e.disabled);
    function s() {
      n("click:prev");
    }
    function o() {
      n("click:next");
    }
    function u() {
      n("click:year");
    }
    function c() {
      n("click:month");
    }
    return F(() => m("div", {
      class: ["v-date-picker-controls"]
    }, [m(je, {
      class: "v-date-picker-controls__month-btn",
      disabled: i.value,
      text: e.text,
      variant: "text",
      rounded: !0,
      onClick: c
    }, null), m(je, {
      key: "mode-btn",
      class: "v-date-picker-controls__mode-btn",
      disabled: l.value,
      density: "comfortable",
      icon: e.modeIcon,
      variant: "text",
      onClick: u
    }, null), m(Z5, {
      key: "mode-spacer"
    }, null), m("div", {
      key: "month-buttons",
      class: "v-date-picker-controls__month"
    }, [m(je, {
      disabled: a.value,
      icon: e.prevIcon,
      variant: "text",
      onClick: s
    }, null), m(je, {
      disabled: r.value,
      icon: e.nextIcon,
      variant: "text",
      onClick: o
    }, null)])])), {};
  }
}), mw = B({
  appendIcon: String,
  color: String,
  header: String,
  transition: String,
  onClick: Dt()
}, "VDatePickerHeader"), M1 = X()({
  name: "VDatePickerHeader",
  props: mw(),
  emits: {
    click: () => !0,
    "click:append": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      backgroundColorClasses: l,
      backgroundColorStyles: a
    } = Fe(e, "color");
    function r() {
      n("click");
    }
    function s() {
      n("click:append");
    }
    return F(() => {
      const o = !!(i.default || e.header), u = !!(i.append || e.appendIcon);
      return m("div", {
        class: ["v-date-picker-header", {
          "v-date-picker-header--clickable": !!e.onClick
        }, l.value],
        style: a.value,
        onClick: r
      }, [i.prepend && m("div", {
        key: "prepend",
        class: "v-date-picker-header__prepend"
      }, [i.prepend()]), o && m(en, {
        key: "content",
        name: e.transition
      }, {
        default: () => {
          var c;
          return [m("div", {
            key: e.header,
            class: "v-date-picker-header__content"
          }, [((c = i.default) == null ? void 0 : c.call(i)) ?? e.header])];
        }
      }), u && m("div", {
        class: "v-date-picker-header__append"
      }, [i.append ? m(Te, {
        key: "append-defaults",
        disabled: !e.appendIcon,
        defaults: {
          VBtn: {
            icon: e.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => {
          var c;
          return [(c = i.append) == null ? void 0 : c.call(i)];
        }
      }) : m(je, {
        key: "append-btn",
        icon: e.appendIcon,
        variant: "text",
        onClick: s
      }, null)])]);
    }), {};
  }
}), gw = B({
  allowedDates: [Array, Function],
  disabled: Boolean,
  displayValue: null,
  modelValue: Array,
  month: [Number, String],
  max: null,
  min: null,
  showAdjacentMonths: Boolean,
  year: [Number, String],
  weekdays: {
    type: Array,
    default: () => [0, 1, 2, 3, 4, 5, 6]
  },
  weeksInMonth: {
    type: String,
    default: "dynamic"
  },
  firstDayOfWeek: [Number, String]
}, "calendar");
function vw(e) {
  const t = ls(), n = pe(e, "modelValue", [], (h) => ut(h)), i = C(() => e.displayValue ? t.date(e.displayValue) : n.value.length > 0 ? t.date(n.value[0]) : e.min ? t.date(e.min) : Array.isArray(e.allowedDates) ? t.date(e.allowedDates[0]) : t.date()), l = pe(e, "year", void 0, (h) => {
    const g = h != null ? Number(h) : t.getYear(i.value);
    return t.startOfYear(t.setYear(t.date(), g));
  }, (h) => t.getYear(h)), a = pe(e, "month", void 0, (h) => {
    const g = h != null ? Number(h) : t.getMonth(i.value), v = t.setYear(t.startOfMonth(t.date()), t.getYear(l.value));
    return t.setMonth(v, g);
  }, (h) => t.getMonth(h)), r = C(() => {
    const h = Number(e.firstDayOfWeek ?? 0);
    return e.weekdays.map((g) => (g + h) % 7);
  }), s = C(() => {
    const h = t.getWeekArray(a.value, e.firstDayOfWeek), g = h.flat(), v = 6 * 7;
    if (e.weeksInMonth === "static" && g.length < v) {
      const p = g[g.length - 1];
      let O = [];
      for (let b = 1; b <= v - g.length; b++)
        O.push(t.addDays(p, b)), b % 7 === 0 && (h.push(O), O = []);
    }
    return h;
  });
  function o(h, g) {
    return h.filter((v) => r.value.includes(t.toJsDate(v).getDay())).map((v, p) => {
      const O = t.toISO(v), b = !t.isSameMonth(v, a.value), V = t.isSameDay(v, t.startOfMonth(a.value)), $ = t.isSameDay(v, t.endOfMonth(a.value)), x = t.isSameDay(v, a.value);
      return {
        date: v,
        isoDate: O,
        formatted: t.format(v, "keyboardDate"),
        year: t.getYear(v),
        month: t.getMonth(v),
        isDisabled: f(v),
        isWeekStart: p % 7 === 0,
        isWeekEnd: p % 7 === 6,
        isToday: t.isSameDay(v, g),
        isAdjacent: b,
        isHidden: b && !e.showAdjacentMonths,
        isStart: V,
        isSelected: n.value.some((Q) => t.isSameDay(v, Q)),
        isEnd: $,
        isSame: x,
        localized: t.format(v, "dayOfMonth")
      };
    });
  }
  const u = C(() => {
    const h = t.startOfWeek(i.value, e.firstDayOfWeek), g = [];
    for (let p = 0; p <= 6; p++)
      g.push(t.addDays(h, p));
    const v = t.date();
    return o(g, v);
  }), c = C(() => {
    const h = s.value.flat(), g = t.date();
    return o(h, g);
  }), d = C(() => s.value.map((h) => h.length ? hO(t, h[0]) : null));
  function f(h) {
    if (e.disabled) return !0;
    const g = t.date(h);
    return e.min && t.isAfter(t.date(e.min), g) || e.max && t.isAfter(g, t.date(e.max)) ? !0 : Array.isArray(e.allowedDates) && e.allowedDates.length > 0 ? !e.allowedDates.some((v) => t.isSameDay(t.date(v), g)) : typeof e.allowedDates == "function" ? !e.allowedDates(g) : !1;
  }
  return {
    displayValue: i,
    daysInMonth: c,
    daysInWeek: u,
    genDays: o,
    model: n,
    weeksInMonth: s,
    weekDays: r,
    weekNumbers: d
  };
}
const D5 = B({
  color: String,
  hideWeekdays: Boolean,
  multiple: [Boolean, Number, String],
  showWeek: Boolean,
  transition: {
    type: String,
    default: "picker-transition"
  },
  reverseTransition: {
    type: String,
    default: "picker-reverse-transition"
  },
  ...gw()
}, "VDatePickerMonth"), T1 = X()({
  name: "VDatePickerMonth",
  props: D5(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const l = z(), {
      daysInMonth: a,
      model: r,
      weekNumbers: s
    } = vw(e), o = ls(), u = ie(), c = ie(), d = ie(!1), f = C(() => d.value ? e.reverseTransition : e.transition);
    e.multiple === "range" && r.value.length > 0 && (u.value = r.value[0], r.value.length > 1 && (c.value = r.value[r.value.length - 1]));
    const h = C(() => {
      const O = ["number", "string"].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0;
      return r.value.length >= O;
    });
    ee(a, (O, b) => {
      b && (d.value = o.isBefore(O[0].date, b[0].date));
    });
    function g(O) {
      const b = o.startOfDay(O);
      if (r.value.length === 0 ? u.value = void 0 : r.value.length === 1 && (u.value = r.value[0], c.value = void 0), !u.value)
        u.value = b, r.value = [u.value];
      else if (c.value)
        u.value = O, c.value = void 0, r.value = [u.value];
      else {
        if (o.isSameDay(b, u.value)) {
          u.value = void 0, r.value = [];
          return;
        } else o.isBefore(b, u.value) ? (c.value = o.endOfDay(u.value), u.value = b) : c.value = o.endOfDay(b);
        const V = o.getDiff(c.value, u.value, "days"), $ = [u.value];
        for (let x = 1; x < V; x++) {
          const Q = o.addDays(u.value, x);
          $.push(Q);
        }
        $.push(c.value), r.value = $;
      }
    }
    function v(O) {
      const b = r.value.findIndex((V) => o.isSameDay(V, O));
      if (b === -1)
        r.value = [...r.value, O];
      else {
        const V = [...r.value];
        V.splice(b, 1), r.value = V;
      }
    }
    function p(O) {
      e.multiple === "range" ? g(O) : e.multiple ? v(O) : r.value = [O];
    }
    return () => m("div", {
      class: "v-date-picker-month"
    }, [e.showWeek && m("div", {
      key: "weeks",
      class: "v-date-picker-month__weeks"
    }, [!e.hideWeekdays && m("div", {
      key: "hide-week-days",
      class: "v-date-picker-month__day"
    }, [ke("")]), s.value.map((O) => m("div", {
      class: ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
    }, [O]))]), m(en, {
      name: f.value
    }, {
      default: () => {
        var O;
        return [m("div", {
          ref: l,
          key: (O = a.value[0].date) == null ? void 0 : O.toString(),
          class: "v-date-picker-month__days"
        }, [!e.hideWeekdays && o.getWeekdays(e.firstDayOfWeek).map((b) => m("div", {
          class: ["v-date-picker-month__day", "v-date-picker-month__weekday"]
        }, [b])), a.value.map((b, V) => {
          const $ = {
            props: {
              onClick: () => p(b.date)
            },
            item: b,
            i: V
          };
          return h.value && !b.isSelected && (b.isDisabled = !0), m("div", {
            class: ["v-date-picker-month__day", {
              "v-date-picker-month__day--adjacent": b.isAdjacent,
              "v-date-picker-month__day--hide-adjacent": b.isHidden,
              "v-date-picker-month__day--selected": b.isSelected,
              "v-date-picker-month__day--week-end": b.isWeekEnd,
              "v-date-picker-month__day--week-start": b.isWeekStart
            }],
            "data-v-date": b.isDisabled ? void 0 : b.isoDate
          }, [(e.showAdjacentMonths || !b.isAdjacent) && m(Te, {
            defaults: {
              VBtn: {
                class: "v-date-picker-month__day-btn",
                color: (b.isSelected || b.isToday) && !b.isDisabled ? e.color : void 0,
                disabled: b.isDisabled,
                icon: !0,
                ripple: !1,
                text: b.localized,
                variant: b.isDisabled ? b.isToday ? "outlined" : "text" : b.isToday && !b.isSelected ? "outlined" : "flat",
                onClick: () => p(b.date)
              }
            }
          }, {
            default: () => {
              var x;
              return [((x = i.day) == null ? void 0 : x.call(i, $)) ?? m(je, $.props, null)];
            }
          })]);
        })])];
      }
    })]);
  }
}), B5 = B({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  year: Number
}, "VDatePickerMonths"), _1 = X()({
  name: "VDatePickerMonths",
  props: B5(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const l = ls(), a = pe(e, "modelValue"), r = C(() => {
      let s = l.startOfYear(l.date());
      return e.year && (s = l.setYear(s, e.year)), si(12).map((o) => {
        const u = l.format(s, "monthShort"), c = !!(e.min && l.isAfter(l.startOfMonth(l.date(e.min)), s) || e.max && l.isAfter(s, l.startOfMonth(l.date(e.max))));
        return s = l.getNextMonth(s), {
          isDisabled: c,
          text: u,
          value: o
        };
      });
    });
    return ft(() => {
      a.value = a.value ?? l.getMonth(l.date());
    }), F(() => m("div", {
      class: "v-date-picker-months",
      style: {
        height: se(e.height)
      }
    }, [m("div", {
      class: "v-date-picker-months__content"
    }, [r.value.map((s, o) => {
      var d;
      const u = {
        active: a.value === o,
        color: a.value === o ? e.color : void 0,
        disabled: s.isDisabled,
        rounded: !0,
        text: s.text,
        variant: a.value === s.value ? "flat" : "text",
        onClick: () => c(o)
      };
      function c(f) {
        if (a.value === f) {
          n("update:modelValue", a.value);
          return;
        }
        a.value = f;
      }
      return ((d = i.month) == null ? void 0 : d.call(i, {
        month: s,
        i: o,
        props: u
      })) ?? m(je, q({
        key: "month"
      }, u), null);
    })])])), {};
  }
}), E5 = B({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number
}, "VDatePickerYears"), A1 = X()({
  name: "VDatePickerYears",
  props: E5(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const l = ls(), a = pe(e, "modelValue"), r = C(() => {
      const o = l.getYear(l.date());
      let u = o - 100, c = o + 52;
      e.min && (u = l.getYear(l.date(e.min))), e.max && (c = l.getYear(l.date(e.max)));
      let d = l.startOfYear(l.date());
      return d = l.setYear(d, u), si(c - u + 1, u).map((f) => {
        const h = l.format(d, "year");
        return d = l.setYear(d, l.getYear(d) + 1), {
          text: h,
          value: f
        };
      });
    });
    ft(() => {
      a.value = a.value ?? l.getYear(l.date());
    });
    const s = ko();
    return it(async () => {
      var o;
      await He(), (o = s.el) == null || o.scrollIntoView({
        block: "center"
      });
    }), F(() => m("div", {
      class: "v-date-picker-years",
      style: {
        height: se(e.height)
      }
    }, [m("div", {
      class: "v-date-picker-years__content"
    }, [r.value.map((o, u) => {
      var d;
      const c = {
        ref: a.value === o.value ? s : void 0,
        active: a.value === o.value,
        color: a.value === o.value ? e.color : void 0,
        rounded: !0,
        text: o.text,
        variant: a.value === o.value ? "flat" : "text",
        onClick: () => {
          if (a.value === o.value) {
            n("update:modelValue", a.value);
            return;
          }
          a.value = o.value;
        }
      };
      return ((d = i.year) == null ? void 0 : d.call(i, {
        year: o,
        i: u,
        props: c
      })) ?? m(je, q({
        key: "month"
      }, c), null);
    })])])), {};
  }
}), pw = Oi("v-picker-title"), z5 = B({
  bgColor: String,
  landscape: Boolean,
  title: String,
  hideHeader: Boolean,
  ...Au()
}, "VPicker"), W2 = X()({
  name: "VPicker",
  props: z5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = Fe(H(e, "color"));
    return F(() => {
      const a = Rl.filterProps(e), r = !!(e.title || n.title);
      return m(Rl, q(a, {
        color: e.bgColor,
        class: ["v-picker", {
          "v-picker--landscape": e.landscape,
          "v-picker--with-actions": !!n.actions
        }, e.class],
        style: e.style
      }), {
        default: () => {
          var s;
          return [!e.hideHeader && m("div", {
            key: "header",
            class: [i.value],
            style: [l.value]
          }, [r && m(pw, {
            key: "picker-title"
          }, {
            default: () => {
              var o;
              return [((o = n.title) == null ? void 0 : o.call(n)) ?? e.title];
            }
          }), n.header && m("div", {
            class: "v-picker__header"
          }, [n.header()])]), m("div", {
            class: "v-picker__body"
          }, [(s = n.default) == null ? void 0 : s.call(n)]), n.actions && m(Te, {
            defaults: {
              VBtn: {
                slim: !0,
                variant: "text"
              }
            }
          }, {
            default: () => [m("div", {
              class: "v-picker__actions"
            }, [n.actions()])]
          })];
        }
      });
    }), {};
  }
}), Ow = B({
  // TODO: implement in v3.5
  // calendarIcon: {
  //   type: String,
  //   default: '$calendar',
  // },
  // keyboardIcon: {
  //   type: String,
  //   default: '$edit',
  // },
  // inputMode: {
  //   type: String as PropType<'calendar' | 'keyboard'>,
  //   default: 'calendar',
  // },
  // inputText: {
  //   type: String,
  //   default: '$vuetify.datePicker.input.placeholder',
  // },
  // inputPlaceholder: {
  //   type: String,
  //   default: 'dd/mm/yyyy',
  // },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  ...I5(),
  ...D5({
    weeksInMonth: "static"
  }),
  ...St(B5(), ["modelValue"]),
  ...St(E5(), ["modelValue"]),
  ...z5({
    title: "$vuetify.datePicker.title"
  }),
  modelValue: null
}, "VDatePicker"), yw = X()({
  name: "VDatePicker",
  props: Ow(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0,
    // 'update:inputMode': (date: any) => true,
    "update:viewMode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const l = ls(), {
      t: a
    } = pt(), r = pe(e, "modelValue", void 0, (y) => ut(y), (y) => e.multiple ? y : y[0]), s = pe(e, "viewMode"), o = C(() => {
      var L;
      const y = l.date((L = r.value) == null ? void 0 : L[0]);
      return y && l.isValid(y) ? y : l.date();
    }), u = z(Number(e.month ?? l.getMonth(l.startOfMonth(o.value)))), c = z(Number(e.year ?? l.getYear(l.startOfYear(l.setMonth(o.value, u.value))))), d = ie(!1), f = C(() => e.multiple && r.value.length > 1 ? a("$vuetify.datePicker.itemsSelected", r.value.length) : r.value[0] && l.isValid(r.value[0]) ? l.format(l.date(r.value[0]), "normalDateWithWeekday") : a(e.header)), h = C(() => {
      let y = l.date();
      return y = l.setDate(y, 1), y = l.setMonth(y, u.value), y = l.setYear(y, c.value), l.format(y, "monthAndYear");
    }), g = C(() => `date-picker-header${d.value ? "-reverse" : ""}-transition`), v = C(() => {
      const y = l.date(e.min);
      return e.min && l.isValid(y) ? y : null;
    }), p = C(() => {
      const y = l.date(e.max);
      return e.max && l.isValid(y) ? y : null;
    }), O = C(() => {
      if (e.disabled) return !0;
      const y = [];
      if (s.value !== "month")
        y.push("prev", "next");
      else {
        let L = l.date();
        if (L = l.setYear(L, c.value), L = l.setMonth(L, u.value), v.value) {
          const k = l.addDays(l.startOfMonth(L), -1);
          l.isAfter(v.value, k) && y.push("prev");
        }
        if (p.value) {
          const k = l.addDays(l.endOfMonth(L), 1);
          l.isAfter(k, p.value) && y.push("next");
        }
      }
      return y;
    });
    function b() {
      u.value < 11 ? u.value++ : (c.value++, u.value = 0, w(c.value)), M(u.value);
    }
    function V() {
      u.value > 0 ? u.value-- : (c.value--, u.value = 11, w(c.value)), M(u.value);
    }
    function $() {
      s.value = "month";
    }
    function x() {
      s.value = s.value === "months" ? "month" : "months";
    }
    function Q() {
      s.value = s.value === "year" ? "month" : "year";
    }
    function M(y) {
      s.value === "months" && x(), n("update:month", y);
    }
    function w(y) {
      s.value === "year" && Q(), n("update:year", y);
    }
    return ee(r, (y, L) => {
      const k = ut(L), S = ut(y);
      if (!S.length) return;
      const P = l.date(k[k.length - 1]), T = l.date(S[S.length - 1]), _ = l.getMonth(T), D = l.getYear(T);
      _ !== u.value && (u.value = _, M(u.value)), D !== c.value && (c.value = D, w(c.value)), d.value = l.isBefore(P, T);
    }), F(() => {
      const y = W2.filterProps(e), L = L1.filterProps(e), k = M1.filterProps(e), S = T1.filterProps(e), P = St(_1.filterProps(e), ["modelValue"]), T = St(A1.filterProps(e), ["modelValue"]), _ = {
        header: f.value,
        transition: g.value
      };
      return m(W2, q(y, {
        class: ["v-date-picker", `v-date-picker--${s.value}`, {
          "v-date-picker--show-week": e.showWeek
        }, e.class],
        style: e.style
      }), {
        title: () => {
          var D;
          return ((D = i.title) == null ? void 0 : D.call(i)) ?? m("div", {
            class: "v-date-picker__title"
          }, [a(e.title)]);
        },
        header: () => i.header ? m(Te, {
          defaults: {
            VDatePickerHeader: {
              ..._
            }
          }
        }, {
          default: () => {
            var D;
            return [(D = i.header) == null ? void 0 : D.call(i, _)];
          }
        }) : m(M1, q({
          key: "header"
        }, k, _, {
          onClick: s.value !== "month" ? $ : void 0
        }), {
          ...i,
          default: void 0
        }),
        default: () => m(le, null, [m(L1, q(L, {
          disabled: O.value,
          text: h.value,
          "onClick:next": b,
          "onClick:prev": V,
          "onClick:month": x,
          "onClick:year": Q
        }), null), m(_r, {
          hideOnLeave: !0
        }, {
          default: () => [s.value === "months" ? m(_1, q({
            key: "date-picker-months"
          }, P, {
            modelValue: u.value,
            "onUpdate:modelValue": [(D) => u.value = D, M],
            min: v.value,
            max: p.value,
            year: c.value
          }), null) : s.value === "year" ? m(A1, q({
            key: "date-picker-years"
          }, T, {
            modelValue: c.value,
            "onUpdate:modelValue": [(D) => c.value = D, w],
            min: v.value,
            max: p.value
          }), null) : m(T1, q({
            key: "date-picker-month"
          }, S, {
            modelValue: r.value,
            "onUpdate:modelValue": (D) => r.value = D,
            month: u.value,
            "onUpdate:month": [(D) => u.value = D, M],
            year: c.value,
            "onUpdate:year": [(D) => c.value = D, w],
            min: v.value,
            max: p.value
          }), null)]
        })]),
        actions: i.actions
      });
    }), {};
  }
}), bw = B({
  actionText: String,
  bgColor: String,
  color: String,
  icon: Se,
  image: String,
  justify: {
    type: String,
    default: "center"
  },
  headline: String,
  title: String,
  text: String,
  textWidth: {
    type: [Number, String],
    default: 500
  },
  href: String,
  to: String,
  ...ue(),
  ...wt(),
  ...yi({
    size: void 0
  }),
  ...Ie()
}, "VEmptyState"), Cw = X()({
  name: "VEmptyState",
  props: bw(),
  emits: {
    "click:action": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      themeClasses: l
    } = Xe(e), {
      backgroundColorClasses: a,
      backgroundColorStyles: r
    } = Fe(H(e, "bgColor")), {
      dimensionStyles: s
    } = kt(e), {
      displayClasses: o
    } = Dn();
    function u(c) {
      n("click:action", c);
    }
    return F(() => {
      var p, O, b;
      const c = !!(i.actions || e.actionText), d = !!(i.headline || e.headline), f = !!(i.title || e.title), h = !!(i.text || e.text), g = !!(i.media || e.image || e.icon), v = e.size || (e.image ? 200 : 96);
      return m("div", {
        class: ["v-empty-state", {
          [`v-empty-state--${e.justify}`]: !0
        }, l.value, a.value, o.value, e.class],
        style: [r.value, s.value, e.style]
      }, [g && m("div", {
        key: "media",
        class: "v-empty-state__media"
      }, [i.media ? m(Te, {
        key: "media-defaults",
        defaults: {
          VImg: {
            src: e.image,
            height: v
          },
          VIcon: {
            size: v,
            icon: e.icon
          }
        }
      }, {
        default: () => [i.media()]
      }) : m(le, null, [e.image ? m($i, {
        key: "image",
        src: e.image,
        height: v
      }, null) : e.icon ? m(ze, {
        key: "icon",
        color: e.color,
        size: v,
        icon: e.icon
      }, null) : void 0])]), d && m("div", {
        key: "headline",
        class: "v-empty-state__headline"
      }, [((p = i.headline) == null ? void 0 : p.call(i)) ?? e.headline]), f && m("div", {
        key: "title",
        class: "v-empty-state__title"
      }, [((O = i.title) == null ? void 0 : O.call(i)) ?? e.title]), h && m("div", {
        key: "text",
        class: "v-empty-state__text",
        style: {
          maxWidth: se(e.textWidth)
        }
      }, [((b = i.text) == null ? void 0 : b.call(i)) ?? e.text]), i.default && m("div", {
        key: "content",
        class: "v-empty-state__content"
      }, [i.default()]), c && m("div", {
        key: "actions",
        class: "v-empty-state__actions"
      }, [m(Te, {
        defaults: {
          VBtn: {
            class: "v-empty-state__action-btn",
            color: e.color ?? "surface-variant",
            text: e.actionText
          }
        }
      }, {
        default: () => {
          var V;
          return [((V = i.actions) == null ? void 0 : V.call(i, {
            props: {
              onClick: u
            }
          })) ?? m(je, {
            onClick: u
          }, null)];
        }
      })])]);
    }), {};
  }
}), Dr = Symbol.for("vuetify:v-expansion-panel"), H5 = B({
  ...ue(),
  ...Sf()
}, "VExpansionPanelText"), R1 = X()({
  name: "VExpansionPanelText",
  props: H5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Be(Dr);
    if (!i) throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent: l,
      onAfterLeave: a
    } = wf(e, i.isSelected);
    return F(() => m(Cu, {
      onAfterLeave: a
    }, {
      default: () => {
        var r;
        return [Je(m("div", {
          class: ["v-expansion-panel-text", e.class],
          style: e.style
        }, [n.default && l.value && m("div", {
          class: "v-expansion-panel-text__wrapper"
        }, [(r = n.default) == null ? void 0 : r.call(n)])]), [[xn, i.isSelected.value]])];
      }
    })), {};
  }
}), j5 = B({
  color: String,
  expandIcon: {
    type: Se,
    default: "$expand"
  },
  collapseIcon: {
    type: Se,
    default: "$collapse"
  },
  hideActions: Boolean,
  focusable: Boolean,
  static: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !1
  },
  readonly: Boolean,
  ...ue(),
  ...wt()
}, "VExpansionPanelTitle"), Z1 = X()({
  name: "VExpansionPanelTitle",
  directives: {
    Ripple: Ti
  },
  props: j5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Be(Dr);
    if (!i) throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses: l,
      backgroundColorStyles: a
    } = Fe(e, "color"), {
      dimensionStyles: r
    } = kt(e), s = C(() => ({
      collapseIcon: e.collapseIcon,
      disabled: i.disabled.value,
      expanded: i.isSelected.value,
      expandIcon: e.expandIcon,
      readonly: e.readonly
    })), o = C(() => i.isSelected.value ? e.collapseIcon : e.expandIcon);
    return F(() => {
      var u;
      return Je(m("button", {
        class: ["v-expansion-panel-title", {
          "v-expansion-panel-title--active": i.isSelected.value,
          "v-expansion-panel-title--focusable": e.focusable,
          "v-expansion-panel-title--static": e.static
        }, l.value, e.class],
        style: [a.value, r.value, e.style],
        type: "button",
        tabindex: i.disabled.value ? -1 : void 0,
        disabled: i.disabled.value,
        "aria-expanded": i.isSelected.value,
        onClick: e.readonly ? void 0 : i.toggle
      }, [m("span", {
        class: "v-expansion-panel-title__overlay"
      }, null), (u = n.default) == null ? void 0 : u.call(n, s.value), !e.hideActions && m(Te, {
        defaults: {
          VIcon: {
            icon: o.value
          }
        }
      }, {
        default: () => {
          var c;
          return [m("span", {
            class: "v-expansion-panel-title__icon"
          }, [((c = n.actions) == null ? void 0 : c.call(n, s.value)) ?? m(ze, null, null)])];
        }
      })]), [[Pn("ripple"), e.ripple]]);
    }), {};
  }
}), X5 = B({
  title: String,
  text: String,
  bgColor: String,
  ...Lt(),
  ...Jl(),
  ...at(),
  ...Ve(),
  ...j5(),
  ...H5()
}, "VExpansionPanel"), Sw = X()({
  name: "VExpansionPanel",
  props: X5(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = ea(e, Dr), {
      backgroundColorClasses: l,
      backgroundColorStyles: a
    } = Fe(e, "bgColor"), {
      elevationClasses: r
    } = Et(e), {
      roundedClasses: s
    } = gt(e), o = C(() => (i == null ? void 0 : i.disabled.value) || e.disabled), u = C(() => i.group.items.value.reduce((f, h, g) => (i.group.selected.value.includes(h.id) && f.push(g), f), [])), c = C(() => {
      const f = i.group.items.value.findIndex((h) => h.id === i.id);
      return !i.isSelected.value && u.value.some((h) => h - f === 1);
    }), d = C(() => {
      const f = i.group.items.value.findIndex((h) => h.id === i.id);
      return !i.isSelected.value && u.value.some((h) => h - f === -1);
    });
    return lt(Dr, i), F(() => {
      const f = !!(n.text || e.text), h = !!(n.title || e.title), g = Z1.filterProps(e), v = R1.filterProps(e);
      return m(e.tag, {
        class: ["v-expansion-panel", {
          "v-expansion-panel--active": i.isSelected.value,
          "v-expansion-panel--before-active": c.value,
          "v-expansion-panel--after-active": d.value,
          "v-expansion-panel--disabled": o.value
        }, s.value, l.value, e.class],
        style: [a.value, e.style]
      }, {
        default: () => [m("div", {
          class: ["v-expansion-panel__shadow", ...r.value]
        }, null), m(Te, {
          defaults: {
            VExpansionPanelTitle: {
              ...g
            },
            VExpansionPanelText: {
              ...v
            }
          }
        }, {
          default: () => {
            var p;
            return [h && m(Z1, {
              key: "title"
            }, {
              default: () => [n.title ? n.title() : e.title]
            }), f && m(R1, {
              key: "text"
            }, {
              default: () => [n.text ? n.text() : e.text]
            }), (p = n.default) == null ? void 0 : p.call(n)];
          }
        })]
      });
    }), {
      groupItem: i
    };
  }
}), ww = ["default", "accordion", "inset", "popout"], kw = B({
  flat: Boolean,
  ...Kl(),
  ...rf(X5(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"]),
  ...Ie(),
  ...ue(),
  ...Ve(),
  variant: {
    type: String,
    default: "default",
    validator: (e) => ww.includes(e)
  }
}, "VExpansionPanels"), xw = X()({
  name: "VExpansionPanels",
  props: kw(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      next: i,
      prev: l
    } = ul(e, Dr), {
      themeClasses: a
    } = Xe(e), r = C(() => e.variant && `v-expansion-panels--variant-${e.variant}`);
    return ht({
      VExpansionPanel: {
        bgColor: H(e, "bgColor"),
        collapseIcon: H(e, "collapseIcon"),
        color: H(e, "color"),
        eager: H(e, "eager"),
        elevation: H(e, "elevation"),
        expandIcon: H(e, "expandIcon"),
        focusable: H(e, "focusable"),
        hideActions: H(e, "hideActions"),
        readonly: H(e, "readonly"),
        ripple: H(e, "ripple"),
        rounded: H(e, "rounded"),
        static: H(e, "static")
      }
    }), F(() => m(e.tag, {
      class: ["v-expansion-panels", {
        "v-expansion-panels--flat": e.flat,
        "v-expansion-panels--tile": e.tile
      }, a.value, r.value, e.class],
      style: e.style
    }, {
      default: () => {
        var s;
        return [(s = n.default) == null ? void 0 : s.call(n, {
          prev: l,
          next: i
        })];
      }
    })), {
      next: i,
      prev: l
    };
  }
}), Pw = B({
  app: Boolean,
  appear: Boolean,
  extended: Boolean,
  layout: Boolean,
  offset: Boolean,
  modelValue: {
    type: Boolean,
    default: !0
  },
  ...St(xu({
    active: !0
  }), ["location"]),
  ...Yl(),
  ..._i(),
  ...Gn({
    transition: "fab-transition"
  })
}, "VFab"), $w = X()({
  name: "VFab",
  props: Pw(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), l = ie(56), a = z(), {
      resizeRef: r
    } = Yn((d) => {
      d.length && (l.value = d[0].target.clientHeight);
    }), s = C(() => e.app || e.absolute), o = C(() => {
      var d;
      return s.value ? ((d = e.location) == null ? void 0 : d.split(" ").shift()) ?? "bottom" : !1;
    }), u = C(() => {
      var d;
      return s.value ? ((d = e.location) == null ? void 0 : d.split(" ")[1]) ?? "end" : !1;
    });
    un(() => e.app, () => {
      const d = Fl({
        id: e.name,
        order: C(() => parseInt(e.order, 10)),
        position: o,
        layoutSize: C(() => e.layout ? l.value + 24 : 0),
        elementSize: C(() => l.value + 24),
        active: C(() => e.app && i.value),
        absolute: H(e, "absolute")
      });
      ft(() => {
        a.value = d.layoutItemStyles.value;
      });
    });
    const c = z();
    return F(() => {
      const d = je.filterProps(e);
      return m("div", {
        ref: c,
        class: ["v-fab", {
          "v-fab--absolute": e.absolute,
          "v-fab--app": !!e.app,
          "v-fab--extended": e.extended,
          "v-fab--offset": e.offset,
          [`v-fab--${o.value}`]: s.value,
          [`v-fab--${u.value}`]: s.value
        }, e.class],
        style: [e.app ? {
          ...a.value
        } : {
          height: "inherit",
          width: void 0
        }, e.style]
      }, [m("div", {
        class: "v-fab__container"
      }, [m(en, {
        appear: e.appear,
        transition: e.transition
      }, {
        default: () => [Je(m(je, q({
          ref: r
        }, d, {
          active: void 0,
          location: void 0
        }), n), [[xn, e.active]])]
      })])]);
    }), {};
  }
}), Vw = B({
  chips: Boolean,
  counter: Boolean,
  counterSizeString: {
    type: String,
    default: "$vuetify.fileInput.counterSize"
  },
  counterString: {
    type: String,
    default: "$vuetify.fileInput.counter"
  },
  hideInput: Boolean,
  multiple: Boolean,
  showSize: {
    type: [Boolean, Number, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || [1e3, 1024].includes(Number(e))
  },
  ...Ri({
    prependIcon: "$file"
  }),
  modelValue: {
    type: [Array, Object],
    default: (e) => e.multiple ? [] : null,
    validator: (e) => ut(e).every((t) => t != null && typeof t == "object")
  },
  ...hs({
    clearable: !0
  })
}, "VFileInput"), Qw = X()({
  name: "VFileInput",
  inheritAttrs: !1,
  props: Vw(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: l
    } = t;
    const {
      t: a
    } = pt(), r = pe(e, "modelValue", e.modelValue, (y) => ut(y), (y) => !e.multiple && Array.isArray(y) ? y[0] : y), {
      isFocused: s,
      focus: o,
      blur: u
    } = Ai(e), c = C(() => typeof e.showSize != "boolean" ? e.showSize : void 0), d = C(() => (r.value ?? []).reduce((y, L) => {
      let {
        size: k = 0
      } = L;
      return y + k;
    }, 0)), f = C(() => s2(d.value, c.value)), h = C(() => (r.value ?? []).map((y) => {
      const {
        name: L = "",
        size: k = 0
      } = y;
      return e.showSize ? `${L} (${s2(k, c.value)})` : L;
    })), g = C(() => {
      var L;
      const y = ((L = r.value) == null ? void 0 : L.length) ?? 0;
      return e.showSize ? a(e.counterSizeString, y, f.value) : a(e.counterString, y);
    }), v = z(), p = z(), O = z(), b = C(() => s.value || e.active), V = C(() => ["plain", "underlined"].includes(e.variant));
    function $() {
      var y;
      O.value !== document.activeElement && ((y = O.value) == null || y.focus()), s.value || o();
    }
    function x(y) {
      var L;
      (L = O.value) == null || L.click();
    }
    function Q(y) {
      i("mousedown:control", y);
    }
    function M(y) {
      var L;
      (L = O.value) == null || L.click(), i("click:control", y);
    }
    function w(y) {
      y.stopPropagation(), $(), He(() => {
        r.value = [], of(e["onClick:clear"], y);
      });
    }
    return ee(r, (y) => {
      (!Array.isArray(y) || !y.length) && O.value && (O.value.value = "");
    }), F(() => {
      const y = !!(l.counter || e.counter), L = !!(y || l.details), [k, S] = sl(n), {
        modelValue: P,
        ...T
      } = Ft.filterProps(e), _ = Af(e);
      return m(Ft, q({
        ref: v,
        modelValue: r.value,
        "onUpdate:modelValue": (D) => r.value = D,
        class: ["v-file-input", {
          "v-file-input--chips": !!e.chips,
          "v-file-input--hide": e.hideInput,
          "v-input--plain-underlined": V.value
        }, e.class],
        style: e.style,
        "onClick:prepend": x
      }, k, T, {
        centerAffix: !V.value,
        focused: s.value
      }), {
        ...l,
        default: (D) => {
          let {
            id: N,
            isDisabled: K,
            isDirty: E,
            isReadonly: I,
            isValid: Z
          } = D;
          return m(Ua, q({
            ref: p,
            "prepend-icon": e.prependIcon,
            onMousedown: Q,
            onClick: M,
            "onClick:clear": w,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, _, {
            id: N.value,
            active: b.value || E.value,
            dirty: E.value || e.dirty,
            disabled: K.value,
            focused: s.value,
            error: Z.value === !1
          }), {
            ...l,
            default: (Y) => {
              var ye;
              let {
                props: {
                  class: ce,
                  ...de
                }
              } = Y;
              return m(le, null, [m("input", q({
                ref: O,
                type: "file",
                readonly: I.value,
                disabled: K.value,
                multiple: e.multiple,
                name: e.name,
                onClick: (U) => {
                  U.stopPropagation(), I.value && U.preventDefault(), $();
                },
                onChange: (U) => {
                  if (!U.target) return;
                  const ge = U.target;
                  r.value = [...ge.files ?? []];
                },
                onFocus: $,
                onBlur: u
              }, de, S), null), m("div", {
                class: ce
              }, [!!((ye = r.value) != null && ye.length) && !e.hideInput && (l.selection ? l.selection({
                fileNames: h.value,
                totalBytes: d.value,
                totalBytesReadable: f.value
              }) : e.chips ? h.value.map((U) => m(Wa, {
                key: U,
                size: "small",
                text: U
              }, null)) : h.value.join(", "))])]);
            }
          });
        },
        details: L ? (D) => {
          var N, K;
          return m(le, null, [(N = l.details) == null ? void 0 : N.call(l, D), y && m(le, null, [m("span", null, null), m(Qu, {
            active: !!((K = r.value) != null && K.length),
            value: g.value,
            disabled: e.disabled
          }, l.counter)])]);
        } : void 0
      });
    }), Bn({}, v, p, O);
  }
}), Lw = B({
  app: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...yn(),
  ...ue(),
  ...Lt(),
  ...Yl(),
  ...at(),
  ...Ve({
    tag: "footer"
  }),
  ...Ie()
}, "VFooter"), Mw = X()({
  name: "VFooter",
  props: Lw(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = z(), {
      themeClasses: l
    } = Xe(e), {
      backgroundColorClasses: a,
      backgroundColorStyles: r
    } = Fe(H(e, "color")), {
      borderClasses: s
    } = Qn(e), {
      elevationClasses: o
    } = Et(e), {
      roundedClasses: u
    } = gt(e), c = ie(32), {
      resizeRef: d
    } = Yn((h) => {
      h.length && (c.value = h[0].target.clientHeight);
    }), f = C(() => e.height === "auto" ? c.value : parseInt(e.height, 10));
    return un(() => e.app, () => {
      const h = Fl({
        id: e.name,
        order: C(() => parseInt(e.order, 10)),
        position: C(() => "bottom"),
        layoutSize: f,
        elementSize: C(() => e.height === "auto" ? void 0 : f.value),
        active: C(() => e.app),
        absolute: H(e, "absolute")
      });
      ft(() => {
        i.value = h.layoutItemStyles.value;
      });
    }), F(() => m(e.tag, {
      ref: d,
      class: ["v-footer", l.value, a.value, s.value, o.value, u.value, e.class],
      style: [r.value, e.app ? i.value : {
        height: se(e.height)
      }, e.style]
    }, n)), {};
  }
}), Tw = B({
  ...ue(),
  ...fb()
}, "VForm"), _w = X()({
  name: "VForm",
  props: Tw(),
  emits: {
    "update:modelValue": (e) => !0,
    submit: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const l = hb(e), a = z();
    function r(o) {
      o.preventDefault(), l.reset();
    }
    function s(o) {
      const u = o, c = l.validate();
      u.then = c.then.bind(c), u.catch = c.catch.bind(c), u.finally = c.finally.bind(c), i("submit", u), u.defaultPrevented || c.then((d) => {
        var h;
        let {
          valid: f
        } = d;
        f && ((h = a.value) == null || h.submit());
      }), u.preventDefault();
    }
    return F(() => {
      var o;
      return m("form", {
        ref: a,
        class: ["v-form", e.class],
        style: e.style,
        novalidate: !0,
        onReset: r,
        onSubmit: s
      }, [(o = n.default) == null ? void 0 : o.call(n, l)]);
    }), Bn(l, a);
  }
}), Aw = B({
  disabled: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  ...yf()
}, "VHover"), Rw = X()({
  name: "VHover",
  props: Aw(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), {
      runOpenDelay: l,
      runCloseDelay: a
    } = bf(e, (r) => !e.disabled && (i.value = r));
    return () => {
      var r;
      return (r = n.default) == null ? void 0 : r.call(n, {
        isHovering: i.value,
        props: {
          onMouseenter: l,
          onMouseleave: a
        }
      });
    };
  }
}), Zw = B({
  color: String,
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  side: {
    type: String,
    default: "end",
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  mode: {
    type: String,
    default: "intersect",
    validator: (e) => ["intersect", "manual"].includes(e)
  },
  margin: [Number, String],
  loadMoreText: {
    type: String,
    default: "$vuetify.infiniteScroll.loadMore"
  },
  emptyText: {
    type: String,
    default: "$vuetify.infiniteScroll.empty"
  },
  ...wt(),
  ...Ve()
}, "VInfiniteScroll"), U2 = $n({
  name: "VInfiniteScrollIntersect",
  props: {
    side: {
      type: String,
      required: !0
    },
    rootMargin: String
  },
  emits: {
    intersect: (e, t) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const {
      intersectionRef: i,
      isIntersecting: l
    } = Su();
    return ee(l, async (a) => {
      n("intersect", e.side, a);
    }), F(() => m("div", {
      class: "v-infinite-scroll-intersect",
      style: {
        "--v-infinite-margin-size": e.rootMargin
      },
      ref: i
    }, [ke("")])), {};
  }
}), Iw = X()({
  name: "VInfiniteScroll",
  props: Zw(),
  emits: {
    load: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const l = z(), a = ie("ok"), r = ie("ok"), s = C(() => se(e.margin)), o = ie(!1);
    function u(x) {
      if (!l.value) return;
      const Q = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      l.value[Q] = x;
    }
    function c() {
      if (!l.value) return 0;
      const x = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      return l.value[x];
    }
    function d() {
      if (!l.value) return 0;
      const x = e.direction === "vertical" ? "scrollHeight" : "scrollWidth";
      return l.value[x];
    }
    function f() {
      if (!l.value) return 0;
      const x = e.direction === "vertical" ? "clientHeight" : "clientWidth";
      return l.value[x];
    }
    it(() => {
      l.value && (e.side === "start" ? u(d()) : e.side === "both" && u(d() / 2 - f() / 2));
    });
    function h(x, Q) {
      x === "start" ? a.value = Q : x === "end" && (r.value = Q);
    }
    function g(x) {
      return x === "start" ? a.value : r.value;
    }
    let v = 0;
    function p(x, Q) {
      o.value = Q, o.value && O(x);
    }
    function O(x) {
      if (e.mode !== "manual" && !o.value) return;
      const Q = g(x);
      if (!l.value || ["empty", "loading"].includes(Q)) return;
      v = d(), h(x, "loading");
      function M(w) {
        h(x, w), He(() => {
          w === "empty" || w === "error" || (w === "ok" && x === "start" && u(d() - v + c()), e.mode !== "manual" && He(() => {
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(() => {
                window.requestAnimationFrame(() => {
                  O(x);
                });
              });
            });
          }));
        });
      }
      i("load", {
        side: x,
        done: M
      });
    }
    const {
      t: b
    } = pt();
    function V(x, Q) {
      var y, L, k, S, P;
      if (e.side !== x && e.side !== "both") return;
      const M = () => O(x), w = {
        side: x,
        props: {
          onClick: M,
          color: e.color
        }
      };
      return Q === "error" ? (y = n.error) == null ? void 0 : y.call(n, w) : Q === "empty" ? ((L = n.empty) == null ? void 0 : L.call(n, w)) ?? m("div", null, [b(e.emptyText)]) : e.mode === "manual" ? Q === "loading" ? ((k = n.loading) == null ? void 0 : k.call(n, w)) ?? m(Qa, {
        indeterminate: !0,
        color: e.color
      }, null) : ((S = n["load-more"]) == null ? void 0 : S.call(n, w)) ?? m(je, {
        variant: "outlined",
        color: e.color,
        onClick: M
      }, {
        default: () => [b(e.loadMoreText)]
      }) : ((P = n.loading) == null ? void 0 : P.call(n, w)) ?? m(Qa, {
        indeterminate: !0,
        color: e.color
      }, null);
    }
    const {
      dimensionStyles: $
    } = kt(e);
    F(() => {
      const x = e.tag, Q = e.side === "start" || e.side === "both", M = e.side === "end" || e.side === "both", w = e.mode === "intersect";
      return m(x, {
        ref: l,
        class: ["v-infinite-scroll", `v-infinite-scroll--${e.direction}`, {
          "v-infinite-scroll--start": Q,
          "v-infinite-scroll--end": M
        }],
        style: $.value
      }, {
        default: () => {
          var y;
          return [m("div", {
            class: "v-infinite-scroll__side"
          }, [V("start", a.value)]), Q && w && m(U2, {
            key: "start",
            side: "start",
            onIntersect: p,
            rootMargin: s.value
          }, null), (y = n.default) == null ? void 0 : y.call(n), M && w && m(U2, {
            key: "end",
            side: "end",
            onIntersect: p,
            rootMargin: s.value
          }, null), m("div", {
            class: "v-infinite-scroll__side"
          }, [V("end", r.value)])];
        }
      });
    });
  }
}), N5 = Symbol.for("vuetify:v-item-group"), Dw = B({
  ...ue(),
  ...Kl({
    selectedClass: "v-item--selected"
  }),
  ...Ve(),
  ...Ie()
}, "VItemGroup"), Bw = X()({
  name: "VItemGroup",
  props: Dw(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e), {
      isSelected: l,
      select: a,
      next: r,
      prev: s,
      selected: o
    } = ul(e, N5);
    return () => m(e.tag, {
      class: ["v-item-group", i.value, e.class],
      style: e.style
    }, {
      default: () => {
        var u;
        return [(u = n.default) == null ? void 0 : u.call(n, {
          isSelected: l,
          select: a,
          next: r,
          prev: s,
          selected: o.value
        })];
      }
    });
  }
}), Ew = X()({
  name: "VItem",
  props: Jl(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: i,
      select: l,
      toggle: a,
      selectedClass: r,
      value: s,
      disabled: o
    } = ea(e, N5);
    return () => {
      var u;
      return (u = n.default) == null ? void 0 : u.call(n, {
        isSelected: i.value,
        selectedClass: r.value,
        select: l,
        toggle: a,
        value: s.value,
        disabled: o.value
      });
    };
  }
}), zw = Oi("v-kbd"), Hw = B({
  ...ue(),
  ...wt(),
  ...Lg()
}, "VLayout"), jw = X()({
  name: "VLayout",
  props: Hw(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutClasses: i,
      layoutStyles: l,
      getLayoutItem: a,
      items: r,
      layoutRef: s
    } = Tg(e), {
      dimensionStyles: o
    } = kt(e);
    return F(() => {
      var u;
      return m("div", {
        ref: s,
        class: [i.value, e.class],
        style: [o.value, l.value, e.style]
      }, [(u = n.default) == null ? void 0 : u.call(n)]);
    }), {
      getLayoutItem: a,
      items: r
    };
  }
}), Xw = B({
  position: {
    type: String,
    required: !0
  },
  size: {
    type: [Number, String],
    default: 300
  },
  modelValue: Boolean,
  ...ue(),
  ...Yl()
}, "VLayoutItem"), Nw = X()({
  name: "VLayoutItem",
  props: Xw(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutItemStyles: i
    } = Fl({
      id: e.name,
      order: C(() => parseInt(e.order, 10)),
      position: H(e, "position"),
      elementSize: H(e, "size"),
      layoutSize: H(e, "size"),
      active: H(e, "modelValue"),
      absolute: H(e, "absolute")
    });
    return () => {
      var l;
      return m("div", {
        class: ["v-layout-item", e.class],
        style: [i.value, e.style]
      }, [(l = n.default) == null ? void 0 : l.call(n)]);
    };
  }
}), qw = B({
  modelValue: Boolean,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  ...ue(),
  ...wt(),
  ...Ve(),
  ...Gn({
    transition: "fade-transition"
  })
}, "VLazy"), Yw = X()({
  name: "VLazy",
  directives: {
    intersect: as
  },
  props: qw(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = kt(e), l = pe(e, "modelValue");
    function a(r) {
      l.value || (l.value = r);
    }
    return F(() => Je(m(e.tag, {
      class: ["v-lazy", e.class],
      style: [i.value, e.style]
    }, {
      default: () => [l.value && m(en, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => {
          var r;
          return [(r = n.default) == null ? void 0 : r.call(n)];
        }
      })]
    }), [[Pn("intersect"), {
      handler: a,
      options: e.options
    }, null]])), {};
  }
}), Fw = B({
  locale: String,
  fallbackLocale: String,
  messages: Object,
  rtl: {
    type: Boolean,
    default: void 0
  },
  ...ue()
}, "VLocaleProvider"), Ww = X()({
  name: "VLocaleProvider",
  props: Fw(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: i
    } = kp(e);
    return F(() => {
      var l;
      return m("div", {
        class: ["v-locale-provider", i.value, e.class],
        style: e.style
      }, [(l = n.default) == null ? void 0 : l.call(n)]);
    }), {};
  }
}), Uw = B({
  scrollable: Boolean,
  ...ue(),
  ...wt(),
  ...Ve({
    tag: "main"
  })
}, "VMain"), Gw = X()({
  name: "VMain",
  props: Uw(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = kt(e), {
      mainStyles: l
    } = Mg(), {
      ssrBootStyles: a
    } = Ul();
    return F(() => m(e.tag, {
      class: ["v-main", {
        "v-main--scrollable": e.scrollable
      }, e.class],
      style: [l.value, a.value, i.value, e.style]
    }, {
      default: () => {
        var r, s;
        return [e.scrollable ? m("div", {
          class: "v-main__scroller"
        }, [(r = n.default) == null ? void 0 : r.call(n)]) : (s = n.default) == null ? void 0 : s.call(n)];
      }
    })), {};
  }
});
function Kw(e) {
  let {
    rootEl: t,
    isSticky: n,
    layoutItemStyles: i
  } = e;
  const l = ie(!1), a = ie(0), r = C(() => {
    const u = typeof l.value == "boolean" ? "top" : l.value;
    return [n.value ? {
      top: "auto",
      bottom: "auto",
      height: void 0
    } : void 0, l.value ? {
      [u]: se(a.value)
    } : {
      top: i.value.top
    }];
  });
  it(() => {
    ee(n, (u) => {
      u ? window.addEventListener("scroll", o, {
        passive: !0
      }) : window.removeEventListener("scroll", o);
    }, {
      immediate: !0
    });
  }), Wt(() => {
    window.removeEventListener("scroll", o);
  });
  let s = 0;
  function o() {
    const u = s > window.scrollY ? "up" : "down", c = t.value.getBoundingClientRect(), d = parseFloat(i.value.top ?? 0), f = window.scrollY - Math.max(0, a.value - d), h = c.height + Math.max(a.value, d) - window.scrollY - window.innerHeight, g = parseFloat(getComputedStyle(t.value).getPropertyValue("--v-body-scroll-y")) || 0;
    c.height < window.innerHeight - d ? (l.value = "top", a.value = d) : u === "up" && l.value === "bottom" || u === "down" && l.value === "top" ? (a.value = window.scrollY + c.top - g, l.value = !0) : u === "down" && h <= 0 ? (a.value = 0, l.value = "bottom") : u === "up" && f <= 0 && (g ? l.value !== "top" && (a.value = -f + g + d, l.value = "top") : (a.value = c.top + f, l.value = "top")), s = window.scrollY;
  }
  return {
    isStuck: l,
    stickyStyles: r
  };
}
const Jw = 100, ek = 20;
function G2(e) {
  return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * 1.41421356237;
}
function K2(e) {
  if (e.length < 2)
    return 0;
  if (e.length === 2)
    return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t);
  let t = 0;
  for (let n = e.length - 1; n > 0; n--) {
    if (e[n].t === e[n - 1].t)
      continue;
    const i = G2(t), l = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t);
    t += (l - i) * Math.abs(l), n === e.length - 1 && (t *= 0.5);
  }
  return G2(t) * 1e3;
}
function tk() {
  const e = {};
  function t(l) {
    Array.from(l.changedTouches).forEach((a) => {
      (e[a.identifier] ?? (e[a.identifier] = new D7(ek))).push([l.timeStamp, a]);
    });
  }
  function n(l) {
    Array.from(l.changedTouches).forEach((a) => {
      delete e[a.identifier];
    });
  }
  function i(l) {
    var u;
    const a = (u = e[l]) == null ? void 0 : u.values().reverse();
    if (!a)
      throw new Error(`No samples for touch id ${l}`);
    const r = a[0], s = [], o = [];
    for (const c of a) {
      if (r[0] - c[0] > Jw) break;
      s.push({
        t: c[0],
        d: c[1].clientX
      }), o.push({
        t: c[0],
        d: c[1].clientY
      });
    }
    return {
      x: K2(s),
      y: K2(o),
      get direction() {
        const {
          x: c,
          y: d
        } = this, [f, h] = [Math.abs(c), Math.abs(d)];
        return f > h && c >= 0 ? "right" : f > h && c <= 0 ? "left" : h > f && d >= 0 ? "down" : h > f && d <= 0 ? "up" : nk();
      }
    };
  }
  return {
    addMovement: t,
    endTouch: n,
    getVelocity: i
  };
}
function nk() {
  throw new Error();
}
function ik(e) {
  let {
    el: t,
    isActive: n,
    isTemporary: i,
    width: l,
    touchless: a,
    position: r
  } = e;
  it(() => {
    window.addEventListener("touchstart", b, {
      passive: !0
    }), window.addEventListener("touchmove", V, {
      passive: !1
    }), window.addEventListener("touchend", $, {
      passive: !0
    });
  }), Wt(() => {
    window.removeEventListener("touchstart", b), window.removeEventListener("touchmove", V), window.removeEventListener("touchend", $);
  });
  const s = C(() => ["left", "right"].includes(r.value)), {
    addMovement: o,
    endTouch: u,
    getVelocity: c
  } = tk();
  let d = !1;
  const f = ie(!1), h = ie(0), g = ie(0);
  let v;
  function p(Q, M) {
    return (r.value === "left" ? Q : r.value === "right" ? document.documentElement.clientWidth - Q : r.value === "top" ? Q : r.value === "bottom" ? document.documentElement.clientHeight - Q : sa()) - (M ? l.value : 0);
  }
  function O(Q) {
    let M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const w = r.value === "left" ? (Q - g.value) / l.value : r.value === "right" ? (document.documentElement.clientWidth - Q - g.value) / l.value : r.value === "top" ? (Q - g.value) / l.value : r.value === "bottom" ? (document.documentElement.clientHeight - Q - g.value) / l.value : sa();
    return M ? Math.max(0, Math.min(1, w)) : w;
  }
  function b(Q) {
    if (a.value) return;
    const M = Q.changedTouches[0].clientX, w = Q.changedTouches[0].clientY, y = 25, L = r.value === "left" ? M < y : r.value === "right" ? M > document.documentElement.clientWidth - y : r.value === "top" ? w < y : r.value === "bottom" ? w > document.documentElement.clientHeight - y : sa(), k = n.value && (r.value === "left" ? M < l.value : r.value === "right" ? M > document.documentElement.clientWidth - l.value : r.value === "top" ? w < l.value : r.value === "bottom" ? w > document.documentElement.clientHeight - l.value : sa());
    (L || k || n.value && i.value) && (v = [M, w], g.value = p(s.value ? M : w, n.value), h.value = O(s.value ? M : w), d = g.value > -20 && g.value < 80, u(Q), o(Q));
  }
  function V(Q) {
    const M = Q.changedTouches[0].clientX, w = Q.changedTouches[0].clientY;
    if (d) {
      if (!Q.cancelable) {
        d = !1;
        return;
      }
      const L = Math.abs(M - v[0]), k = Math.abs(w - v[1]);
      (s.value ? L > k && L > 3 : k > L && k > 3) ? (f.value = !0, d = !1) : (s.value ? k : L) > 3 && (d = !1);
    }
    if (!f.value) return;
    Q.preventDefault(), o(Q);
    const y = O(s.value ? M : w, !1);
    h.value = Math.max(0, Math.min(1, y)), y > 1 ? g.value = p(s.value ? M : w, !0) : y < 0 && (g.value = p(s.value ? M : w, !1));
  }
  function $(Q) {
    if (d = !1, !f.value) return;
    o(Q), f.value = !1;
    const M = c(Q.changedTouches[0].identifier), w = Math.abs(M.x), y = Math.abs(M.y);
    (s.value ? w > y && w > 400 : y > w && y > 3) ? n.value = M.direction === ({
      left: "right",
      right: "left",
      top: "down",
      bottom: "up"
    }[r.value] || sa()) : n.value = h.value > 0.5;
  }
  const x = C(() => f.value ? {
    transform: r.value === "left" ? `translateX(calc(-100% + ${h.value * l.value}px))` : r.value === "right" ? `translateX(calc(100% - ${h.value * l.value}px))` : r.value === "top" ? `translateY(calc(-100% + ${h.value * l.value}px))` : r.value === "bottom" ? `translateY(calc(100% - ${h.value * l.value}px))` : sa(),
    transition: "none"
  } : void 0);
  return un(f, () => {
    var w, y;
    const Q = ((w = t.value) == null ? void 0 : w.style.transform) ?? null, M = ((y = t.value) == null ? void 0 : y.style.transition) ?? null;
    ft(() => {
      var L, k, S, P;
      (k = t.value) == null || k.style.setProperty("transform", ((L = x.value) == null ? void 0 : L.transform) || "none"), (P = t.value) == null || P.style.setProperty("transition", ((S = x.value) == null ? void 0 : S.transition) || null);
    }), tn(() => {
      var L, k;
      (L = t.value) == null || L.style.setProperty("transform", Q), (k = t.value) == null || k.style.setProperty("transition", M);
    });
  }), {
    isDragging: f,
    dragProgress: h,
    dragStyles: x
  };
}
function sa() {
  throw new Error();
}
const lk = ["start", "end", "left", "right", "top", "bottom"], ak = B({
  color: String,
  disableResizeWatcher: Boolean,
  disableRouteWatcher: Boolean,
  expandOnHover: Boolean,
  floating: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  permanent: Boolean,
  rail: {
    type: Boolean,
    default: null
  },
  railWidth: {
    type: [Number, String],
    default: 56
  },
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  image: String,
  temporary: Boolean,
  persistent: Boolean,
  touchless: Boolean,
  width: {
    type: [Number, String],
    default: 256
  },
  location: {
    type: String,
    default: "start",
    validator: (e) => lk.includes(e)
  },
  sticky: Boolean,
  ...yn(),
  ...ue(),
  ...yf(),
  ...ql({
    mobile: null
  }),
  ...Lt(),
  ...Yl(),
  ...at(),
  ...Ve({
    tag: "nav"
  }),
  ...Ie()
}, "VNavigationDrawer"), rk = X()({
  name: "VNavigationDrawer",
  props: ak(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:rail": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: l
    } = t;
    const {
      isRtl: a
    } = Qt(), {
      themeClasses: r
    } = Xe(e), {
      borderClasses: s
    } = Qn(e), {
      backgroundColorClasses: o,
      backgroundColorStyles: u
    } = Fe(H(e, "color")), {
      elevationClasses: c
    } = Et(e), {
      displayClasses: d,
      mobile: f
    } = Dn(e), {
      roundedClasses: h
    } = gt(e), g = Jg(), v = pe(e, "modelValue", null, (Z) => !!Z), {
      ssrBootStyles: p
    } = Ul(), {
      scopeId: O
    } = Wl(), b = z(), V = ie(!1), {
      runOpenDelay: $,
      runCloseDelay: x
    } = bf(e, (Z) => {
      V.value = Z;
    }), Q = C(() => e.rail && e.expandOnHover && V.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width)), M = C(() => a1(e.location, a.value)), w = C(() => e.persistent), y = C(() => !e.permanent && (f.value || e.temporary)), L = C(() => e.sticky && !y.value && M.value !== "bottom");
    un(() => e.expandOnHover && e.rail != null, () => {
      ee(V, (Z) => i("update:rail", !Z));
    }), un(() => !e.disableResizeWatcher, () => {
      ee(y, (Z) => !e.permanent && He(() => v.value = !Z));
    }), un(() => !e.disableRouteWatcher && !!g, () => {
      ee(g.currentRoute, () => y.value && (v.value = !1));
    }), ee(() => e.permanent, (Z) => {
      Z && (v.value = !0);
    }), e.modelValue == null && !y.value && (v.value = e.permanent || !f.value);
    const {
      isDragging: k,
      dragProgress: S
    } = ik({
      el: b,
      isActive: v,
      isTemporary: y,
      width: Q,
      touchless: H(e, "touchless"),
      position: M
    }), P = C(() => {
      const Z = y.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : Q.value;
      return k.value ? Z * S.value : Z;
    }), T = C(() => ["top", "bottom"].includes(e.location) ? 0 : Q.value), {
      layoutItemStyles: _,
      layoutItemScrimStyles: D
    } = Fl({
      id: e.name,
      order: C(() => parseInt(e.order, 10)),
      position: M,
      layoutSize: P,
      elementSize: T,
      active: C(() => v.value || k.value),
      disableTransitions: C(() => k.value),
      absolute: C(() => (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        e.absolute || L.value && typeof N.value != "string"
      ))
    }), {
      isStuck: N,
      stickyStyles: K
    } = Kw({
      rootEl: b,
      isSticky: L,
      layoutItemStyles: _
    }), E = Fe(C(() => typeof e.scrim == "string" ? e.scrim : null)), I = C(() => ({
      ...k.value ? {
        opacity: S.value * 0.2,
        transition: "none"
      } : void 0,
      ...D.value
    }));
    return ht({
      VList: {
        bgColor: "transparent"
      }
    }), F(() => {
      const Z = l.image || e.image;
      return m(le, null, [m(e.tag, q({
        ref: b,
        onMouseenter: $,
        onMouseleave: x,
        class: ["v-navigation-drawer", `v-navigation-drawer--${M.value}`, {
          "v-navigation-drawer--expand-on-hover": e.expandOnHover,
          "v-navigation-drawer--floating": e.floating,
          "v-navigation-drawer--is-hovering": V.value,
          "v-navigation-drawer--rail": e.rail,
          "v-navigation-drawer--temporary": y.value,
          "v-navigation-drawer--persistent": w.value,
          "v-navigation-drawer--active": v.value,
          "v-navigation-drawer--sticky": L.value
        }, r.value, o.value, s.value, d.value, c.value, h.value, e.class],
        style: [u.value, _.value, p.value, K.value, e.style, ["top", "bottom"].includes(M.value) ? {
          height: "auto"
        } : {}]
      }, O, n), {
        default: () => {
          var Y, ce, de;
          return [Z && m("div", {
            key: "image",
            class: "v-navigation-drawer__img"
          }, [l.image ? m(Te, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                alt: "",
                cover: !0,
                height: "inherit",
                src: e.image
              }
            }
          }, l.image) : m($i, {
            key: "image-img",
            alt: "",
            cover: !0,
            height: "inherit",
            src: e.image
          }, null)]), l.prepend && m("div", {
            class: "v-navigation-drawer__prepend"
          }, [(Y = l.prepend) == null ? void 0 : Y.call(l)]), m("div", {
            class: "v-navigation-drawer__content"
          }, [(ce = l.default) == null ? void 0 : ce.call(l)]), l.append && m("div", {
            class: "v-navigation-drawer__append"
          }, [(de = l.append) == null ? void 0 : de.call(l)])];
        }
      }), m(Ui, {
        name: "fade-transition"
      }, {
        default: () => [y.value && (k.value || v.value) && !!e.scrim && m("div", q({
          class: ["v-navigation-drawer__scrim", E.backgroundColorClasses.value],
          style: [I.value, E.backgroundColorStyles.value],
          onClick: () => {
            w.value || (v.value = !1);
          }
        }, O), null)]
      })]);
    }), {
      isStuck: N
    };
  }
}), sk = $n({
  name: "VNoSsr",
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Kg();
    return () => {
      var l;
      return i.value && ((l = n.default) == null ? void 0 : l.call(n));
    };
  }
}), ok = B({
  autofocus: Boolean,
  divider: String,
  focusAll: Boolean,
  label: {
    type: String,
    default: "$vuetify.input.otp"
  },
  length: {
    type: [Number, String],
    default: 6
  },
  modelValue: {
    type: [Number, String],
    default: void 0
  },
  placeholder: String,
  type: {
    type: String,
    default: "number"
  },
  ...wt(),
  ...ds(),
  ...hu(hs({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])
}, "VOtpInput"), uk = X()({
  name: "VOtpInput",
  props: ok(),
  emits: {
    finish: (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: l
    } = t;
    const {
      dimensionStyles: a
    } = kt(e), {
      isFocused: r,
      focus: s,
      blur: o
    } = Ai(e), u = pe(e, "modelValue", "", (w) => w == null ? [] : String(w).split(""), (w) => w.join("")), {
      t: c
    } = pt(), d = C(() => Number(e.length)), f = C(() => Array(d.value).fill(0)), h = z(-1), g = z(), v = z([]), p = C(() => v.value[h.value]);
    function O() {
      if (M(p.value.value)) {
        p.value.value = "";
        return;
      }
      const w = u.value.slice(), y = p.value.value;
      w[h.value] = y;
      let L = null;
      h.value > u.value.length ? L = u.value.length + 1 : h.value + 1 !== d.value && (L = "next"), u.value = w, L && Pl(g.value, L);
    }
    function b(w) {
      const y = u.value.slice(), L = h.value;
      let k = null;
      ["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(w.key) && (w.preventDefault(), w.key === "ArrowLeft" ? k = "prev" : w.key === "ArrowRight" ? k = "next" : ["Backspace", "Delete"].includes(w.key) && (y[h.value] = "", u.value = y, h.value > 0 && w.key === "Backspace" ? k = "prev" : requestAnimationFrame(() => {
        var S;
        (S = v.value[L]) == null || S.select();
      })), requestAnimationFrame(() => {
        k != null && Pl(g.value, k);
      }));
    }
    function V(w, y) {
      var k, S;
      y.preventDefault(), y.stopPropagation();
      const L = ((k = y == null ? void 0 : y.clipboardData) == null ? void 0 : k.getData("Text").slice(0, d.value)) ?? "";
      M(L) || (u.value = L.split(""), (S = v.value) == null || S[w].blur());
    }
    function $() {
      u.value = [];
    }
    function x(w, y) {
      s(), h.value = y;
    }
    function Q() {
      o(), h.value = -1;
    }
    function M(w) {
      return e.type === "number" && /[^0-9]/g.test(w);
    }
    return ht({
      VField: {
        color: C(() => e.color),
        bgColor: C(() => e.color),
        baseColor: C(() => e.baseColor),
        disabled: C(() => e.disabled),
        error: C(() => e.error),
        variant: C(() => e.variant)
      }
    }, {
      scoped: !0
    }), ee(u, (w) => {
      w.length === d.value && i("finish", w.join(""));
    }, {
      deep: !0
    }), ee(h, (w) => {
      w < 0 || He(() => {
        var y;
        (y = v.value[w]) == null || y.select();
      });
    }), F(() => {
      var L;
      const [w, y] = sl(n);
      return m("div", q({
        class: ["v-otp-input", {
          "v-otp-input--divided": !!e.divider
        }, e.class],
        style: [e.style]
      }, w), [m("div", {
        ref: g,
        class: "v-otp-input__content",
        style: [a.value]
      }, [f.value.map((k, S) => m(le, null, [e.divider && S !== 0 && m("span", {
        class: "v-otp-input__divider"
      }, [e.divider]), m(Ua, {
        focused: r.value && e.focusAll || h.value === S,
        key: S
      }, {
        ...l,
        loader: void 0,
        default: () => m("input", {
          ref: (P) => v.value[S] = P,
          "aria-label": c(e.label, S + 1),
          autofocus: S === 0 && e.autofocus,
          autocomplete: "one-time-code",
          class: ["v-otp-input__field"],
          disabled: e.disabled,
          inputmode: e.type === "number" ? "numeric" : "text",
          min: e.type === "number" ? 0 : void 0,
          maxlength: "1",
          placeholder: e.placeholder,
          type: e.type === "number" ? "text" : e.type,
          value: u.value[S],
          onInput: O,
          onFocus: (P) => x(P, S),
          onBlur: Q,
          onKeydown: b,
          onPaste: (P) => V(S, P)
        }, null)
      })])), m("input", q({
        class: "v-otp-input-input",
        type: "hidden"
      }, y, {
        value: u.value.join("")
      }), null), m(Fn, {
        contained: !0,
        "content-class": "v-otp-input__loader",
        "model-value": !!e.loading,
        persistent: !0
      }, {
        default: () => {
          var k;
          return [((k = l.loader) == null ? void 0 : k.call(l)) ?? m(Qa, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            size: "24",
            width: "2"
          }, null)];
        }
      }), (L = l.default) == null ? void 0 : L.call(l)])]);
    }), {
      blur: () => {
        var w;
        (w = v.value) == null || w.some((y) => y.blur());
      },
      focus: () => {
        var w;
        (w = v.value) == null || w[0].focus();
      },
      reset: $,
      isFocused: r
    };
  }
});
function ck(e) {
  return Math.floor(Math.abs(e)) * Math.sign(e);
}
const dk = B({
  scale: {
    type: [Number, String],
    default: 0.5
  },
  ...ue()
}, "VParallax"), fk = X()({
  name: "VParallax",
  props: dk(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      intersectionRef: i,
      isIntersecting: l
    } = Su(), {
      resizeRef: a,
      contentRect: r
    } = Yn(), {
      height: s
    } = Dn(), o = z();
    ft(() => {
      var h;
      i.value = a.value = (h = o.value) == null ? void 0 : h.$el;
    });
    let u;
    ee(l, (h) => {
      h ? (u = hf(i.value), u = u === document.scrollingElement ? document : u, u.addEventListener("scroll", f, {
        passive: !0
      }), f()) : u.removeEventListener("scroll", f);
    }), Wt(() => {
      u == null || u.removeEventListener("scroll", f);
    }), ee(s, f), ee(() => {
      var h;
      return (h = r.value) == null ? void 0 : h.height;
    }, f);
    const c = C(() => 1 - Ot(+e.scale));
    let d = -1;
    function f() {
      l.value && (cancelAnimationFrame(d), d = requestAnimationFrame(() => {
        var x;
        const h = ((x = o.value) == null ? void 0 : x.$el).querySelector(".v-img__img");
        if (!h) return;
        const g = u instanceof Document ? document.documentElement.clientHeight : u.clientHeight, v = u instanceof Document ? window.scrollY : u.scrollTop, p = i.value.getBoundingClientRect().top + v, O = r.value.height, b = p + (O - g) / 2, V = ck((v - b) * c.value), $ = Math.max(1, (c.value * (g - O) + O) / O);
        h.style.setProperty("transform", `translateY(${V}px) scale(${$})`);
      }));
    }
    return F(() => m($i, {
      class: ["v-parallax", {
        "v-parallax--active": l.value
      }, e.class],
      style: e.style,
      ref: o,
      cover: !0,
      onLoadstart: f,
      onLoad: f
    }, n)), {};
  }
}), hk = B({
  ...Pu({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })
}, "VRadio"), mk = X()({
  name: "VRadio",
  props: hk(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => {
      const i = Ki.filterProps(e);
      return m(Ki, q(i, {
        class: ["v-radio", e.class],
        style: e.style,
        type: "radio"
      }), n);
    }), {};
  }
}), gk = B({
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...Ri(),
  ...St(Qf(), ["multiple"]),
  trueIcon: {
    type: Se,
    default: "$radioOn"
  },
  falseIcon: {
    type: Se,
    default: "$radioOff"
  },
  type: {
    type: String,
    default: "radio"
  }
}, "VRadioGroup"), vk = X()({
  name: "VRadioGroup",
  inheritAttrs: !1,
  props: gk(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const l = Bt(), a = C(() => e.id || `radio-group-${l}`), r = pe(e, "modelValue");
    return F(() => {
      const [s, o] = sl(n), u = Ft.filterProps(e), c = Ki.filterProps(e), d = i.label ? i.label({
        label: e.label,
        props: {
          for: a.value
        }
      }) : e.label;
      return m(Ft, q({
        class: ["v-radio-group", e.class],
        style: e.style
      }, s, u, {
        modelValue: r.value,
        "onUpdate:modelValue": (f) => r.value = f,
        id: a.value
      }), {
        ...i,
        default: (f) => {
          let {
            id: h,
            messagesId: g,
            isDisabled: v,
            isReadonly: p
          } = f;
          return m(le, null, [d && m(Fa, {
            id: h.value
          }, {
            default: () => [d]
          }), m(d4, q(c, {
            id: h.value,
            "aria-describedby": g.value,
            defaultsTarget: "VRadio",
            trueIcon: e.trueIcon,
            falseIcon: e.falseIcon,
            type: e.type,
            disabled: v.value,
            readonly: p.value,
            "aria-labelledby": d ? h.value : void 0,
            multiple: !1
          }, o, {
            modelValue: r.value,
            "onUpdate:modelValue": (O) => r.value = O
          }), i)]);
        }
      });
    }), {};
  }
}), pk = B({
  ...ds(),
  ...Ri(),
  ...J4(),
  strict: Boolean,
  modelValue: {
    type: Array,
    default: () => [0, 0]
  }
}, "VRangeSlider"), Ok = X()({
  name: "VRangeSlider",
  props: pk(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    end: (e) => !0,
    start: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: i
    } = t;
    const l = z(), a = z(), r = z(), {
      rtlClasses: s
    } = Qt();
    function o(L) {
      if (!l.value || !a.value) return;
      const k = x1(L, l.value.$el, e.direction), S = x1(L, a.value.$el, e.direction), P = Math.abs(k), T = Math.abs(S);
      return P < T || P === T && k < 0 ? l.value.$el : a.value.$el;
    }
    const u = e5(e), c = pe(e, "modelValue", void 0, (L) => L != null && L.length ? L.map((k) => u.roundValue(k)) : [0, 0]), {
      activeThumbRef: d,
      hasLabels: f,
      max: h,
      min: g,
      mousePressed: v,
      onSliderMousedown: p,
      onSliderTouchstart: O,
      position: b,
      trackContainerRef: V,
      readonly: $
    } = t5({
      props: e,
      steps: u,
      onSliderStart: () => {
        i("start", c.value);
      },
      onSliderEnd: (L) => {
        var P;
        let {
          value: k
        } = L;
        const S = d.value === ((P = l.value) == null ? void 0 : P.$el) ? [k, c.value[1]] : [c.value[0], k];
        !e.strict && S[0] < S[1] && (c.value = S), i("end", c.value);
      },
      onSliderMove: (L) => {
        var T, _, D, N;
        let {
          value: k
        } = L;
        const [S, P] = c.value;
        !e.strict && S === P && S !== g.value && (d.value = k > S ? (T = a.value) == null ? void 0 : T.$el : (_ = l.value) == null ? void 0 : _.$el, (D = d.value) == null || D.focus()), d.value === ((N = l.value) == null ? void 0 : N.$el) ? c.value = [Math.min(k, P), P] : c.value = [S, Math.max(S, k)];
      },
      getActiveThumb: o
    }), {
      isFocused: x,
      focus: Q,
      blur: M
    } = Ai(e), w = C(() => b(c.value[0])), y = C(() => b(c.value[1]));
    return F(() => {
      const L = Ft.filterProps(e), k = !!(e.label || n.label || n.prepend);
      return m(Ft, q({
        class: ["v-slider", "v-range-slider", {
          "v-slider--has-labels": !!n["tick-label"] || f.value,
          "v-slider--focused": x.value,
          "v-slider--pressed": v.value,
          "v-slider--disabled": e.disabled
        }, s.value, e.class],
        style: e.style,
        ref: r
      }, L, {
        focused: x.value
      }), {
        ...n,
        prepend: k ? (S) => {
          var P, T;
          return m(le, null, [((P = n.label) == null ? void 0 : P.call(n, S)) ?? (e.label ? m(Fa, {
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (T = n.prepend) == null ? void 0 : T.call(n, S)]);
        } : void 0,
        default: (S) => {
          var _, D;
          let {
            id: P,
            messagesId: T
          } = S;
          return m("div", {
            class: "v-slider__container",
            onMousedown: $.value ? void 0 : p,
            onTouchstartPassive: $.value ? void 0 : O
          }, [m("input", {
            id: `${P.value}_start`,
            name: e.name || P.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: c.value[0]
          }, null), m("input", {
            id: `${P.value}_stop`,
            name: e.name || P.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: c.value[1]
          }, null), m(n5, {
            ref: V,
            start: w.value,
            stop: y.value
          }, {
            "tick-label": n["tick-label"]
          }), m(P1, {
            ref: l,
            "aria-describedby": T.value,
            focused: x && d.value === ((_ = l.value) == null ? void 0 : _.$el),
            modelValue: c.value[0],
            "onUpdate:modelValue": (N) => c.value = [N, c.value[1]],
            onFocus: (N) => {
              var K, E, I, Z;
              Q(), d.value = (K = l.value) == null ? void 0 : K.$el, c.value[0] === c.value[1] && c.value[1] === g.value && N.relatedTarget !== ((E = a.value) == null ? void 0 : E.$el) && ((I = l.value) == null || I.$el.blur(), (Z = a.value) == null || Z.$el.focus());
            },
            onBlur: () => {
              M(), d.value = void 0;
            },
            min: g.value,
            max: c.value[1],
            position: w.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          }), m(P1, {
            ref: a,
            "aria-describedby": T.value,
            focused: x && d.value === ((D = a.value) == null ? void 0 : D.$el),
            modelValue: c.value[1],
            "onUpdate:modelValue": (N) => c.value = [c.value[0], N],
            onFocus: (N) => {
              var K, E, I, Z;
              Q(), d.value = (K = a.value) == null ? void 0 : K.$el, c.value[0] === c.value[1] && c.value[0] === h.value && N.relatedTarget !== ((E = l.value) == null ? void 0 : E.$el) && ((I = a.value) == null || I.$el.blur(), (Z = l.value) == null || Z.$el.focus());
            },
            onBlur: () => {
              M(), d.value = void 0;
            },
            min: c.value[0],
            max: h.value,
            position: y.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), {};
  }
}), yk = B({
  name: String,
  itemAriaLabel: {
    type: String,
    default: "$vuetify.rating.ariaLabel.item"
  },
  activeColor: String,
  color: String,
  clearable: Boolean,
  disabled: Boolean,
  emptyIcon: {
    type: Se,
    default: "$ratingEmpty"
  },
  fullIcon: {
    type: Se,
    default: "$ratingFull"
  },
  halfIncrements: Boolean,
  hover: Boolean,
  length: {
    type: [Number, String],
    default: 5
  },
  readonly: Boolean,
  modelValue: {
    type: [Number, String],
    default: 0
  },
  itemLabels: Array,
  itemLabelPosition: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ripple: Boolean,
  ...ue(),
  ...Zt(),
  ...yi(),
  ...Ve(),
  ...Ie()
}, "VRating"), bk = X()({
  name: "VRating",
  props: yk(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: i
    } = pt(), {
      themeClasses: l
    } = Xe(e), a = pe(e, "modelValue"), r = C(() => Ot(parseFloat(a.value), 0, +e.length)), s = C(() => si(Number(e.length), 1)), o = C(() => s.value.flatMap((v) => e.halfIncrements ? [v - 0.5, v] : [v])), u = ie(-1), c = C(() => o.value.map((v) => {
      const p = e.hover && u.value > -1, O = r.value >= v, b = u.value >= v, $ = (p ? b : O) ? e.fullIcon : e.emptyIcon, x = e.activeColor ?? e.color, Q = O || b ? x : e.color;
      return {
        isFilled: O,
        isHovered: b,
        icon: $,
        color: Q
      };
    })), d = C(() => [0, ...o.value].map((v) => {
      function p() {
        u.value = v;
      }
      function O() {
        u.value = -1;
      }
      function b() {
        e.disabled || e.readonly || (a.value = r.value === v && e.clearable ? 0 : v);
      }
      return {
        onMouseenter: e.hover ? p : void 0,
        onMouseleave: e.hover ? O : void 0,
        onClick: b
      };
    })), f = C(() => e.name ?? `v-rating-${Bt()}`);
    function h(v) {
      var w, y;
      let {
        value: p,
        index: O,
        showStar: b = !0
      } = v;
      const {
        onMouseenter: V,
        onMouseleave: $,
        onClick: x
      } = d.value[O + 1], Q = `${f.value}-${String(p).replace(".", "-")}`, M = {
        color: (w = c.value[O]) == null ? void 0 : w.color,
        density: e.density,
        disabled: e.disabled,
        icon: (y = c.value[O]) == null ? void 0 : y.icon,
        ripple: e.ripple,
        size: e.size,
        variant: "plain"
      };
      return m(le, null, [m("label", {
        for: Q,
        class: {
          "v-rating__item--half": e.halfIncrements && p % 1 > 0,
          "v-rating__item--full": e.halfIncrements && p % 1 === 0
        },
        onMouseenter: V,
        onMouseleave: $,
        onClick: x
      }, [m("span", {
        class: "v-rating__hidden"
      }, [i(e.itemAriaLabel, p, e.length)]), b ? n.item ? n.item({
        ...c.value[O],
        props: M,
        value: p,
        index: O,
        rating: r.value
      }) : m(je, q({
        "aria-label": i(e.itemAriaLabel, p, e.length)
      }, M), null) : void 0]), m("input", {
        class: "v-rating__hidden",
        name: f.value,
        id: Q,
        type: "radio",
        value: p,
        checked: r.value === p,
        tabindex: -1,
        readonly: e.readonly,
        disabled: e.disabled
      }, null)]);
    }
    function g(v) {
      return n["item-label"] ? n["item-label"](v) : v.label ? m("span", null, [v.label]) : m("span", null, [ke("")]);
    }
    return F(() => {
      var p;
      const v = !!((p = e.itemLabels) != null && p.length) || n["item-label"];
      return m(e.tag, {
        class: ["v-rating", {
          "v-rating--hover": e.hover,
          "v-rating--readonly": e.readonly
        }, l.value, e.class],
        style: e.style
      }, {
        default: () => [m(h, {
          value: 0,
          index: -1,
          showStar: !1
        }, null), s.value.map((O, b) => {
          var V, $;
          return m("div", {
            class: "v-rating__wrapper"
          }, [v && e.itemLabelPosition === "top" ? g({
            value: O,
            index: b,
            label: (V = e.itemLabels) == null ? void 0 : V[b]
          }) : void 0, m("div", {
            class: "v-rating__item"
          }, [e.halfIncrements ? m(le, null, [m(h, {
            value: O - 0.5,
            index: b * 2
          }, null), m(h, {
            value: O,
            index: b * 2 + 1
          }, null)]) : m(h, {
            value: O,
            index: b
          }, null)]), v && e.itemLabelPosition === "bottom" ? g({
            value: O,
            index: b,
            label: ($ = e.itemLabels) == null ? void 0 : $[b]
          }) : void 0]);
        })]
      });
    }), {};
  }
}), Ck = {
  actions: "button@2",
  article: "heading, paragraph",
  avatar: "avatar",
  button: "button",
  card: "image, heading",
  "card-avatar": "image, list-item-avatar",
  chip: "chip",
  "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
  "date-picker-options": "text, avatar@2",
  "date-picker-days": "avatar@28",
  divider: "divider",
  heading: "heading",
  image: "image",
  "list-item": "text",
  "list-item-avatar": "avatar, text",
  "list-item-two-line": "sentences",
  "list-item-avatar-two-line": "avatar, sentences",
  "list-item-three-line": "paragraph",
  "list-item-avatar-three-line": "avatar, paragraph",
  ossein: "ossein",
  paragraph: "text@3",
  sentences: "text@2",
  subtitle: "text",
  table: "table-heading, table-thead, table-tbody, table-tfoot",
  "table-heading": "chip, text",
  "table-thead": "heading@6",
  "table-tbody": "table-row-divider@6",
  "table-row-divider": "table-row, divider",
  "table-row": "text@6",
  "table-tfoot": "text@2, avatar@2",
  text: "text"
};
function Sk(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return m("div", {
    class: ["v-skeleton-loader__bone", `v-skeleton-loader__${e}`]
  }, [t]);
}
function J2(e) {
  const [t, n] = e.split("@");
  return Array.from({
    length: n
  }).map(() => Xu(t));
}
function Xu(e) {
  let t = [];
  if (!e) return t;
  const n = Ck[e];
  if (e !== n) {
    if (e.includes(",")) return e0(e);
    if (e.includes("@")) return J2(e);
    n.includes(",") ? t = e0(n) : n.includes("@") ? t = J2(n) : n && t.push(Xu(n));
  }
  return [Sk(e, t)];
}
function e0(e) {
  return e.replace(/\s/g, "").split(",").map(Xu);
}
const wk = B({
  boilerplate: Boolean,
  color: String,
  loading: Boolean,
  loadingText: {
    type: String,
    default: "$vuetify.loading"
  },
  type: {
    type: [String, Array],
    default: "ossein"
  },
  ...wt(),
  ...Lt(),
  ...Ie()
}, "VSkeletonLoader"), kk = X()({
  name: "VSkeletonLoader",
  props: wk(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: l
    } = Fe(H(e, "color")), {
      dimensionStyles: a
    } = kt(e), {
      elevationClasses: r
    } = Et(e), {
      themeClasses: s
    } = Xe(e), {
      t: o
    } = pt(), u = C(() => Xu(ut(e.type).join(",")));
    return F(() => {
      var f;
      const c = !n.default || e.loading, d = e.boilerplate || !c ? {} : {
        ariaLive: "polite",
        ariaLabel: o(e.loadingText),
        role: "alert"
      };
      return m("div", q({
        class: ["v-skeleton-loader", {
          "v-skeleton-loader--boilerplate": e.boilerplate
        }, s.value, i.value, r.value],
        style: [l.value, c ? a.value : {}]
      }, d), [c ? u.value : (f = n.default) == null ? void 0 : f.call(n)]);
    }), {};
  }
}), xk = X()({
  name: "VSlideGroupItem",
  props: Jl(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = ea(e, b4);
    return () => {
      var l;
      return (l = n.default) == null ? void 0 : l.call(n, {
        isSelected: i.isSelected.value,
        select: i.select,
        toggle: i.toggle,
        selectedClass: i.selectedClass.value
      });
    };
  }
});
function Pk(e) {
  const t = ie(e());
  let n = -1;
  function i() {
    clearInterval(n);
  }
  function l() {
    i(), He(() => t.value = e());
  }
  function a(r) {
    const s = r ? getComputedStyle(r) : {
      transitionDuration: 0.2
    }, o = parseFloat(s.transitionDuration) * 1e3 || 200;
    if (i(), t.value <= 0) return;
    const u = performance.now();
    n = window.setInterval(() => {
      const c = performance.now() - u + o;
      t.value = Math.max(e() - c, 0), t.value <= 0 && i();
    }, o);
  }
  return tn(i), {
    clear: i,
    time: t,
    start: a,
    reset: l
  };
}
const $k = B({
  multiLine: Boolean,
  text: String,
  timer: [Boolean, String],
  timeout: {
    type: [Number, String],
    default: 5e3
  },
  vertical: Boolean,
  ..._i({
    location: "bottom"
  }),
  ...qa(),
  ...at(),
  ...En(),
  ...Ie(),
  ...St(os({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])
}, "VSnackbar"), Vk = X()({
  name: "VSnackbar",
  props: $k(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), {
      positionClasses: l
    } = Ya(e), {
      scopeId: a
    } = Wl(), {
      themeClasses: r
    } = Xe(e), {
      colorClasses: s,
      colorStyles: o,
      variantClasses: u
    } = Gl(e), {
      roundedClasses: c
    } = gt(e), d = Pk(() => Number(e.timeout)), f = z(), h = z(), g = ie(!1), v = ie(0), p = z(), O = Be(Lr, void 0);
    un(() => !!O, () => {
      const k = Mg();
      ft(() => {
        p.value = k.mainStyles.value;
      });
    }), ee(i, V), ee(() => e.timeout, V), it(() => {
      i.value && V();
    });
    let b = -1;
    function V() {
      d.reset(), window.clearTimeout(b);
      const k = Number(e.timeout);
      if (!i.value || k === -1) return;
      const S = af(h.value);
      d.start(S), b = window.setTimeout(() => {
        i.value = !1;
      }, k);
    }
    function $() {
      d.reset(), window.clearTimeout(b);
    }
    function x() {
      g.value = !0, $();
    }
    function Q() {
      g.value = !1, V();
    }
    function M(k) {
      v.value = k.touches[0].clientY;
    }
    function w(k) {
      Math.abs(v.value - k.changedTouches[0].clientY) > 50 && (i.value = !1);
    }
    function y() {
      g.value && Q();
    }
    const L = C(() => e.location.split(" ").reduce((k, S) => (k[`v-snackbar--${S}`] = !0, k), {}));
    return F(() => {
      const k = Fn.filterProps(e), S = !!(n.default || n.text || e.text);
      return m(Fn, q({
        ref: f,
        class: ["v-snackbar", {
          "v-snackbar--active": i.value,
          "v-snackbar--multi-line": e.multiLine && !e.vertical,
          "v-snackbar--timer": !!e.timer,
          "v-snackbar--vertical": e.vertical
        }, L.value, l.value, e.class],
        style: [p.value, e.style]
      }, k, {
        modelValue: i.value,
        "onUpdate:modelValue": (P) => i.value = P,
        contentProps: q({
          class: ["v-snackbar__wrapper", r.value, s.value, c.value, u.value],
          style: [o.value],
          onPointerenter: x,
          onPointerleave: Q
        }, k.contentProps),
        persistent: !0,
        noClickAnimation: !0,
        scrim: !1,
        scrollStrategy: "none",
        _disableGlobalStack: !0,
        onTouchstartPassive: M,
        onTouchend: w,
        onAfterLeave: y
      }, a), {
        default: () => {
          var P, T;
          return [ol(!1, "v-snackbar"), e.timer && !g.value && m("div", {
            key: "timer",
            class: "v-snackbar__timer"
          }, [m(wu, {
            ref: h,
            color: typeof e.timer == "string" ? e.timer : "info",
            max: e.timeout,
            "model-value": d.time.value
          }, null)]), S && m("div", {
            key: "content",
            class: "v-snackbar__content",
            role: "status",
            "aria-live": "polite"
          }, [((P = n.text) == null ? void 0 : P.call(n)) ?? e.text, (T = n.default) == null ? void 0 : T.call(n)]), n.actions && m(Te, {
            defaults: {
              VBtn: {
                variant: "text",
                ripple: !1,
                slim: !0
              }
            }
          }, {
            default: () => [m("div", {
              class: "v-snackbar__actions"
            }, [n.actions({
              isActive: i
            })])]
          })];
        },
        activator: n.activator
      });
    }), Bn({}, f);
  }
}), q5 = B({
  autoDraw: Boolean,
  autoDrawDuration: [Number, String],
  autoDrawEasing: {
    type: String,
    default: "ease"
  },
  color: String,
  gradient: {
    type: Array,
    default: () => []
  },
  gradientDirection: {
    type: String,
    validator: (e) => ["top", "bottom", "left", "right"].includes(e),
    default: "top"
  },
  height: {
    type: [String, Number],
    default: 75
  },
  labels: {
    type: Array,
    default: () => []
  },
  labelSize: {
    type: [Number, String],
    default: 7
  },
  lineWidth: {
    type: [String, Number],
    default: 4
  },
  id: String,
  itemValue: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  min: [String, Number],
  max: [String, Number],
  padding: {
    type: [String, Number],
    default: 8
  },
  showLabels: Boolean,
  smooth: Boolean,
  width: {
    type: [Number, String],
    default: 300
  }
}, "Line"), Y5 = B({
  autoLineWidth: Boolean,
  ...q5()
}, "VBarline"), t0 = X()({
  name: "VBarline",
  props: Y5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Bt(), l = C(() => e.id || `barline-${i}`), a = C(() => Number(e.autoDrawDuration) || 500), r = C(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), s = C(() => parseFloat(e.lineWidth) || 4), o = C(() => Math.max(e.modelValue.length * s.value, Number(e.width))), u = C(() => ({
      minX: 0,
      maxX: o.value,
      minY: 0,
      maxY: parseInt(e.height, 10)
    })), c = C(() => e.modelValue.map((v) => Pt(v, e.itemValue, v)));
    function d(v, p) {
      const {
        minX: O,
        maxX: b,
        minY: V,
        maxY: $
      } = p, x = v.length;
      let Q = e.max != null ? Number(e.max) : Math.max(...v), M = e.min != null ? Number(e.min) : Math.min(...v);
      M > 0 && e.min == null && (M = 0), Q < 0 && e.max == null && (Q = 0);
      const w = b / x, y = ($ - V) / (Q - M || 1), L = $ - Math.abs(M * y);
      return v.map((k, S) => {
        const P = Math.abs(y * k);
        return {
          x: O + S * w,
          y: L - P + +(k < 0) * P,
          height: P,
          value: k
        };
      });
    }
    const f = C(() => {
      const v = [], p = d(c.value, u.value), O = p.length;
      for (let b = 0; v.length < O; b++) {
        const V = p[b];
        let $ = e.labels[b];
        $ || ($ = typeof V == "object" ? V.value : V), v.push({
          x: V.x,
          value: String($)
        });
      }
      return v;
    }), h = C(() => d(c.value, u.value)), g = C(() => (Math.abs(h.value[0].x - h.value[1].x) - s.value) / 2);
    F(() => {
      const v = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return m("svg", {
        display: "block"
      }, [m("defs", null, [m("linearGradient", {
        id: l.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [v.map((p, O) => m("stop", {
        offset: O / Math.max(v.length - 1, 1),
        "stop-color": p || "currentColor"
      }, null))])]), m("clipPath", {
        id: `${l.value}-clip`
      }, [h.value.map((p) => m("rect", {
        x: p.x + g.value,
        y: p.y,
        width: s.value,
        height: p.height,
        rx: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0,
        ry: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0
      }, [e.autoDraw && m(le, null, [m("animate", {
        attributeName: "y",
        from: p.y + p.height,
        to: p.y,
        dur: `${a.value}ms`,
        fill: "freeze"
      }, null), m("animate", {
        attributeName: "height",
        from: "0",
        to: p.height,
        dur: `${a.value}ms`,
        fill: "freeze"
      }, null)])]))]), r.value && m("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [f.value.map((p, O) => {
        var b;
        return m("text", {
          x: p.x + g.value + s.value / 2,
          y: parseInt(e.height, 10) - 2 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((b = n.label) == null ? void 0 : b.call(n, {
          index: O,
          value: p.value
        })) ?? p.value]);
      })]), m("g", {
        "clip-path": `url(#${l.value}-clip)`,
        fill: `url(#${l.value})`
      }, [m("rect", {
        x: 0,
        y: 0,
        width: Math.max(e.modelValue.length * s.value, Number(e.width)),
        height: e.height
      }, null)])]);
    });
  }
});
function Qk(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
  if (e.length === 0) return "";
  const l = e.shift(), a = e[e.length - 1];
  return (n ? `M${l.x} ${i - l.x + 2} L${l.x} ${l.y}` : `M${l.x} ${l.y}`) + e.map((r, s) => {
    const o = e[s + 1], u = e[s - 1] || l, c = o && Lk(o, r, u);
    if (!o || c)
      return `L${r.x} ${r.y}`;
    const d = Math.min(n0(u, r), n0(o, r)), h = d / 2 < t ? d / 2 : t, g = i0(u, r, h), v = i0(o, r, h);
    return `L${g.x} ${g.y}S${r.x} ${r.y} ${v.x} ${v.y}`;
  }).join("") + (n ? `L${a.x} ${i - l.x + 2} Z` : "");
}
function _s(e) {
  return parseInt(e, 10);
}
function Lk(e, t, n) {
  return _s(e.x + n.x) === _s(2 * t.x) && _s(e.y + n.y) === _s(2 * t.y);
}
function n0(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function i0(e, t, n) {
  const i = {
    x: e.x - t.x,
    y: e.y - t.y
  }, l = Math.sqrt(i.x * i.x + i.y * i.y), a = {
    x: i.x / l,
    y: i.y / l
  };
  return {
    x: t.x + a.x * n,
    y: t.y + a.y * n
  };
}
const F5 = B({
  fill: Boolean,
  ...q5()
}, "VTrendline"), l0 = X()({
  name: "VTrendline",
  props: F5(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Bt(), l = C(() => e.id || `trendline-${i}`), a = C(() => Number(e.autoDrawDuration) || (e.fill ? 500 : 2e3)), r = z(0), s = z(null);
    function o(p, O) {
      const {
        minX: b,
        maxX: V,
        minY: $,
        maxY: x
      } = O, Q = p.length, M = e.max != null ? Number(e.max) : Math.max(...p), w = e.min != null ? Number(e.min) : Math.min(...p), y = (V - b) / (Q - 1), L = (x - $) / (M - w || 1);
      return p.map((k, S) => ({
        x: b + S * y,
        y: x - (k - w) * L,
        value: k
      }));
    }
    const u = C(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), c = C(() => parseFloat(e.lineWidth) || 4), d = C(() => Number(e.width)), f = C(() => {
      const p = Number(e.padding);
      return {
        minX: p,
        maxX: d.value - p,
        minY: p,
        maxY: parseInt(e.height, 10) - p
      };
    }), h = C(() => e.modelValue.map((p) => Pt(p, e.itemValue, p))), g = C(() => {
      const p = [], O = o(h.value, f.value), b = O.length;
      for (let V = 0; p.length < b; V++) {
        const $ = O[V];
        let x = e.labels[V];
        x || (x = typeof $ == "object" ? $.value : $), p.push({
          x: $.x,
          value: String(x)
        });
      }
      return p;
    });
    ee(() => e.modelValue, async () => {
      if (await He(), !e.autoDraw || !s.value) return;
      const p = s.value, O = p.getTotalLength();
      e.fill ? (p.style.transformOrigin = "bottom center", p.style.transition = "none", p.style.transform = "scaleY(0)", p.getBoundingClientRect(), p.style.transition = `transform ${a.value}ms ${e.autoDrawEasing}`, p.style.transform = "scaleY(1)") : (p.style.strokeDasharray = `${O}`, p.style.strokeDashoffset = `${O}`, p.getBoundingClientRect(), p.style.transition = `stroke-dashoffset ${a.value}ms ${e.autoDrawEasing}`, p.style.strokeDashoffset = "0"), r.value = O;
    }, {
      immediate: !0
    });
    function v(p) {
      return Qk(o(h.value, f.value), e.smooth ? 8 : Number(e.smooth), p, parseInt(e.height, 10));
    }
    F(() => {
      var O;
      const p = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return m("svg", {
        display: "block",
        "stroke-width": parseFloat(e.lineWidth) ?? 4
      }, [m("defs", null, [m("linearGradient", {
        id: l.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [p.map((b, V) => m("stop", {
        offset: V / Math.max(p.length - 1, 1),
        "stop-color": b || "currentColor"
      }, null))])]), u.value && m("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [g.value.map((b, V) => {
        var $;
        return m("text", {
          x: b.x + c.value / 2 + c.value / 2,
          y: parseInt(e.height, 10) - 4 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [(($ = n.label) == null ? void 0 : $.call(n, {
          index: V,
          value: b.value
        })) ?? b.value]);
      })]), m("path", {
        ref: s,
        d: v(e.fill),
        fill: e.fill ? `url(#${l.value})` : "none",
        stroke: e.fill ? "none" : `url(#${l.value})`
      }, null), e.fill && m("path", {
        d: v(!1),
        fill: "none",
        stroke: e.color ?? ((O = e.gradient) == null ? void 0 : O[0])
      }, null)]);
    });
  }
}), Mk = B({
  type: {
    type: String,
    default: "trend"
  },
  ...Y5(),
  ...F5()
}, "VSparkline"), Tk = X()({
  name: "VSparkline",
  props: Mk(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: i,
      textColorStyles: l
    } = Yt(H(e, "color")), a = C(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), r = C(() => {
      let s = parseInt(e.height, 10);
      return a.value && (s += parseInt(e.labelSize, 10) * 1.5), s;
    });
    F(() => {
      const s = e.type === "trend" ? l0 : t0, o = e.type === "trend" ? l0.filterProps(e) : t0.filterProps(e);
      return m(s, q({
        key: e.type,
        class: i.value,
        style: l.value,
        viewBox: `0 0 ${e.width} ${parseInt(r.value, 10)}`
      }, o), n);
    });
  }
}), _k = B({
  ...ue(),
  ...Z4({
    offset: 8,
    minWidth: 0,
    openDelay: 0,
    closeDelay: 100,
    location: "top center",
    transition: "scale-transition"
  })
}, "VSpeedDial"), Ak = X()({
  name: "VSpeedDial",
  props: _k(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = pe(e, "modelValue"), l = z(), a = C(() => {
      var u;
      const [s, o = "center"] = ((u = e.location) == null ? void 0 : u.split(" ")) ?? [];
      return `${s} ${o}`;
    }), r = C(() => ({
      [`v-speed-dial__content--${a.value.replace(" ", "-")}`]: !0
    }));
    return F(() => {
      const s = La.filterProps(e);
      return m(La, q(s, {
        modelValue: i.value,
        "onUpdate:modelValue": (o) => i.value = o,
        class: e.class,
        style: e.style,
        contentClass: ["v-speed-dial__content", r.value, e.contentClass],
        location: a.value,
        ref: l,
        transition: "fade-transition"
      }), {
        ...n,
        default: (o) => m(Te, {
          defaults: {
            VBtn: {
              size: "small"
            }
          }
        }, {
          default: () => [m(en, {
            appear: !0,
            group: !0,
            transition: e.transition
          }, {
            default: () => {
              var u;
              return [(u = n.default) == null ? void 0 : u.call(n, o)];
            }
          })]
        })
      });
    }), {};
  }
}), Jf = Symbol.for("vuetify:v-stepper"), W5 = B({
  color: String,
  disabled: {
    type: [Boolean, String],
    default: !1
  },
  prevText: {
    type: String,
    default: "$vuetify.stepper.prev"
  },
  nextText: {
    type: String,
    default: "$vuetify.stepper.next"
  }
}, "VStepperActions"), U5 = X()({
  name: "VStepperActions",
  props: W5(),
  emits: {
    "click:prev": () => !0,
    "click:next": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: i
    } = t;
    const {
      t: l
    } = pt();
    function a() {
      n("click:prev");
    }
    function r() {
      n("click:next");
    }
    return F(() => {
      const s = {
        onClick: a
      }, o = {
        onClick: r
      };
      return m("div", {
        class: "v-stepper-actions"
      }, [m(Te, {
        defaults: {
          VBtn: {
            disabled: ["prev", !0].includes(e.disabled),
            text: l(e.prevText),
            variant: "text"
          }
        }
      }, {
        default: () => {
          var u;
          return [((u = i.prev) == null ? void 0 : u.call(i, {
            props: s
          })) ?? m(je, s, null)];
        }
      }), m(Te, {
        defaults: {
          VBtn: {
            color: e.color,
            disabled: ["next", !0].includes(e.disabled),
            text: l(e.nextText),
            variant: "tonal"
          }
        }
      }, {
        default: () => {
          var u;
          return [((u = i.next) == null ? void 0 : u.call(i, {
            props: o
          })) ?? m(je, o, null)];
        }
      })]);
    }), {};
  }
}), G5 = Oi("v-stepper-header"), Rk = B({
  color: String,
  title: String,
  subtitle: String,
  complete: Boolean,
  completeIcon: {
    type: String,
    default: "$complete"
  },
  editable: Boolean,
  editIcon: {
    type: String,
    default: "$edit"
  },
  error: Boolean,
  errorIcon: {
    type: String,
    default: "$error"
  },
  icon: String,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  rules: {
    type: Array,
    default: () => []
  }
}, "StepperItem"), Zk = B({
  ...Rk(),
  ...Jl()
}, "VStepperItem"), K5 = X()({
  name: "VStepperItem",
  directives: {
    Ripple: Ti
  },
  props: Zk(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = ea(e, Jf, !0), l = C(() => (i == null ? void 0 : i.value.value) ?? e.value), a = C(() => e.rules.every((f) => f() === !0)), r = C(() => !e.disabled && e.editable), s = C(() => !e.disabled && e.editable), o = C(() => e.error || !a.value), u = C(() => e.complete || e.rules.length > 0 && a.value), c = C(() => o.value ? e.errorIcon : u.value ? e.completeIcon : i.isSelected.value && e.editable ? e.editIcon : e.icon), d = C(() => ({
      canEdit: s.value,
      hasError: o.value,
      hasCompleted: u.value,
      title: e.title,
      subtitle: e.subtitle,
      step: l.value,
      value: e.value
    }));
    return F(() => {
      var p, O, b;
      const f = (!i || i.isSelected.value || u.value || s.value) && !o.value && !e.disabled, h = !!(e.title != null || n.title), g = !!(e.subtitle != null || n.subtitle);
      function v() {
        i == null || i.toggle();
      }
      return Je(m("button", {
        class: ["v-stepper-item", {
          "v-stepper-item--complete": u.value,
          "v-stepper-item--disabled": e.disabled,
          "v-stepper-item--error": o.value
        }, i == null ? void 0 : i.selectedClass.value],
        disabled: !e.editable,
        onClick: v
      }, [r.value && ol(!0, "v-stepper-item"), m(An, {
        key: "stepper-avatar",
        class: "v-stepper-item__avatar",
        color: f ? e.color : void 0,
        size: 24
      }, {
        default: () => {
          var V;
          return [((V = n.icon) == null ? void 0 : V.call(n, d.value)) ?? (c.value ? m(ze, {
            icon: c.value
          }, null) : l.value)];
        }
      }), m("div", {
        class: "v-stepper-item__content"
      }, [h && m("div", {
        key: "title",
        class: "v-stepper-item__title"
      }, [((p = n.title) == null ? void 0 : p.call(n, d.value)) ?? e.title]), g && m("div", {
        key: "subtitle",
        class: "v-stepper-item__subtitle"
      }, [((O = n.subtitle) == null ? void 0 : O.call(n, d.value)) ?? e.subtitle]), (b = n.default) == null ? void 0 : b.call(n, d.value)])]), [[Pn("ripple"), e.ripple && e.editable, null]]);
    }), {};
  }
}), Ik = B({
  ...St(Tu(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VStepperWindow"), J5 = X()({
  name: "VStepperWindow",
  props: Ik(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Be(Jf, null), l = pe(e, "modelValue"), a = C({
      get() {
        var r;
        return l.value != null || !i ? l.value : (r = i.items.value.find((s) => i.selected.value.includes(s.id))) == null ? void 0 : r.value;
      },
      set(r) {
        l.value = r;
      }
    });
    return F(() => {
      const r = _l.filterProps(e);
      return m(_l, q({
        _as: "VStepperWindow"
      }, r, {
        modelValue: a.value,
        "onUpdate:modelValue": (s) => a.value = s,
        class: ["v-stepper-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), Dk = B({
  ..._u()
}, "VStepperWindowItem"), e3 = X()({
  name: "VStepperWindowItem",
  props: Dk(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => {
      const i = Al.filterProps(e);
      return m(Al, q({
        _as: "VStepperWindowItem"
      }, i, {
        class: ["v-stepper-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
}), Bk = B({
  altLabels: Boolean,
  bgColor: String,
  completeIcon: String,
  editIcon: String,
  editable: Boolean,
  errorIcon: String,
  hideActions: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: String,
    default: "title"
  },
  itemValue: {
    type: String,
    default: "value"
  },
  nonLinear: Boolean,
  flat: Boolean,
  ...ql()
}, "Stepper"), Ek = B({
  ...Bk(),
  ...Kl({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  }),
  ...Au(),
  ...hu(W5(), ["prevText", "nextText"])
}, "VStepper"), zk = X()({
  name: "VStepper",
  props: Ek(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: i,
      next: l,
      prev: a,
      selected: r
    } = ul(e, Jf), {
      displayClasses: s,
      mobile: o
    } = Dn(e), {
      completeIcon: u,
      editIcon: c,
      errorIcon: d,
      color: f,
      editable: h,
      prevText: g,
      nextText: v
    } = Nl(e), p = C(() => e.items.map((V, $) => {
      const x = Pt(V, e.itemTitle, V), Q = Pt(V, e.itemValue, $ + 1);
      return {
        title: x,
        value: Q,
        raw: V
      };
    })), O = C(() => i.value.findIndex((V) => r.value.includes(V.id))), b = C(() => e.disabled ? e.disabled : O.value === 0 ? "prev" : O.value === i.value.length - 1 ? "next" : !1);
    return ht({
      VStepperItem: {
        editable: h,
        errorIcon: d,
        completeIcon: u,
        editIcon: c,
        prevText: g,
        nextText: v
      },
      VStepperActions: {
        color: f,
        disabled: b,
        prevText: g,
        nextText: v
      }
    }), F(() => {
      const V = Rl.filterProps(e), $ = !!(n.header || e.items.length), x = e.items.length > 0, Q = !e.hideActions && !!(x || n.actions);
      return m(Rl, q(V, {
        color: e.bgColor,
        class: ["v-stepper", {
          "v-stepper--alt-labels": e.altLabels,
          "v-stepper--flat": e.flat,
          "v-stepper--non-linear": e.nonLinear,
          "v-stepper--mobile": o.value
        }, s.value, e.class],
        style: e.style
      }), {
        default: () => {
          var M, w;
          return [$ && m(G5, {
            key: "stepper-header"
          }, {
            default: () => [p.value.map((y, L) => {
              let {
                raw: k,
                ...S
              } = y;
              return m(le, null, [!!L && m(fs, null, null), m(K5, S, {
                default: n[`header-item.${S.value}`] ?? n.header,
                icon: n.icon,
                title: n.title,
                subtitle: n.subtitle
              })]);
            })]
          }), x && m(J5, {
            key: "stepper-window"
          }, {
            default: () => [p.value.map((y) => m(e3, {
              value: y.value
            }, {
              default: () => {
                var L, k;
                return ((L = n[`item.${y.value}`]) == null ? void 0 : L.call(n, y)) ?? ((k = n.item) == null ? void 0 : k.call(n, y));
              }
            }))]
          }), (M = n.default) == null ? void 0 : M.call(n, {
            prev: a,
            next: l
          }), Q && (((w = n.actions) == null ? void 0 : w.call(n, {
            next: l,
            prev: a
          })) ?? m(U5, {
            key: "stepper-actions",
            "onClick:prev": a,
            "onClick:next": l
          }, n))];
        }
      });
    }), {
      prev: a,
      next: l
    };
  }
}), Hk = B({
  indeterminate: Boolean,
  inset: Boolean,
  flat: Boolean,
  loading: {
    type: [Boolean, String],
    default: !1
  },
  ...Ri(),
  ...Pu()
}, "VSwitch"), jk = X()({
  name: "VSwitch",
  inheritAttrs: !1,
  props: Hk(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const l = pe(e, "indeterminate"), a = pe(e, "modelValue"), {
      loaderClasses: r
    } = us(e), {
      isFocused: s,
      focus: o,
      blur: u
    } = Ai(e), c = z(), d = qe && window.matchMedia("(forced-colors: active)").matches, f = C(() => typeof e.loading == "string" && e.loading !== "" ? e.loading : e.color), h = Bt(), g = C(() => e.id || `switch-${h}`);
    function v() {
      l.value && (l.value = !1);
    }
    function p(O) {
      var b, V;
      O.stopPropagation(), O.preventDefault(), (V = (b = c.value) == null ? void 0 : b.input) == null || V.click();
    }
    return F(() => {
      const [O, b] = sl(n), V = Ft.filterProps(e), $ = Ki.filterProps(e);
      return m(Ft, q({
        class: ["v-switch", {
          "v-switch--flat": e.flat
        }, {
          "v-switch--inset": e.inset
        }, {
          "v-switch--indeterminate": l.value
        }, r.value, e.class]
      }, O, V, {
        modelValue: a.value,
        "onUpdate:modelValue": (x) => a.value = x,
        id: g.value,
        focused: s.value,
        style: e.style
      }), {
        ...i,
        default: (x) => {
          let {
            id: Q,
            messagesId: M,
            isDisabled: w,
            isReadonly: y,
            isValid: L
          } = x;
          const k = {
            model: a,
            isValid: L
          };
          return m(Ki, q({
            ref: c
          }, $, {
            modelValue: a.value,
            "onUpdate:modelValue": [(S) => a.value = S, v],
            id: Q.value,
            "aria-describedby": M.value,
            type: "checkbox",
            "aria-checked": l.value ? "mixed" : void 0,
            disabled: w.value,
            readonly: y.value,
            onFocus: o,
            onBlur: u
          }, b), {
            ...i,
            default: (S) => {
              let {
                backgroundColorClasses: P,
                backgroundColorStyles: T
              } = S;
              return m("div", {
                class: ["v-switch__track", d ? void 0 : P.value],
                style: T.value,
                onClick: p
              }, [i["track-true"] && m("div", {
                key: "prepend",
                class: "v-switch__track-true"
              }, [i["track-true"](k)]), i["track-false"] && m("div", {
                key: "append",
                class: "v-switch__track-false"
              }, [i["track-false"](k)])]);
            },
            input: (S) => {
              let {
                inputNode: P,
                icon: T,
                backgroundColorClasses: _,
                backgroundColorStyles: D
              } = S;
              return m(le, null, [P, m("div", {
                class: ["v-switch__thumb", {
                  "v-switch__thumb--filled": T || e.loading
                }, e.inset || d ? void 0 : _.value],
                style: e.inset ? void 0 : D.value
              }, [i.thumb ? m(Te, {
                defaults: {
                  VIcon: {
                    icon: T,
                    size: "x-small"
                  }
                }
              }, {
                default: () => [i.thumb({
                  ...k,
                  icon: T
                })]
              }) : m(xf, null, {
                default: () => [e.loading ? m(cs, {
                  name: "v-switch",
                  active: !0,
                  color: L.value === !1 ? void 0 : f.value
                }, {
                  default: (N) => i.loader ? i.loader(N) : m(Qa, {
                    active: N.isActive,
                    color: N.color,
                    indeterminate: !0,
                    size: "16",
                    width: "2"
                  }, null)
                }) : T && m(ze, {
                  key: String(T),
                  icon: T,
                  size: "x-small"
                }, null)]
              })])]);
            }
          });
        }
      });
    }), {};
  }
}), Xk = B({
  color: String,
  height: [Number, String],
  window: Boolean,
  ...ue(),
  ...Lt(),
  ...Yl(),
  ...at(),
  ...Ve(),
  ...Ie()
}, "VSystemBar"), Nk = X()({
  name: "VSystemBar",
  props: Xk(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: a
    } = Fe(H(e, "color")), {
      elevationClasses: r
    } = Et(e), {
      roundedClasses: s
    } = gt(e), {
      ssrBootStyles: o
    } = Ul(), u = C(() => e.height ?? (e.window ? 32 : 24)), {
      layoutItemStyles: c
    } = Fl({
      id: e.name,
      order: C(() => parseInt(e.order, 10)),
      position: ie("top"),
      layoutSize: u,
      elementSize: u,
      active: C(() => !0),
      absolute: H(e, "absolute")
    });
    return F(() => m(e.tag, {
      class: ["v-system-bar", {
        "v-system-bar--window": e.window
      }, i.value, l.value, r.value, s.value, e.class],
      style: [a.value, c.value, o.value, e.style]
    }, n)), {};
  }
}), eh = Symbol.for("vuetify:v-tabs"), qk = B({
  fixed: Boolean,
  sliderColor: String,
  hideSlider: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...St(xu({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab"), t3 = X()({
  name: "VTab",
  props: qk(),
  setup(e, t) {
    let {
      slots: n,
      attrs: i
    } = t;
    const {
      textColorClasses: l,
      textColorStyles: a
    } = Yt(e, "sliderColor"), r = z(), s = z(), o = C(() => e.direction === "horizontal"), u = C(() => {
      var d, f;
      return ((f = (d = r.value) == null ? void 0 : d.group) == null ? void 0 : f.isSelected.value) ?? !1;
    });
    function c(d) {
      var h, g;
      let {
        value: f
      } = d;
      if (f) {
        const v = (g = (h = r.value) == null ? void 0 : h.$el.parentElement) == null ? void 0 : g.querySelector(".v-tab--selected .v-tab__slider"), p = s.value;
        if (!v || !p) return;
        const O = getComputedStyle(v).color, b = v.getBoundingClientRect(), V = p.getBoundingClientRect(), $ = o.value ? "x" : "y", x = o.value ? "X" : "Y", Q = o.value ? "right" : "bottom", M = o.value ? "width" : "height", w = b[$], y = V[$], L = w > y ? b[Q] - V[Q] : b[$] - V[$], k = Math.sign(L) > 0 ? o.value ? "right" : "bottom" : Math.sign(L) < 0 ? o.value ? "left" : "top" : "center", P = (Math.abs(L) + (Math.sign(L) < 0 ? b[M] : V[M])) / Math.max(b[M], V[M]) || 0, T = b[M] / V[M] || 0, _ = 1.5;
        Cl(p, {
          backgroundColor: [O, "currentcolor"],
          transform: [`translate${x}(${L}px) scale${x}(${T})`, `translate${x}(${L / _}px) scale${x}(${(P - 1) / _ + 1})`, "none"],
          transformOrigin: Array(3).fill(k)
        }, {
          duration: 225,
          easing: Vr
        });
      }
    }
    return F(() => {
      const d = je.filterProps(e);
      return m(je, q({
        symbol: eh,
        ref: r,
        class: ["v-tab", e.class],
        style: e.style,
        tabindex: u.value ? 0 : -1,
        role: "tab",
        "aria-selected": String(u.value),
        active: !1
      }, d, i, {
        block: e.fixed,
        maxWidth: e.fixed ? 300 : void 0,
        "onGroup:selected": c
      }), {
        ...n,
        default: () => {
          var f;
          return m(le, null, [((f = n.default) == null ? void 0 : f.call(n)) ?? e.text, !e.hideSlider && m("div", {
            ref: s,
            class: ["v-tab__slider", l.value],
            style: a.value
          }, null)]);
        }
      });
    }), Bn({}, r);
  }
}), Yk = B({
  ...St(Tu(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VTabsWindow"), n3 = X()({
  name: "VTabsWindow",
  props: Yk(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = Be(eh, null), l = pe(e, "modelValue"), a = C({
      get() {
        var r;
        return l.value != null || !i ? l.value : (r = i.items.value.find((s) => i.selected.value.includes(s.id))) == null ? void 0 : r.value;
      },
      set(r) {
        l.value = r;
      }
    });
    return F(() => {
      const r = _l.filterProps(e);
      return m(_l, q({
        _as: "VTabsWindow"
      }, r, {
        modelValue: a.value,
        "onUpdate:modelValue": (s) => a.value = s,
        class: ["v-tabs-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), Fk = B({
  ..._u()
}, "VTabsWindowItem"), i3 = X()({
  name: "VTabsWindowItem",
  props: Fk(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F(() => {
      const i = Al.filterProps(e);
      return m(Al, q({
        _as: "VTabsWindowItem"
      }, i, {
        class: ["v-tabs-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
});
function Wk(e) {
  return e ? e.map((t) => lf(t) ? t : {
    text: t,
    value: t
  }) : [];
}
const Uk = B({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  sliderColor: String,
  ...Lf({
    mandatory: "force",
    selectedClass: "v-tab-item--selected"
  }),
  ...Zt(),
  ...Ve()
}, "VTabs"), Gk = X()({
  name: "VTabs",
  props: Uk(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: i
    } = t;
    const l = pe(e, "modelValue"), a = C(() => Wk(e.items)), {
      densityClasses: r
    } = nn(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: o
    } = Fe(H(e, "bgColor")), {
      scopeId: u
    } = Wl();
    return ht({
      VTab: {
        color: H(e, "color"),
        direction: H(e, "direction"),
        stacked: H(e, "stacked"),
        fixed: H(e, "fixedTabs"),
        sliderColor: H(e, "sliderColor"),
        hideSlider: H(e, "hideSlider")
      }
    }), F(() => {
      const c = Rr.filterProps(e), d = !!(i.window || e.items.length > 0);
      return m(le, null, [m(Rr, q(c, {
        modelValue: l.value,
        "onUpdate:modelValue": (f) => l.value = f,
        class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
          "v-tabs--fixed-tabs": e.fixedTabs,
          "v-tabs--grow": e.grow,
          "v-tabs--stacked": e.stacked
        }, r.value, s.value, e.class],
        style: [{
          "--v-tabs-height": se(e.height)
        }, o.value, e.style],
        role: "tablist",
        symbol: eh
      }, u, n), {
        default: () => {
          var f;
          return [((f = i.default) == null ? void 0 : f.call(i)) ?? a.value.map((h) => {
            var g;
            return ((g = i.tab) == null ? void 0 : g.call(i, {
              item: h
            })) ?? m(t3, q(h, {
              key: h.text,
              value: h.value
            }), {
              default: i[`tab.${h.value}`] ? () => {
                var v;
                return (v = i[`tab.${h.value}`]) == null ? void 0 : v.call(i, {
                  item: h
                });
              } : void 0
            });
          })];
        }
      }), d && m(n3, q({
        modelValue: l.value,
        "onUpdate:modelValue": (f) => l.value = f,
        key: "tabs-window"
      }, u), {
        default: () => {
          var f;
          return [a.value.map((h) => {
            var g;
            return ((g = i.item) == null ? void 0 : g.call(i, {
              item: h
            })) ?? m(i3, {
              value: h.value
            }, {
              default: () => {
                var v;
                return (v = i[`item.${h.value}`]) == null ? void 0 : v.call(i, {
                  item: h
                });
              }
            });
          }), (f = i.window) == null ? void 0 : f.call(i)];
        }
      })]);
    }), {};
  }
}), Kk = B({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (e) => !isNaN(parseFloat(e))
  },
  maxRows: {
    type: [Number, String],
    validator: (e) => !isNaN(parseFloat(e))
  },
  suffix: String,
  modelModifiers: Object,
  ...Ri(),
  ...hs()
}, "VTextarea"), Jk = X()({
  name: "VTextarea",
  directives: {
    Intersect: as
  },
  inheritAttrs: !1,
  props: Kk(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: i,
      slots: l
    } = t;
    const a = pe(e, "modelValue"), {
      isFocused: r,
      focus: s,
      blur: o
    } = Ai(e), u = C(() => typeof e.counterValue == "function" ? e.counterValue(a.value) : (a.value || "").toString().length), c = C(() => {
      if (n.maxlength) return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    });
    function d(k, S) {
      var P, T;
      !e.autofocus || !k || (T = (P = S[0].target) == null ? void 0 : P.focus) == null || T.call(P);
    }
    const f = z(), h = z(), g = ie(""), v = z(), p = C(() => e.persistentPlaceholder || r.value || e.active);
    function O() {
      var k;
      v.value !== document.activeElement && ((k = v.value) == null || k.focus()), r.value || s();
    }
    function b(k) {
      O(), i("click:control", k);
    }
    function V(k) {
      i("mousedown:control", k);
    }
    function $(k) {
      k.stopPropagation(), O(), He(() => {
        a.value = "", of(e["onClick:clear"], k);
      });
    }
    function x(k) {
      var P;
      const S = k.target;
      if (a.value = S.value, (P = e.modelModifiers) != null && P.trim) {
        const T = [S.selectionStart, S.selectionEnd];
        He(() => {
          S.selectionStart = T[0], S.selectionEnd = T[1];
        });
      }
    }
    const Q = z(), M = z(+e.rows), w = C(() => ["plain", "underlined"].includes(e.variant));
    ft(() => {
      e.autoGrow || (M.value = +e.rows);
    });
    function y() {
      e.autoGrow && He(() => {
        if (!Q.value || !h.value) return;
        const k = getComputedStyle(Q.value), S = getComputedStyle(h.value.$el), P = parseFloat(k.getPropertyValue("--v-field-padding-top")) + parseFloat(k.getPropertyValue("--v-input-padding-top")) + parseFloat(k.getPropertyValue("--v-field-padding-bottom")), T = Q.value.scrollHeight, _ = parseFloat(k.lineHeight), D = Math.max(parseFloat(e.rows) * _ + P, parseFloat(S.getPropertyValue("--v-input-control-height"))), N = parseFloat(e.maxRows) * _ + P || 1 / 0, K = Ot(T ?? 0, D, N);
        M.value = Math.floor((K - P) / _), g.value = se(K);
      });
    }
    it(y), ee(a, y), ee(() => e.rows, y), ee(() => e.maxRows, y), ee(() => e.density, y);
    let L;
    return ee(Q, (k) => {
      k ? (L = new ResizeObserver(y), L.observe(Q.value)) : L == null || L.disconnect();
    }), Wt(() => {
      L == null || L.disconnect();
    }), F(() => {
      const k = !!(l.counter || e.counter || e.counterValue), S = !!(k || l.details), [P, T] = sl(n), {
        modelValue: _,
        ...D
      } = Ft.filterProps(e), N = Af(e);
      return m(Ft, q({
        ref: f,
        modelValue: a.value,
        "onUpdate:modelValue": (K) => a.value = K,
        class: ["v-textarea v-text-field", {
          "v-textarea--prefixed": e.prefix,
          "v-textarea--suffixed": e.suffix,
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-textarea--auto-grow": e.autoGrow,
          "v-textarea--no-resize": e.noResize || e.autoGrow,
          "v-input--plain-underlined": w.value
        }, e.class],
        style: e.style
      }, P, D, {
        centerAffix: M.value === 1 && !w.value,
        focused: r.value
      }), {
        ...l,
        default: (K) => {
          let {
            id: E,
            isDisabled: I,
            isDirty: Z,
            isReadonly: Y,
            isValid: ce
          } = K;
          return m(Ua, q({
            ref: h,
            style: {
              "--v-textarea-control-height": g.value
            },
            onClick: b,
            onMousedown: V,
            "onClick:clear": $,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, N, {
            id: E.value,
            active: p.value || Z.value,
            centerAffix: M.value === 1 && !w.value,
            dirty: Z.value || e.dirty,
            disabled: I.value,
            focused: r.value,
            error: ce.value === !1
          }), {
            ...l,
            default: (de) => {
              let {
                props: {
                  class: ye,
                  ...U
                }
              } = de;
              return m(le, null, [e.prefix && m("span", {
                class: "v-text-field__prefix"
              }, [e.prefix]), Je(m("textarea", q({
                ref: v,
                class: ye,
                value: a.value,
                onInput: x,
                autofocus: e.autofocus,
                readonly: Y.value,
                disabled: I.value,
                placeholder: e.placeholder,
                rows: e.rows,
                name: e.name,
                onFocus: O,
                onBlur: o
              }, U, T), null), [[Pn("intersect"), {
                handler: d
              }, null, {
                once: !0
              }]]), e.autoGrow && Je(m("textarea", {
                class: [ye, "v-textarea__sizer"],
                id: `${U.id}-sizer`,
                "onUpdate:modelValue": (ge) => a.value = ge,
                ref: Q,
                readonly: !0,
                "aria-hidden": "true"
              }, null), [[g7, a.value]]), e.suffix && m("span", {
                class: "v-text-field__suffix"
              }, [e.suffix])]);
            }
          });
        },
        details: S ? (K) => {
          var E;
          return m(le, null, [(E = l.details) == null ? void 0 : E.call(l, K), k && m(le, null, [m("span", null, null), m(Qu, {
            active: e.persistentCounter || r.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, l.counter)])]);
        } : void 0
      });
    }), Bn({}, f, h, v);
  }
}), ex = B({
  withBackground: Boolean,
  ...ue(),
  ...Ie(),
  ...Ve()
}, "VThemeProvider"), tx = X()({
  name: "VThemeProvider",
  props: ex(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e);
    return () => {
      var l;
      return e.withBackground ? m(e.tag, {
        class: ["v-theme-provider", i.value, e.class],
        style: e.style
      }, {
        default: () => {
          var a;
          return [(a = n.default) == null ? void 0 : a.call(n)];
        }
      }) : (l = n.default) == null ? void 0 : l.call(n);
    };
  }
}), nx = B({
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  icon: Se,
  iconColor: String,
  lineColor: String,
  ...ue(),
  ...at(),
  ...yi(),
  ...Lt()
}, "VTimelineDivider"), ix = X()({
  name: "VTimelineDivider",
  props: nx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      sizeClasses: i,
      sizeStyles: l
    } = Na(e, "v-timeline-divider__dot"), {
      backgroundColorStyles: a,
      backgroundColorClasses: r
    } = Fe(H(e, "dotColor")), {
      roundedClasses: s
    } = gt(e, "v-timeline-divider__dot"), {
      elevationClasses: o
    } = Et(e), {
      backgroundColorClasses: u,
      backgroundColorStyles: c
    } = Fe(H(e, "lineColor"));
    return F(() => m("div", {
      class: ["v-timeline-divider", {
        "v-timeline-divider--fill-dot": e.fillDot
      }, e.class],
      style: e.style
    }, [m("div", {
      class: ["v-timeline-divider__before", u.value],
      style: c.value
    }, null), !e.hideDot && m("div", {
      key: "dot",
      class: ["v-timeline-divider__dot", o.value, s.value, i.value],
      style: l.value
    }, [m("div", {
      class: ["v-timeline-divider__inner-dot", r.value, s.value],
      style: a.value
    }, [n.default ? m(Te, {
      key: "icon-defaults",
      disabled: !e.icon,
      defaults: {
        VIcon: {
          color: e.iconColor,
          icon: e.icon,
          size: e.size
        }
      }
    }, n.default) : m(ze, {
      key: "icon",
      color: e.iconColor,
      icon: e.icon,
      size: e.size
    }, null)])]), m("div", {
      class: ["v-timeline-divider__after", u.value],
      style: c.value
    }, null)])), {};
  }
}), l3 = B({
  density: String,
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  hideOpposite: {
    type: Boolean,
    default: void 0
  },
  icon: Se,
  iconColor: String,
  lineInset: [Number, String],
  ...ue(),
  ...wt(),
  ...Lt(),
  ...at(),
  ...yi(),
  ...Ve()
}, "VTimelineItem"), lx = X()({
  name: "VTimelineItem",
  props: l3(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: i
    } = kt(e), l = ie(0), a = z();
    return ee(a, (r) => {
      var s;
      r && (l.value = ((s = r.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : s.getBoundingClientRect().width) ?? 0);
    }, {
      flush: "post"
    }), F(() => {
      var r, s;
      return m("div", {
        class: ["v-timeline-item", {
          "v-timeline-item--fill-dot": e.fillDot
        }, e.class],
        style: [{
          "--v-timeline-dot-size": se(l.value),
          "--v-timeline-line-inset": e.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${se(e.lineInset)})` : se(0)
        }, e.style]
      }, [m("div", {
        class: "v-timeline-item__body",
        style: i.value
      }, [(r = n.default) == null ? void 0 : r.call(n)]), m(ix, {
        ref: a,
        hideDot: e.hideDot,
        icon: e.icon,
        iconColor: e.iconColor,
        size: e.size,
        elevation: e.elevation,
        dotColor: e.dotColor,
        fillDot: e.fillDot,
        rounded: e.rounded
      }, {
        default: n.icon
      }), e.density !== "compact" && m("div", {
        class: "v-timeline-item__opposite"
      }, [!e.hideOpposite && ((s = n.opposite) == null ? void 0 : s.call(n))])]);
    }), {};
  }
}), ax = B({
  align: {
    type: String,
    default: "center",
    validator: (e) => ["center", "start"].includes(e)
  },
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  justify: {
    type: String,
    default: "auto",
    validator: (e) => ["auto", "center"].includes(e)
  },
  side: {
    type: String,
    validator: (e) => e == null || ["start", "end"].includes(e)
  },
  lineThickness: {
    type: [String, Number],
    default: 2
  },
  lineColor: String,
  truncateLine: {
    type: String,
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  ...hu(l3({
    lineInset: 0
  }), ["dotColor", "fillDot", "hideOpposite", "iconColor", "lineInset", "size"]),
  ...ue(),
  ...Zt(),
  ...Ve(),
  ...Ie()
}, "VTimeline"), rx = X()({
  name: "VTimeline",
  props: ax(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: i
    } = Xe(e), {
      densityClasses: l
    } = nn(e), {
      rtlClasses: a
    } = Qt();
    ht({
      VTimelineDivider: {
        lineColor: H(e, "lineColor")
      },
      VTimelineItem: {
        density: H(e, "density"),
        dotColor: H(e, "dotColor"),
        fillDot: H(e, "fillDot"),
        hideOpposite: H(e, "hideOpposite"),
        iconColor: H(e, "iconColor"),
        lineColor: H(e, "lineColor"),
        lineInset: H(e, "lineInset"),
        size: H(e, "size")
      }
    });
    const r = C(() => {
      const o = e.side ? e.side : e.density !== "default" ? "end" : null;
      return o && `v-timeline--side-${o}`;
    }), s = C(() => {
      const o = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
      switch (e.truncateLine) {
        case "both":
          return o;
        case "start":
          return o[0];
        case "end":
          return o[1];
        default:
          return null;
      }
    });
    return F(() => m(e.tag, {
      class: ["v-timeline", `v-timeline--${e.direction}`, `v-timeline--align-${e.align}`, `v-timeline--justify-${e.justify}`, s.value, {
        "v-timeline--inset-line": !!e.lineInset
      }, i.value, l.value, r.value, a.value, e.class],
      style: [{
        "--v-timeline-line-thickness": se(e.lineThickness)
      }, e.style]
    }, n)), {};
  }
}), sx = B({
  ...ue(),
  ...En({
    variant: "text"
  })
}, "VToolbarItems"), ox = X()({
  name: "VToolbarItems",
  props: sx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ht({
      VBtn: {
        color: H(e, "color"),
        height: "inherit",
        variant: H(e, "variant")
      }
    }), F(() => {
      var i;
      return m("div", {
        class: ["v-toolbar-items", e.class],
        style: e.style
      }, [(i = n.default) == null ? void 0 : i.call(n)]);
    }), {};
  }
}), ux = X()({
  name: "VValidation",
  props: v4(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const i = p4(e, "validation");
    return () => {
      var l;
      return (l = n.default) == null ? void 0 : l.call(n, i);
    };
  }
}), cx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VAlert: rb,
  VAlertTitle: u4,
  VApp: wy,
  VAppBar: Hy,
  VAppBarNavIcon: nb,
  VAppBarTitle: ib,
  VAutocomplete: oC,
  VAvatar: An,
  VBadge: cC,
  VBanner: hC,
  VBannerActions: E4,
  VBannerText: z4,
  VBottomNavigation: gC,
  VBottomSheet: pC,
  VBreadcrumbs: CC,
  VBreadcrumbsDivider: j4,
  VBreadcrumbsItem: X4,
  VBtn: je,
  VBtnGroup: y1,
  VBtnToggle: Fy,
  VCard: PC,
  VCardActions: N4,
  VCardItem: F4,
  VCardSubtitle: q4,
  VCardText: W4,
  VCardTitle: Y4,
  VCarousel: VC,
  VCarouselItem: LC,
  VCheckbox: gb,
  VCheckboxBtn: Vi,
  VChip: Wa,
  VChipGroup: bb,
  VClassIcon: pf,
  VCode: MC,
  VCol: rw,
  VColorPicker: yS,
  VCombobox: SS,
  VComponentIcon: d1,
  VConfirmEdit: kS,
  VContainer: nw,
  VCounter: Qu,
  VDataIterator: AS,
  VDataTable: US,
  VDataTableFooter: Ir,
  VDataTableHeaders: Zl,
  VDataTableRow: Ff,
  VDataTableRows: Il,
  VDataTableServer: ew,
  VDataTableVirtual: KS,
  VDatePicker: yw,
  VDatePickerControls: L1,
  VDatePickerHeader: M1,
  VDatePickerMonth: T1,
  VDatePickerMonths: _1,
  VDatePickerYears: A1,
  VDefaultsProvider: Te,
  VDialog: S1,
  VDialogBottomTransition: $y,
  VDialogTopTransition: Vy,
  VDialogTransition: bu,
  VDivider: fs,
  VEmptyState: Cw,
  VExpandTransition: Cu,
  VExpandXTransition: $f,
  VExpansionPanel: Sw,
  VExpansionPanelText: R1,
  VExpansionPanelTitle: Z1,
  VExpansionPanels: xw,
  VFab: $w,
  VFabTransition: Py,
  VFadeTransition: _r,
  VField: Ua,
  VFieldLabel: fr,
  VFileInput: Qw,
  VFooter: Mw,
  VForm: _w,
  VHover: Rw,
  VIcon: ze,
  VImg: $i,
  VInfiniteScroll: Iw,
  VInput: Ft,
  VItem: Ew,
  VItemGroup: Bw,
  VKbd: zw,
  VLabel: Fa,
  VLayout: jw,
  VLayoutItem: Nw,
  VLazy: Yw,
  VLigatureIcon: bO,
  VList: Vu,
  VListGroup: C1,
  VListImg: jb,
  VListItem: Qi,
  VListItemAction: Nb,
  VListItemMedia: Yb,
  VListItemSubtitle: Q4,
  VListItemTitle: L4,
  VListSubheader: M4,
  VLocaleProvider: Ww,
  VMain: Gw,
  VMenu: La,
  VMessages: m4,
  VNavigationDrawer: rk,
  VNoSsr: sk,
  VOtpInput: uk,
  VOverlay: Fn,
  VPagination: V1,
  VParallax: fk,
  VProgressCircular: Qa,
  VProgressLinear: wu,
  VRadio: mk,
  VRadioGroup: vk,
  VRangeSlider: Ok,
  VRating: bk,
  VResponsive: p1,
  VRow: hw,
  VScaleTransition: xf,
  VScrollXReverseTransition: Ly,
  VScrollXTransition: Qy,
  VScrollYReverseTransition: Ty,
  VScrollYTransition: My,
  VSelect: If,
  VSelectionControl: Ki,
  VSelectionControlGroup: d4,
  VSheet: Rl,
  VSkeletonLoader: kk,
  VSlideGroup: Rr,
  VSlideGroupItem: xk,
  VSlideXReverseTransition: Ay,
  VSlideXTransition: _y,
  VSlideYReverseTransition: Ry,
  VSlideYTransition: Pf,
  VSlider: $1,
  VSnackbar: Vk,
  VSpacer: Z5,
  VSparkline: Tk,
  VSpeedDial: Ak,
  VStepper: zk,
  VStepperActions: U5,
  VStepperHeader: G5,
  VStepperItem: K5,
  VStepperWindow: J5,
  VStepperWindowItem: e3,
  VSvgIcon: vf,
  VSwitch: jk,
  VSystemBar: Nk,
  VTab: t3,
  VTable: Dl,
  VTabs: Gk,
  VTabsWindow: n3,
  VTabsWindowItem: i3,
  VTextField: Tl,
  VTextarea: Jk,
  VThemeProvider: tx,
  VTimeline: rx,
  VTimelineItem: lx,
  VToolbar: O1,
  VToolbarItems: ox,
  VToolbarTitle: kf,
  VTooltip: e4,
  VValidation: ux,
  VVirtualScroll: Mu,
  VWindow: _l,
  VWindowItem: Al
}, Symbol.toStringTag, { value: "Module" })), dx = {
  dark: !1,
  colors: {},
  variables: { "font-family": "Paperlogy, Noto Sans KR, sans-serif" }
}, a3 = {
  defaultTheme: "defaultTheme",
  themes: { defaultTheme: dx }
}, bt = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [i, l] of t)
    n[i] = l;
  return n;
}, fx = {
  __name: "SBtn",
  props: {
    title: {
      type: String,
      required: !1,
      default: ""
    },
    to: {
      type: String,
      required: !1,
      default: null
    },
    height: {
      type: [String, Number],
      required: !1,
      default: null
    },
    size: {
      type: String,
      default: "default",
      // medium
      validator: (e) => ["default", "x-small", "small", "large", "x-large"].includes(e)
    },
    color: {
      type: String,
      default: "blue"
    },
    icon: {
      type: String,
      default: void 0
    }
  },
  setup(e) {
    const t = e, n = v7(), i = C(() => !!(n.icon || t.icon));
    return (l, a) => {
      const r = ae("v-btn");
      return j(), xe(r, {
        class: "s-btn",
        elevation: "0",
        "s-color": e.color,
        size: e.size,
        to: e.to,
        height: e.height,
        icon: e.icon
      }, Gi({ _: 2 }, [
        i.value && !l.$slots.default ? {
          name: "icon",
          fn: W(() => [
            m(Me(ze), null, {
              default: W(() => [
                ke(he(e.icon), 1)
              ]),
              _: 1
            })
          ]),
          key: "0"
        } : {
          name: "default",
          fn: W(() => [
            ke(he(e.title) + " ", 1),
            Ae(l.$slots, "default", {}, void 0, !0)
          ]),
          key: "1"
        }
      ]), 1032, ["s-color", "size", "to", "height", "icon"]);
    };
  }
}, rn = /* @__PURE__ */ bt(fx, [["__scopeId", "data-v-5e15c61d"]]), hx = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_206_5961)'%3e%3cpath%20d='M8%200C3.584%200%200%203.584%200%208C0%2012.416%203.584%2016%208%2016C12.416%2016%2016%2012.416%2016%208C16%203.584%2012.416%200%208%200ZM8.728%2012.92C8.48%2013.168%208.048%2012.992%208.048%2012.64V12C8.032%2012%208.016%2012%208%2012C6.976%2012%205.952%2011.608%205.168%2010.832C4.024%209.688%203.72%208.016%204.256%206.592C4.408%206.184%204.944%206.08%205.248%206.392C5.424%206.568%205.464%206.824%205.384%207.048C5.016%208.04%205.224%209.192%206.024%209.992C6.584%2010.552%207.32%2010.816%208.056%2010.8V10.048C8.056%209.688%208.488%209.512%208.736%209.768L10.032%2011.064C10.192%2011.224%2010.192%2011.472%2010.032%2011.632L8.728%2012.92ZM10.752%209.616C10.576%209.44%2010.536%209.184%2010.616%208.96C10.984%207.968%2010.776%206.816%209.976%206.016C9.416%205.456%208.68%205.184%207.952%205.2V5.952C7.952%206.312%207.52%206.488%207.272%206.232L5.968%204.944C5.808%204.784%205.808%204.536%205.968%204.376L7.264%203.08C7.512%202.832%207.944%203.008%207.944%203.36V4.008C8.984%203.992%2010.032%204.368%2010.824%205.168C11.968%206.312%2012.272%207.984%2011.736%209.408C11.584%209.824%2011.056%209.928%2010.752%209.616Z'%20fill='%231B75BB'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_206_5961'%3e%3crect%20width='16'%20height='16'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e", mx = { class: "position-relative refresh-time-wrapper" }, gx = { class: "refresh-time" }, vx = ["src"], px = {
  __name: "SRefreshBtn",
  props: {
    onClickRefresh: {
      type: Function,
      required: !0
    },
    refreshDate: {
      type: Date,
      default: /* @__PURE__ */ new Date()
    },
    refreshDateTitle: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e, n = C(() => {
      const i = t.refreshDate.getFullYear(), l = (t.refreshDate.getMonth() + 1).toString().padStart(2, "0"), a = t.refreshDate.getDate().toString().padStart(2, "0"), r = t.refreshDate.getHours().toString().padStart(2, "0"), s = t.refreshDate.getMinutes().toString().padStart(2, "0"), o = t.refreshDate.getSeconds().toString().padStart(2, "0");
      return `${i}-${l}-${a} ${r}:${s}:${o}`;
    });
    return (i, l) => (j(), ne("span", mx, [
      G("span", gx, he(e.refreshDateTitle) + " : " + he(n.value), 1),
      G("img", {
        class: "cursor-pointer ml-1 refresh-icon",
        height: "16",
        width: "16",
        src: Me(hx),
        onClick: l[0] || (l[0] = (...a) => e.onClickRefresh && e.onClickRefresh(...a))
      }, null, 8, vx)
    ]));
  }
}, r3 = /* @__PURE__ */ bt(px, [["__scopeId", "data-v-6f5f944d"]]), Ox = {};
function yx(e, t) {
  const n = ae("v-text-field"), i = ae("v-col"), l = ae("v-checkbox"), a = ae("v-row");
  return j(), xe(a, null, {
    default: W(() => [
      m(i, null, {
        default: W(() => [
          m(n, {
            density: "compact",
            variant: "outlined"
          })
        ]),
        _: 1
      }),
      m(i, null, {
        default: W(() => [
          m(l, {
            density: "compact",
            variant: "outlined"
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  });
}
const bx = /* @__PURE__ */ bt(Ox, [["render", yx]]), Cx = { class: "shell-script-wrapper" }, Sx = { class: "line-numbers" }, wx = {
  __name: "SShellScriptInput",
  props: /* @__PURE__ */ So({
    labelTitle: {
      type: String,
      default: null,
      required: !1
    }
  }, {
    modelValue: {
      type: String,
      default: "",
      required: !0
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = tf(e, "modelValue"), n = z(1), i = () => {
      n.value = t.value.split(`
`).length;
    };
    return i(), (l, a) => {
      const r = ae("v-label"), s = ae("v-textarea");
      return j(), ne(le, null, [
        e.labelTitle ? (j(), xe(r, { key: 0 }, {
          default: W(() => [
            ke(he(e.labelTitle), 1)
          ]),
          _: 1
        })) : _e("", !0),
        G("div", Cx, [
          G("div", Sx, [
            (j(!0), ne(le, null, vt(n.value, (o) => (j(), ne("span", { key: o }, he(o), 1))), 128))
          ]),
          m(s, {
            modelValue: t.value,
            "onUpdate:modelValue": a[0] || (a[0] = (o) => t.value = o),
            placeholder: "",
            "auto-grow": "",
            rows: "10",
            outlined: "",
            class: "shell-script-textarea",
            onInput: i
          }, null, 8, ["modelValue"])
        ])
      ], 64);
    };
  }
}, kx = { class: "s-file-input" }, xx = {
  __name: "SFileInputBtn",
  props: {
    placeholder: {
      type: String,
      default: " "
    },
    modelValue: {
      type: [Object, String],
      default: null
    },
    errorMessages: {
      type: Array,
      default: () => []
    },
    btnDisabled: {
      type: Boolean,
      default: !1
    },
    hideDetails: {
      type: [String, Boolean],
      default: "auto"
    },
    buttonText: {
      type: String,
      default: " "
    },
    accept: {
      type: String,
      default: "*"
    }
  },
  emits: ["update:model-value"],
  setup(e, { emit: t }) {
    const n = e, i = t, l = z(null), a = z(null), r = (s) => {
      l.value = s, a.value = s == null ? void 0 : s.name, i("update:model-value", s);
    };
    return it(() => {
      l.value = n.modelValue;
    }), (s, o) => {
      const u = ae("v-file-input"), c = ae("v-text-field");
      return j(), ne("div", kx, [
        m(u, {
          ref: "importFile",
          "model-value": l.value,
          class: "d-none",
          "onUpdate:modelValue": r,
          accept: e.accept
        }, null, 8, ["model-value", "accept"]),
        m(c, {
          "model-value": a.value,
          variant: "outlined",
          density: "compact",
          "hide-details": e.hideDetails,
          readonly: "",
          "error-messages": e.errorMessages,
          placeholder: e.placeholder
        }, null, 8, ["model-value", "hide-details", "error-messages", "placeholder"]),
        m(Me(rn), {
          height: "30",
          variant: "outlined",
          disabled: e.btnDisabled,
          onClick: o[0] || (o[0] = (d) => s.$refs.importFile.click())
        }, {
          default: W(() => [
            m(Me(ru), {
              name: "file",
              size: 16,
              class: "mr-1"
            }),
            ke(" " + he(e.buttonText), 1)
          ]),
          _: 1
        }, 8, ["disabled"])
      ]);
    };
  }
}, Px = { class: "s-key-value-selector__filter" }, $x = { class: "s-key-value-selector__table" }, Vx = { key: 0 }, Qx = {
  colspan: "3",
  class: "s-key-value-selector__empty"
}, Lx = { class: "s-key-value-selector__add-item" }, Mx = { class: "s-key-value-selector__actions" }, Tx = { class: "s-key-value-selector__buttons" }, _x = {
  __name: "SKeyValueSelect",
  props: {
    items: {
      type: Array,
      default: () => []
    },
    keyList: {
      type: Array,
      default: () => []
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    displayText: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "labels",
      validator: (e) => ["labels", "tags"].includes(e)
    },
    applyButtonText: {
      type: String,
      default: ""
    },
    cancelButtonText: {
      type: String,
      default: ""
    },
    resetButtonText: {
      type: String,
      default: ""
    },
    typeText: {
      type: Object,
      default: () => ({
        title: null,
        key: null,
        value: null,
        add: null,
        select: null
      }),
      description: "   "
    },
    allSelectButtonText: {
      type: String,
      default: " "
    },
    getValueList: {
      type: Function,
      default: () => []
    },
    density: {
      type: String,
      default: "comfortable"
    },
    width: {
      type: [String, Number],
      default: 316
    }
  },
  emits: [
    "update:model-value",
    "cancel",
    "apply",
    "add-label"
  ],
  setup(e, { emit: t }) {
    const n = e, i = t, l = z([]), a = z([]), r = z(!1), s = z({}), o = async (S) => {
      const P = S.filter((_) => _ && !s.value[_]);
      if (!P.length) return;
      const T = P.map(async (_) => {
        try {
          const D = { keys: [_] };
          let N = [];
          N = await n.getValueList(n.type, D);
          let K = [];
          return N.length > 0 && typeof N[0] == "object" && "value" in N[0] ? K = N.map((E) => {
            const { value: I } = E, Z = I.split(":");
            return Z.length > 1 ? Z[1] : I;
          }) : K = N.map((E) => {
            const I = E.split(":");
            return I.length > 1 ? I[1] : E;
          }), { key: _, values: K };
        } catch (D) {
          return console.error("Failed to fetch values for key:", _, D), { key: _, values: [] };
        }
      });
      try {
        (await Promise.all(T)).forEach(({ key: D, values: N }) => {
          s.value[D] = N;
        });
      } catch (_) {
        console.error("Error fetching value lists in parallel:", _);
      }
    };
    it(() => {
      l.value = [...n.modelValue || []], a.value = [];
      const S = l.value.map((P) => P.key).filter(Boolean);
      S.length > 0 && o(S);
    }), ee(
      () => n.modelValue,
      (S) => {
        l.value = [...S || []], r.value || (a.value = []);
        const P = S.map((T) => T.key).filter(Boolean);
        P.length > 0 && o(P);
      },
      { deep: !0 }
    ), ee(
      () => r.value,
      (S) => {
        S && (a.value = l.value.map((P) => ({
          key: P.key,
          values: [...P.values],
          isKeyMenuOpen: !1,
          isValueMenuOpen: !1
        })));
      }
    );
    const u = C(() => a.value.some((S) => {
      var P;
      return S.key && ((P = S.values) == null ? void 0 : P.length) > 0;
    }) || a.value.length > 0), c = C(() => {
      var P;
      if (n.displayText) return n.displayText;
      const S = ((P = n.modelValue) == null ? void 0 : P.filter((T) => T.key && T.values.length > 0).length) || 0;
      return S === 0 ? n.typeText.empty : `${n.typeText.title} ${S}`;
    }), d = () => n.keyList.at(0) === typeof {} ? n.keyList.map((P) => P.key) : n.keyList, f = (S) => {
      var P;
      return (P = a.value[S]) != null && P.key ? s.value[a.value[S].key] ? s.value[a.value[S].key] : [] : [];
    }, h = () => {
      a.value.push({
        key: "",
        values: [],
        isKeyMenuOpen: !1,
        isValueMenuOpen: !1
      });
    }, g = async (S, P) => {
      a.value[P].key = S, a.value[P].values = [], a.value[P].isKeyMenuOpen = !1, s.value[S] || o([S]);
    }, v = (S, P) => {
      const T = a.value[P], _ = T.values.indexOf(S);
      _ === -1 ? T.values.push(S) : T.values.splice(_, 1);
    }, p = (S) => a.value[S].values.length === f(S).length, O = (S) => a.value[S].values.length > 0 && !p(S), b = (S) => {
      const P = a.value[S];
      p(S) ? P.values = [] : P.values = [...f(S)];
    }, V = (S) => {
      a.value.splice(S, 1);
    }, $ = () => {
      l.value = [...n.modelValue || []], a.value = [], r.value = !1, i("cancel");
    }, x = () => {
      const S = a.value.filter(
        (P) => P.key && P.values.length
      );
      l.value = [...S], i(
        "update:model-value",
        S.map((P) => ({
          key: P.key,
          values: P.values
        }))
      ), i(
        "apply",
        S.map((P) => ({
          key: P.key,
          values: P.values
        }))
      ), r.value = !1, a.value = [];
    }, Q = (S, P) => {
      P == null || P.stopPropagation();
    }, M = (S, P) => {
      P == null || P.stopPropagation(), S.isKeyMenuOpen || (S.isValueMenuOpen = !1);
    }, w = (S) => {
      if (a.value.some(
        (_) => _.isKeyMenuOpen || _.isValueMenuOpen
      )) {
        S == null || S.preventDefault(), S == null || S.stopPropagation();
        return;
      }
      const T = a.value.filter(
        (_) => _.key && _.values.length
      );
      l.value = [...T], i(
        "update:model-value",
        T.map((_) => ({
          key: _.key,
          values: _.values
        }))
      ), i(
        "apply",
        T.map((_) => ({
          key: _.key,
          values: _.values
        }))
      ), r.value = !1, a.value = [];
    }, y = C(() => a.value.filter((S) => S)), L = (S) => {
      const P = a.value[S];
      P.values = [], P.isValueMenuOpen = !1;
    }, k = (S) => {
      const P = a.value[S];
      P.isValueMenuOpen = !1;
    };
    return (S, P) => {
      const T = ae("v-list-item"), _ = ae("v-list"), D = ae("v-menu"), N = ae("v-checkbox-btn"), K = ae("v-divider"), E = ae("v-list-item-action");
      return j(), xe(D, {
        modelValue: r.value,
        "onUpdate:modelValue": P[0] || (P[0] = (I) => r.value = I),
        class: "s-key-value-selector",
        "close-on-content-click": !1,
        "close-on-click": !1,
        "max-height": 300,
        location: "bottom",
        offset: 5,
        transition: "scroll-y-transition",
        "onClick:outside": w
      }, {
        activator: W(({ props: I, isActive: Z }) => [
          m(Me(rn), q(I, {
            width: e.width,
            class: "s-key-value-selector__button",
            variant: "outlined",
            color: "black",
            density: e.density,
            "append-icon": Z ? "mdi-menu-up" : "mdi-menu-down"
          }), {
            default: W(() => [
              ke(he(c.value), 1)
            ]),
            _: 2
          }, 1040, ["width", "density", "append-icon"])
        ]),
        default: W(() => [
          m(_, { class: "s-key-value-selector__list" }, {
            default: W(() => [
              G("div", Px, [
                G("table", $x, [
                  G("thead", null, [
                    G("tr", null, [
                      G("th", null, he(e.typeText.key), 1),
                      G("th", null, he(e.typeText.value), 1),
                      P[1] || (P[1] = G("th", { width: "40" }, null, -1))
                    ])
                  ]),
                  G("tbody", null, [
                    !u.value && !a.value.length ? (j(), ne("tr", Vx, [
                      G("td", Qx, [
                        G("div", Lx, he(e.typeText.empty), 1)
                      ])
                    ])) : _e("", !0),
                    (j(!0), ne(le, null, vt(y.value, (I, Z) => (j(), ne("tr", {
                      key: "adding-" + Z
                    }, [
                      G("td", null, [
                        I ? (j(), xe(D, {
                          key: 0,
                          "close-on-content-click": !1,
                          "close-on-click": !1,
                          modelValue: I.isKeyMenuOpen,
                          "onUpdate:modelValue": (Y) => I.isKeyMenuOpen = Y,
                          "max-height": 300,
                          location: "bottom",
                          offset: 5,
                          density: "compact",
                          transition: "scroll-y-transition",
                          "onClick:outside": _t((Y) => Q(I, Y), ["stop"])
                        }, {
                          activator: W(({ props: Y, isActive: ce }) => [
                            m(Me(rn), q({ ref_for: !0 }, Y, {
                              variant: "outlined",
                              color: "black",
                              class: "s-key-value-selector__button",
                              "append-icon": ce ? "mdi-menu-up" : "mdi-menu-down"
                            }), {
                              default: W(() => [
                                ke(he(I.key || e.typeText.select), 1)
                              ]),
                              _: 2
                            }, 1040, ["append-icon"])
                          ]),
                          default: W(() => [
                            m(_, null, {
                              default: W(() => [
                                (j(!0), ne(le, null, vt(d(), (Y) => (j(), xe(T, {
                                  class: "s-key-value-selector__list-item",
                                  key: Y,
                                  value: Y,
                                  onClick: (ce) => g(Y, Z)
                                }, {
                                  default: W(() => [
                                    ke(he(Y), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["value", "onClick"]))), 128))
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1032, ["modelValue", "onUpdate:modelValue", "onClick:outside"])) : _e("", !0)
                      ]),
                      G("td", null, [
                        I ? (j(), xe(D, {
                          key: 0,
                          "close-on-content-click": !1,
                          "close-on-click": !1,
                          modelValue: I.isValueMenuOpen,
                          "onUpdate:modelValue": (Y) => I.isValueMenuOpen = Y,
                          "max-height": 300,
                          location: "bottom",
                          offset: 5,
                          transition: "scroll-y-transition",
                          "onClick:outside": _t((Y) => M(I, Y), ["stop"])
                        }, {
                          activator: W(({ props: Y, isActive: ce }) => [
                            m(Me(rn), q({ ref_for: !0 }, Y, {
                              variant: "outlined",
                              color: "black",
                              class: "s-key-value-selector__button",
                              disabled: !I.key,
                              "append-icon": ce ? "mdi-menu-up" : "mdi-menu-down"
                            }), {
                              default: W(() => [
                                ke(he(I.values.length ? `${e.typeText.value} ${I.values.length}` : e.typeText.selectValue), 1)
                              ]),
                              _: 2
                            }, 1040, ["disabled", "append-icon"])
                          ]),
                          default: W(() => [
                            m(_, { density: e.density }, {
                              default: W(() => [
                                m(T, {
                                  class: "s-key-value-selector__list-item",
                                  title: e.allSelectButtonText,
                                  onClick: _t((Y) => b(Z), ["stop"]),
                                  disabled: !I.key
                                }, {
                                  prepend: W(() => [
                                    m(N, {
                                      density: "compact",
                                      class: "s-key-value-selector__checkbox-btn",
                                      "model-value": p(Z),
                                      indeterminate: O(Z),
                                      disabled: !I.key
                                    }, null, 8, ["model-value", "indeterminate", "disabled"])
                                  ]),
                                  _: 2
                                }, 1032, ["title", "onClick", "disabled"]),
                                m(K),
                                (j(!0), ne(le, null, vt(f(Z), (Y) => (j(), xe(T, {
                                  key: Y,
                                  value: Y,
                                  class: ct(["s-key-value-selector__list-item", { "v-list-item--active": I.values.includes(Y) }]),
                                  onClick: _t((ce) => v(Y, Z), ["stop"]),
                                  disabled: !I.key
                                }, {
                                  prepend: W(() => [
                                    m(N, {
                                      density: "compact",
                                      class: "s-key-value-selector__checkbox-btn",
                                      "model-value": I.values.includes(Y),
                                      disabled: !I.key
                                    }, null, 8, ["model-value", "disabled"])
                                  ]),
                                  default: W(() => [
                                    ke(" " + he(Y), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["value", "class", "onClick", "disabled"]))), 128)),
                                f(Z).length > 0 ? (j(), xe(K, { key: 0 })) : _e("", !0),
                                m(E, { class: "s-key-value-selector__value-actions" }, {
                                  default: W(() => [
                                    m(Me(rn), {
                                      variant: "text",
                                      density: "compact",
                                      class: "s-key-value-selector__value-btn",
                                      onClick: _t((Y) => L(Z), ["stop"])
                                    }, {
                                      default: W(() => [
                                        ke(he(e.resetButtonText), 1)
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"]),
                                    m(Me(rn), {
                                      variant: "text",
                                      density: "compact",
                                      class: "s-key-value-selector__value-btn s-key-value-selector__value-btn--apply",
                                      onClick: _t((Y) => k(Z), ["stop"])
                                    }, {
                                      default: W(() => [
                                        ke(he(e.applyButtonText), 1)
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"])
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1032, ["density"])
                          ]),
                          _: 2
                        }, 1032, ["modelValue", "onUpdate:modelValue", "onClick:outside"])) : _e("", !0)
                      ]),
                      G("td", null, [
                        m(Me(rn), {
                          density: "compact",
                          icon: "mdi-minus-circle",
                          variant: "text",
                          color: "red",
                          onClick: (Y) => V(Z)
                        }, null, 8, ["onClick"])
                      ])
                    ]))), 128))
                  ])
                ])
              ]),
              G("div", Mx, [
                m(Me(rn), {
                  class: "s-key-value-selector__add-btn",
                  variant: "text",
                  "prepend-icon": "mdi-plus",
                  onClick: h
                }, {
                  default: W(() => [
                    ke(he(e.typeText.add), 1)
                  ]),
                  _: 1
                }),
                G("div", Tx, [
                  m(Me(rn), {
                    variant: "outlined",
                    onClick: $
                  }, {
                    default: W(() => [
                      ke(he(e.cancelButtonText), 1)
                    ]),
                    _: 1
                  }),
                  m(Me(rn), {
                    onClick: x,
                    disabled: a.value.length > 0 && !a.value.some((I) => I.key && I.values.length)
                  }, {
                    default: W(() => [
                      ke(he(e.applyButtonText), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]);
    };
  }
}, Ax = /* @__PURE__ */ bt(_x, [["__scopeId", "data-v-77fb0d78"]]), Rx = { class: "s-alert" }, Zx = {
  __name: "SAlert",
  props: {
    titleName: {
      type: String,
      default: "",
      description: " "
    },
    modelValue: {
      type: Boolean,
      default: !1,
      description: "  "
    },
    multiLine: {
      type: Boolean,
      default: !1,
      description: "    ."
    },
    color: {
      type: String,
      default: "#036EB8",
      description: " "
    },
    height: {
      type: [String, Number],
      default: "48px",
      description: " "
    },
    width: {
      type: [String, Number],
      default: "450px",
      description: " "
    },
    timeout: {
      type: Number,
      default: 5e3,
      description: "  "
    },
    isClose: {
      type: Boolean,
      default: !0,
      description: "Close   "
    },
    alertStyle: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:model-value"],
  setup(e, { emit: t }) {
    const n = t, i = e, l = z(i.modelValue), a = (s) => {
      l.value = s, n("update:model-value", s);
    }, r = () => {
      l.value = !1, n("update:model-value", !1);
    };
    return ft(() => {
      l.value = i.modelValue;
    }), (s, o) => {
      const u = ae("v-snackbar");
      return j(), ne("div", Rx, [
        m(u, {
          style: on(e.alertStyle),
          "model-value": l.value,
          "multi-line": e.multiLine,
          timeout: e.timeout,
          color: e.color,
          height: e.height,
          elevation: "0",
          "min-width": "600",
          location: "top",
          "onUpdate:modelValue": a
        }, {
          actions: W(() => [
            e.isClose ? (j(), xe(rn, {
              key: 0,
              color: "#fff",
              variant: "text",
              onClick: r
            }, {
              default: W(() => o[0] || (o[0] = [
                ke("Close")
              ])),
              _: 1
            })) : _e("", !0)
          ]),
          default: W(() => [
            Ae(s.$slots, "alert-icon"),
            G("pre", null, he(e.titleName), 1)
          ]),
          _: 3
        }, 8, ["style", "model-value", "multi-line", "timeout", "color", "height"])
      ]);
    };
  }
}, Ix = { class: "s-empty" }, Dx = {
  key: 0,
  class: "s-empty__card-title"
}, Bx = { class: "s-empty__card-content" }, Ex = { style: { color: "#007bff", "font-size": "18px" } }, zx = {
  __name: "SEmpty",
  props: {
    title: {
      type: String,
      default: "",
      description: "empty "
    },
    description: {
      type: String,
      default: "",
      description: "empty "
    },
    elevation: {
      type: [Number, String],
      description: "   0~24 ",
      default: void 0
    },
    outlined: {
      type: Boolean,
      description: "  ",
      default: !0
    },
    shadowed: {
      type: Boolean,
      description: "    on/off",
      default: !0
    },
    onClick: {
      type: Function,
      description: "description  ",
      default: void 0
    }
  },
  setup(e) {
    return (t, n) => {
      const i = ae("v-btn"), l = ae("v-sheet");
      return j(), ne("div", Ix, [
        m(l, {
          class: "s-empty__card",
          elevation: e.elevation,
          border: "",
          rounded: "",
          shadowed: e.shadowed
        }, {
          default: W(() => [
            e.title ? (j(), ne("div", Dx, he(e.title), 1)) : _e("", !0),
            G("div", Bx, [
              e.onClick ? (j(), xe(i, {
                key: 0,
                flat: "",
                onClick: e.onClick
              }, {
                default: W(() => [
                  G("span", Ex, he(e.description), 1)
                ]),
                _: 1
              }, 8, ["onClick"])) : (j(), ne(le, { key: 1 }, [
                ke(he(e.description), 1)
              ], 64))
            ]),
            Ae(t.$slots, "default", {}, void 0, !0)
          ]),
          _: 3
        }, 8, ["elevation", "shadowed"])
      ]);
    };
  }
}, s3 = /* @__PURE__ */ bt(zx, [["__scopeId", "data-v-3cf38698"]]);
class Ne {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, n, i) {
    [t, n] = Ma(this, t, n);
    let l = [];
    return this.decompose(
      0,
      t,
      l,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      l,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      l,
      1
      /* Open.From */
    ), ai.from(l, this.length - (n - t) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, n = this.length) {
    [t, n] = Ma(this, t, n);
    let i = [];
    return this.decompose(t, n, i, 0), ai.from(i, n - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let n = this.scanIdentical(t, 1), i = this.length - this.scanIdentical(t, -1), l = new yr(this), a = new yr(t);
    for (let r = n, s = n; ; ) {
      if (l.next(r), a.next(r), r = 0, l.lineBreak != a.lineBreak || l.done != a.done || l.value != a.value)
        return !1;
      if (s += l.value.length, l.done || s >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new yr(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, n = this.length) {
    return new o3(this, t, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, n) {
    let i;
    if (t == null)
      i = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let l = this.line(t).from;
      i = this.iterRange(l, Math.max(l, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new u3(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? Ne.empty : t.length <= 32 ? new Ct(t) : ai.from(Ct.split(t, []));
  }
}
class Ct extends Ne {
  constructor(t, n = Hx(t)) {
    super(), this.text = t, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, n, i, l) {
    for (let a = 0; ; a++) {
      let r = this.text[a], s = l + r.length;
      if ((n ? i : s) >= t)
        return new jx(l, s, i, r);
      l = s + 1, i++;
    }
  }
  decompose(t, n, i, l) {
    let a = t <= 0 && n >= this.length ? this : new Ct(a0(this.text, t, n), Math.min(n, this.length) - Math.max(0, t));
    if (l & 1) {
      let r = i.pop(), s = so(a.text, r.text.slice(), 0, a.length);
      if (s.length <= 32)
        i.push(new Ct(s, r.length + a.length));
      else {
        let o = s.length >> 1;
        i.push(new Ct(s.slice(0, o)), new Ct(s.slice(o)));
      }
    } else
      i.push(a);
  }
  replace(t, n, i) {
    if (!(i instanceof Ct))
      return super.replace(t, n, i);
    [t, n] = Ma(this, t, n);
    let l = so(this.text, so(i.text, a0(this.text, 0, t)), n), a = this.length + i.length - (n - t);
    return l.length <= 32 ? new Ct(l, a) : ai.from(Ct.split(l, []), a);
  }
  sliceString(t, n = this.length, i = `
`) {
    [t, n] = Ma(this, t, n);
    let l = "";
    for (let a = 0, r = 0; a <= n && r < this.text.length; r++) {
      let s = this.text[r], o = a + s.length;
      a > t && r && (l += i), t < o && n > a && (l += s.slice(Math.max(0, t - a), n - a)), a = o + 1;
    }
    return l;
  }
  flatten(t) {
    for (let n of this.text)
      t.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, n) {
    let i = [], l = -1;
    for (let a of t)
      i.push(a), l += a.length + 1, i.length == 32 && (n.push(new Ct(i, l)), i = [], l = -1);
    return l > -1 && n.push(new Ct(i, l)), n;
  }
}
class ai extends Ne {
  constructor(t, n) {
    super(), this.children = t, this.length = n, this.lines = 0;
    for (let i of t)
      this.lines += i.lines;
  }
  lineInner(t, n, i, l) {
    for (let a = 0; ; a++) {
      let r = this.children[a], s = l + r.length, o = i + r.lines - 1;
      if ((n ? o : s) >= t)
        return r.lineInner(t, n, i, l);
      l = s + 1, i = o + 1;
    }
  }
  decompose(t, n, i, l) {
    for (let a = 0, r = 0; r <= n && a < this.children.length; a++) {
      let s = this.children[a], o = r + s.length;
      if (t <= o && n >= r) {
        let u = l & ((r <= t ? 1 : 0) | (o >= n ? 2 : 0));
        r >= t && o <= n && !u ? i.push(s) : s.decompose(t - r, n - r, i, u);
      }
      r = o + 1;
    }
  }
  replace(t, n, i) {
    if ([t, n] = Ma(this, t, n), i.lines < this.lines)
      for (let l = 0, a = 0; l < this.children.length; l++) {
        let r = this.children[l], s = a + r.length;
        if (t >= a && n <= s) {
          let o = r.replace(t - a, n - a, i), u = this.lines - r.lines + o.lines;
          if (o.lines < u >> 4 && o.lines > u >> 6) {
            let c = this.children.slice();
            return c[l] = o, new ai(c, this.length - (n - t) + i.length);
          }
          return super.replace(a, s, o);
        }
        a = s + 1;
      }
    return super.replace(t, n, i);
  }
  sliceString(t, n = this.length, i = `
`) {
    [t, n] = Ma(this, t, n);
    let l = "";
    for (let a = 0, r = 0; a < this.children.length && r <= n; a++) {
      let s = this.children[a], o = r + s.length;
      r > t && a && (l += i), t < o && n > r && (l += s.sliceString(t - r, n - r, i)), r = o + 1;
    }
    return l;
  }
  flatten(t) {
    for (let n of this.children)
      n.flatten(t);
  }
  scanIdentical(t, n) {
    if (!(t instanceof ai))
      return 0;
    let i = 0, [l, a, r, s] = n > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; l += n, a += n) {
      if (l == r || a == s)
        return i;
      let o = this.children[l], u = t.children[a];
      if (o != u)
        return i + o.scanIdentical(u, n);
      i += o.length + 1;
    }
  }
  static from(t, n = t.reduce((i, l) => i + l.length + 1, -1)) {
    let i = 0;
    for (let h of t)
      i += h.lines;
    if (i < 32) {
      let h = [];
      for (let g of t)
        g.flatten(h);
      return new Ct(h, n);
    }
    let l = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), a = l << 1, r = l >> 1, s = [], o = 0, u = -1, c = [];
    function d(h) {
      let g;
      if (h.lines > a && h instanceof ai)
        for (let v of h.children)
          d(v);
      else h.lines > r && (o > r || !o) ? (f(), s.push(h)) : h instanceof Ct && o && (g = c[c.length - 1]) instanceof Ct && h.lines + g.lines <= 32 ? (o += h.lines, u += h.length + 1, c[c.length - 1] = new Ct(g.text.concat(h.text), g.length + 1 + h.length)) : (o + h.lines > l && f(), o += h.lines, u += h.length + 1, c.push(h));
    }
    function f() {
      o != 0 && (s.push(c.length == 1 ? c[0] : ai.from(c, u)), u = -1, o = c.length = 0);
    }
    for (let h of t)
      d(h);
    return f(), s.length == 1 ? s[0] : new ai(s, n);
  }
}
Ne.empty = /* @__PURE__ */ new Ct([""], 0);
function Hx(e) {
  let t = -1;
  for (let n of e)
    t += n.length + 1;
  return t;
}
function so(e, t, n = 0, i = 1e9) {
  for (let l = 0, a = 0, r = !0; a < e.length && l <= i; a++) {
    let s = e[a], o = l + s.length;
    o >= n && (o > i && (s = s.slice(0, i - l)), l < n && (s = s.slice(n - l)), r ? (t[t.length - 1] += s, r = !1) : t.push(s)), l = o + 1;
  }
  return t;
}
function a0(e, t, n) {
  return so(e, [""], t, n);
}
class yr {
  constructor(t, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [n > 0 ? 1 : (t instanceof Ct ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, l = this.nodes[i], a = this.offsets[i], r = a >> 1, s = l instanceof Ct ? l.text.length : l.children.length;
      if (r == (n > 0 ? s : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((a & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[i] += n, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (l instanceof Ct) {
        let o = l.text[r + (n < 0 ? -1 : 0)];
        if (this.offsets[i] += n, o.length > Math.max(0, t))
          return this.value = t == 0 ? o : n > 0 ? o.slice(t) : o.slice(0, o.length - t), this;
        t -= o.length;
      } else {
        let o = l.children[r + (n < 0 ? -1 : 0)];
        t > o.length ? (t -= o.length, this.offsets[i] += n) : (n < 0 && this.offsets[i]--, this.nodes.push(o), this.offsets.push(n > 0 ? 1 : (o instanceof Ct ? o.text.length : o.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}
class o3 {
  constructor(t, n, i) {
    this.value = "", this.done = !1, this.cursor = new yr(t, n > i ? -1 : 1), this.pos = n > i ? t.length : 0, this.from = Math.min(n, i), this.to = Math.max(n, i);
  }
  nextInner(t, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let i = n < 0 ? this.pos - this.from : this.to - this.pos;
    t > i && (t = i), i -= t;
    let { value: l } = this.cursor.next(t);
    return this.pos += (l.length + t) * n, this.value = l.length <= i ? l : n < 0 ? l.slice(l.length - i) : l.slice(0, i), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class u3 {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: n, lineBreak: i, value: l } = this.inner.next(t);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = l, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Ne.prototype[Symbol.iterator] = function() {
  return this.iter();
}, yr.prototype[Symbol.iterator] = o3.prototype[Symbol.iterator] = u3.prototype[Symbol.iterator] = function() {
  return this;
});
class jx {
  /**
  @internal
  */
  constructor(t, n, i, l) {
    this.from = t, this.to = n, this.number = i, this.text = l;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Ma(e, t, n) {
  return t = Math.max(0, Math.min(e.length, t)), [t, Math.max(t, Math.min(e.length, n))];
}
let Oa = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
for (let e = 1; e < Oa.length; e++)
  Oa[e] += Oa[e - 1];
function Xx(e) {
  for (let t = 1; t < Oa.length; t += 2)
    if (Oa[t] > e)
      return Oa[t - 1] <= e;
  return !1;
}
function r0(e) {
  return e >= 127462 && e <= 127487;
}
const s0 = 8205;
function qt(e, t, n = !0, i = !0) {
  return (n ? c3 : Nx)(e, t, i);
}
function c3(e, t, n) {
  if (t == e.length)
    return t;
  t && d3(e.charCodeAt(t)) && f3(e.charCodeAt(t - 1)) && t--;
  let i = Ht(e, t);
  for (t += Ln(i); t < e.length; ) {
    let l = Ht(e, t);
    if (i == s0 || l == s0 || n && Xx(l))
      t += Ln(l), i = l;
    else if (r0(l)) {
      let a = 0, r = t - 2;
      for (; r >= 0 && r0(Ht(e, r)); )
        a++, r -= 2;
      if (a % 2 == 0)
        break;
      t += 2;
    } else
      break;
  }
  return t;
}
function Nx(e, t, n) {
  for (; t > 0; ) {
    let i = c3(e, t - 2, n);
    if (i < t)
      return i;
    t--;
  }
  return 0;
}
function d3(e) {
  return e >= 56320 && e < 57344;
}
function f3(e) {
  return e >= 55296 && e < 56320;
}
function Ht(e, t) {
  let n = e.charCodeAt(t);
  if (!f3(n) || t + 1 == e.length)
    return n;
  let i = e.charCodeAt(t + 1);
  return d3(i) ? (n - 55296 << 10) + (i - 56320) + 65536 : n;
}
function th(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
function Ln(e) {
  return e < 65536 ? 1 : 2;
}
const I1 = /\r\n?|\n/;
var Nt = /* @__PURE__ */ function(e) {
  return e[e.Simple = 0] = "Simple", e[e.TrackDel = 1] = "TrackDel", e[e.TrackBefore = 2] = "TrackBefore", e[e.TrackAfter = 3] = "TrackAfter", e;
}(Nt || (Nt = {}));
class fi {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      t += this.sections[n];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let i = this.sections[n + 1];
      t += i < 0 ? this.sections[n] : i;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let n = 0, i = 0, l = 0; n < this.sections.length; ) {
      let a = this.sections[n++], r = this.sections[n++];
      r < 0 ? (t(i, l, a), l += a) : l += r, i += a;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, n = !1) {
    D1(this, t, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let n = 0; n < this.sections.length; ) {
      let i = this.sections[n++], l = this.sections[n++];
      l < 0 ? t.push(i, l) : t.push(l, i);
    }
    return new fi(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : h3(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(t, n = !1) {
    return t.empty ? this : B1(this, t, n);
  }
  mapPos(t, n = -1, i = Nt.Simple) {
    let l = 0, a = 0;
    for (let r = 0; r < this.sections.length; ) {
      let s = this.sections[r++], o = this.sections[r++], u = l + s;
      if (o < 0) {
        if (u > t)
          return a + (t - l);
        a += s;
      } else {
        if (i != Nt.Simple && u >= t && (i == Nt.TrackDel && l < t && u > t || i == Nt.TrackBefore && l < t || i == Nt.TrackAfter && u > t))
          return null;
        if (u > t || u == t && n < 0 && !s)
          return t == l || n < 0 ? a : a + o;
        a += o;
      }
      l = u;
    }
    if (t > l)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${l}`);
    return a;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, n = t) {
    for (let i = 0, l = 0; i < this.sections.length && l <= n; ) {
      let a = this.sections[i++], r = this.sections[i++], s = l + a;
      if (r >= 0 && l <= n && s >= t)
        return l < t && s > n ? "cover" : !0;
      l = s;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let n = 0; n < this.sections.length; ) {
      let i = this.sections[n++], l = this.sections[n++];
      t += (t ? " " : "") + i + (l >= 0 ? ":" + l : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new fi(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new fi(t);
  }
}
class Tt extends fi {
  constructor(t, n) {
    super(t), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return D1(this, (n, i, l, a, r) => t = t.replace(l, l + (i - n), r), !1), t;
  }
  mapDesc(t, n = !1) {
    return B1(this, t, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let n = this.sections.slice(), i = [];
    for (let l = 0, a = 0; l < n.length; l += 2) {
      let r = n[l], s = n[l + 1];
      if (s >= 0) {
        n[l] = s, n[l + 1] = r;
        let o = l >> 1;
        for (; i.length < o; )
          i.push(Ne.empty);
        i.push(r ? t.slice(a, a + r) : Ne.empty);
      }
      a += r;
    }
    return new Tt(n, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : h3(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, n = !1) {
    return t.empty ? this : B1(this, t, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, n = !1) {
    D1(this, t, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return fi.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let n = [], i = [], l = [], a = new Br(this);
    e: for (let r = 0, s = 0; ; ) {
      let o = r == t.length ? 1e9 : t[r++];
      for (; s < o || s == o && a.len == 0; ) {
        if (a.done)
          break e;
        let c = Math.min(a.len, o - s);
        Gt(l, c, -1);
        let d = a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0;
        Gt(n, c, d), d > 0 && Ni(i, n, a.text), a.forward(c), s += c;
      }
      let u = t[r++];
      for (; s < u; ) {
        if (a.done)
          break e;
        let c = Math.min(a.len, u - s);
        Gt(n, c, -1), Gt(l, c, a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0), a.forward(c), s += c;
      }
    }
    return {
      changes: new Tt(n, i),
      filtered: fi.create(l)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let i = this.sections[n], l = this.sections[n + 1];
      l < 0 ? t.push(i) : l == 0 ? t.push([i]) : t.push([i].concat(this.inserted[n >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, n, i) {
    let l = [], a = [], r = 0, s = null;
    function o(c = !1) {
      if (!c && !l.length)
        return;
      r < n && Gt(l, n - r, -1);
      let d = new Tt(l, a);
      s = s ? s.compose(d.map(s)) : d, l = [], a = [], r = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let d of c)
          u(d);
      else if (c instanceof Tt) {
        if (c.length != n)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${n})`);
        o(), s = s ? s.compose(c.map(s)) : c;
      } else {
        let { from: d, to: f = d, insert: h } = c;
        if (d > f || d < 0 || f > n)
          throw new RangeError(`Invalid change range ${d} to ${f} (in doc of length ${n})`);
        let g = h ? typeof h == "string" ? Ne.of(h.split(i || I1)) : h : Ne.empty, v = g.length;
        if (d == f && v == 0)
          return;
        d < r && o(), d > r && Gt(l, d - r, -1), Gt(l, f - d, v), Ni(a, l, g), r = f;
      }
    }
    return u(t), o(!s), s;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new Tt(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], i = [];
    for (let l = 0; l < t.length; l++) {
      let a = t[l];
      if (typeof a == "number")
        n.push(a, -1);
      else {
        if (!Array.isArray(a) || typeof a[0] != "number" || a.some((r, s) => s && typeof r != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (a.length == 1)
          n.push(a[0], 0);
        else {
          for (; i.length < l; )
            i.push(Ne.empty);
          i[l] = Ne.of(a.slice(1)), n.push(a[0], i[l].length);
        }
      }
    }
    return new Tt(n, i);
  }
  /**
  @internal
  */
  static createSet(t, n) {
    return new Tt(t, n);
  }
}
function Gt(e, t, n, i = !1) {
  if (t == 0 && n <= 0)
    return;
  let l = e.length - 2;
  l >= 0 && n <= 0 && n == e[l + 1] ? e[l] += t : t == 0 && e[l] == 0 ? e[l + 1] += n : i ? (e[l] += t, e[l + 1] += n) : e.push(t, n);
}
function Ni(e, t, n) {
  if (n.length == 0)
    return;
  let i = t.length - 2 >> 1;
  if (i < e.length)
    e[e.length - 1] = e[e.length - 1].append(n);
  else {
    for (; e.length < i; )
      e.push(Ne.empty);
    e.push(n);
  }
}
function D1(e, t, n) {
  let i = e.inserted;
  for (let l = 0, a = 0, r = 0; r < e.sections.length; ) {
    let s = e.sections[r++], o = e.sections[r++];
    if (o < 0)
      l += s, a += s;
    else {
      let u = l, c = a, d = Ne.empty;
      for (; u += s, c += o, o && i && (d = d.append(i[r - 2 >> 1])), !(n || r == e.sections.length || e.sections[r + 1] < 0); )
        s = e.sections[r++], o = e.sections[r++];
      t(l, u, a, c, d), l = u, a = c;
    }
  }
}
function B1(e, t, n, i = !1) {
  let l = [], a = i ? [] : null, r = new Br(e), s = new Br(t);
  for (let o = -1; ; )
    if (r.ins == -1 && s.ins == -1) {
      let u = Math.min(r.len, s.len);
      Gt(l, u, -1), r.forward(u), s.forward(u);
    } else if (s.ins >= 0 && (r.ins < 0 || o == r.i || r.off == 0 && (s.len < r.len || s.len == r.len && !n))) {
      let u = s.len;
      for (Gt(l, s.ins, -1); u; ) {
        let c = Math.min(r.len, u);
        r.ins >= 0 && o < r.i && r.len <= c && (Gt(l, 0, r.ins), a && Ni(a, l, r.text), o = r.i), r.forward(c), u -= c;
      }
      s.next();
    } else if (r.ins >= 0) {
      let u = 0, c = r.len;
      for (; c; )
        if (s.ins == -1) {
          let d = Math.min(c, s.len);
          u += d, c -= d, s.forward(d);
        } else if (s.ins == 0 && s.len < c)
          c -= s.len, s.next();
        else
          break;
      Gt(l, u, o < r.i ? r.ins : 0), a && o < r.i && Ni(a, l, r.text), o = r.i, r.forward(r.len - c);
    } else {
      if (r.done && s.done)
        return a ? Tt.createSet(l, a) : fi.create(l);
      throw new Error("Mismatched change set lengths");
    }
}
function h3(e, t, n = !1) {
  let i = [], l = n ? [] : null, a = new Br(e), r = new Br(t);
  for (let s = !1; ; ) {
    if (a.done && r.done)
      return l ? Tt.createSet(i, l) : fi.create(i);
    if (a.ins == 0)
      Gt(i, a.len, 0, s), a.next();
    else if (r.len == 0 && !r.done)
      Gt(i, 0, r.ins, s), l && Ni(l, i, r.text), r.next();
    else {
      if (a.done || r.done)
        throw new Error("Mismatched change set lengths");
      {
        let o = Math.min(a.len2, r.len), u = i.length;
        if (a.ins == -1) {
          let c = r.ins == -1 ? -1 : r.off ? 0 : r.ins;
          Gt(i, o, c, s), l && c && Ni(l, i, r.text);
        } else r.ins == -1 ? (Gt(i, a.off ? 0 : a.len, o, s), l && Ni(l, i, a.textBit(o))) : (Gt(i, a.off ? 0 : a.len, r.off ? 0 : r.ins, s), l && !r.off && Ni(l, i, r.text));
        s = (a.ins > o || r.ins >= 0 && r.len > o) && (s || i.length > u), a.forward2(o), r.forward(o);
      }
    }
  }
}
class Br {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, n = this.i - 2 >> 1;
    return n >= t.length ? Ne.empty : t[n];
  }
  textBit(t) {
    let { inserted: n } = this.set, i = this.i - 2 >> 1;
    return i >= n.length && !t ? Ne.empty : n[i].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}
class Sl {
  constructor(t, n, i) {
    this.from = t, this.to = n, this.flags = i;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, n = -1) {
    let i, l;
    return this.empty ? i = l = t.mapPos(this.from, n) : (i = t.mapPos(this.from, 1), l = t.mapPos(this.to, -1)), i == this.from && l == this.to ? this : new Sl(i, l, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, n = t) {
    if (t <= this.anchor && n >= this.anchor)
      return J.range(t, n);
    let i = Math.abs(t - this.anchor) > Math.abs(n - this.anchor) ? t : n;
    return J.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(t, n = !1) {
    return this.anchor == t.anchor && this.head == t.head && (!n || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return J.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, n, i) {
    return new Sl(t, n, i);
  }
}
class J {
  constructor(t, n) {
    this.ranges = t, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, n = -1) {
    return t.empty ? this : J.create(this.ranges.map((i) => i.map(t, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, n = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(t.ranges[i], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new J([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, n = !0) {
    return J.create([t].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, n = this.mainIndex) {
    let i = this.ranges.slice();
    return i[n] = t, J.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new J(t.ranges.map((n) => Sl.fromJSON(n)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, n = t) {
    return new J([J.range(t, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, n = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, l = 0; l < t.length; l++) {
      let a = t[l];
      if (a.empty ? a.from <= i : a.from < i)
        return J.normalized(t.slice(), n);
      i = a.to;
    }
    return new J(t, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, n = 0, i, l) {
    return Sl.create(t, t, (n == 0 ? 0 : n < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (l ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, n, i, l) {
    let a = (i ?? 16777215) << 6 | (l == null ? 7 : Math.min(6, l));
    return n < t ? Sl.create(n, t, 48 | a) : Sl.create(t, n, (n > t ? 8 : 0) | a);
  }
  /**
  @internal
  */
  static normalized(t, n = 0) {
    let i = t[n];
    t.sort((l, a) => l.from - a.from), n = t.indexOf(i);
    for (let l = 1; l < t.length; l++) {
      let a = t[l], r = t[l - 1];
      if (a.empty ? a.from <= r.to : a.from < r.to) {
        let s = r.from, o = Math.max(a.to, r.to);
        l <= n && n--, t.splice(--l, 2, a.anchor > a.head ? J.range(o, s) : J.range(s, o));
      }
    }
    return new J(t, n);
  }
}
function m3(e, t) {
  for (let n of e.ranges)
    if (n.to > t)
      throw new RangeError("Selection points outside of document");
}
let nh = 0;
class ve {
  constructor(t, n, i, l, a) {
    this.combine = t, this.compareInput = n, this.compare = i, this.isStatic = l, this.id = nh++, this.default = t([]), this.extensions = typeof a == "function" ? a(this) : a;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new ve(t.combine || ((n) => n), t.compareInput || ((n, i) => n === i), t.compare || (t.combine ? (n, i) => n === i : ih), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new oo([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new oo(t, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new oo(t, this, 2, n);
  }
  from(t, n) {
    return n || (n = (i) => i), this.compute([t], (i) => n(i.field(t)));
  }
}
function ih(e, t) {
  return e == t || e.length == t.length && e.every((n, i) => n === t[i]);
}
class oo {
  constructor(t, n, i, l) {
    this.dependencies = t, this.facet = n, this.type = i, this.value = l, this.id = nh++;
  }
  dynamicSlot(t) {
    var n;
    let i = this.value, l = this.facet.compareInput, a = this.id, r = t[a] >> 1, s = this.type == 2, o = !1, u = !1, c = [];
    for (let d of this.dependencies)
      d == "doc" ? o = !0 : d == "selection" ? u = !0 : ((n = t[d.id]) !== null && n !== void 0 ? n : 1) & 1 || c.push(t[d.id]);
    return {
      create(d) {
        return d.values[r] = i(d), 1;
      },
      update(d, f) {
        if (o && f.docChanged || u && (f.docChanged || f.selection) || E1(d, c)) {
          let h = i(d);
          if (s ? !o0(h, d.values[r], l) : !l(h, d.values[r]))
            return d.values[r] = h, 1;
        }
        return 0;
      },
      reconfigure: (d, f) => {
        let h, g = f.config.address[a];
        if (g != null) {
          let v = Ao(f, g);
          if (this.dependencies.every((p) => p instanceof ve ? f.facet(p) === d.facet(p) : p instanceof Mt ? f.field(p, !1) == d.field(p, !1) : !0) || (s ? o0(h = i(d), v, l) : l(h = i(d), v)))
            return d.values[r] = v, 0;
        } else
          h = i(d);
        return d.values[r] = h, 1;
      }
    };
  }
}
function o0(e, t, n) {
  if (e.length != t.length)
    return !1;
  for (let i = 0; i < e.length; i++)
    if (!n(e[i], t[i]))
      return !1;
  return !0;
}
function E1(e, t) {
  let n = !1;
  for (let i of t)
    br(e, i) & 1 && (n = !0);
  return n;
}
function qx(e, t, n) {
  let i = n.map((o) => e[o.id]), l = n.map((o) => o.type), a = i.filter((o) => !(o & 1)), r = e[t.id] >> 1;
  function s(o) {
    let u = [];
    for (let c = 0; c < i.length; c++) {
      let d = Ao(o, i[c]);
      if (l[c] == 2)
        for (let f of d)
          u.push(f);
      else
        u.push(d);
    }
    return t.combine(u);
  }
  return {
    create(o) {
      for (let u of i)
        br(o, u);
      return o.values[r] = s(o), 1;
    },
    update(o, u) {
      if (!E1(o, a))
        return 0;
      let c = s(o);
      return t.compare(c, o.values[r]) ? 0 : (o.values[r] = c, 1);
    },
    reconfigure(o, u) {
      let c = E1(o, i), d = u.config.facets[t.id], f = u.facet(t);
      if (d && !c && ih(n, d))
        return o.values[r] = f, 0;
      let h = s(o);
      return t.compare(h, f) ? (o.values[r] = f, 0) : (o.values[r] = h, 1);
    }
  };
}
const u0 = /* @__PURE__ */ ve.define({ static: !0 });
class Mt {
  constructor(t, n, i, l, a) {
    this.id = t, this.createF = n, this.updateF = i, this.compareF = l, this.spec = a, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let n = new Mt(nh++, t.create, t.update, t.compare || ((i, l) => i === l), t);
    return t.provide && (n.provides = t.provide(n)), n;
  }
  create(t) {
    let n = t.facet(u0).find((i) => i.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let n = t[this.id] >> 1;
    return {
      create: (i) => (i.values[n] = this.create(i), 1),
      update: (i, l) => {
        let a = i.values[n], r = this.updateF(a, l);
        return this.compareF(a, r) ? 0 : (i.values[n] = r, 1);
      },
      reconfigure: (i, l) => l.config.address[this.id] != null ? (i.values[n] = l.field(this), 0) : (i.values[n] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, u0.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const pl = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function lr(e) {
  return (t) => new g3(t, e);
}
const cl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ lr(pl.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ lr(pl.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ lr(pl.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ lr(pl.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ lr(pl.lowest)
};
class g3 {
  constructor(t, n) {
    this.inner = t, this.prec = n;
  }
}
class Ta {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new z1(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return Ta.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}
class z1 {
  constructor(t, n) {
    this.compartment = t, this.inner = n;
  }
}
class _o {
  constructor(t, n, i, l, a, r) {
    for (this.base = t, this.compartments = n, this.dynamicSlots = i, this.address = l, this.staticValues = a, this.facets = r, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let n = this.address[t.id];
    return n == null ? t.default : this.staticValues[n >> 1];
  }
  static resolve(t, n, i) {
    let l = [], a = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Map();
    for (let f of Yx(t, n, r))
      f instanceof Mt ? l.push(f) : (a[f.facet.id] || (a[f.facet.id] = [])).push(f);
    let s = /* @__PURE__ */ Object.create(null), o = [], u = [];
    for (let f of l)
      s[f.id] = u.length << 1, u.push((h) => f.slot(h));
    let c = i == null ? void 0 : i.config.facets;
    for (let f in a) {
      let h = a[f], g = h[0].facet, v = c && c[f] || [];
      if (h.every(
        (p) => p.type == 0
        /* Provider.Static */
      ))
        if (s[g.id] = o.length << 1 | 1, ih(v, h))
          o.push(i.facet(g));
        else {
          let p = g.combine(h.map((O) => O.value));
          o.push(i && g.compare(p, i.facet(g)) ? i.facet(g) : p);
        }
      else {
        for (let p of h)
          p.type == 0 ? (s[p.id] = o.length << 1 | 1, o.push(p.value)) : (s[p.id] = u.length << 1, u.push((O) => p.dynamicSlot(O)));
        s[g.id] = u.length << 1, u.push((p) => qx(p, g, h));
      }
    }
    let d = u.map((f) => f(s));
    return new _o(t, r, d, s, o, a);
  }
}
function Yx(e, t, n) {
  let i = [[], [], [], [], []], l = /* @__PURE__ */ new Map();
  function a(r, s) {
    let o = l.get(r);
    if (o != null) {
      if (o <= s)
        return;
      let u = i[o].indexOf(r);
      u > -1 && i[o].splice(u, 1), r instanceof z1 && n.delete(r.compartment);
    }
    if (l.set(r, s), Array.isArray(r))
      for (let u of r)
        a(u, s);
    else if (r instanceof z1) {
      if (n.has(r.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = t.get(r.compartment) || r.inner;
      n.set(r.compartment, u), a(u, s);
    } else if (r instanceof g3)
      a(r.inner, r.prec);
    else if (r instanceof Mt)
      i[s].push(r), r.provides && a(r.provides, s);
    else if (r instanceof oo)
      i[s].push(r), r.facet.extensions && a(r.facet.extensions, pl.default);
    else {
      let u = r.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${r}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      a(u, s);
    }
  }
  return a(e, pl.default), i.reduce((r, s) => r.concat(s));
}
function br(e, t) {
  if (t & 1)
    return 2;
  let n = t >> 1, i = e.status[n];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  e.status[n] = 4;
  let l = e.computeSlot(e, e.config.dynamicSlots[n]);
  return e.status[n] = 2 | l;
}
function Ao(e, t) {
  return t & 1 ? e.config.staticValues[t >> 1] : e.values[t >> 1];
}
const v3 = /* @__PURE__ */ ve.define(), H1 = /* @__PURE__ */ ve.define({
  combine: (e) => e.some((t) => t),
  static: !0
}), p3 = /* @__PURE__ */ ve.define({
  combine: (e) => e.length ? e[0] : void 0,
  static: !0
}), O3 = /* @__PURE__ */ ve.define(), y3 = /* @__PURE__ */ ve.define(), b3 = /* @__PURE__ */ ve.define(), C3 = /* @__PURE__ */ ve.define({
  combine: (e) => e.length ? e[0] : !1
});
class Zi {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new Fx();
  }
}
class Fx {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new Zi(this, t);
  }
}
class Wx {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new Le(this, t);
  }
}
class Le {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let n = this.type.map(this.value, t);
    return n === void 0 ? void 0 : n == this.value ? this : new Le(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new Wx(t.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, n) {
    if (!t.length)
      return t;
    let i = [];
    for (let l of t) {
      let a = l.map(n);
      a && i.push(a);
    }
    return i;
  }
}
Le.reconfigure = /* @__PURE__ */ Le.define();
Le.appendConfig = /* @__PURE__ */ Le.define();
class $t {
  constructor(t, n, i, l, a, r) {
    this.startState = t, this.changes = n, this.selection = i, this.effects = l, this.annotations = a, this.scrollIntoView = r, this._doc = null, this._state = null, i && m3(i, n.newLength), a.some((s) => s.type == $t.time) || (this.annotations = a.concat($t.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, n, i, l, a, r) {
    return new $t(t, n, i, l, a, r);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let n of this.annotations)
      if (n.type == t)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let n = this.annotation($t.userEvent);
    return !!(n && (n == t || n.length > t.length && n.slice(0, t.length) == t && n[t.length] == "."));
  }
}
$t.time = /* @__PURE__ */ Zi.define();
$t.userEvent = /* @__PURE__ */ Zi.define();
$t.addToHistory = /* @__PURE__ */ Zi.define();
$t.remote = /* @__PURE__ */ Zi.define();
function Ux(e, t) {
  let n = [];
  for (let i = 0, l = 0; ; ) {
    let a, r;
    if (i < e.length && (l == t.length || t[l] >= e[i]))
      a = e[i++], r = e[i++];
    else if (l < t.length)
      a = t[l++], r = t[l++];
    else
      return n;
    !n.length || n[n.length - 1] < a ? n.push(a, r) : n[n.length - 1] < r && (n[n.length - 1] = r);
  }
}
function S3(e, t, n) {
  var i;
  let l, a, r;
  return n ? (l = t.changes, a = Tt.empty(t.changes.length), r = e.changes.compose(t.changes)) : (l = t.changes.map(e.changes), a = e.changes.mapDesc(t.changes, !0), r = e.changes.compose(l)), {
    changes: r,
    selection: t.selection ? t.selection.map(a) : (i = e.selection) === null || i === void 0 ? void 0 : i.map(l),
    effects: Le.mapEffects(e.effects, l).concat(Le.mapEffects(t.effects, a)),
    annotations: e.annotations.length ? e.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: e.scrollIntoView || t.scrollIntoView
  };
}
function j1(e, t, n) {
  let i = t.selection, l = ya(t.annotations);
  return t.userEvent && (l = l.concat($t.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof Tt ? t.changes : Tt.of(t.changes || [], n, e.facet(p3)),
    selection: i && (i instanceof J ? i : J.single(i.anchor, i.head)),
    effects: ya(t.effects),
    annotations: l,
    scrollIntoView: !!t.scrollIntoView
  };
}
function w3(e, t, n) {
  let i = j1(e, t.length ? t[0] : {}, e.doc.length);
  t.length && t[0].filter === !1 && (n = !1);
  for (let a = 1; a < t.length; a++) {
    t[a].filter === !1 && (n = !1);
    let r = !!t[a].sequential;
    i = S3(i, j1(e, t[a], r ? i.changes.newLength : e.doc.length), r);
  }
  let l = $t.create(e, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return Kx(n ? Gx(l) : l);
}
function Gx(e) {
  let t = e.startState, n = !0;
  for (let l of t.facet(O3)) {
    let a = l(e);
    if (a === !1) {
      n = !1;
      break;
    }
    Array.isArray(a) && (n = n === !0 ? a : Ux(n, a));
  }
  if (n !== !0) {
    let l, a;
    if (n === !1)
      a = e.changes.invertedDesc, l = Tt.empty(t.doc.length);
    else {
      let r = e.changes.filter(n);
      l = r.changes, a = r.filtered.mapDesc(r.changes).invertedDesc;
    }
    e = $t.create(t, l, e.selection && e.selection.map(a), Le.mapEffects(e.effects, a), e.annotations, e.scrollIntoView);
  }
  let i = t.facet(y3);
  for (let l = i.length - 1; l >= 0; l--) {
    let a = i[l](e);
    a instanceof $t ? e = a : Array.isArray(a) && a.length == 1 && a[0] instanceof $t ? e = a[0] : e = w3(t, ya(a), !1);
  }
  return e;
}
function Kx(e) {
  let t = e.startState, n = t.facet(b3), i = e;
  for (let l = n.length - 1; l >= 0; l--) {
    let a = n[l](e);
    a && Object.keys(a).length && (i = S3(i, j1(t, a, e.changes.newLength), !0));
  }
  return i == e ? e : $t.create(t, e.changes, e.selection, i.effects, i.annotations, i.scrollIntoView);
}
const Jx = [];
function ya(e) {
  return e == null ? Jx : Array.isArray(e) ? e : [e];
}
var dt = /* @__PURE__ */ function(e) {
  return e[e.Word = 0] = "Word", e[e.Space = 1] = "Space", e[e.Other = 2] = "Other", e;
}(dt || (dt = {}));
const eP = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let X1;
try {
  X1 = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function tP(e) {
  if (X1)
    return X1.test(e);
  for (let t = 0; t < e.length; t++) {
    let n = e[t];
    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || eP.test(n)))
      return !0;
  }
  return !1;
}
function nP(e) {
  return (t) => {
    if (!/\S/.test(t))
      return dt.Space;
    if (tP(t))
      return dt.Word;
    for (let n = 0; n < e.length; n++)
      if (t.indexOf(e[n]) > -1)
        return dt.Word;
    return dt.Other;
  };
}
class Re {
  constructor(t, n, i, l, a, r) {
    this.config = t, this.doc = n, this.selection = i, this.values = l, this.status = t.statusTemplate.slice(), this.computeSlot = a, r && (r._state = this);
    for (let s = 0; s < this.config.dynamicSlots.length; s++)
      br(this, s << 1);
    this.computeSlot = null;
  }
  field(t, n = !0) {
    let i = this.config.address[t.id];
    if (i == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return br(this, i), Ao(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return w3(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let n = this.config, { base: i, compartments: l } = n;
    for (let s of t.effects)
      s.is(Ta.reconfigure) ? (n && (l = /* @__PURE__ */ new Map(), n.compartments.forEach((o, u) => l.set(u, o)), n = null), l.set(s.value.compartment, s.value.extension)) : s.is(Le.reconfigure) ? (n = null, i = s.value) : s.is(Le.appendConfig) && (n = null, i = ya(i).concat(s.value));
    let a;
    n ? a = t.startState.values.slice() : (n = _o.resolve(i, l, this), a = new Re(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (o, u) => u.reconfigure(o, this), null).values);
    let r = t.startState.facet(H1) ? t.newSelection : t.newSelection.asSingle();
    new Re(n, t.newDoc, r, a, (s, o) => o.update(s, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: t },
      range: J.cursor(n.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let n = this.selection, i = t(n.ranges[0]), l = this.changes(i.changes), a = [i.range], r = ya(i.effects);
    for (let s = 1; s < n.ranges.length; s++) {
      let o = t(n.ranges[s]), u = this.changes(o.changes), c = u.map(l);
      for (let f = 0; f < s; f++)
        a[f] = a[f].map(c);
      let d = l.mapDesc(u, !0);
      a.push(o.range.map(d)), l = l.compose(c), r = Le.mapEffects(r, c).concat(Le.mapEffects(ya(o.effects), d));
    }
    return {
      changes: l,
      selection: J.create(a, n.mainIndex),
      effects: r
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof Tt ? t : Tt.of(t, this.doc.length, this.facet(Re.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return Ne.of(t.split(this.facet(Re.lineSeparator) || I1));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, n = this.doc.length) {
    return this.doc.sliceString(t, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let n = this.config.address[t.id];
    return n == null ? t.default : (br(this, n), Ao(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let i in t) {
        let l = t[i];
        l instanceof Mt && this.config.address[l.id] != null && (n[i] = l.spec.toJSON(this.field(t[i]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, n = {}, i) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let l = [];
    if (i) {
      for (let a in i)
        if (Object.prototype.hasOwnProperty.call(t, a)) {
          let r = i[a], s = t[a];
          l.push(r.init((o) => r.spec.fromJSON(s, o)));
        }
    }
    return Re.create({
      doc: t.doc,
      selection: J.fromJSON(t.selection),
      extensions: n.extensions ? l.concat([n.extensions]) : l
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let n = _o.resolve(t.extensions || [], /* @__PURE__ */ new Map()), i = t.doc instanceof Ne ? t.doc : Ne.of((t.doc || "").split(n.staticFacet(Re.lineSeparator) || I1)), l = t.selection ? t.selection instanceof J ? t.selection : J.single(t.selection.anchor, t.selection.head) : J.single(0);
    return m3(l, i.length), n.staticFacet(H1) || (l = l.asSingle()), new Re(n, i, l, n.dynamicSlots.map(() => null), (a, r) => r.create(a), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Re.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Re.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(C3);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...n) {
    for (let i of this.facet(Re.phrases))
      if (Object.prototype.hasOwnProperty.call(i, t)) {
        t = i[t];
        break;
      }
    return n.length && (t = t.replace(/\$(\$|\d*)/g, (i, l) => {
      if (l == "$")
        return "$";
      let a = +(l || 1);
      return !a || a > n.length ? i : n[a - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, n, i = -1) {
    let l = [];
    for (let a of this.facet(v3))
      for (let r of a(this, n, i))
        Object.prototype.hasOwnProperty.call(r, t) && l.push(r[t]);
    return l;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    return nP(this.languageDataAt("wordChars", t).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: n, from: i, length: l } = this.doc.lineAt(t), a = this.charCategorizer(t), r = t - i, s = t - i;
    for (; r > 0; ) {
      let o = qt(n, r, !1);
      if (a(n.slice(o, r)) != dt.Word)
        break;
      r = o;
    }
    for (; s < l; ) {
      let o = qt(n, s);
      if (a(n.slice(s, o)) != dt.Word)
        break;
      s = o;
    }
    return r == s ? null : J.range(r + i, s + i);
  }
}
Re.allowMultipleSelections = H1;
Re.tabSize = /* @__PURE__ */ ve.define({
  combine: (e) => e.length ? e[0] : 4
});
Re.lineSeparator = p3;
Re.readOnly = C3;
Re.phrases = /* @__PURE__ */ ve.define({
  compare(e, t) {
    let n = Object.keys(e), i = Object.keys(t);
    return n.length == i.length && n.every((l) => e[l] == t[l]);
  }
});
Re.languageData = v3;
Re.changeFilter = O3;
Re.transactionFilter = y3;
Re.transactionExtender = b3;
Ta.reconfigure = /* @__PURE__ */ Le.define();
function Kn(e, t, n = {}) {
  let i = {};
  for (let l of e)
    for (let a of Object.keys(l)) {
      let r = l[a], s = i[a];
      if (s === void 0)
        i[a] = r;
      else if (!(s === r || r === void 0)) if (Object.hasOwnProperty.call(n, a))
        i[a] = n[a](s, r);
      else
        throw new Error("Config merge conflict for field " + a);
    }
  for (let l in t)
    i[l] === void 0 && (i[l] = t[l]);
  return i;
}
class Bl {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, n = t) {
    return N1.create(t, n, this);
  }
}
Bl.prototype.startSide = Bl.prototype.endSide = 0;
Bl.prototype.point = !1;
Bl.prototype.mapMode = Nt.TrackDel;
let N1 = class k3 {
  constructor(t, n, i) {
    this.from = t, this.to = n, this.value = i;
  }
  /**
  @internal
  */
  static create(t, n, i) {
    return new k3(t, n, i);
  }
};
function q1(e, t) {
  return e.from - t.from || e.value.startSide - t.value.startSide;
}
class lh {
  constructor(t, n, i, l) {
    this.from = t, this.to = n, this.value = i, this.maxPoint = l;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, n, i, l = 0) {
    let a = i ? this.to : this.from;
    for (let r = l, s = a.length; ; ) {
      if (r == s)
        return r;
      let o = r + s >> 1, u = a[o] - t || (i ? this.value[o].endSide : this.value[o].startSide) - n;
      if (o == r)
        return u >= 0 ? r : s;
      u >= 0 ? s = o : r = o + 1;
    }
  }
  between(t, n, i, l) {
    for (let a = this.findIndex(n, -1e9, !0), r = this.findIndex(i, 1e9, !1, a); a < r; a++)
      if (l(this.from[a] + t, this.to[a] + t, this.value[a]) === !1)
        return !1;
  }
  map(t, n) {
    let i = [], l = [], a = [], r = -1, s = -1;
    for (let o = 0; o < this.value.length; o++) {
      let u = this.value[o], c = this.from[o] + t, d = this.to[o] + t, f, h;
      if (c == d) {
        let g = n.mapPos(c, u.startSide, u.mapMode);
        if (g == null || (f = h = g, u.startSide != u.endSide && (h = n.mapPos(c, u.endSide), h < f)))
          continue;
      } else if (f = n.mapPos(c, u.startSide), h = n.mapPos(d, u.endSide), f > h || f == h && u.startSide > 0 && u.endSide <= 0)
        continue;
      (h - f || u.endSide - u.startSide) < 0 || (r < 0 && (r = f), u.point && (s = Math.max(s, h - f)), i.push(u), l.push(f - r), a.push(h - r));
    }
    return { mapped: i.length ? new lh(l, a, i, s) : null, pos: r };
  }
}
class Ee {
  constructor(t, n, i, l) {
    this.chunkPos = t, this.chunk = n, this.nextLayer = i, this.maxPoint = l;
  }
  /**
  @internal
  */
  static create(t, n, i, l) {
    return new Ee(t, n, i, l);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let n of this.chunk)
      t += n.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: n = [], sort: i = !1, filterFrom: l = 0, filterTo: a = this.length } = t, r = t.filter;
    if (n.length == 0 && !r)
      return this;
    if (i && (n = n.slice().sort(q1)), this.isEmpty)
      return n.length ? Ee.of(n) : this;
    let s = new x3(this, null, -1).goto(0), o = 0, u = [], c = new Ji();
    for (; s.value || o < n.length; )
      if (o < n.length && (s.from - n[o].from || s.startSide - n[o].value.startSide) >= 0) {
        let d = n[o++];
        c.addInner(d.from, d.to, d.value) || u.push(d);
      } else s.rangeIndex == 1 && s.chunkIndex < this.chunk.length && (o == n.length || this.chunkEnd(s.chunkIndex) < n[o].from) && (!r || l > this.chunkEnd(s.chunkIndex) || a < this.chunkPos[s.chunkIndex]) && c.addChunk(this.chunkPos[s.chunkIndex], this.chunk[s.chunkIndex]) ? s.nextChunk() : ((!r || l > s.to || a < s.from || r(s.from, s.to, s.value)) && (c.addInner(s.from, s.to, s.value) || u.push(N1.create(s.from, s.to, s.value))), s.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? Ee.empty : this.nextLayer.update({ add: u, filter: r, filterFrom: l, filterTo: a }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let n = [], i = [], l = -1;
    for (let r = 0; r < this.chunk.length; r++) {
      let s = this.chunkPos[r], o = this.chunk[r], u = t.touchesRange(s, s + o.length);
      if (u === !1)
        l = Math.max(l, o.maxPoint), n.push(o), i.push(t.mapPos(s));
      else if (u === !0) {
        let { mapped: c, pos: d } = o.map(s, t);
        c && (l = Math.max(l, c.maxPoint), n.push(c), i.push(d));
      }
    }
    let a = this.nextLayer.map(t);
    return n.length == 0 ? a : new Ee(i, n, a || Ee.empty, l);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, n, i) {
    if (!this.isEmpty) {
      for (let l = 0; l < this.chunk.length; l++) {
        let a = this.chunkPos[l], r = this.chunk[l];
        if (n >= a && t <= a + r.length && r.between(a, t - a, n - a, i) === !1)
          return;
      }
      this.nextLayer.between(t, n, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return Er.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, n = 0) {
    return Er.from(t).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, n, i, l, a = -1) {
    let r = t.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= a), s = n.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= a), o = c0(r, s, i), u = new ar(r, o, a), c = new ar(s, o, a);
    i.iterGaps((d, f, h) => d0(u, d, c, f, h, l)), i.empty && i.length == 0 && d0(u, 0, c, 0, 0, l);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, n, i = 0, l) {
    l == null && (l = 999999999);
    let a = t.filter((c) => !c.isEmpty && n.indexOf(c) < 0), r = n.filter((c) => !c.isEmpty && t.indexOf(c) < 0);
    if (a.length != r.length)
      return !1;
    if (!a.length)
      return !0;
    let s = c0(a, r), o = new ar(a, s, 0).goto(i), u = new ar(r, s, 0).goto(i);
    for (; ; ) {
      if (o.to != u.to || !Y1(o.active, u.active) || o.point && (!u.point || !o.point.eq(u.point)))
        return !1;
      if (o.to > l)
        return !0;
      o.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, n, i, l, a = -1) {
    let r = new ar(t, null, a).goto(n), s = n, o = r.openStart;
    for (; ; ) {
      let u = Math.min(r.to, i);
      if (r.point) {
        let c = r.activeForPoint(r.to), d = r.pointFrom < n ? c.length + 1 : r.point.startSide < 0 ? c.length : Math.min(c.length, o);
        l.point(s, u, r.point, c, d, r.pointRank), o = Math.min(r.openEnd(u), c.length);
      } else u > s && (l.span(s, u, r.active, o), o = r.openEnd(u));
      if (r.to > i)
        return o + (r.point && r.to > i ? 1 : 0);
      s = r.to, r.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, n = !1) {
    let i = new Ji();
    for (let l of t instanceof N1 ? [t] : n ? iP(t) : t)
      i.add(l.from, l.to, l.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return Ee.empty;
    let n = t[t.length - 1];
    for (let i = t.length - 2; i >= 0; i--)
      for (let l = t[i]; l != Ee.empty; l = l.nextLayer)
        n = new Ee(l.chunkPos, l.chunk, n, Math.max(l.maxPoint, n.maxPoint));
    return n;
  }
}
Ee.empty = /* @__PURE__ */ new Ee([], [], null, -1);
function iP(e) {
  if (e.length > 1)
    for (let t = e[0], n = 1; n < e.length; n++) {
      let i = e[n];
      if (q1(t, i) > 0)
        return e.slice().sort(q1);
      t = i;
    }
  return e;
}
Ee.empty.nextLayer = Ee.empty;
class Ji {
  finishChunk(t) {
    this.chunks.push(new lh(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, n, i) {
    this.addInner(t, n, i) || (this.nextLayer || (this.nextLayer = new Ji())).add(t, n, i);
  }
  /**
  @internal
  */
  addInner(t, n, i) {
    let l = t - this.lastTo || i.startSide - this.last.endSide;
    if (l <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return l < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(n - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = n, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, n - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, n) {
    if ((t - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(t);
    let i = n.value.length - 1;
    return this.last = n.value[i], this.lastFrom = n.from[i] + t, this.lastTo = n.to[i] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Ee.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let n = Ee.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, n;
  }
}
function c0(e, t, n) {
  let i = /* @__PURE__ */ new Map();
  for (let a of e)
    for (let r = 0; r < a.chunk.length; r++)
      a.chunk[r].maxPoint <= 0 && i.set(a.chunk[r], a.chunkPos[r]);
  let l = /* @__PURE__ */ new Set();
  for (let a of t)
    for (let r = 0; r < a.chunk.length; r++) {
      let s = i.get(a.chunk[r]);
      s != null && (n ? n.mapPos(s) : s) == a.chunkPos[r] && !(n != null && n.touchesRange(s, s + a.chunk[r].length)) && l.add(a.chunk[r]);
    }
  return l;
}
class x3 {
  constructor(t, n, i, l = 0) {
    this.layer = t, this.skip = n, this.minPoint = i, this.rank = l;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, n, !1), this;
  }
  gotoInner(t, n, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let l = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(l) || this.layer.chunkEnd(this.chunkIndex) < t || l.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let l = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!i || this.rangeIndex < l) && this.setRangeIndex(l);
    }
    this.next();
  }
  forward(t, n) {
    (this.to - t || this.endSide - n) < 0 && this.gotoInner(t, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], i = t + n.from[this.rangeIndex];
        if (this.from = i, this.to = t + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}
class Er {
  constructor(t) {
    this.heap = t;
  }
  static from(t, n = null, i = -1) {
    let l = [];
    for (let a = 0; a < t.length; a++)
      for (let r = t[a]; !r.isEmpty; r = r.nextLayer)
        r.maxPoint >= i && l.push(new x3(r, n, i, a));
    return l.length == 1 ? l[0] : new Er(l);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, n = -1e9) {
    for (let i of this.heap)
      i.goto(t, n);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Sc(this.heap, i);
    return this.next(), this;
  }
  forward(t, n) {
    for (let i of this.heap)
      i.forward(t, n);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Sc(this.heap, i);
    (this.to - t || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), Sc(this.heap, 0);
    }
  }
}
function Sc(e, t) {
  for (let n = e[t]; ; ) {
    let i = (t << 1) + 1;
    if (i >= e.length)
      break;
    let l = e[i];
    if (i + 1 < e.length && l.compare(e[i + 1]) >= 0 && (l = e[i + 1], i++), n.compare(l) < 0)
      break;
    e[i] = n, e[t] = l, t = i;
  }
}
class ar {
  constructor(t, n, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Er.from(t, n, i);
  }
  goto(t, n = -1e9) {
    return this.cursor.goto(t, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(t, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, n);
  }
  removeActive(t) {
    As(this.active, t), As(this.activeTo, t), As(this.activeRank, t), this.minActive = f0(this.active, this.activeTo);
  }
  addActive(t) {
    let n = 0, { value: i, to: l, rank: a } = this.cursor;
    for (; n < this.activeRank.length && (a - this.activeRank[n] || l - this.activeTo[n]) > 0; )
      n++;
    Rs(this.active, n, i), Rs(this.activeTo, n, l), Rs(this.activeRank, n, a), t && Rs(t, n, this.cursor.from), this.minActive = f0(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, n = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let l = this.minActive;
      if (l > -1 && (this.activeTo[l] - this.cursor.from || this.active[l].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[l] > t) {
          this.to = this.activeTo[l], this.endSide = this.active[l].endSide;
          break;
        }
        this.removeActive(l), i && As(i, l);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let a = this.cursor.value;
          if (!a.point)
            this.addActive(i), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = a, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = a.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let l = i.length - 1; l >= 0 && i[l] < t; l--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > t || this.activeTo[i] == t && this.active[i].endSide >= this.point.endSide) && n.push(this.active[i]);
    return n.reverse();
  }
  openEnd(t) {
    let n = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > t; i--)
      n++;
    return n;
  }
}
function d0(e, t, n, i, l, a) {
  e.goto(t), n.goto(i);
  let r = i + l, s = i, o = i - t;
  for (; ; ) {
    let u = e.to + o - n.to || e.endSide - n.endSide, c = u < 0 ? e.to + o : n.to, d = Math.min(c, r);
    if (e.point || n.point ? e.point && n.point && (e.point == n.point || e.point.eq(n.point)) && Y1(e.activeForPoint(e.to), n.activeForPoint(n.to)) || a.comparePoint(s, d, e.point, n.point) : d > s && !Y1(e.active, n.active) && a.compareRange(s, d, e.active, n.active), c > r)
      break;
    s = c, u <= 0 && e.next(), u >= 0 && n.next();
  }
}
function Y1(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n] && !e[n].eq(t[n]))
      return !1;
  return !0;
}
function As(e, t) {
  for (let n = t, i = e.length - 1; n < i; n++)
    e[n] = e[n + 1];
  e.pop();
}
function Rs(e, t, n) {
  for (let i = e.length - 1; i >= t; i--)
    e[i + 1] = e[i];
  e[t] = n;
}
function f0(e, t) {
  let n = -1, i = 1e9;
  for (let l = 0; l < t.length; l++)
    (t[l] - i || e[l].endSide - e[n].endSide) < 0 && (n = l, i = t[l]);
  return n;
}
function Ga(e, t, n = e.length) {
  let i = 0;
  for (let l = 0; l < n; )
    e.charCodeAt(l) == 9 ? (i += t - i % t, l++) : (i++, l = qt(e, l));
  return i;
}
function F1(e, t, n, i) {
  for (let l = 0, a = 0; ; ) {
    if (a >= t)
      return l;
    if (l == e.length)
      break;
    a += e.charCodeAt(l) == 9 ? n - a % n : 1, l = qt(e, l);
  }
  return i === !0 ? -1 : e.length;
}
const W1 = "", h0 = typeof Symbol > "u" ? "__" + W1 : Symbol.for(W1), U1 = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), m0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class el {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, n) {
    this.rules = [];
    let { finish: i } = n || {};
    function l(r) {
      return /^@/.test(r) ? [r] : r.split(/,\s*/);
    }
    function a(r, s, o, u) {
      let c = [], d = /^@(\w+)\b/.exec(r[0]), f = d && d[1] == "keyframes";
      if (d && s == null) return o.push(r[0] + ";");
      for (let h in s) {
        let g = s[h];
        if (/&/.test(h))
          a(
            h.split(/,\s*/).map((v) => r.map((p) => v.replace(/&/, p))).reduce((v, p) => v.concat(p)),
            g,
            o
          );
        else if (g && typeof g == "object") {
          if (!d) throw new RangeError("The value of a property (" + h + ") should be a primitive value.");
          a(l(h), g, c, f);
        } else g != null && c.push(h.replace(/_.*/, "").replace(/[A-Z]/g, (v) => "-" + v.toLowerCase()) + ": " + g + ";");
      }
      (c.length || f) && o.push((i && !d && !u ? r.map(i) : r).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let r in t) a(l(r), t[r], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let t = m0[h0] || 1;
    return m0[h0] = t + 1, W1 + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, n, i) {
    let l = t[U1], a = i && i.nonce;
    l ? a && l.setNonce(a) : l = new lP(t, a), l.mount(Array.isArray(n) ? n : [n], t);
  }
}
let g0 = /* @__PURE__ */ new Map();
class lP {
  constructor(t, n) {
    let i = t.ownerDocument || t, l = i.defaultView;
    if (!t.head && t.adoptedStyleSheets && l.CSSStyleSheet) {
      let a = g0.get(i);
      if (a) return t[U1] = a;
      this.sheet = new l.CSSStyleSheet(), g0.set(i, this);
    } else
      this.styleTag = i.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], t[U1] = this;
  }
  mount(t, n) {
    let i = this.sheet, l = 0, a = 0;
    for (let r = 0; r < t.length; r++) {
      let s = t[r], o = this.modules.indexOf(s);
      if (o < a && o > -1 && (this.modules.splice(o, 1), a--, o = -1), o == -1) {
        if (this.modules.splice(a++, 0, s), i) for (let u = 0; u < s.rules.length; u++)
          i.insertRule(s.rules[u], l++);
      } else {
        for (; a < o; ) l += this.modules[a++].rules.length;
        l += s.rules.length, a++;
      }
    }
    if (i)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let r = "";
      for (let o = 0; o < this.modules.length; o++)
        r += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = r;
      let s = n.head || n;
      this.styleTag.parentNode != s && s.insertBefore(this.styleTag, s.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}
var tl = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, zr = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, aP = typeof navigator < "u" && /Mac/.test(navigator.platform), rP = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var jt = 0; jt < 10; jt++) tl[48 + jt] = tl[96 + jt] = String(jt);
for (var jt = 1; jt <= 24; jt++) tl[jt + 111] = "F" + jt;
for (var jt = 65; jt <= 90; jt++)
  tl[jt] = String.fromCharCode(jt + 32), zr[jt] = String.fromCharCode(jt);
for (var wc in tl) zr.hasOwnProperty(wc) || (zr[wc] = tl[wc]);
function sP(e) {
  var t = aP && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || rP && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified", n = !t && e.key || (e.shiftKey ? zr : tl)[e.keyCode] || e.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function Hr(e) {
  let t;
  return e.nodeType == 11 ? t = e.getSelection ? e : e.ownerDocument : t = e, t.getSelection();
}
function G1(e, t) {
  return t ? e == t || e.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
function uo(e, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return G1(e, t.anchorNode);
  } catch {
    return !1;
  }
}
function _a(e) {
  return e.nodeType == 3 ? zl(e, 0, e.nodeValue.length).getClientRects() : e.nodeType == 1 ? e.getClientRects() : [];
}
function Cr(e, t, n, i) {
  return n ? v0(e, t, n, i, -1) || v0(e, t, n, i, 1) : !1;
}
function El(e) {
  for (var t = 0; ; t++)
    if (e = e.previousSibling, !e)
      return t;
}
function Ro(e) {
  return e.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName);
}
function v0(e, t, n, i, l) {
  for (; ; ) {
    if (e == n && t == i)
      return !0;
    if (t == (l < 0 ? 0 : mi(e))) {
      if (e.nodeName == "DIV")
        return !1;
      let a = e.parentNode;
      if (!a || a.nodeType != 1)
        return !1;
      t = El(e) + (l < 0 ? 0 : 1), e = a;
    } else if (e.nodeType == 1) {
      if (e = e.childNodes[t + (l < 0 ? -1 : 0)], e.nodeType == 1 && e.contentEditable == "false")
        return !1;
      t = l < 0 ? mi(e) : 0;
    } else
      return !1;
  }
}
function mi(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function vs(e, t) {
  let n = t ? e.left : e.right;
  return { left: n, right: n, top: e.top, bottom: e.bottom };
}
function oP(e) {
  let t = e.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: e.innerWidth,
    top: 0,
    bottom: e.innerHeight
  };
}
function P3(e, t) {
  let n = t.width / e.offsetWidth, i = t.height / e.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(t.width - e.offsetWidth) < 1) && (n = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(t.height - e.offsetHeight) < 1) && (i = 1), { scaleX: n, scaleY: i };
}
function uP(e, t, n, i, l, a, r, s) {
  let o = e.ownerDocument, u = o.defaultView || window;
  for (let c = e, d = !1; c && !d; )
    if (c.nodeType == 1) {
      let f, h = c == o.body, g = 1, v = 1;
      if (h)
        f = oP(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (d = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let b = c.getBoundingClientRect();
        ({ scaleX: g, scaleY: v } = P3(c, b)), f = {
          left: b.left,
          right: b.left + c.clientWidth * g,
          top: b.top,
          bottom: b.top + c.clientHeight * v
        };
      }
      let p = 0, O = 0;
      if (l == "nearest")
        t.top < f.top ? (O = -(f.top - t.top + r), n > 0 && t.bottom > f.bottom + O && (O = t.bottom - f.bottom + O + r)) : t.bottom > f.bottom && (O = t.bottom - f.bottom + r, n < 0 && t.top - O < f.top && (O = -(f.top + O - t.top + r)));
      else {
        let b = t.bottom - t.top, V = f.bottom - f.top;
        O = (l == "center" && b <= V ? t.top + b / 2 - V / 2 : l == "start" || l == "center" && n < 0 ? t.top - r : t.bottom - V + r) - f.top;
      }
      if (i == "nearest" ? t.left < f.left ? (p = -(f.left - t.left + a), n > 0 && t.right > f.right + p && (p = t.right - f.right + p + a)) : t.right > f.right && (p = t.right - f.right + a, n < 0 && t.left < f.left + p && (p = -(f.left + p - t.left + a))) : p = (i == "center" ? t.left + (t.right - t.left) / 2 - (f.right - f.left) / 2 : i == "start" == s ? t.left - a : t.right - (f.right - f.left) + a) - f.left, p || O)
        if (h)
          u.scrollBy(p, O);
        else {
          let b = 0, V = 0;
          if (O) {
            let $ = c.scrollTop;
            c.scrollTop += O / v, V = (c.scrollTop - $) * v;
          }
          if (p) {
            let $ = c.scrollLeft;
            c.scrollLeft += p / g, b = (c.scrollLeft - $) * g;
          }
          t = {
            left: t.left - b,
            top: t.top - V,
            right: t.right - b,
            bottom: t.bottom - V
          }, b && Math.abs(b - p) < 1 && (i = "nearest"), V && Math.abs(V - O) < 1 && (l = "nearest");
        }
      if (h)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function cP(e) {
  let t = e.ownerDocument, n, i;
  for (let l = e.parentNode; l && !(l == t.body || n && i); )
    if (l.nodeType == 1)
      !i && l.scrollHeight > l.clientHeight && (i = l), !n && l.scrollWidth > l.clientWidth && (n = l), l = l.assignedSlot || l.parentNode;
    else if (l.nodeType == 11)
      l = l.host;
    else
      break;
  return { x: n, y: i };
}
class dP {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: n, focusNode: i } = t;
    this.set(n, Math.min(t.anchorOffset, n ? mi(n) : 0), i, Math.min(t.focusOffset, i ? mi(i) : 0));
  }
  set(t, n, i, l) {
    this.anchorNode = t, this.anchorOffset = n, this.focusNode = i, this.focusOffset = l;
  }
}
let oa = null;
function $3(e) {
  if (e.setActive)
    return e.setActive();
  if (oa)
    return e.focus(oa);
  let t = [];
  for (let n = e; n && (t.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (e.focus(oa == null ? {
    get preventScroll() {
      return oa = { preventScroll: !0 }, !0;
    }
  } : void 0), !oa) {
    oa = !1;
    for (let n = 0; n < t.length; ) {
      let i = t[n++], l = t[n++], a = t[n++];
      i.scrollTop != l && (i.scrollTop = l), i.scrollLeft != a && (i.scrollLeft = a);
    }
  }
}
let p0;
function zl(e, t, n = t) {
  let i = p0 || (p0 = document.createRange());
  return i.setEnd(e, n), i.setStart(e, t), i;
}
function ba(e, t, n, i) {
  let l = { key: t, code: t, keyCode: n, which: n, cancelable: !0 };
  i && ({ altKey: l.altKey, ctrlKey: l.ctrlKey, shiftKey: l.shiftKey, metaKey: l.metaKey } = i);
  let a = new KeyboardEvent("keydown", l);
  a.synthetic = !0, e.dispatchEvent(a);
  let r = new KeyboardEvent("keyup", l);
  return r.synthetic = !0, e.dispatchEvent(r), a.defaultPrevented || r.defaultPrevented;
}
function fP(e) {
  for (; e; ) {
    if (e && (e.nodeType == 9 || e.nodeType == 11 && e.host))
      return e;
    e = e.assignedSlot || e.parentNode;
  }
  return null;
}
function V3(e) {
  for (; e.attributes.length; )
    e.removeAttributeNode(e.attributes[0]);
}
function hP(e, t) {
  let n = t.focusNode, i = t.focusOffset;
  if (!n || t.anchorNode != n || t.anchorOffset != i)
    return !1;
  for (i = Math.min(i, mi(n)); ; )
    if (i) {
      if (n.nodeType != 1)
        return !1;
      let l = n.childNodes[i - 1];
      l.contentEditable == "false" ? i-- : (n = l, i = mi(n));
    } else {
      if (n == e)
        return !0;
      i = El(n), n = n.parentNode;
    }
}
function Q3(e) {
  return e.scrollTop > Math.max(1, e.scrollHeight - e.clientHeight - 4);
}
function L3(e, t) {
  for (let n = e, i = t; ; ) {
    if (n.nodeType == 3 && i > 0)
      return { node: n, offset: i };
    if (n.nodeType == 1 && i > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[i - 1], i = mi(n);
    } else if (n.parentNode && !Ro(n))
      i = El(n), n = n.parentNode;
    else
      return null;
  }
}
function M3(e, t) {
  for (let n = e, i = t; ; ) {
    if (n.nodeType == 3 && i < n.nodeValue.length)
      return { node: n, offset: i };
    if (n.nodeType == 1 && i < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[i], i = 0;
    } else if (n.parentNode && !Ro(n))
      i = El(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class Kt {
  constructor(t, n, i = !0) {
    this.node = t, this.offset = n, this.precise = i;
  }
  static before(t, n) {
    return new Kt(t.parentNode, El(t), n);
  }
  static after(t, n) {
    return new Kt(t.parentNode, El(t) + 1, n);
  }
}
const ah = [];
class Ke {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let n = this.posAtStart;
    for (let i of this.children) {
      if (i == t)
        return n;
      n += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, n) {
    if (this.flags & 2) {
      let i = this.dom, l = null, a;
      for (let r of this.children) {
        if (r.flags & 7) {
          if (!r.dom && (a = l ? l.nextSibling : i.firstChild)) {
            let s = Ke.get(a);
            (!s || !s.parent && s.canReuseDOM(r)) && r.reuseDOM(a);
          }
          r.sync(t, n), r.flags &= -8;
        }
        if (a = l ? l.nextSibling : i.firstChild, n && !n.written && n.node == i && a != r.dom && (n.written = !0), r.dom.parentNode == i)
          for (; a && a != r.dom; )
            a = O0(a);
        else
          i.insertBefore(r.dom, a);
        l = r.dom;
      }
      for (a = l ? l.nextSibling : i.firstChild, a && n && n.node == i && (n.written = !0); a; )
        a = O0(a);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(t, n), i.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, n) {
    let i;
    if (t == this.dom)
      i = this.dom.childNodes[n];
    else {
      let l = mi(t) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let a = t.parentNode;
        if (a == this.dom)
          break;
        l == 0 && a.firstChild != a.lastChild && (t == a.firstChild ? l = -1 : l = 1), t = a;
      }
      l < 0 ? i = t : i = t.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Ke.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let l = 0, a = 0; ; l++) {
      let r = this.children[l];
      if (r.dom == i)
        return a;
      a += r.length + r.breakAfter;
    }
  }
  domBoundsAround(t, n, i = 0) {
    let l = -1, a = -1, r = -1, s = -1;
    for (let o = 0, u = i, c = i; o < this.children.length; o++) {
      let d = this.children[o], f = u + d.length;
      if (u < t && f > n)
        return d.domBoundsAround(t, n, u);
      if (f >= t && l == -1 && (l = o, a = u), u > n && d.dom.parentNode == this.dom) {
        r = o, s = c;
        break;
      }
      c = f, u = f + d.breakAfter;
    }
    return {
      from: a,
      to: s < 0 ? i + this.length : s,
      startDOM: (l ? this.children[l - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: r < this.children.length && r >= 0 ? this.children[r].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let n = this.parent; n; n = n.parent) {
      if (t && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let n = t.parent;
      if (!n)
        return t;
      t = n;
    }
  }
  replaceChildren(t, n, i = ah) {
    this.markDirty();
    for (let l = t; l < n; l++) {
      let a = this.children[l];
      a.parent == this && i.indexOf(a) < 0 && a.destroy();
    }
    i.length < 250 ? this.children.splice(t, n - t, ...i) : this.children = [].concat(this.children.slice(0, t), i, this.children.slice(n));
    for (let l = 0; l < i.length; l++)
      i[l].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new T3(this.children, t, this.children.length);
  }
  childPos(t, n = 1) {
    return this.childCursor().findPos(t, n);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, n, i, l, a, r) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}
Ke.prototype.breakAfter = 0;
function O0(e) {
  let t = e.nextSibling;
  return e.parentNode.removeChild(e), t;
}
class T3 {
  constructor(t, n, i) {
    this.children = t, this.pos = n, this.i = i, this.off = 0;
  }
  findPos(t, n = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function _3(e, t, n, i, l, a, r, s, o) {
  let { children: u } = e, c = u.length ? u[t] : null, d = a.length ? a[a.length - 1] : null, f = d ? d.breakAfter : r;
  if (!(t == i && c && !r && !f && a.length < 2 && c.merge(n, l, a.length ? d : null, n == 0, s, o))) {
    if (i < u.length) {
      let h = u[i];
      h && (l < h.length || h.breakAfter && (d != null && d.breakAfter)) ? (t == i && (h = h.split(l), l = 0), !f && d && h.merge(0, l, d, !0, 0, o) ? a[a.length - 1] = h : ((l || h.children.length && !h.children[0].length) && h.merge(0, l, null, !1, 0, o), a.push(h))) : h != null && h.breakAfter && (d ? d.breakAfter = 1 : r = 1), i++;
    }
    for (c && (c.breakAfter = r, n > 0 && (!r && a.length && c.merge(n, c.length, a[0], !1, s, 0) ? c.breakAfter = a.shift().breakAfter : (n < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(n, c.length, null, !1, s, 0), t++)); t < i && a.length; )
      if (u[i - 1].become(a[a.length - 1]))
        i--, a.pop(), o = a.length ? 0 : s;
      else if (u[t].become(a[0]))
        t++, a.shift(), s = a.length ? 0 : o;
      else
        break;
    !a.length && t && i < u.length && !u[t - 1].breakAfter && u[i].merge(0, 0, u[t - 1], !1, s, o) && t--, (t < i || a.length) && e.replaceChildren(t, i, a);
  }
}
function A3(e, t, n, i, l, a) {
  let r = e.childCursor(), { i: s, off: o } = r.findPos(n, 1), { i: u, off: c } = r.findPos(t, -1), d = t - n;
  for (let f of i)
    d += f.length;
  e.length += d, _3(e, u, c, s, o, i, 0, l, a);
}
let hn = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, K1 = typeof document < "u" ? document : { documentElement: { style: {} } };
const J1 = /* @__PURE__ */ /Edge\/(\d+)/.exec(hn.userAgent), R3 = /* @__PURE__ */ /MSIE \d/.test(hn.userAgent), ed = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(hn.userAgent), Nu = !!(R3 || ed || J1), y0 = !Nu && /* @__PURE__ */ /gecko\/(\d+)/i.test(hn.userAgent), kc = !Nu && /* @__PURE__ */ /Chrome\/(\d+)/.exec(hn.userAgent), b0 = "webkitFontSmoothing" in K1.documentElement.style, Z3 = !Nu && /* @__PURE__ */ /Apple Computer/.test(hn.vendor), C0 = Z3 && (/* @__PURE__ */ /Mobile\/\w+/.test(hn.userAgent) || hn.maxTouchPoints > 2);
var Oe = {
  mac: C0 || /* @__PURE__ */ /Mac/.test(hn.platform),
  windows: /* @__PURE__ */ /Win/.test(hn.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(hn.platform),
  ie: Nu,
  ie_version: R3 ? K1.documentMode || 6 : ed ? +ed[1] : J1 ? +J1[1] : 0,
  gecko: y0,
  gecko_version: y0 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(hn.userAgent) || [0, 0])[1] : 0,
  chrome: !!kc,
  chrome_version: kc ? +kc[1] : 0,
  ios: C0,
  android: /* @__PURE__ */ /Android\b/.test(hn.userAgent),
  webkit: b0,
  safari: Z3,
  webkit_version: b0 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(hn.userAgent) || [0, 0])[1] : 0,
  tabSize: K1.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const mP = 256;
class Wn extends Ke {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, n, i) {
    return this.flags & 8 || i && (!(i instanceof Wn) || this.length - (n - t) + i.length > mP || i.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(t) {
    let n = new Wn(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(t, n) {
    return t == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(t) {
    return new Kt(this.dom, t);
  }
  domBoundsAround(t, n, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, n) {
    return gP(this.dom, t, n);
  }
}
class Li extends Ke {
  constructor(t, n = [], i = 0) {
    super(), this.mark = t, this.children = n, this.length = i;
    for (let l of n)
      l.setParent(this);
  }
  setAttrs(t) {
    if (V3(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        t.setAttribute(n, this.mark.attrs[n]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, n);
  }
  merge(t, n, i, l, a, r) {
    return i && (!(i instanceof Li && i.mark.eq(this.mark)) || t && a <= 0 || n < this.length && r <= 0) ? !1 : (A3(this, t, n, i ? i.children.slice() : [], a - 1, r - 1), this.markDirty(), !0);
  }
  split(t) {
    let n = [], i = 0, l = -1, a = 0;
    for (let s of this.children) {
      let o = i + s.length;
      o > t && n.push(i < t ? s.split(t - i) : s), l < 0 && i >= t && (l = a), i = o, a++;
    }
    let r = this.length - t;
    return this.length = t, l > -1 && (this.children.length = l, this.markDirty()), new Li(this.mark, n, r);
  }
  domAtPos(t) {
    return I3(this, t);
  }
  coordsAt(t, n) {
    return B3(this, t, n);
  }
}
function gP(e, t, n) {
  let i = e.nodeValue.length;
  t > i && (t = i);
  let l = t, a = t, r = 0;
  t == 0 && n < 0 || t == i && n >= 0 ? Oe.chrome || Oe.gecko || (t ? (l--, r = 1) : a < i && (a++, r = -1)) : n < 0 ? l-- : a < i && a++;
  let s = zl(e, l, a).getClientRects();
  if (!s.length)
    return null;
  let o = s[(r ? r < 0 : n >= 0) ? 0 : s.length - 1];
  return Oe.safari && !r && o.width == 0 && (o = Array.prototype.find.call(s, (u) => u.width) || o), r ? vs(o, r < 0) : o || null;
}
class qi extends Ke {
  static create(t, n, i) {
    return new qi(t, n, i);
  }
  constructor(t, n, i) {
    super(), this.widget = t, this.length = n, this.side = i, this.prevWidget = null;
  }
  split(t) {
    let n = qi.create(this.widget, this.length - t, this.side);
    return this.length -= t, n;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t, n, i, l, a, r) {
    return i && (!(i instanceof qi) || !this.widget.compare(i.widget) || t > 0 && a <= 0 || n < this.length && r <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - n), !0);
  }
  become(t) {
    return t instanceof qi && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Ne.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: n } = t, i = n && n.state.doc, l = this.posAtStart;
    return i ? i.slice(l, l + this.length) : Ne.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? Kt.before(this.dom) : Kt.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, n) {
    let i = this.widget.coordsAt(this.dom, t, n);
    if (i)
      return i;
    let l = this.dom.getClientRects(), a = null;
    if (!l.length)
      return null;
    let r = this.side ? this.side < 0 : t > 0;
    for (let s = r ? l.length - 1 : 0; a = l[s], !(t > 0 ? s == 0 : s == l.length - 1 || a.top < a.bottom); s += r ? -1 : 1)
      ;
    return vs(a, !r);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Aa extends Ke {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof Aa && t.side == this.side;
  }
  split() {
    return new Aa(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? Kt.before(this.dom) : Kt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Ne.empty;
  }
  get isHidden() {
    return !0;
  }
}
Wn.prototype.children = qi.prototype.children = Aa.prototype.children = ah;
function I3(e, t) {
  let n = e.dom, { children: i } = e, l = 0;
  for (let a = 0; l < i.length; l++) {
    let r = i[l], s = a + r.length;
    if (!(s == a && r.getSide() <= 0)) {
      if (t > a && t < s && r.dom.parentNode == n)
        return r.domAtPos(t - a);
      if (t <= a)
        break;
      a = s;
    }
  }
  for (let a = l; a > 0; a--) {
    let r = i[a - 1];
    if (r.dom.parentNode == n)
      return r.domAtPos(r.length);
  }
  for (let a = l; a < i.length; a++) {
    let r = i[a];
    if (r.dom.parentNode == n)
      return r.domAtPos(0);
  }
  return new Kt(n, 0);
}
function D3(e, t, n) {
  let i, { children: l } = e;
  n > 0 && t instanceof Li && l.length && (i = l[l.length - 1]) instanceof Li && i.mark.eq(t.mark) ? D3(i, t.children[0], n - 1) : (l.push(t), t.setParent(e)), e.length += t.length;
}
function B3(e, t, n) {
  let i = null, l = -1, a = null, r = -1;
  function s(u, c) {
    for (let d = 0, f = 0; d < u.children.length && f <= c; d++) {
      let h = u.children[d], g = f + h.length;
      g >= c && (h.children.length ? s(h, c - f) : (!a || a.isHidden && n > 0) && (g > c || f == g && h.getSide() > 0) ? (a = h, r = c - f) : (f < c || f == g && h.getSide() < 0 && !h.isHidden) && (i = h, l = c - f)), f = g;
    }
  }
  s(e, t);
  let o = (n < 0 ? i : a) || i || a;
  return o ? o.coordsAt(Math.max(0, o == i ? l : r), n) : vP(e);
}
function vP(e) {
  let t = e.dom.lastChild;
  if (!t)
    return e.dom.getBoundingClientRect();
  let n = _a(t);
  return n[n.length - 1] || null;
}
function td(e, t) {
  for (let n in e)
    n == "class" && t.class ? t.class += " " + e.class : n == "style" && t.style ? t.style += ";" + e.style : t[n] = e[n];
  return t;
}
const S0 = /* @__PURE__ */ Object.create(null);
function Zo(e, t, n) {
  if (e == t)
    return !0;
  e || (e = S0), t || (t = S0);
  let i = Object.keys(e), l = Object.keys(t);
  if (i.length - (n && i.indexOf(n) > -1 ? 1 : 0) != l.length - (n && l.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let a of i)
    if (a != n && (l.indexOf(a) == -1 || e[a] !== t[a]))
      return !1;
  return !0;
}
function nd(e, t, n) {
  let i = !1;
  if (t)
    for (let l in t)
      n && l in n || (i = !0, l == "style" ? e.style.cssText = "" : e.removeAttribute(l));
  if (n)
    for (let l in n)
      t && t[l] == n[l] || (i = !0, l == "style" ? e.style.cssText = n[l] : e.setAttribute(l, n[l]));
  return i;
}
function pP(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < e.attributes.length; n++) {
    let i = e.attributes[n];
    t[i.name] = i.value;
  }
  return t;
}
class bi {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, n, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}
var cn = /* @__PURE__ */ function(e) {
  return e[e.Text = 0] = "Text", e[e.WidgetBefore = 1] = "WidgetBefore", e[e.WidgetAfter = 2] = "WidgetAfter", e[e.WidgetRange = 3] = "WidgetRange", e;
}(cn || (cn = {}));
class Ce extends Bl {
  constructor(t, n, i, l) {
    super(), this.startSide = t, this.endSide = n, this.widget = i, this.spec = l;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new ps(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let n = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block;
    return n += i && !t.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new nl(t, n, n, i, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let n = !!t.block, i, l;
    if (t.isBlockGap)
      i = -5e8, l = 4e8;
    else {
      let { start: a, end: r } = E3(t, n);
      i = (a ? n ? -3e8 : -1 : 5e8) - 1, l = (r ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new nl(t, i, l, n, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new Os(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, n = !1) {
    return Ee.of(t, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Ce.none = Ee.empty;
class ps extends Ce {
  constructor(t) {
    let { start: n, end: i } = E3(t);
    super(n ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var n, i;
    return this == t || t instanceof ps && this.tagName == t.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (t.class || ((i = t.attrs) === null || i === void 0 ? void 0 : i.class)) && Zo(this.attrs, t.attrs, "class");
  }
  range(t, n = t) {
    if (t >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, n);
  }
}
ps.prototype.point = !1;
class Os extends Ce {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof Os && this.spec.class == t.spec.class && Zo(this.spec.attributes, t.spec.attributes);
  }
  range(t, n = t) {
    if (n != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, n);
  }
}
Os.prototype.mapMode = Nt.TrackBefore;
Os.prototype.point = !0;
class nl extends Ce {
  constructor(t, n, i, l, a, r) {
    super(n, i, a, t), this.block = l, this.isReplace = r, this.mapMode = l ? n <= 0 ? Nt.TrackBefore : Nt.TrackAfter : Nt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? cn.WidgetRange : this.startSide <= 0 ? cn.WidgetBefore : cn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof nl && OP(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, n = t) {
    if (this.isReplace && (t > n || t == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, n);
  }
}
nl.prototype.point = !0;
function E3(e, t = !1) {
  let { inclusiveStart: n, inclusiveEnd: i } = e;
  return n == null && (n = e.inclusive), i == null && (i = e.inclusive), { start: n ?? t, end: i ?? t };
}
function OP(e, t) {
  return e == t || !!(e && t && e.compare(t));
}
function id(e, t, n, i = 0) {
  let l = n.length - 1;
  l >= 0 && n[l] + i >= e ? n[l] = Math.max(n[l], t) : n.push(e, t);
}
class xt extends Ke {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(t, n, i, l, a, r) {
    if (i) {
      if (!(i instanceof xt))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return l && this.setDeco(i ? i.attrs : null), A3(this, t, n, i ? i.children.slice() : [], a, r), !0;
  }
  split(t) {
    let n = new xt();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i, off: l } = this.childPos(t);
    l && (n.append(this.children[i].split(l), 0), this.children[i].merge(l, this.children[i].length, null, !1, 0, 0), i++);
    for (let a = i; a < this.children.length; a++)
      n.append(this.children[a], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = t, n;
  }
  transferDOM(t) {
    this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    Zo(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, n) {
    D3(this, t, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(t) {
    let n = t.spec.attributes, i = t.spec.class;
    n && (this.attrs = td(n, this.attrs || {})), i && (this.attrs = td({ class: i }, this.attrs || {}));
  }
  domAtPos(t) {
    return I3(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, n) {
    var i;
    this.dom ? this.flags & 4 && (V3(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (nd(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, n);
    let l = this.dom.lastChild;
    for (; l && Ke.get(l) instanceof Li; )
      l = l.lastChild;
    if (!l || !this.length || l.nodeName != "BR" && ((i = Ke.get(l)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!Oe.ios || !this.children.some((a) => a instanceof Wn))) {
      let a = document.createElement("BR");
      a.cmIgnore = !0, this.dom.appendChild(a);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, n;
    for (let i of this.children) {
      if (!(i instanceof Wn) || /[^ -~]/.test(i.text))
        return null;
      let l = _a(i.dom);
      if (l.length != 1)
        return null;
      t += l[0].width, n = l[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(t, n) {
    let i = B3(this, t, n);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: l } = this.parent.view.viewState, a = i.bottom - i.top;
      if (Math.abs(a - l.lineHeight) < 2 && l.textHeight < a) {
        let r = (a - l.textHeight) / 2;
        return { top: i.top + r, bottom: i.bottom - r, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(t) {
    return t instanceof xt && this.children.length == 0 && t.children.length == 0 && Zo(this.attrs, t.attrs) && this.breakAfter == t.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(t, n) {
    for (let i = 0, l = 0; i < t.children.length; i++) {
      let a = t.children[i], r = l + a.length;
      if (r >= n) {
        if (a instanceof xt)
          return a;
        if (r > n)
          break;
      }
      l = r + a.breakAfter;
    }
    return null;
  }
}
class xi extends Ke {
  constructor(t, n, i) {
    super(), this.widget = t, this.length = n, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, n, i, l, a, r) {
    return i && (!(i instanceof xi) || !this.widget.compare(i.widget) || t > 0 && a <= 0 || n < this.length && r <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - n), !0);
  }
  domAtPos(t) {
    return t == 0 ? Kt.before(this.dom) : Kt.after(this.dom, t == this.length);
  }
  split(t) {
    let n = this.length - t;
    this.length = t;
    let i = new xi(this.widget, n, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return ah;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Ne.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof xi && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, n) {
    let i = this.widget.coordsAt(this.dom, t, n);
    return i || (this.widget instanceof ld ? null : vs(this.dom.getBoundingClientRect(), this.length ? t == 0 : n <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: n, endSide: i } = this.deco;
    return n == i ? !1 : t < 0 ? n < 0 : i > 0;
  }
}
class ld extends bi {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Sr {
  constructor(t, n, i, l) {
    this.doc = t, this.pos = n, this.end = i, this.disallowBlockEffectsFor = l, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof xi && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new xt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Zs(new Aa(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof xi) && this.getLine();
  }
  buildText(t, n, i) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: a, lineBreak: r, done: s } = this.cursor.next(this.skip);
        if (this.skip = 0, s)
          throw new Error("Ran out of text content when drawing inline views");
        if (r) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = a, this.textOff = 0;
      }
      let l = Math.min(
        this.text.length - this.textOff,
        t,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - i)), this.getLine().append(Zs(new Wn(this.text.slice(this.textOff, this.textOff + l)), n), i), this.atCursorPos = !0, this.textOff += l, t -= l, i = 0;
    }
  }
  span(t, n, i, l) {
    this.buildText(n - t, i, l), this.pos = n, this.openStart < 0 && (this.openStart = l);
  }
  point(t, n, i, l, a, r) {
    if (this.disallowBlockEffectsFor[r] && i instanceof nl) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let s = n - t;
    if (i instanceof nl)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new xi(i.widget || Ra.block, s, i));
      else {
        let o = qi.create(i.widget || Ra.inline, s, s ? 0 : i.startSide), u = this.atCursorPos && !o.isEditable && a <= l.length && (t < n || i.startSide > 0), c = !o.isEditable && (t < n || a > l.length || i.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !u && !o.isEditable && (this.pendingBuffer = 0), this.flushBuffer(l), u && (d.append(Zs(new Aa(1), l), a), a = l.length + Math.max(0, a - l.length)), d.append(Zs(o, l), a), this.atCursorPos = c, this.pendingBuffer = c ? t < n || a > l.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = l.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    s && (this.textOff + s <= this.text.length ? this.textOff += s : (this.skip += s - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = a);
  }
  static build(t, n, i, l, a) {
    let r = new Sr(t, n, i, a);
    return r.openEnd = Ee.spans(l, n, i, r), r.openStart < 0 && (r.openStart = r.openEnd), r.finish(r.openEnd), r;
  }
}
function Zs(e, t) {
  for (let n of t)
    e = new Li(n, [e], e.length);
  return e;
}
class Ra extends bi {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
Ra.inline = /* @__PURE__ */ new Ra("span");
Ra.block = /* @__PURE__ */ new Ra("div");
var ot = /* @__PURE__ */ function(e) {
  return e[e.LTR = 0] = "LTR", e[e.RTL = 1] = "RTL", e;
}(ot || (ot = {}));
const Hl = ot.LTR, rh = ot.RTL;
function z3(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
    t.push(1 << +e[n]);
  return t;
}
const yP = /* @__PURE__ */ z3("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), bP = /* @__PURE__ */ z3("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), ad = /* @__PURE__ */ Object.create(null), ti = [];
for (let e of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ e.charCodeAt(0), n = /* @__PURE__ */ e.charCodeAt(1);
  ad[t] = n, ad[n] = -t;
}
function H3(e) {
  return e <= 247 ? yP[e] : 1424 <= e && e <= 1524 ? 2 : 1536 <= e && e <= 1785 ? bP[e - 1536] : 1774 <= e && e <= 2220 ? 4 : 8192 <= e && e <= 8204 ? 256 : 64336 <= e && e <= 65023 ? 4 : 1;
}
const CP = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Yi {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? rh : Hl;
  }
  /**
  @internal
  */
  constructor(t, n, i) {
    this.from = t, this.to = n, this.level = i;
  }
  /**
  @internal
  */
  side(t, n) {
    return this.dir == n == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, n) {
    return t == (this.dir == n);
  }
  /**
  @internal
  */
  static find(t, n, i, l) {
    let a = -1;
    for (let r = 0; r < t.length; r++) {
      let s = t[r];
      if (s.from <= n && s.to >= n) {
        if (s.level == i)
          return r;
        (a < 0 || (l != 0 ? l < 0 ? s.from < n : s.to > n : t[a].level > s.level)) && (a = r);
      }
    }
    if (a < 0)
      throw new RangeError("Index out of range");
    return a;
  }
}
function j3(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++) {
    let i = e[n], l = t[n];
    if (i.from != l.from || i.to != l.to || i.direction != l.direction || !j3(i.inner, l.inner))
      return !1;
  }
  return !0;
}
const Ge = [];
function SP(e, t, n, i, l) {
  for (let a = 0; a <= i.length; a++) {
    let r = a ? i[a - 1].to : t, s = a < i.length ? i[a].from : n, o = a ? 256 : l;
    for (let u = r, c = o, d = o; u < s; u++) {
      let f = H3(e.charCodeAt(u));
      f == 512 ? f = c : f == 8 && d == 4 && (f = 16), Ge[u] = f == 4 ? 2 : f, f & 7 && (d = f), c = f;
    }
    for (let u = r, c = o, d = o; u < s; u++) {
      let f = Ge[u];
      if (f == 128)
        u < s - 1 && c == Ge[u + 1] && c & 24 ? f = Ge[u] = c : Ge[u] = 256;
      else if (f == 64) {
        let h = u + 1;
        for (; h < s && Ge[h] == 64; )
          h++;
        let g = u && c == 8 || h < n && Ge[h] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let v = u; v < h; v++)
          Ge[v] = g;
        u = h - 1;
      } else f == 8 && d == 1 && (Ge[u] = 1);
      c = f, f & 7 && (d = f);
    }
  }
}
function wP(e, t, n, i, l) {
  let a = l == 1 ? 2 : 1;
  for (let r = 0, s = 0, o = 0; r <= i.length; r++) {
    let u = r ? i[r - 1].to : t, c = r < i.length ? i[r].from : n;
    for (let d = u, f, h, g; d < c; d++)
      if (h = ad[f = e.charCodeAt(d)])
        if (h < 0) {
          for (let v = s - 3; v >= 0; v -= 3)
            if (ti[v + 1] == -h) {
              let p = ti[v + 2], O = p & 2 ? l : p & 4 ? p & 1 ? a : l : 0;
              O && (Ge[d] = Ge[ti[v]] = O), s = v;
              break;
            }
        } else {
          if (ti.length == 189)
            break;
          ti[s++] = d, ti[s++] = f, ti[s++] = o;
        }
      else if ((g = Ge[d]) == 2 || g == 1) {
        let v = g == l;
        o = v ? 0 : 1;
        for (let p = s - 3; p >= 0; p -= 3) {
          let O = ti[p + 2];
          if (O & 2)
            break;
          if (v)
            ti[p + 2] |= 2;
          else {
            if (O & 4)
              break;
            ti[p + 2] |= 4;
          }
        }
      }
  }
}
function kP(e, t, n, i) {
  for (let l = 0, a = i; l <= n.length; l++) {
    let r = l ? n[l - 1].to : e, s = l < n.length ? n[l].from : t;
    for (let o = r; o < s; ) {
      let u = Ge[o];
      if (u == 256) {
        let c = o + 1;
        for (; ; )
          if (c == s) {
            if (l == n.length)
              break;
            c = n[l++].to, s = l < n.length ? n[l].from : t;
          } else if (Ge[c] == 256)
            c++;
          else
            break;
        let d = a == 1, f = (c < t ? Ge[c] : i) == 1, h = d == f ? d ? 1 : 2 : i;
        for (let g = c, v = l, p = v ? n[v - 1].to : e; g > o; )
          g == p && (g = n[--v].from, p = v ? n[v - 1].to : e), Ge[--g] = h;
        o = c;
      } else
        a = u, o++;
    }
  }
}
function rd(e, t, n, i, l, a, r) {
  let s = i % 2 ? 2 : 1;
  if (i % 2 == l % 2)
    for (let o = t, u = 0; o < n; ) {
      let c = !0, d = !1;
      if (u == a.length || o < a[u].from) {
        let v = Ge[o];
        v != s && (c = !1, d = v == 16);
      }
      let f = !c && s == 1 ? [] : null, h = c ? i : i + 1, g = o;
      e: for (; ; )
        if (u < a.length && g == a[u].from) {
          if (d)
            break e;
          let v = a[u];
          if (!c)
            for (let p = v.to, O = u + 1; ; ) {
              if (p == n)
                break e;
              if (O < a.length && a[O].from == p)
                p = a[O++].to;
              else {
                if (Ge[p] == s)
                  break e;
                break;
              }
            }
          if (u++, f)
            f.push(v);
          else {
            v.from > o && r.push(new Yi(o, v.from, h));
            let p = v.direction == Hl != !(h % 2);
            sd(e, p ? i + 1 : i, l, v.inner, v.from, v.to, r), o = v.to;
          }
          g = v.to;
        } else {
          if (g == n || (c ? Ge[g] != s : Ge[g] == s))
            break;
          g++;
        }
      f ? rd(e, o, g, i + 1, l, f, r) : o < g && r.push(new Yi(o, g, h)), o = g;
    }
  else
    for (let o = n, u = a.length; o > t; ) {
      let c = !0, d = !1;
      if (!u || o > a[u - 1].to) {
        let v = Ge[o - 1];
        v != s && (c = !1, d = v == 16);
      }
      let f = !c && s == 1 ? [] : null, h = c ? i : i + 1, g = o;
      e: for (; ; )
        if (u && g == a[u - 1].to) {
          if (d)
            break e;
          let v = a[--u];
          if (!c)
            for (let p = v.from, O = u; ; ) {
              if (p == t)
                break e;
              if (O && a[O - 1].to == p)
                p = a[--O].from;
              else {
                if (Ge[p - 1] == s)
                  break e;
                break;
              }
            }
          if (f)
            f.push(v);
          else {
            v.to < o && r.push(new Yi(v.to, o, h));
            let p = v.direction == Hl != !(h % 2);
            sd(e, p ? i + 1 : i, l, v.inner, v.from, v.to, r), o = v.from;
          }
          g = v.from;
        } else {
          if (g == t || (c ? Ge[g - 1] != s : Ge[g - 1] == s))
            break;
          g--;
        }
      f ? rd(e, g, o, i + 1, l, f, r) : g < o && r.push(new Yi(g, o, h)), o = g;
    }
}
function sd(e, t, n, i, l, a, r) {
  let s = t % 2 ? 2 : 1;
  SP(e, l, a, i, s), wP(e, l, a, i, s), kP(l, a, i, s), rd(e, l, a, t, n, i, r);
}
function xP(e, t, n) {
  if (!e)
    return [new Yi(0, 0, t == rh ? 1 : 0)];
  if (t == Hl && !n.length && !CP.test(e))
    return X3(e.length);
  if (n.length)
    for (; e.length > Ge.length; )
      Ge[Ge.length] = 256;
  let i = [], l = t == Hl ? 0 : 1;
  return sd(e, l, l, n, 0, e.length, i), i;
}
function X3(e) {
  return [new Yi(0, e, 0)];
}
let N3 = "";
function PP(e, t, n, i, l) {
  var a;
  let r = i.head - e.from, s = Yi.find(t, r, (a = i.bidiLevel) !== null && a !== void 0 ? a : -1, i.assoc), o = t[s], u = o.side(l, n);
  if (r == u) {
    let f = s += l ? 1 : -1;
    if (f < 0 || f >= t.length)
      return null;
    o = t[s = f], r = o.side(!l, n), u = o.side(l, n);
  }
  let c = qt(e.text, r, o.forward(l, n));
  (c < o.from || c > o.to) && (c = u), N3 = e.text.slice(Math.min(r, c), Math.max(r, c));
  let d = s == (l ? t.length - 1 : 0) ? null : t[s + (l ? 1 : -1)];
  return d && c == u && d.level + (l ? 0 : 1) < o.level ? J.cursor(d.side(!l, n) + e.from, d.forward(l, n) ? 1 : -1, d.level) : J.cursor(c + e.from, o.forward(l, n) ? -1 : 1, o.level);
}
function $P(e, t, n) {
  for (let i = t; i < n; i++) {
    let l = H3(e.charCodeAt(i));
    if (l == 1)
      return Hl;
    if (l == 2 || l == 4)
      return rh;
  }
  return Hl;
}
const q3 = /* @__PURE__ */ ve.define(), Y3 = /* @__PURE__ */ ve.define(), F3 = /* @__PURE__ */ ve.define(), W3 = /* @__PURE__ */ ve.define(), od = /* @__PURE__ */ ve.define(), U3 = /* @__PURE__ */ ve.define(), G3 = /* @__PURE__ */ ve.define(), sh = /* @__PURE__ */ ve.define(), oh = /* @__PURE__ */ ve.define(), K3 = /* @__PURE__ */ ve.define({
  combine: (e) => e.some((t) => t)
}), J3 = /* @__PURE__ */ ve.define({
  combine: (e) => e.some((t) => t)
}), ev = /* @__PURE__ */ ve.define();
class Ca {
  constructor(t, n = "nearest", i = "nearest", l = 5, a = 5, r = !1) {
    this.range = t, this.y = n, this.x = i, this.yMargin = l, this.xMargin = a, this.isSnapshot = r;
  }
  map(t) {
    return t.empty ? this : new Ca(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new Ca(J.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Is = /* @__PURE__ */ Le.define({ map: (e, t) => e.map(t) }), tv = /* @__PURE__ */ Le.define();
function sn(e, t, n) {
  let i = e.facet(W3);
  i.length ? i[0](t) : window.onerror ? window.onerror(String(t), n, void 0, void 0, t) : n ? console.error(n + ":", t) : console.error(t);
}
const ji = /* @__PURE__ */ ve.define({ combine: (e) => e.length ? e[0] : !0 });
let VP = 0;
const hr = /* @__PURE__ */ ve.define();
class yt {
  constructor(t, n, i, l, a) {
    this.id = t, this.create = n, this.domEventHandlers = i, this.domEventObservers = l, this.extension = a(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, n) {
    const { eventHandlers: i, eventObservers: l, provide: a, decorations: r } = n || {};
    return new yt(VP++, t, i, l, (s) => {
      let o = [hr.of(s)];
      return r && o.push(jr.of((u) => {
        let c = u.plugin(s);
        return c ? r(c) : Ce.none;
      })), a && o.push(a(s)), o;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, n) {
    return yt.define((i) => new t(i), n);
  }
}
class xc {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (i) {
            if (sn(n.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(t);
      } catch (n) {
        sn(t.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        sn(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const nv = /* @__PURE__ */ ve.define(), uh = /* @__PURE__ */ ve.define(), jr = /* @__PURE__ */ ve.define(), iv = /* @__PURE__ */ ve.define(), ch = /* @__PURE__ */ ve.define(), lv = /* @__PURE__ */ ve.define();
function w0(e, t) {
  let n = e.state.facet(lv);
  if (!n.length)
    return n;
  let i = n.map((a) => a instanceof Function ? a(e) : a), l = [];
  return Ee.spans(i, t.from, t.to, {
    point() {
    },
    span(a, r, s, o) {
      let u = a - t.from, c = r - t.from, d = l;
      for (let f = s.length - 1; f >= 0; f--, o--) {
        let h = s[f].spec.bidiIsolate, g;
        if (h == null && (h = $P(t.text, u, c)), o > 0 && d.length && (g = d[d.length - 1]).to == u && g.direction == h)
          g.to = c, d = g.inner;
        else {
          let v = { from: u, to: c, direction: h, inner: [] };
          d.push(v), d = v.inner;
        }
      }
    }
  }), l;
}
const av = /* @__PURE__ */ ve.define();
function rv(e) {
  let t = 0, n = 0, i = 0, l = 0;
  for (let a of e.state.facet(av)) {
    let r = a(e);
    r && (r.left != null && (t = Math.max(t, r.left)), r.right != null && (n = Math.max(n, r.right)), r.top != null && (i = Math.max(i, r.top)), r.bottom != null && (l = Math.max(l, r.bottom)));
  }
  return { left: t, right: n, top: i, bottom: l };
}
const mr = /* @__PURE__ */ ve.define();
class _n {
  constructor(t, n, i, l) {
    this.fromA = t, this.toA = n, this.fromB = i, this.toB = l;
  }
  join(t) {
    return new _n(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let n = t.length, i = this;
    for (; n > 0; n--) {
      let l = t[n - 1];
      if (!(l.fromA > i.toA)) {
        if (l.toA < i.fromA)
          break;
        i = i.join(l), t.splice(n - 1, 1);
      }
    }
    return t.splice(n, 0, i), t;
  }
  static extendWithRanges(t, n) {
    if (n.length == 0)
      return t;
    let i = [];
    for (let l = 0, a = 0, r = 0, s = 0; ; l++) {
      let o = l == t.length ? null : t[l], u = r - s, c = o ? o.fromB : 1e9;
      for (; a < n.length && n[a] < c; ) {
        let d = n[a], f = n[a + 1], h = Math.max(s, d), g = Math.min(c, f);
        if (h <= g && new _n(h + u, g + u, h, g).addToSet(i), f > c)
          break;
        a += 2;
      }
      if (!o)
        return i;
      new _n(o.fromA, o.toA, o.fromB, o.toB).addToSet(i), r = o.toA, s = o.toB;
    }
  }
}
class Io {
  constructor(t, n, i) {
    this.view = t, this.state = n, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = Tt.empty(this.startState.doc.length);
    for (let a of i)
      this.changes = this.changes.compose(a.changes);
    let l = [];
    this.changes.iterChangedRanges((a, r, s, o) => l.push(new _n(a, r, s, o))), this.changedRanges = l;
  }
  /**
  @internal
  */
  static create(t, n, i) {
    return new Io(t, n, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class k0 extends Ke {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = Ce.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new xt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new _n(0, 0, 0, t.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(t) {
    var n;
    let i = t.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: u, toA: c }) => c < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let l = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? l = this.domChanged.newSel.head : !RP(t.changes, this.hasComposition) && !t.selectionSet && (l = t.state.selection.main.head));
    let a = l > -1 ? LP(this.view, t.changes, l) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u, to: c } = this.hasComposition;
      i = new _n(u, c, t.changes.mapPos(u, -1), t.changes.mapPos(c, 1)).addToSet(i.slice());
    }
    this.hasComposition = a ? { from: a.range.fromB, to: a.range.toB } : null, (Oe.ie || Oe.chrome) && !a && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let r = this.decorations, s = this.updateDeco(), o = _P(r, s, t.changes);
    return i = _n.extendWithRanges(i, o), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, t.startState.doc.length, a), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, n, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, n, i);
    let { observer: l } = this.view;
    l.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let r = Oe.chrome || Oe.ios ? { node: l.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, r), this.flags &= -8, r && (r.written || l.selectionRange.focusNode != r.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (r) => r.flags &= -9
      /* ViewFlag.Composition */
    );
    let a = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let r of this.children)
        r instanceof xi && r.widget instanceof ld && a.push(r.dom);
    l.updateGaps(a);
  }
  updateChildren(t, n, i) {
    let l = i ? i.range.addToSet(t.slice()) : t, a = this.childCursor(n);
    for (let r = l.length - 1; ; r--) {
      let s = r >= 0 ? l[r] : null;
      if (!s)
        break;
      let { fromA: o, toA: u, fromB: c, toB: d } = s, f, h, g, v;
      if (i && i.range.fromB < d && i.range.toB > c) {
        let $ = Sr.build(this.view.state.doc, c, i.range.fromB, this.decorations, this.dynamicDecorationMap), x = Sr.build(this.view.state.doc, i.range.toB, d, this.decorations, this.dynamicDecorationMap);
        h = $.breakAtStart, g = $.openStart, v = x.openEnd;
        let Q = this.compositionView(i);
        x.breakAtStart ? Q.breakAfter = 1 : x.content.length && Q.merge(Q.length, Q.length, x.content[0], !1, x.openStart, 0) && (Q.breakAfter = x.content[0].breakAfter, x.content.shift()), $.content.length && Q.merge(0, 0, $.content[$.content.length - 1], !0, 0, $.openEnd) && $.content.pop(), f = $.content.concat(Q).concat(x.content);
      } else
        ({ content: f, breakAtStart: h, openStart: g, openEnd: v } = Sr.build(this.view.state.doc, c, d, this.decorations, this.dynamicDecorationMap));
      let { i: p, off: O } = a.findPos(u, 1), { i: b, off: V } = a.findPos(o, -1);
      _3(this, b, V, p, O, f, h, g, v);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let n of t.transactions)
      for (let i of n.effects)
        i.is(tv) && (this.editContextFormatting = i.value);
  }
  compositionView(t) {
    let n = new Wn(t.text.nodeValue);
    n.flags |= 8;
    for (let { deco: l } of t.marks)
      n = new Li(l, [n], n.length);
    let i = new xt();
    return i.append(n, 0), i;
  }
  fixCompositionDOM(t) {
    let n = (a, r) => {
      r.flags |= 8 | (r.children.some(
        (o) => o.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(r);
      let s = Ke.get(a);
      s && s != r && (s.dom = null), r.setDOM(a);
    }, i = this.childPos(t.range.fromB, 1), l = this.children[i.i];
    n(t.line, l);
    for (let a = t.marks.length - 1; a >= -1; a--)
      i = l.childPos(i.off, 1), l = l.children[i.i], n(a >= 0 ? t.marks[a].node : t.text, l);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, n = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, l = i == this.dom, a = !l && uo(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(l || n || a))
      return;
    let r = this.forceSelection;
    this.forceSelection = !1;
    let s = this.view.state.selection.main, o = this.moveToLine(this.domAtPos(s.anchor)), u = s.empty ? o : this.moveToLine(this.domAtPos(s.head));
    if (Oe.gecko && s.empty && !this.hasComposition && QP(o)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => o.node.insertBefore(d, o.node.childNodes[o.offset] || null)), o = u = new Kt(d, 0), r = !0;
    }
    let c = this.view.observer.selectionRange;
    (r || !c.focusNode || (!Cr(o.node, o.offset, c.anchorNode, c.anchorOffset) || !Cr(u.node, u.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, s)) && (this.view.observer.ignore(() => {
      Oe.android && Oe.chrome && this.dom.contains(c.focusNode) && AP(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = Hr(this.view.root);
      if (d) if (s.empty) {
        if (Oe.gecko) {
          let f = MP(o.node, o.offset);
          if (f && f != 3) {
            let h = (f == 1 ? L3 : M3)(o.node, o.offset);
            h && (o = new Kt(h.node, h.offset));
          }
        }
        d.collapse(o.node, o.offset), s.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = s.bidiLevel);
      } else if (d.extend) {
        d.collapse(o.node, o.offset);
        try {
          d.extend(u.node, u.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        s.anchor > s.head && ([o, u] = [u, o]), f.setEnd(u.node, u.offset), f.setStart(o.node, o.offset), d.removeAllRanges(), d.addRange(f);
      }
      a && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(o, u)), this.impreciseAnchor = o.precise ? null : new Kt(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new Kt(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, n) {
    return this.hasComposition && n.empty && Cr(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, n = t.state.selection.main, i = Hr(t.root), { anchorNode: l, anchorOffset: a } = t.observer.selectionRange;
    if (!i || !n.empty || !n.assoc || !i.modify)
      return;
    let r = xt.find(this, n.head);
    if (!r)
      return;
    let s = r.posAtStart;
    if (n.head == s || n.head == s + r.length)
      return;
    let o = this.coordsAt(n.head, -1), u = this.coordsAt(n.head, 1);
    if (!o || !u || o.bottom > u.top)
      return;
    let c = this.domAtPos(n.head + n.assoc);
    i.collapse(c.node, c.offset), i.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let d = t.observer.selectionRange;
    t.docView.posFromDOM(d.anchorNode, d.anchorOffset) != n.from && i.collapse(l, a);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(t) {
    let n = this.dom, i;
    if (t.node != n)
      return t;
    for (let l = t.offset; !i && l < n.childNodes.length; l++) {
      let a = Ke.get(n.childNodes[l]);
      a instanceof xt && (i = a.domAtPos(0));
    }
    for (let l = t.offset - 1; !i && l >= 0; l--) {
      let a = Ke.get(n.childNodes[l]);
      a instanceof xt && (i = a.domAtPos(a.length));
    }
    return i ? new Kt(i.node, i.offset, !0) : t;
  }
  nearest(t) {
    for (let n = t; n; ) {
      let i = Ke.get(n);
      if (i && i.rootView == this)
        return i;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(t, n) {
    let i = this.nearest(t);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(t, n) + i.posAtStart;
  }
  domAtPos(t) {
    let { i: n, off: i } = this.childCursor().findPos(t, -1);
    for (; n < this.children.length - 1; ) {
      let l = this.children[n];
      if (i < l.length || l instanceof xt)
        break;
      n++, i = 0;
    }
    return this.children[n].domAtPos(i);
  }
  coordsAt(t, n) {
    let i = null, l = 0;
    for (let a = this.length, r = this.children.length - 1; r >= 0; r--) {
      let s = this.children[r], o = a - s.breakAfter, u = o - s.length;
      if (o < t)
        break;
      if (u <= t && (u < t || s.covers(-1)) && (o > t || s.covers(1)) && (!i || s instanceof xt && !(i instanceof xt && n >= 0)))
        i = s, l = u;
      else if (i && u == t && o == t && s instanceof xi && Math.abs(n) < 2) {
        if (s.deco.startSide < 0)
          break;
        r && (i = null);
      }
      a = u;
    }
    return i ? i.coordsAt(t - l, n) : null;
  }
  coordsForChar(t) {
    let { i: n, off: i } = this.childPos(t, 1), l = this.children[n];
    if (!(l instanceof xt))
      return null;
    for (; l.children.length; ) {
      let { i: s, off: o } = l.childPos(i, 1);
      for (; ; s++) {
        if (s == l.children.length)
          return null;
        if ((l = l.children[s]).length)
          break;
      }
      i = o;
    }
    if (!(l instanceof Wn))
      return null;
    let a = qt(l.text, i);
    if (a == i)
      return null;
    let r = zl(l.dom, i, a).getClientRects();
    for (let s = 0; s < r.length; s++) {
      let o = r[s];
      if (s == r.length - 1 || o.top < o.bottom && o.left < o.right)
        return o;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let n = [], { from: i, to: l } = t, a = this.view.contentDOM.clientWidth, r = a > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, s = -1, o = this.view.textDirection == ot.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let d = this.children[c], f = u + d.length;
      if (f > l)
        break;
      if (u >= i) {
        let h = d.dom.getBoundingClientRect();
        if (n.push(h.height), r) {
          let g = d.dom.lastChild, v = g ? _a(g) : [];
          if (v.length) {
            let p = v[v.length - 1], O = o ? p.right - h.left : h.right - p.left;
            O > s && (s = O, this.minWidth = a, this.minWidthFrom = u, this.minWidthTo = f);
          }
        }
      }
      u = f + d.breakAfter;
    }
    return n;
  }
  textDirectionAt(t) {
    let { i: n } = this.childPos(t, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? ot.RTL : ot.LTR;
  }
  measureTextSize() {
    for (let a of this.children)
      if (a instanceof xt) {
        let r = a.measureTextSize();
        if (r)
          return r;
      }
    let t = document.createElement("div"), n, i, l;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let a = _a(t.firstChild)[0];
      n = t.getBoundingClientRect().height, i = a ? a.width / 27 : 7, l = a ? a.height : n, t.remove();
    }), { lineHeight: n, charWidth: i, textHeight: l };
  }
  childCursor(t = this.length) {
    let n = this.children.length;
    return n && (t -= this.children[--n].length), new T3(this.children, t, n);
  }
  computeBlockGapDeco() {
    let t = [], n = this.view.viewState;
    for (let i = 0, l = 0; ; l++) {
      let a = l == n.viewports.length ? null : n.viewports[l], r = a ? a.from - 1 : this.length;
      if (r > i) {
        let s = (n.lineBlockAt(r).bottom - n.lineBlockAt(i).top) / this.view.scaleY;
        t.push(Ce.replace({
          widget: new ld(s),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, r));
      }
      if (!a)
        break;
      i = a.to + 1;
    }
    return Ce.set(t);
  }
  updateDeco() {
    let t = 1, n = this.view.state.facet(jr).map((a) => (this.dynamicDecorationMap[t++] = typeof a == "function") ? a(this.view) : a), i = !1, l = this.view.state.facet(iv).map((a, r) => {
      let s = typeof a == "function";
      return s && (i = !0), s ? a(this.view) : a;
    });
    for (l.length && (this.dynamicDecorationMap[t++] = i, n.push(Ee.join(l))), this.decorations = [
      this.editContextFormatting,
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    return this.decorations;
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let u = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = u.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let u of this.view.state.facet(ev))
      try {
        if (u(this.view, t.range, t))
          return !0;
      } catch (c) {
        sn(this.view.state, c, "scroll handler");
      }
    let { range: n } = t, i = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), l;
    if (!i)
      return;
    !n.empty && (l = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, l.left),
      top: Math.min(i.top, l.top),
      right: Math.max(i.right, l.right),
      bottom: Math.max(i.bottom, l.bottom)
    });
    let a = rv(this.view), r = {
      left: i.left - a.left,
      top: i.top - a.top,
      right: i.right + a.right,
      bottom: i.bottom + a.bottom
    }, { offsetWidth: s, offsetHeight: o } = this.view.scrollDOM;
    uP(this.view.scrollDOM, r, n.head < n.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, s), -s), Math.max(Math.min(t.yMargin, o), -o), this.view.textDirection == ot.LTR);
  }
}
function QP(e) {
  return e.node.nodeType == 1 && e.node.firstChild && (e.offset == 0 || e.node.childNodes[e.offset - 1].contentEditable == "false") && (e.offset == e.node.childNodes.length || e.node.childNodes[e.offset].contentEditable == "false");
}
function sv(e, t) {
  let n = e.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let i = L3(n.focusNode, n.focusOffset), l = M3(n.focusNode, n.focusOffset), a = i || l;
  if (l && i && l.node != i.node) {
    let s = Ke.get(l.node);
    if (!s || s instanceof Wn && s.text != l.node.nodeValue)
      a = l;
    else if (e.docView.lastCompositionAfterCursor) {
      let o = Ke.get(i.node);
      !o || o instanceof Wn && o.text != i.node.nodeValue || (a = l);
    }
  }
  if (e.docView.lastCompositionAfterCursor = a != i, !a)
    return null;
  let r = t - a.offset;
  return { from: r, to: r + a.node.nodeValue.length, node: a.node };
}
function LP(e, t, n) {
  let i = sv(e, n);
  if (!i)
    return null;
  let { node: l, from: a, to: r } = i, s = l.nodeValue;
  if (/[\n\r]/.test(s) || e.state.doc.sliceString(i.from, i.to) != s)
    return null;
  let o = t.invertedDesc, u = new _n(o.mapPos(a), o.mapPos(r), a, r), c = [];
  for (let d = l.parentNode; ; d = d.parentNode) {
    let f = Ke.get(d);
    if (f instanceof Li)
      c.push({ node: d, deco: f.mark });
    else {
      if (f instanceof xt || d.nodeName == "DIV" && d.parentNode == e.contentDOM)
        return { range: u, text: l, marks: c, line: d };
      if (d != e.contentDOM)
        c.push({ node: d, deco: new ps({
          inclusive: !0,
          attributes: pP(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function MP(e, t) {
  return e.nodeType != 1 ? 0 : (t && e.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < e.childNodes.length && e.childNodes[t].contentEditable == "false" ? 2 : 0);
}
let TP = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, n) {
    id(t, n, this.changes);
  }
  comparePoint(t, n) {
    id(t, n, this.changes);
  }
};
function _P(e, t, n) {
  let i = new TP();
  return Ee.compare(e, t, n, i), i.changes;
}
function AP(e, t) {
  for (let n = e; n && n != t; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function RP(e, t) {
  let n = !1;
  return t && e.iterChangedRanges((i, l) => {
    i < t.to && l > t.from && (n = !0);
  }), n;
}
function ZP(e, t, n = 1) {
  let i = e.charCategorizer(t), l = e.doc.lineAt(t), a = t - l.from;
  if (l.length == 0)
    return J.cursor(t);
  a == 0 ? n = 1 : a == l.length && (n = -1);
  let r = a, s = a;
  n < 0 ? r = qt(l.text, a, !1) : s = qt(l.text, a);
  let o = i(l.text.slice(r, s));
  for (; r > 0; ) {
    let u = qt(l.text, r, !1);
    if (i(l.text.slice(u, r)) != o)
      break;
    r = u;
  }
  for (; s < l.length; ) {
    let u = qt(l.text, s);
    if (i(l.text.slice(s, u)) != o)
      break;
    s = u;
  }
  return J.range(r + l.from, s + l.from);
}
function IP(e, t) {
  return t.left > e ? t.left - e : Math.max(0, e - t.right);
}
function DP(e, t) {
  return t.top > e ? t.top - e : Math.max(0, e - t.bottom);
}
function Pc(e, t) {
  return e.top < t.bottom - 1 && e.bottom > t.top + 1;
}
function x0(e, t) {
  return t < e.top ? { top: t, left: e.left, right: e.right, bottom: e.bottom } : e;
}
function P0(e, t) {
  return t > e.bottom ? { top: e.top, left: e.left, right: e.right, bottom: t } : e;
}
function ud(e, t, n) {
  let i, l, a, r, s = !1, o, u, c, d;
  for (let g = e.firstChild; g; g = g.nextSibling) {
    let v = _a(g);
    for (let p = 0; p < v.length; p++) {
      let O = v[p];
      l && Pc(l, O) && (O = x0(P0(O, l.bottom), l.top));
      let b = IP(t, O), V = DP(n, O);
      if (b == 0 && V == 0)
        return g.nodeType == 3 ? $0(g, t, n) : ud(g, t, n);
      if (!i || r > V || r == V && a > b) {
        i = g, l = O, a = b, r = V;
        let $ = V ? n < O.top ? -1 : 1 : b ? t < O.left ? -1 : 1 : 0;
        s = !$ || ($ > 0 ? p < v.length - 1 : p > 0);
      }
      b == 0 ? n > O.bottom && (!c || c.bottom < O.bottom) ? (o = g, c = O) : n < O.top && (!d || d.top > O.top) && (u = g, d = O) : c && Pc(c, O) ? c = P0(c, O.bottom) : d && Pc(d, O) && (d = x0(d, O.top));
    }
  }
  if (c && c.bottom >= n ? (i = o, l = c) : d && d.top <= n && (i = u, l = d), !i)
    return { node: e, offset: 0 };
  let f = Math.max(l.left, Math.min(l.right, t));
  if (i.nodeType == 3)
    return $0(i, f, n);
  if (s && i.contentEditable != "false")
    return ud(i, f, n);
  let h = Array.prototype.indexOf.call(e.childNodes, i) + (t >= (l.left + l.right) / 2 ? 1 : 0);
  return { node: e, offset: h };
}
function $0(e, t, n) {
  let i = e.nodeValue.length, l = -1, a = 1e9, r = 0;
  for (let s = 0; s < i; s++) {
    let o = zl(e, s, s + 1).getClientRects();
    for (let u = 0; u < o.length; u++) {
      let c = o[u];
      if (c.top == c.bottom)
        continue;
      r || (r = t - c.left);
      let d = (c.top > n ? c.top - n : n - c.bottom) - 1;
      if (c.left - 1 <= t && c.right + 1 >= t && d < a) {
        let f = t >= (c.left + c.right) / 2, h = f;
        if ((Oe.chrome || Oe.gecko) && zl(e, s).getBoundingClientRect().left == c.right && (h = !f), d <= 0)
          return { node: e, offset: s + (h ? 1 : 0) };
        l = s + (h ? 1 : 0), a = d;
      }
    }
  }
  return { node: e, offset: l > -1 ? l : r > 0 ? e.nodeValue.length : 0 };
}
function ov(e, t, n, i = -1) {
  var l, a;
  let r = e.contentDOM.getBoundingClientRect(), s = r.top + e.viewState.paddingTop, o, { docHeight: u } = e.viewState, { x: c, y: d } = t, f = d - s;
  if (f < 0)
    return 0;
  if (f > u)
    return e.state.doc.length;
  for (let $ = e.viewState.heightOracle.textHeight / 2, x = !1; o = e.elementAtHeight(f), o.type != cn.Text; )
    for (; f = i > 0 ? o.bottom + $ : o.top - $, !(f >= 0 && f <= u); ) {
      if (x)
        return n ? null : 0;
      x = !0, i = -i;
    }
  d = s + f;
  let h = o.from;
  if (h < e.viewport.from)
    return e.viewport.from == 0 ? 0 : n ? null : V0(e, r, o, c, d);
  if (h > e.viewport.to)
    return e.viewport.to == e.state.doc.length ? e.state.doc.length : n ? null : V0(e, r, o, c, d);
  let g = e.dom.ownerDocument, v = e.root.elementFromPoint ? e.root : g, p = v.elementFromPoint(c, d);
  p && !e.contentDOM.contains(p) && (p = null), p || (c = Math.max(r.left + 1, Math.min(r.right - 1, c)), p = v.elementFromPoint(c, d), p && !e.contentDOM.contains(p) && (p = null));
  let O, b = -1;
  if (p && ((l = e.docView.nearest(p)) === null || l === void 0 ? void 0 : l.isEditable) != !1) {
    if (g.caretPositionFromPoint) {
      let $ = g.caretPositionFromPoint(c, d);
      $ && ({ offsetNode: O, offset: b } = $);
    } else if (g.caretRangeFromPoint) {
      let $ = g.caretRangeFromPoint(c, d);
      $ && ({ startContainer: O, startOffset: b } = $, (!e.contentDOM.contains(O) || Oe.safari && BP(O, b, c) || Oe.chrome && EP(O, b, c)) && (O = void 0));
    }
    O && (b = Math.min(mi(O), b));
  }
  if (!O || !e.docView.dom.contains(O)) {
    let $ = xt.find(e.docView, h);
    if (!$)
      return f > o.top + o.height / 2 ? o.to : o.from;
    ({ node: O, offset: b } = ud($.dom, c, d));
  }
  let V = e.docView.nearest(O);
  if (!V)
    return null;
  if (V.isWidget && ((a = V.dom) === null || a === void 0 ? void 0 : a.nodeType) == 1) {
    let $ = V.dom.getBoundingClientRect();
    return t.y < $.top || t.y <= $.bottom && t.x <= ($.left + $.right) / 2 ? V.posAtStart : V.posAtEnd;
  } else
    return V.localPosFromDOM(O, b) + V.posAtStart;
}
function V0(e, t, n, i, l) {
  let a = Math.round((i - t.left) * e.defaultCharacterWidth);
  if (e.lineWrapping && n.height > e.defaultLineHeight * 1.5) {
    let s = e.viewState.heightOracle.textHeight, o = Math.floor((l - n.top - (e.defaultLineHeight - s) * 0.5) / s);
    a += o * e.viewState.heightOracle.lineLength;
  }
  let r = e.state.sliceDoc(n.from, n.to);
  return n.from + F1(r, a, e.state.tabSize);
}
function BP(e, t, n) {
  let i;
  if (e.nodeType != 3 || t != (i = e.nodeValue.length))
    return !1;
  for (let l = e.nextSibling; l; l = l.nextSibling)
    if (l.nodeType != 1 || l.nodeName != "BR")
      return !1;
  return zl(e, i - 1, i).getBoundingClientRect().left > n;
}
function EP(e, t, n) {
  if (t != 0)
    return !1;
  for (let l = e; ; ) {
    let a = l.parentNode;
    if (!a || a.nodeType != 1 || a.firstChild != l)
      return !1;
    if (a.classList.contains("cm-line"))
      break;
    l = a;
  }
  let i = e.nodeType == 1 ? e.getBoundingClientRect() : zl(e, 0, Math.max(e.nodeValue.length, 1)).getBoundingClientRect();
  return n - i.left > 5;
}
function cd(e, t) {
  let n = e.lineBlockAt(t);
  if (Array.isArray(n.type)) {
    for (let i of n.type)
      if (i.to > t || i.to == t && (i.to == n.to || i.type == cn.Text))
        return i;
  }
  return n;
}
function zP(e, t, n, i) {
  let l = cd(e, t.head), a = !i || l.type != cn.Text || !(e.lineWrapping || l.widgetLineBreaks) ? null : e.coordsAtPos(t.assoc < 0 && t.head > l.from ? t.head - 1 : t.head);
  if (a) {
    let r = e.dom.getBoundingClientRect(), s = e.textDirectionAt(l.from), o = e.posAtCoords({
      x: n == (s == ot.LTR) ? r.right - 1 : r.left + 1,
      y: (a.top + a.bottom) / 2
    });
    if (o != null)
      return J.cursor(o, n ? -1 : 1);
  }
  return J.cursor(n ? l.to : l.from, n ? -1 : 1);
}
function Q0(e, t, n, i) {
  let l = e.state.doc.lineAt(t.head), a = e.bidiSpans(l), r = e.textDirectionAt(l.from);
  for (let s = t, o = null; ; ) {
    let u = PP(l, a, r, s, n), c = N3;
    if (!u) {
      if (l.number == (n ? e.state.doc.lines : 1))
        return s;
      c = `
`, l = e.state.doc.line(l.number + (n ? 1 : -1)), a = e.bidiSpans(l), u = e.visualLineSide(l, !n);
    }
    if (o) {
      if (!o(c))
        return s;
    } else {
      if (!i)
        return u;
      o = i(c);
    }
    s = u;
  }
}
function HP(e, t, n) {
  let i = e.state.charCategorizer(t), l = i(n);
  return (a) => {
    let r = i(a);
    return l == dt.Space && (l = r), l == r;
  };
}
function jP(e, t, n, i) {
  let l = t.head, a = n ? 1 : -1;
  if (l == (n ? e.state.doc.length : 0))
    return J.cursor(l, t.assoc);
  let r = t.goalColumn, s, o = e.contentDOM.getBoundingClientRect(), u = e.coordsAtPos(l, t.assoc || -1), c = e.documentTop;
  if (u)
    r == null && (r = u.left - o.left), s = a < 0 ? u.top : u.bottom;
  else {
    let h = e.viewState.lineBlockAt(l);
    r == null && (r = Math.min(o.right - o.left, e.defaultCharacterWidth * (l - h.from))), s = (a < 0 ? h.top : h.bottom) + c;
  }
  let d = o.left + r, f = i ?? e.viewState.heightOracle.textHeight >> 1;
  for (let h = 0; ; h += 10) {
    let g = s + (f + h) * a, v = ov(e, { x: d, y: g }, !1, a);
    if (g < o.top || g > o.bottom || (a < 0 ? v < l : v > l)) {
      let p = e.docView.coordsForChar(v), O = !p || g < p.top ? -1 : 1;
      return J.cursor(v, O, void 0, r);
    }
  }
}
function co(e, t, n) {
  for (; ; ) {
    let i = 0;
    for (let l of e)
      l.between(t - 1, t + 1, (a, r, s) => {
        if (t > a && t < r) {
          let o = i || n || (t - a < r - t ? -1 : 1);
          t = o < 0 ? a : r, i = o;
        }
      });
    if (!i)
      return t;
  }
}
function $c(e, t, n) {
  let i = co(e.state.facet(ch).map((l) => l(e)), n.from, t.head > n.from ? -1 : 1);
  return i == n.from ? n : J.cursor(i, i < n.from ? 1 : -1);
}
const gr = "";
class XP {
  constructor(t, n) {
    this.points = t, this.text = "", this.lineSeparator = n.facet(Re.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += gr;
  }
  readRange(t, n) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let l = t; ; ) {
      this.findPointBefore(i, l);
      let a = this.text.length;
      this.readNode(l);
      let r = l.nextSibling;
      if (r == n)
        break;
      let s = Ke.get(l), o = Ke.get(r);
      (s && o ? s.breakAfter : (s ? s.breakAfter : Ro(l)) || Ro(r) && (l.nodeName != "BR" || l.cmIgnore) && this.text.length > a) && this.lineBreak(), l = r;
    }
    return this.findPointBefore(i, n), this;
  }
  readTextNode(t) {
    let n = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, n.length));
    for (let i = 0, l = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let a = -1, r = 1, s;
      if (this.lineSeparator ? (a = n.indexOf(this.lineSeparator, i), r = this.lineSeparator.length) : (s = l.exec(n)) && (a = s.index, r = s[0].length), this.append(n.slice(i, a < 0 ? n.length : a)), a < 0)
        break;
      if (this.lineBreak(), r > 1)
        for (let o of this.points)
          o.node == t && o.pos > this.text.length && (o.pos -= r - 1);
      i = a + r;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let n = Ke.get(t), i = n && n.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let l = i.iter(); !l.next().done; )
        l.lineBreak ? this.lineBreak() : this.append(l.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, n) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == n && (i.pos = this.text.length);
  }
  findPointInside(t, n) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (NP(t, i.node, i.offset) ? n : 0));
  }
}
function NP(e, t, n) {
  for (; ; ) {
    if (!t || n < mi(t))
      return !1;
    if (t == e)
      return !0;
    n = El(t) + 1, t = t.parentNode;
  }
}
class L0 {
  constructor(t, n) {
    this.node = t, this.offset = n, this.pos = -1;
  }
}
class qP {
  constructor(t, n, i, l) {
    this.typeOver = l, this.bounds = null, this.text = "", this.domChanged = n > -1;
    let { impreciseHead: a, impreciseAnchor: r } = t.docView;
    if (t.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = t.docView.domBoundsAround(n, i, 0))) {
      let s = a || r ? [] : WP(t), o = new XP(s, t.state);
      o.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = o.text, this.newSel = UP(s, this.bounds.from);
    } else {
      let s = t.observer.selectionRange, o = a && a.node == s.focusNode && a.offset == s.focusOffset || !G1(t.contentDOM, s.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(s.focusNode, s.focusOffset), u = r && r.node == s.anchorNode && r.offset == s.anchorOffset || !G1(t.contentDOM, s.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(s.anchorNode, s.anchorOffset), c = t.viewport;
      if ((Oe.ios || Oe.chrome) && t.state.selection.main.empty && o != u && (c.from > 0 || c.to < t.state.doc.length)) {
        let d = Math.min(o, u), f = Math.max(o, u), h = c.from - d, g = c.to - f;
        (h == 0 || h == 1 || d == 0) && (g == 0 || g == -1 || f == t.state.doc.length) && (o = 0, u = t.state.doc.length);
      }
      this.newSel = J.single(u, o);
    }
  }
}
function uv(e, t) {
  let n, { newSel: i } = t, l = e.state.selection.main, a = e.inputState.lastKeyTime > Date.now() - 100 ? e.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: r, to: s } = t.bounds, o = l.from, u = null;
    (a === 8 || Oe.android && t.text.length < s - r) && (o = l.to, u = "end");
    let c = FP(e.state.doc.sliceString(r, s, gr), t.text, o - r, u);
    c && (Oe.chrome && a == 13 && c.toB == c.from + 2 && t.text.slice(c.from, c.toB) == gr + gr && c.toB--, n = {
      from: r + c.from,
      to: r + c.toA,
      insert: Ne.of(t.text.slice(c.from, c.toB).split(gr))
    });
  } else i && (!e.hasFocus && e.state.facet(ji) || i.main.eq(l)) && (i = null);
  if (!n && !i)
    return !1;
  if (!n && t.typeOver && !l.empty && i && i.main.empty ? n = { from: l.from, to: l.to, insert: e.state.doc.slice(l.from, l.to) } : n && n.from >= l.from && n.to <= l.to && (n.from != l.from || n.to != l.to) && l.to - l.from - (n.to - n.from) <= 4 ? n = {
    from: l.from,
    to: l.to,
    insert: e.state.doc.slice(l.from, n.from).append(n.insert).append(e.state.doc.slice(n.to, l.to))
  } : (Oe.mac || Oe.android) && n && n.from == n.to && n.from == l.head - 1 && /^\. ?$/.test(n.insert.toString()) && e.contentDOM.getAttribute("autocorrect") == "off" ? (i && n.insert.length == 2 && (i = J.single(i.main.anchor - 1, i.main.head - 1)), n = { from: l.from, to: l.to, insert: Ne.of([" "]) }) : Oe.chrome && n && n.from == n.to && n.from == l.head && n.insert.toString() == `
 ` && e.lineWrapping && (i && (i = J.single(i.main.anchor - 1, i.main.head - 1)), n = { from: l.from, to: l.to, insert: Ne.of([" "]) }), n)
    return dh(e, n, i, a);
  if (i && !i.main.eq(l)) {
    let r = !1, s = "select";
    return e.inputState.lastSelectionTime > Date.now() - 50 && (e.inputState.lastSelectionOrigin == "select" && (r = !0), s = e.inputState.lastSelectionOrigin), e.dispatch({ selection: i, scrollIntoView: r, userEvent: s }), !0;
  } else
    return !1;
}
function dh(e, t, n, i = -1) {
  if (Oe.ios && e.inputState.flushIOSKey(t))
    return !0;
  let l = e.state.selection.main;
  if (Oe.android && (t.to == l.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == l.from || t.from == l.from - 1 && e.state.sliceDoc(t.from, l.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && ba(e.contentDOM, "Enter", 13) || (t.from == l.from - 1 && t.to == l.to && t.insert.length == 0 || i == 8 && t.insert.length < t.to - t.from && t.to > l.head) && ba(e.contentDOM, "Backspace", 8) || t.from == l.from && t.to == l.to + 1 && t.insert.length == 0 && ba(e.contentDOM, "Delete", 46)))
    return !0;
  let a = t.insert.toString();
  e.inputState.composing >= 0 && e.inputState.composing++;
  let r, s = () => r || (r = YP(e, t, n));
  return e.state.facet(U3).some((o) => o(e, t.from, t.to, a, s)) || e.dispatch(s()), !0;
}
function YP(e, t, n) {
  let i, l = e.state, a = l.selection.main;
  if (t.from >= a.from && t.to <= a.to && t.to - t.from >= (a.to - a.from) / 3 && (!n || n.main.empty && n.main.from == t.from + t.insert.length) && e.inputState.composing < 0) {
    let s = a.from < t.from ? l.sliceDoc(a.from, t.from) : "", o = a.to > t.to ? l.sliceDoc(t.to, a.to) : "";
    i = l.replaceSelection(e.state.toText(s + t.insert.sliceString(0, void 0, e.state.lineBreak) + o));
  } else {
    let s = l.changes(t), o = n && n.main.to <= s.newLength ? n.main : void 0;
    if (l.selection.ranges.length > 1 && e.inputState.composing >= 0 && t.to <= a.to && t.to >= a.to - 10) {
      let u = e.state.sliceDoc(t.from, t.to), c, d = n && sv(e, n.main.head);
      if (d) {
        let g = t.insert.length - (t.to - t.from);
        c = { from: d.from, to: d.to - g };
      } else
        c = e.state.doc.lineAt(a.head);
      let f = a.to - t.to, h = a.to - a.from;
      i = l.changeByRange((g) => {
        if (g.from == a.from && g.to == a.to)
          return { changes: s, range: o || g.map(s) };
        let v = g.to - f, p = v - u.length;
        if (g.to - g.from != h || e.state.sliceDoc(p, v) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        g.to >= c.from && g.from <= c.to)
          return { range: g };
        let O = l.changes({ from: p, to: v, insert: t.insert }), b = g.to - a.to;
        return {
          changes: O,
          range: o ? J.range(Math.max(0, o.anchor + b), Math.max(0, o.head + b)) : g.map(O)
        };
      });
    } else
      i = {
        changes: s,
        selection: o && l.selection.replaceRange(o)
      };
  }
  let r = "input.type";
  return (e.composing || e.inputState.compositionPendingChange && e.inputState.compositionEndedAt > Date.now() - 50) && (e.inputState.compositionPendingChange = !1, r += ".compose", e.inputState.compositionFirstChange && (r += ".start", e.inputState.compositionFirstChange = !1)), l.update(i, { userEvent: r, scrollIntoView: !0 });
}
function FP(e, t, n, i) {
  let l = Math.min(e.length, t.length), a = 0;
  for (; a < l && e.charCodeAt(a) == t.charCodeAt(a); )
    a++;
  if (a == l && e.length == t.length)
    return null;
  let r = e.length, s = t.length;
  for (; r > 0 && s > 0 && e.charCodeAt(r - 1) == t.charCodeAt(s - 1); )
    r--, s--;
  if (i == "end") {
    let o = Math.max(0, a - Math.min(r, s));
    n -= r + o - a;
  }
  if (r < a && e.length < t.length) {
    let o = n <= a && n >= r ? a - n : 0;
    a -= o, s = a + (s - r), r = a;
  } else if (s < a) {
    let o = n <= a && n >= s ? a - n : 0;
    a -= o, r = a + (r - s), s = a;
  }
  return { from: a, toA: r, toB: s };
}
function WP(e) {
  let t = [];
  if (e.root.activeElement != e.contentDOM)
    return t;
  let { anchorNode: n, anchorOffset: i, focusNode: l, focusOffset: a } = e.observer.selectionRange;
  return n && (t.push(new L0(n, i)), (l != n || a != i) && t.push(new L0(l, a))), t;
}
function UP(e, t) {
  if (e.length == 0)
    return null;
  let n = e[0].pos, i = e.length == 2 ? e[1].pos : n;
  return n > -1 && i > -1 ? J.single(n + t, i + t) : null;
}
class GP {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, Oe.safari && t.contentDOM.addEventListener("input", () => null), Oe.gecko && h$(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !a$(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || this.runHandlers(t.type, t);
  }
  runHandlers(t, n) {
    let i = this.handlers[t];
    if (i) {
      for (let l of i.observers)
        l(this.view, n);
      for (let l of i.handlers) {
        if (n.defaultPrevented)
          break;
        if (l(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let n = KP(t), i = this.handlers, l = this.view.contentDOM;
    for (let a in n)
      if (a != "scroll") {
        let r = !n[a].handlers.length, s = i[a];
        s && r != !s.handlers.length && (l.removeEventListener(a, this.handleEvent), s = null), s || l.addEventListener(a, this.handleEvent, { passive: r });
      }
    for (let a in i)
      a != "scroll" && !n[a] && l.removeEventListener(a, this.handleEvent);
    this.handlers = n;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && dv.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), Oe.android && Oe.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let n;
    return Oe.ios && !t.synthetic && !t.altKey && !t.metaKey && ((n = cv.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || JP.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = n || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, ba(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(t) {
    return /^key/.test(t.type) ? this.composing > 0 ? !0 : Oe.safari && !Oe.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function M0(e, t) {
  return (n, i) => {
    try {
      return t.call(e, i, n);
    } catch (l) {
      sn(n.state, l);
    }
  };
}
function KP(e) {
  let t = /* @__PURE__ */ Object.create(null);
  function n(i) {
    return t[i] || (t[i] = { observers: [], handlers: [] });
  }
  for (let i of e) {
    let l = i.spec;
    if (l && l.domEventHandlers)
      for (let a in l.domEventHandlers) {
        let r = l.domEventHandlers[a];
        r && n(a).handlers.push(M0(i.value, r));
      }
    if (l && l.domEventObservers)
      for (let a in l.domEventObservers) {
        let r = l.domEventObservers[a];
        r && n(a).observers.push(M0(i.value, r));
      }
  }
  for (let i in Un)
    n(i).handlers.push(Un[i]);
  for (let i in Rn)
    n(i).observers.push(Rn[i]);
  return t;
}
const cv = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], JP = "dthko", dv = [16, 17, 18, 20, 91, 92, 224, 225], Ds = 6;
function Bs(e) {
  return Math.max(0, e) * 0.7 + 8;
}
function e$(e, t) {
  return Math.max(Math.abs(e.clientX - t.clientX), Math.abs(e.clientY - t.clientY));
}
class t$ {
  constructor(t, n, i, l) {
    this.view = t, this.startEvent = n, this.style = i, this.mustSelect = l, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = cP(t.contentDOM), this.atoms = t.state.facet(ch).map((r) => r(t));
    let a = t.contentDOM.ownerDocument;
    a.addEventListener("mousemove", this.move = this.move.bind(this)), a.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = t.state.facet(Re.allowMultipleSelections) && n$(t, n), this.dragging = l$(t, n) && mv(n) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && e$(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let n = 0, i = 0, l = 0, a = 0, r = this.view.win.innerWidth, s = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: l, right: r } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: a, bottom: s } = this.scrollParents.y.getBoundingClientRect());
    let o = rv(this.view);
    t.clientX - o.left <= l + Ds ? n = -Bs(l - t.clientX) : t.clientX + o.right >= r - Ds && (n = Bs(t.clientX - r)), t.clientY - o.top <= a + Ds ? i = -Bs(a - t.clientY) : t.clientY + o.bottom >= s - Ds && (i = Bs(t.clientY - s)), this.setScrollSpeed(n, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, n) {
    this.scrollSpeed = { x: t, y: n }, t || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: n } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (t || n) && this.view.win.scrollBy(t, n), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(t) {
    let n = null;
    for (let i = 0; i < t.ranges.length; i++) {
      let l = t.ranges[i], a = null;
      if (l.empty) {
        let r = co(this.atoms, l.from, 0);
        r != l.from && (a = J.cursor(r, -1));
      } else {
        let r = co(this.atoms, l.from, -1), s = co(this.atoms, l.to, 1);
        (r != l.from || s != l.to) && (a = J.range(l.from == l.anchor ? r : s, l.from == l.head ? r : s));
      }
      a && (n || (n = t.ranges.slice()), n[i] = a);
    }
    return n ? J.create(n, t.mainIndex) : t;
  }
  select(t) {
    let { view: n } = this, i = this.skipAtoms(this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !i.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function n$(e, t) {
  let n = e.state.facet(q3);
  return n.length ? n[0](t) : Oe.mac ? t.metaKey : t.ctrlKey;
}
function i$(e, t) {
  let n = e.state.facet(Y3);
  return n.length ? n[0](t) : Oe.mac ? !t.altKey : !t.ctrlKey;
}
function l$(e, t) {
  let { main: n } = e.state.selection;
  if (n.empty)
    return !1;
  let i = Hr(e.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let l = i.getRangeAt(0).getClientRects();
  for (let a = 0; a < l.length; a++) {
    let r = l[a];
    if (r.left <= t.clientX && r.right >= t.clientX && r.top <= t.clientY && r.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
function a$(e, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let n = t.target, i; n != e.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (i = Ke.get(n)) && i.ignoreEvent(t))
      return !1;
  return !0;
}
const Un = /* @__PURE__ */ Object.create(null), Rn = /* @__PURE__ */ Object.create(null), fv = Oe.ie && Oe.ie_version < 15 || Oe.ios && Oe.webkit_version < 604;
function r$(e) {
  let t = e.dom.parentNode;
  if (!t)
    return;
  let n = t.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    e.focus(), n.remove(), hv(e, n.value);
  }, 50);
}
function qu(e, t, n) {
  for (let i of e.facet(t))
    n = i(n, e);
  return n;
}
function hv(e, t) {
  t = qu(e.state, sh, t);
  let { state: n } = e, i, l = 1, a = n.toText(t), r = a.lines == n.selection.ranges.length;
  if (dd != null && n.selection.ranges.every((o) => o.empty) && dd == a.toString()) {
    let o = -1;
    i = n.changeByRange((u) => {
      let c = n.doc.lineAt(u.from);
      if (c.from == o)
        return { range: u };
      o = c.from;
      let d = n.toText((r ? a.line(l++).text : t) + n.lineBreak);
      return {
        changes: { from: c.from, insert: d },
        range: J.cursor(u.from + d.length)
      };
    });
  } else r ? i = n.changeByRange((o) => {
    let u = a.line(l++);
    return {
      changes: { from: o.from, to: o.to, insert: u.text },
      range: J.cursor(o.from + u.length)
    };
  }) : i = n.replaceSelection(a);
  e.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Rn.scroll = (e) => {
  e.inputState.lastScrollTop = e.scrollDOM.scrollTop, e.inputState.lastScrollLeft = e.scrollDOM.scrollLeft;
};
Un.keydown = (e, t) => (e.inputState.setSelectionOrigin("select"), t.keyCode == 27 && e.inputState.tabFocusMode != 0 && (e.inputState.tabFocusMode = Date.now() + 2e3), !1);
Rn.touchstart = (e, t) => {
  e.inputState.lastTouchTime = Date.now(), e.inputState.setSelectionOrigin("select.pointer");
};
Rn.touchmove = (e) => {
  e.inputState.setSelectionOrigin("select.pointer");
};
Un.mousedown = (e, t) => {
  if (e.observer.flush(), e.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let i of e.state.facet(F3))
    if (n = i(e, t), n)
      break;
  if (!n && t.button == 0 && (n = u$(e, t)), n) {
    let i = !e.hasFocus;
    e.inputState.startMouseSelection(new t$(e, t, n, i)), i && e.observer.ignore(() => {
      $3(e.contentDOM);
      let a = e.root.activeElement;
      a && !a.contains(e.contentDOM) && a.blur();
    });
    let l = e.inputState.mouseSelection;
    if (l)
      return l.start(t), l.dragging === !1;
  }
  return !1;
};
function T0(e, t, n, i) {
  if (i == 1)
    return J.cursor(t, n);
  if (i == 2)
    return ZP(e.state, t, n);
  {
    let l = xt.find(e.docView, t), a = e.state.doc.lineAt(l ? l.posAtEnd : t), r = l ? l.posAtStart : a.from, s = l ? l.posAtEnd : a.to;
    return s < e.state.doc.length && s == a.to && s++, J.range(r, s);
  }
}
let _0 = (e, t, n) => t >= n.top && t <= n.bottom && e >= n.left && e <= n.right;
function s$(e, t, n, i) {
  let l = xt.find(e.docView, t);
  if (!l)
    return 1;
  let a = t - l.posAtStart;
  if (a == 0)
    return 1;
  if (a == l.length)
    return -1;
  let r = l.coordsAt(a, -1);
  if (r && _0(n, i, r))
    return -1;
  let s = l.coordsAt(a, 1);
  return s && _0(n, i, s) ? 1 : r && r.bottom >= i ? -1 : 1;
}
function A0(e, t) {
  let n = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: n, bias: s$(e, n, t.clientX, t.clientY) };
}
const o$ = Oe.ie && Oe.ie_version <= 11;
let R0 = null, Z0 = 0, I0 = 0;
function mv(e) {
  if (!o$)
    return e.detail;
  let t = R0, n = I0;
  return R0 = e, I0 = Date.now(), Z0 = !t || n > Date.now() - 400 && Math.abs(t.clientX - e.clientX) < 2 && Math.abs(t.clientY - e.clientY) < 2 ? (Z0 + 1) % 3 : 1;
}
function u$(e, t) {
  let n = A0(e, t), i = mv(t), l = e.state.selection;
  return {
    update(a) {
      a.docChanged && (n.pos = a.changes.mapPos(n.pos), l = l.map(a.changes));
    },
    get(a, r, s) {
      let o = A0(e, a), u, c = T0(e, o.pos, o.bias, i);
      if (n.pos != o.pos && !r) {
        let d = T0(e, n.pos, n.bias, i), f = Math.min(d.from, c.from), h = Math.max(d.to, c.to);
        c = f < c.from ? J.range(f, h) : J.range(h, f);
      }
      return r ? l.replaceRange(l.main.extend(c.from, c.to)) : s && i == 1 && l.ranges.length > 1 && (u = c$(l, o.pos)) ? u : s ? l.addRange(c) : J.create([c]);
    }
  };
}
function c$(e, t) {
  for (let n = 0; n < e.ranges.length; n++) {
    let { from: i, to: l } = e.ranges[n];
    if (i <= t && l >= t)
      return J.create(e.ranges.slice(0, n).concat(e.ranges.slice(n + 1)), e.mainIndex == n ? 0 : e.mainIndex - (e.mainIndex > n ? 1 : 0));
  }
  return null;
}
Un.dragstart = (e, t) => {
  let { selection: { main: n } } = e.state;
  if (t.target.draggable) {
    let l = e.docView.nearest(t.target);
    if (l && l.isWidget) {
      let a = l.posAtStart, r = a + l.length;
      (a >= n.to || r <= n.from) && (n = J.range(a, r));
    }
  }
  let { inputState: i } = e;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = n, t.dataTransfer && (t.dataTransfer.setData("Text", qu(e.state, oh, e.state.sliceDoc(n.from, n.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
Un.dragend = (e) => (e.inputState.draggedContent = null, !1);
function D0(e, t, n, i) {
  if (n = qu(e.state, sh, n), !n)
    return;
  let l = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: a } = e.inputState, r = i && a && i$(e, t) ? { from: a.from, to: a.to } : null, s = { from: l, insert: n }, o = e.state.changes(r ? [r, s] : s);
  e.focus(), e.dispatch({
    changes: o,
    selection: { anchor: o.mapPos(l, -1), head: o.mapPos(l, 1) },
    userEvent: r ? "move.drop" : "input.drop"
  }), e.inputState.draggedContent = null;
}
Un.drop = (e, t) => {
  if (!t.dataTransfer)
    return !1;
  if (e.state.readOnly)
    return !0;
  let n = t.dataTransfer.files;
  if (n && n.length) {
    let i = Array(n.length), l = 0, a = () => {
      ++l == n.length && D0(e, t, i.filter((r) => r != null).join(e.state.lineBreak), !1);
    };
    for (let r = 0; r < n.length; r++) {
      let s = new FileReader();
      s.onerror = a, s.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(s.result) || (i[r] = s.result), a();
      }, s.readAsText(n[r]);
    }
    return !0;
  } else {
    let i = t.dataTransfer.getData("Text");
    if (i)
      return D0(e, t, i, !0), !0;
  }
  return !1;
};
Un.paste = (e, t) => {
  if (e.state.readOnly)
    return !0;
  e.observer.flush();
  let n = fv ? null : t.clipboardData;
  return n ? (hv(e, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (r$(e), !1);
};
function d$(e, t) {
  let n = e.dom.parentNode;
  if (!n)
    return;
  let i = n.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), e.focus();
  }, 50);
}
function f$(e) {
  let t = [], n = [], i = !1;
  for (let l of e.selection.ranges)
    l.empty || (t.push(e.sliceDoc(l.from, l.to)), n.push(l));
  if (!t.length) {
    let l = -1;
    for (let { from: a } of e.selection.ranges) {
      let r = e.doc.lineAt(a);
      r.number > l && (t.push(r.text), n.push({ from: r.from, to: Math.min(e.doc.length, r.to + 1) })), l = r.number;
    }
    i = !0;
  }
  return { text: qu(e, oh, t.join(e.lineBreak)), ranges: n, linewise: i };
}
let dd = null;
Un.copy = Un.cut = (e, t) => {
  let { text: n, ranges: i, linewise: l } = f$(e.state);
  if (!n && !l)
    return !1;
  dd = l ? n : null, t.type == "cut" && !e.state.readOnly && e.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let a = fv ? null : t.clipboardData;
  return a ? (a.clearData(), a.setData("text/plain", n), !0) : (d$(e, n), !1);
};
const gv = /* @__PURE__ */ Zi.define();
function vv(e, t) {
  let n = [];
  for (let i of e.facet(G3)) {
    let l = i(e, t);
    l && n.push(l);
  }
  return n ? e.update({ effects: n, annotations: gv.of(!0) }) : null;
}
function pv(e) {
  setTimeout(() => {
    let t = e.hasFocus;
    if (t != e.inputState.notifiedFocused) {
      let n = vv(e.state, t);
      n ? e.dispatch(n) : e.update([]);
    }
  }, 10);
}
Rn.focus = (e) => {
  e.inputState.lastFocusTime = Date.now(), !e.scrollDOM.scrollTop && (e.inputState.lastScrollTop || e.inputState.lastScrollLeft) && (e.scrollDOM.scrollTop = e.inputState.lastScrollTop, e.scrollDOM.scrollLeft = e.inputState.lastScrollLeft), pv(e);
};
Rn.blur = (e) => {
  e.observer.clearSelectionRange(), pv(e);
};
Rn.compositionstart = Rn.compositionupdate = (e) => {
  e.observer.editContext || (e.inputState.compositionFirstChange == null && (e.inputState.compositionFirstChange = !0), e.inputState.composing < 0 && (e.inputState.composing = 0));
};
Rn.compositionend = (e) => {
  e.observer.editContext || (e.inputState.composing = -1, e.inputState.compositionEndedAt = Date.now(), e.inputState.compositionPendingKey = !0, e.inputState.compositionPendingChange = e.observer.pendingRecords().length > 0, e.inputState.compositionFirstChange = null, Oe.chrome && Oe.android ? e.observer.flushSoon() : e.inputState.compositionPendingChange ? Promise.resolve().then(() => e.observer.flush()) : setTimeout(() => {
    e.inputState.composing < 0 && e.docView.hasComposition && e.update([]);
  }, 50));
};
Rn.contextmenu = (e) => {
  e.inputState.lastContextMenu = Date.now();
};
Un.beforeinput = (e, t) => {
  var n, i;
  if (t.inputType == "insertReplacementText" && e.observer.editContext) {
    let a = (n = t.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), r = t.getTargetRanges();
    if (a && r.length) {
      let s = r[0], o = e.posAtDOM(s.startContainer, s.startOffset), u = e.posAtDOM(s.endContainer, s.endOffset);
      return dh(e, { from: o, to: u, insert: e.state.toText(a) }, null), !0;
    }
  }
  let l;
  if (Oe.chrome && Oe.android && (l = cv.find((a) => a.inputType == t.inputType)) && (e.observer.delayAndroidKey(l.key, l.keyCode), l.key == "Backspace" || l.key == "Delete")) {
    let a = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var r;
      (((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0) > a + 10 && e.hasFocus && (e.contentDOM.blur(), e.focus());
    }, 100);
  }
  return Oe.ios && t.inputType == "deleteContentForward" && e.observer.flushSoon(), Oe.safari && t.inputType == "insertText" && e.inputState.composing >= 0 && setTimeout(() => Rn.compositionend(e, t), 20), !1;
};
const B0 = /* @__PURE__ */ new Set();
function h$(e) {
  B0.has(e) || (B0.add(e), e.addEventListener("copy", () => {
  }), e.addEventListener("cut", () => {
  }));
}
const E0 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Za = !1;
function z0() {
  Za = !1;
}
class m$ {
  constructor(t) {
    this.lineWrapping = t, this.doc = Ne.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, n) {
    let i = this.doc.lineAt(n).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((n - t - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return E0.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let n = !1;
    for (let i = 0; i < t.length; i++) {
      let l = t[i];
      l < 0 ? i++ : this.heightSamples[Math.floor(l * 10)] || (n = !0, this.heightSamples[Math.floor(l * 10)] = !0);
    }
    return n;
  }
  refresh(t, n, i, l, a, r) {
    let s = E0.indexOf(t) > -1, o = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != s;
    if (this.lineWrapping = s, this.lineHeight = n, this.charWidth = i, this.textHeight = l, this.lineLength = a, o) {
      this.heightSamples = {};
      for (let u = 0; u < r.length; u++) {
        let c = r[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return o;
  }
}
class g$ {
  constructor(t, n) {
    this.from = t, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class ri {
  /**
  @internal
  */
  constructor(t, n, i, l, a) {
    this.from = t, this.length = n, this.top = i, this.height = l, this._content = a;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? cn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof nl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new ri(this.from, this.length + t.length, this.top, this.height + t.height, n);
  }
}
var st = /* @__PURE__ */ function(e) {
  return e[e.ByPos = 0] = "ByPos", e[e.ByHeight = 1] = "ByHeight", e[e.ByPosNoHeight = 2] = "ByPosNoHeight", e;
}(st || (st = {}));
const fo = 1e-3;
class dn {
  constructor(t, n, i = 2) {
    this.length = t, this.height = n, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > fo && (Za = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, n, i) {
    return dn.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, n) {
    n.push(this);
  }
  decomposeRight(t, n) {
    n.push(this);
  }
  applyChanges(t, n, i, l) {
    let a = this, r = i.doc;
    for (let s = l.length - 1; s >= 0; s--) {
      let { fromA: o, toA: u, fromB: c, toB: d } = l[s], f = a.lineAt(o, st.ByPosNoHeight, i.setDoc(n), 0, 0), h = f.to >= u ? f : a.lineAt(u, st.ByPosNoHeight, i, 0, 0);
      for (d += h.to - u, u = h.to; s > 0 && f.from <= l[s - 1].toA; )
        o = l[s - 1].fromA, c = l[s - 1].fromB, s--, o < f.from && (f = a.lineAt(o, st.ByPosNoHeight, i, 0, 0));
      c += f.from - o, o = f.from;
      let g = fh.build(i.setDoc(r), t, c, d);
      a = Do(a, a.replace(o, u, g));
    }
    return a.updateHeight(i, 0);
  }
  static empty() {
    return new Sn(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let n = 0, i = t.length, l = 0, a = 0;
    for (; ; )
      if (n == i)
        if (l > a * 2) {
          let s = t[n - 1];
          s.break ? t.splice(--n, 1, s.left, null, s.right) : t.splice(--n, 1, s.left, s.right), i += 1 + s.break, l -= s.size;
        } else if (a > l * 2) {
          let s = t[i];
          s.break ? t.splice(i, 1, s.left, null, s.right) : t.splice(i, 1, s.left, s.right), i += 2 + s.break, a -= s.size;
        } else
          break;
      else if (l < a) {
        let s = t[n++];
        s && (l += s.size);
      } else {
        let s = t[--i];
        s && (a += s.size);
      }
    let r = 0;
    return t[n - 1] == null ? (r = 1, n--) : t[n] == null && (r = 1, i++), new v$(dn.of(t.slice(0, n)), r, dn.of(t.slice(i)));
  }
}
function Do(e, t) {
  return e == t ? e : (e.constructor != t.constructor && (Za = !0), t);
}
dn.prototype.size = 1;
class Ov extends dn {
  constructor(t, n, i) {
    super(t, n), this.deco = i;
  }
  blockAt(t, n, i, l) {
    return new ri(l, this.length, i, this.height, this.deco || 0);
  }
  lineAt(t, n, i, l, a) {
    return this.blockAt(0, i, l, a);
  }
  forEachLine(t, n, i, l, a, r) {
    t <= a + this.length && n >= a && r(this.blockAt(0, i, l, a));
  }
  updateHeight(t, n = 0, i = !1, l) {
    return l && l.from <= n && l.more && this.setHeight(l.heights[l.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Sn extends Ov {
  constructor(t, n) {
    super(t, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, n, i, l) {
    return new ri(l, this.length, i, this.height, this.breaks);
  }
  replace(t, n, i) {
    let l = i[0];
    return i.length == 1 && (l instanceof Sn || l instanceof zt && l.flags & 4) && Math.abs(this.length - l.length) < 10 ? (l instanceof zt ? l = new Sn(l.length, this.height) : l.height = this.height, this.outdated || (l.outdated = !1), l) : dn.of(i);
  }
  updateHeight(t, n = 0, i = !1, l) {
    return l && l.from <= n && l.more ? this.setHeight(l.heights[l.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class zt extends dn {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, n) {
    let i = t.doc.lineAt(n).number, l = t.doc.lineAt(n + this.length).number, a = l - i + 1, r, s = 0;
    if (t.lineWrapping) {
      let o = Math.min(this.height, t.lineHeight * a);
      r = o / a, this.length > a + 1 && (s = (this.height - o) / (this.length - a - 1));
    } else
      r = this.height / a;
    return { firstLine: i, lastLine: l, perLine: r, perChar: s };
  }
  blockAt(t, n, i, l) {
    let { firstLine: a, lastLine: r, perLine: s, perChar: o } = this.heightMetrics(n, l);
    if (n.lineWrapping) {
      let u = l + (t < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length)), c = n.doc.lineAt(u), d = s + c.length * o, f = Math.max(i, t - d / 2);
      return new ri(c.from, c.length, f, d, 0);
    } else {
      let u = Math.max(0, Math.min(r - a, Math.floor((t - i) / s))), { from: c, length: d } = n.doc.line(a + u);
      return new ri(c, d, i + s * u, s, 0);
    }
  }
  lineAt(t, n, i, l, a) {
    if (n == st.ByHeight)
      return this.blockAt(t, i, l, a);
    if (n == st.ByPosNoHeight) {
      let { from: h, to: g } = i.doc.lineAt(t);
      return new ri(h, g - h, 0, 0, 0);
    }
    let { firstLine: r, perLine: s, perChar: o } = this.heightMetrics(i, a), u = i.doc.lineAt(t), c = s + u.length * o, d = u.number - r, f = l + s * d + o * (u.from - a - d);
    return new ri(u.from, u.length, Math.max(l, Math.min(f, l + this.height - c)), c, 0);
  }
  forEachLine(t, n, i, l, a, r) {
    t = Math.max(t, a), n = Math.min(n, a + this.length);
    let { firstLine: s, perLine: o, perChar: u } = this.heightMetrics(i, a);
    for (let c = t, d = l; c <= n; ) {
      let f = i.doc.lineAt(c);
      if (c == t) {
        let g = f.number - s;
        d += o * g + u * (t - a - g);
      }
      let h = o + u * f.length;
      r(new ri(f.from, f.length, d, h, 0)), d += h, c = f.to + 1;
    }
  }
  replace(t, n, i) {
    let l = this.length - n;
    if (l > 0) {
      let a = i[i.length - 1];
      a instanceof zt ? i[i.length - 1] = new zt(a.length + l) : i.push(null, new zt(l - 1));
    }
    if (t > 0) {
      let a = i[0];
      a instanceof zt ? i[0] = new zt(t + a.length) : i.unshift(new zt(t - 1), null);
    }
    return dn.of(i);
  }
  decomposeLeft(t, n) {
    n.push(new zt(t - 1), null);
  }
  decomposeRight(t, n) {
    n.push(null, new zt(this.length - t - 1));
  }
  updateHeight(t, n = 0, i = !1, l) {
    let a = n + this.length;
    if (l && l.from <= n + this.length && l.more) {
      let r = [], s = Math.max(n, l.from), o = -1;
      for (l.from > n && r.push(new zt(l.from - n - 1).updateHeight(t, n)); s <= a && l.more; ) {
        let c = t.doc.lineAt(s).length;
        r.length && r.push(null);
        let d = l.heights[l.index++];
        o == -1 ? o = d : Math.abs(d - o) >= fo && (o = -2);
        let f = new Sn(c, d);
        f.outdated = !1, r.push(f), s += c + 1;
      }
      s <= a && r.push(null, new zt(a - s).updateHeight(t, s));
      let u = dn.of(r);
      return (o < 0 || Math.abs(u.height - this.height) >= fo || Math.abs(o - this.heightMetrics(t, n).perLine) >= fo) && (Za = !0), Do(this, u);
    } else (i || this.outdated) && (this.setHeight(t.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class v$ extends dn {
  constructor(t, n, i) {
    super(t.length + n + i.length, t.height + i.height, n | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, n, i, l) {
    let a = i + this.left.height;
    return t < a ? this.left.blockAt(t, n, i, l) : this.right.blockAt(t, n, a, l + this.left.length + this.break);
  }
  lineAt(t, n, i, l, a) {
    let r = l + this.left.height, s = a + this.left.length + this.break, o = n == st.ByHeight ? t < r : t < s, u = o ? this.left.lineAt(t, n, i, l, a) : this.right.lineAt(t, n, i, r, s);
    if (this.break || (o ? u.to < s : u.from > s))
      return u;
    let c = n == st.ByPosNoHeight ? st.ByPosNoHeight : st.ByPos;
    return o ? u.join(this.right.lineAt(s, c, i, r, s)) : this.left.lineAt(s, c, i, l, a).join(u);
  }
  forEachLine(t, n, i, l, a, r) {
    let s = l + this.left.height, o = a + this.left.length + this.break;
    if (this.break)
      t < o && this.left.forEachLine(t, n, i, l, a, r), n >= o && this.right.forEachLine(t, n, i, s, o, r);
    else {
      let u = this.lineAt(o, st.ByPos, i, l, a);
      t < u.from && this.left.forEachLine(t, u.from - 1, i, l, a, r), u.to >= t && u.from <= n && r(u), n > u.to && this.right.forEachLine(u.to + 1, n, i, s, o, r);
    }
  }
  replace(t, n, i) {
    let l = this.left.length + this.break;
    if (n < l)
      return this.balanced(this.left.replace(t, n, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - l, n - l, i));
    let a = [];
    t > 0 && this.decomposeLeft(t, a);
    let r = a.length;
    for (let s of i)
      a.push(s);
    if (t > 0 && H0(a, r - 1), n < this.length) {
      let s = a.length;
      this.decomposeRight(n, a), H0(a, s);
    }
    return dn.of(a);
  }
  decomposeLeft(t, n) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, n);
    n.push(this.left), this.break && (i++, t >= i && n.push(null)), t > i && this.right.decomposeLeft(t - i, n);
  }
  decomposeRight(t, n) {
    let i = this.left.length, l = i + this.break;
    if (t >= l)
      return this.right.decomposeRight(t - l, n);
    t < i && this.left.decomposeRight(t, n), this.break && t < l && n.push(null), n.push(this.right);
  }
  balanced(t, n) {
    return t.size > 2 * n.size || n.size > 2 * t.size ? dn.of(this.break ? [t, null, n] : [t, n]) : (this.left = Do(this.left, t), this.right = Do(this.right, n), this.setHeight(t.height + n.height), this.outdated = t.outdated || n.outdated, this.size = t.size + n.size, this.length = t.length + this.break + n.length, this);
  }
  updateHeight(t, n = 0, i = !1, l) {
    let { left: a, right: r } = this, s = n + a.length + this.break, o = null;
    return l && l.from <= n + a.length && l.more ? o = a = a.updateHeight(t, n, i, l) : a.updateHeight(t, n, i), l && l.from <= s + r.length && l.more ? o = r = r.updateHeight(t, s, i, l) : r.updateHeight(t, s, i), o ? this.balanced(a, r) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function H0(e, t) {
  let n, i;
  e[t] == null && (n = e[t - 1]) instanceof zt && (i = e[t + 1]) instanceof zt && e.splice(t - 1, 3, new zt(n.length + 1 + i.length));
}
const p$ = 5;
class fh {
  constructor(t, n) {
    this.pos = t, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, n) {
    if (this.lineStart > -1) {
      let i = Math.min(n, this.lineEnd), l = this.nodes[this.nodes.length - 1];
      l instanceof Sn ? l.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Sn(i - this.pos, -1)), this.writtenTo = i, n > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(t, n, i) {
    if (t < n || i.heightRelevant) {
      let l = i.widget ? i.widget.estimatedHeight : 0, a = i.widget ? i.widget.lineBreaks : 0;
      l < 0 && (l = this.oracle.lineHeight);
      let r = n - t;
      i.block ? this.addBlock(new Ov(r, l, i)) : (r || a || l >= p$) && this.addLineDeco(l, a, r);
    } else n > t && this.span(t, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = n, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new Sn(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, n) {
    let i = new zt(n - t);
    return this.oracle.doc.lineAt(t).to == n && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof Sn)
      return t;
    let n = new Sn(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(t) {
    this.enterLine();
    let n = t.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, n && n.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, n, i) {
    let l = this.ensureLine();
    l.length += i, l.collapsed += i, l.widgetHeight = Math.max(l.widgetHeight, t), l.breaks += n, this.writtenTo = this.pos = this.pos + i;
  }
  finish(t) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Sn) && !this.isCovered ? this.nodes.push(new Sn(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let l of this.nodes)
      l instanceof Sn && l.updateHeight(this.oracle, i), i += l ? l.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, n, i, l) {
    let a = new fh(i, t);
    return Ee.spans(n, i, l, a, 0), a.finish(i);
  }
}
function O$(e, t, n) {
  let i = new y$();
  return Ee.compare(e, t, n, i, 0), i.changes;
}
class y$ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, n, i, l) {
    (t < n || i && i.heightRelevant || l && l.heightRelevant) && id(t, n, this.changes, 5);
  }
}
function b$(e, t) {
  let n = e.getBoundingClientRect(), i = e.ownerDocument, l = i.defaultView || window, a = Math.max(0, n.left), r = Math.min(l.innerWidth, n.right), s = Math.max(0, n.top), o = Math.min(l.innerHeight, n.bottom);
  for (let u = e.parentNode; u && u != i.body; )
    if (u.nodeType == 1) {
      let c = u, d = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && d.overflow != "visible") {
        let f = c.getBoundingClientRect();
        a = Math.max(a, f.left), r = Math.min(r, f.right), s = Math.max(s, f.top), o = Math.min(u == e.parentNode ? l.innerHeight : o, f.bottom);
      }
      u = d.position == "absolute" || d.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: a - n.left,
    right: Math.max(a, r) - n.left,
    top: s - (n.top + t),
    bottom: Math.max(s, o) - (n.top + t)
  };
}
function C$(e, t) {
  let n = e.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: t,
    bottom: n.bottom - (n.top + t)
  };
}
class Vc {
  constructor(t, n, i, l) {
    this.from = t, this.to = n, this.size = i, this.displaySize = l;
  }
  static same(t, n) {
    if (t.length != n.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let l = t[i], a = n[i];
      if (l.from != a.from || l.to != a.to || l.size != a.size)
        return !1;
    }
    return !0;
  }
  draw(t, n) {
    return Ce.replace({
      widget: new S$(this.displaySize * (n ? t.scaleY : t.scaleX), n)
    }).range(this.from, this.to);
  }
}
class S$ extends bi {
  constructor(t, n) {
    super(), this.size = t, this.vertical = n;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class j0 {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = X0, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = ot.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = t.facet(uh).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new m$(n), this.stateDeco = t.facet(jr).filter((i) => typeof i != "function"), this.heightMap = dn.empty().applyChanges(this.stateDeco, Ne.empty, this.heightOracle.setDoc(t.doc), [new _n(0, 0, 0, t.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Ce.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: n } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let l = i ? n.head : n.anchor;
      if (!t.some(({ from: a, to: r }) => l >= a && l <= r)) {
        let { from: a, to: r } = this.lineBlockAt(l);
        t.push(new Es(a, r));
      }
    }
    return this.viewports = t.sort((i, l) => i.from - l.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? X0 : new hh(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(vr(t, this.scaler));
    });
  }
  update(t, n = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(jr).filter((c) => typeof c != "function");
    let l = t.changedRanges, a = _n.extendWithRanges(l, O$(i, this.stateDeco, t ? t.changes : Tt.empty(this.state.doc.length))), r = this.heightMap.height, s = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    z0(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), a), (this.heightMap.height != r || Za) && (t.flags |= 2), s ? (this.scrollAnchorPos = t.changes.mapPos(s.from, -1), this.scrollAnchorHeight = s.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let o = a.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (n && (n.range.head < o.from || n.range.head > o.to) || !this.viewportIsAppropriate(o)) && (o = this.getViewport(0, n));
    let u = o.from != this.viewport.from || o.to != this.viewport.to;
    this.viewport = o, t.flags |= this.updateForViewport(), (u || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(J3) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let n = t.contentDOM, i = window.getComputedStyle(n), l = this.heightOracle, a = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? ot.RTL : ot.LTR;
    let r = this.heightOracle.mustRefreshForWrapping(a), s = n.getBoundingClientRect(), o = r || this.mustMeasureContent || this.contentDOMHeight != s.height;
    this.contentDOMHeight = s.height, this.mustMeasureContent = !1;
    let u = 0, c = 0;
    if (s.width && s.height) {
      let { scaleX: $, scaleY: x } = P3(n, s);
      ($ > 5e-3 && Math.abs(this.scaleX - $) > 5e-3 || x > 5e-3 && Math.abs(this.scaleY - x) > 5e-3) && (this.scaleX = $, this.scaleY = x, u |= 8, r = o = !0);
    }
    let d = (parseInt(i.paddingTop) || 0) * this.scaleY, f = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != f) && (this.paddingTop = d, this.paddingBottom = f, u |= 10), this.editorWidth != t.scrollDOM.clientWidth && (l.lineWrapping && (o = !0), this.editorWidth = t.scrollDOM.clientWidth, u |= 8);
    let h = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != h && (this.scrollAnchorHeight = -1, this.scrollTop = h), this.scrolledToBottom = Q3(t.scrollDOM);
    let g = (this.printing ? C$ : b$)(n, this.paddingTop), v = g.top - this.pixelViewport.top, p = g.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g;
    let O = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (O != this.inView && (this.inView = O, O && (o = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let b = s.width;
    if ((this.contentDOMWidth != b || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = s.width, this.editorHeight = t.scrollDOM.clientHeight, u |= 8), o) {
      let $ = t.docView.measureVisibleLineHeights(this.viewport);
      if (l.mustRefreshForHeights($) && (r = !0), r || l.lineWrapping && Math.abs(b - this.contentDOMWidth) > l.charWidth) {
        let { lineHeight: x, charWidth: Q, textHeight: M } = t.docView.measureTextSize();
        r = x > 0 && l.refresh(a, x, Q, M, b / Q, $), r && (t.docView.minWidth = 0, u |= 8);
      }
      v > 0 && p > 0 ? c = Math.max(v, p) : v < 0 && p < 0 && (c = Math.min(v, p)), z0();
      for (let x of this.viewports) {
        let Q = x.from == this.viewport.from ? $ : t.docView.measureVisibleLineHeights(x);
        this.heightMap = (r ? dn.empty().applyChanges(this.stateDeco, Ne.empty, this.heightOracle, [new _n(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(l, 0, r, new g$(x.from, Q));
      }
      Za && (u |= 2);
    }
    let V = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return V && (u & 2 && (u |= this.updateScaler()), this.viewport = this.getViewport(c, this.scrollTarget), u |= this.updateForViewport()), (u & 2 || V) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(r ? [] : this.lineGaps, t)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, n) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), l = this.heightMap, a = this.heightOracle, { visibleTop: r, visibleBottom: s } = this, o = new Es(l.lineAt(r - i * 1e3, st.ByHeight, a, 0, 0).from, l.lineAt(s + (1 - i) * 1e3, st.ByHeight, a, 0, 0).to);
    if (n) {
      let { head: u } = n.range;
      if (u < o.from || u > o.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = l.lineAt(u, st.ByPos, a, 0, 0), f;
        n.y == "center" ? f = (d.top + d.bottom) / 2 - c / 2 : n.y == "start" || n.y == "nearest" && u < o.from ? f = d.top : f = d.bottom - c, o = new Es(l.lineAt(f - 1e3 / 2, st.ByHeight, a, 0, 0).from, l.lineAt(f + c + 1e3 / 2, st.ByHeight, a, 0, 0).to);
      }
    }
    return o;
  }
  mapViewport(t, n) {
    let i = n.mapPos(t.from, -1), l = n.mapPos(t.to, 1);
    return new Es(this.heightMap.lineAt(i, st.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(l, st.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: n }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: l } = this.heightMap.lineAt(t, st.ByPos, this.heightOracle, 0, 0), { bottom: a } = this.heightMap.lineAt(n, st.ByPos, this.heightOracle, 0, 0), { visibleTop: r, visibleBottom: s } = this;
    return (t == 0 || l <= r - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || a >= s + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && l > r - 2 * 1e3 && a < s + 2 * 1e3;
  }
  mapLineGaps(t, n) {
    if (!t.length || n.empty)
      return t;
    let i = [];
    for (let l of t)
      n.touchesRange(l.from, l.to) || i.push(new Vc(n.mapPos(l.from), n.mapPos(l.to), l.size, l.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, n) {
    let i = this.heightOracle.lineWrapping, l = i ? 1e4 : 2e3, a = l >> 1, r = l << 1;
    if (this.defaultTextDirection != ot.LTR && !i)
      return [];
    let s = [], o = (c, d, f, h) => {
      if (d - c < a)
        return;
      let g = this.state.selection.main, v = [g.from];
      g.empty || v.push(g.to);
      for (let O of v)
        if (O > c && O < d) {
          o(c, O - 10, f, h), o(O + 10, d, f, h);
          return;
        }
      let p = k$(t, (O) => O.from >= f.from && O.to <= f.to && Math.abs(O.from - c) < a && Math.abs(O.to - d) < a && !v.some((b) => O.from < b && O.to > b));
      if (!p) {
        if (d < f.to && n && i && n.visibleRanges.some((V) => V.from <= d && V.to >= d)) {
          let V = n.moveToLineBoundary(J.cursor(d), !1, !0).head;
          V > c && (d = V);
        }
        let O = this.gapSize(f, c, d, h), b = i || O < 2e6 ? O : 2e6;
        p = new Vc(c, d, O, b);
      }
      s.push(p);
    }, u = (c) => {
      if (c.length < r || c.type != cn.Text)
        return;
      let d = w$(c.from, c.to, this.stateDeco);
      if (d.total < r)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, h, g;
      if (i) {
        let v = l / this.heightOracle.lineLength * this.heightOracle.lineHeight, p, O;
        if (f != null) {
          let b = Hs(d, f), V = ((this.visibleBottom - this.visibleTop) / 2 + v) / c.height;
          p = b - V, O = b + V;
        } else
          p = (this.visibleTop - c.top - v) / c.height, O = (this.visibleBottom - c.top + v) / c.height;
        h = zs(d, p), g = zs(d, O);
      } else {
        let v = d.total * this.heightOracle.charWidth, p = l * this.heightOracle.charWidth, O = 0;
        if (v > 2e6)
          for (let Q of t)
            Q.from >= c.from && Q.from < c.to && Q.size != Q.displaySize && Q.from * this.heightOracle.charWidth + O < this.pixelViewport.left && (O = Q.size - Q.displaySize);
        let b = this.pixelViewport.left + O, V = this.pixelViewport.right + O, $, x;
        if (f != null) {
          let Q = Hs(d, f), M = ((V - b) / 2 + p) / v;
          $ = Q - M, x = Q + M;
        } else
          $ = (b - p) / v, x = (V + p) / v;
        h = zs(d, $), g = zs(d, x);
      }
      h > c.from && o(c.from, h, c, d), g < c.to && o(g, c.to, c, d);
    };
    for (let c of this.viewportLines)
      Array.isArray(c.type) ? c.type.forEach(u) : u(c);
    return s;
  }
  gapSize(t, n, i, l) {
    let a = Hs(l, i) - Hs(l, n);
    return this.heightOracle.lineWrapping ? t.height * a : l.total * this.heightOracle.charWidth * a;
  }
  updateLineGaps(t) {
    Vc.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = Ce.set(t.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let n = [];
    Ee.spans(t, this.viewport.from, this.viewport.to, {
      span(l, a) {
        n.push({ from: l, to: a });
      },
      point() {
      }
    }, 20);
    let i = n.length != this.visibleRanges.length || this.visibleRanges.some((l, a) => l.from != n[a].from || l.to != n[a].to);
    return this.visibleRanges = n, i ? 4 : 0;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((n) => n.from <= t && n.to >= t) || vr(this.heightMap.lineAt(t, st.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= t && n.bottom >= t) || vr(this.heightMap.lineAt(this.scaler.fromDOM(t), st.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let n = this.lineBlockAtHeight(t + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return vr(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Es {
  constructor(t, n) {
    this.from = t, this.to = n;
  }
}
function w$(e, t, n) {
  let i = [], l = e, a = 0;
  return Ee.spans(n, e, t, {
    span() {
    },
    point(r, s) {
      r > l && (i.push({ from: l, to: r }), a += r - l), l = s;
    }
  }, 20), l < t && (i.push({ from: l, to: t }), a += t - l), { total: a, ranges: i };
}
function zs({ total: e, ranges: t }, n) {
  if (n <= 0)
    return t[0].from;
  if (n >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(e * n);
  for (let l = 0; ; l++) {
    let { from: a, to: r } = t[l], s = r - a;
    if (i <= s)
      return a + i;
    i -= s;
  }
}
function Hs(e, t) {
  let n = 0;
  for (let { from: i, to: l } of e.ranges) {
    if (t <= l) {
      n += t - i;
      break;
    }
    n += l - i;
  }
  return n / e.total;
}
function k$(e, t) {
  for (let n of e)
    if (t(n))
      return n;
}
const X0 = {
  toDOM(e) {
    return e;
  },
  fromDOM(e) {
    return e;
  },
  scale: 1,
  eq(e) {
    return e == this;
  }
};
class hh {
  constructor(t, n, i) {
    let l = 0, a = 0, r = 0;
    this.viewports = i.map(({ from: s, to: o }) => {
      let u = n.lineAt(s, st.ByPos, t, 0, 0).top, c = n.lineAt(o, st.ByPos, t, 0, 0).bottom;
      return l += c - u, { from: s, to: o, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - l) / (n.height - l);
    for (let s of this.viewports)
      s.domTop = r + (s.top - a) * this.scale, r = s.domBottom = s.domTop + (s.bottom - s.top), a = s.bottom;
  }
  toDOM(t) {
    for (let n = 0, i = 0, l = 0; ; n++) {
      let a = n < this.viewports.length ? this.viewports[n] : null;
      if (!a || t < a.top)
        return l + (t - i) * this.scale;
      if (t <= a.bottom)
        return a.domTop + (t - a.top);
      i = a.bottom, l = a.domBottom;
    }
  }
  fromDOM(t) {
    for (let n = 0, i = 0, l = 0; ; n++) {
      let a = n < this.viewports.length ? this.viewports[n] : null;
      if (!a || t < a.domTop)
        return i + (t - l) / this.scale;
      if (t <= a.domBottom)
        return a.top + (t - a.domTop);
      i = a.bottom, l = a.domBottom;
    }
  }
  eq(t) {
    return t instanceof hh ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((n, i) => n.from == t.viewports[i].from && n.to == t.viewports[i].to) : !1;
  }
}
function vr(e, t) {
  if (t.scale == 1)
    return e;
  let n = t.toDOM(e.top), i = t.toDOM(e.bottom);
  return new ri(e.from, e.length, n, i - n, Array.isArray(e._content) ? e._content.map((l) => vr(l, t)) : e._content);
}
const js = /* @__PURE__ */ ve.define({ combine: (e) => e.join(" ") }), fd = /* @__PURE__ */ ve.define({ combine: (e) => e.indexOf(!0) > -1 }), hd = /* @__PURE__ */ el.newName(), yv = /* @__PURE__ */ el.newName(), bv = /* @__PURE__ */ el.newName(), Cv = { "&light": "." + yv, "&dark": "." + bv };
function md(e, t, n) {
  return new el(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (l) => {
        if (l == "&")
          return e;
        if (!n || !n[l])
          throw new RangeError(`Unsupported selector: ${l}`);
        return n[l];
      }) : e + " " + i;
    }
  });
}
const x$ = /* @__PURE__ */ md("." + hd, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, Cv), P$ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Qc = Oe.ie && Oe.ie_version <= 11;
class $$ {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new dP(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((n) => {
      for (let i of n)
        this.queue.push(i);
      (Oe.ie && Oe.ie_version <= 11 || Oe.ios && t.composing) && n.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(Oe.chrome && Oe.chrome_version < 126) && (this.editContext = new Q$(t), t.state.facet(ji) && (t.contentDOM.editContext = this.editContext.editContext)), Qc && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((n, i) => n != t[i]))) {
      this.gapIntersection.disconnect();
      for (let n of t)
        this.gapIntersection.observe(n);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, l = this.selectionRange;
    if (i.state.facet(ji) ? i.root.activeElement != this.dom : !uo(this.dom, l))
      return;
    let a = l.anchorNode && i.docView.nearest(l.anchorNode);
    if (a && a.ignoreEvent(t)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (Oe.ie && Oe.ie_version <= 11 || Oe.android && Oe.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    l.focusNode && Cr(l.focusNode, l.focusOffset, l.anchorNode, l.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, n = Hr(t.root);
    if (!n)
      return !1;
    let i = Oe.safari && t.root.nodeType == 11 && t.root.activeElement == this.dom && V$(this.view, n) || n;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let l = uo(this.dom, i);
    return l && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && hP(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), l && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, n) {
    this.selectionRange.set(t.node, t.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, n = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !n && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : n || (n = this.scrollTargets.slice(0, t)), n && n.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, t)), n) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = n)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, P$), Qc && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Qc && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, n) {
    var i;
    if (!this.delayedAndroidKey) {
      let l = () => {
        let a = this.delayedAndroidKey;
        a && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = a.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && a.force && ba(this.dom, a.key, a.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(l);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let n = -1, i = -1, l = !1;
    for (let a of t) {
      let r = this.readMutation(a);
      r && (r.typeOver && (l = !0), n == -1 ? { from: n, to: i } = r : (n = Math.min(r.from, n), i = Math.max(r.to, i)));
    }
    return { from: n, to: i, typeOver: l };
  }
  readChange() {
    let { from: t, to: n, typeOver: i } = this.processRecords(), l = this.selectionChanged && uo(this.dom, this.selectionRange);
    if (t < 0 && !l)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let a = new qP(this.view, t, n, i);
    return this.view.docView.domChanged = { newSel: a.newSel ? a.newSel.main : null }, a;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, l = uv(this.view, n);
    return this.view.state == i && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), l;
  }
  readMutation(t) {
    let n = this.view.docView.nearest(t.target);
    if (!n || n.ignoreMutation(t))
      return null;
    if (n.markDirty(t.type == "attributes"), t.type == "attributes" && (n.flags |= 4), t.type == "childList") {
      let i = N0(n, t.previousSibling || t.target.previousSibling, -1), l = N0(n, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? n.posAfter(i) : n.posAtStart,
        to: l ? n.posBefore(l) : n.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet(ji) != t.state.facet(ji) && (t.view.contentDOM.editContext = t.state.facet(ji) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, n, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let l of this.scrollTargets)
      l.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function N0(e, t, n) {
  for (; t; ) {
    let i = Ke.get(t);
    if (i && i.parent == e)
      return i;
    let l = t.parentNode;
    t = l != e.dom ? l : n > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
function q0(e, t) {
  let n = t.startContainer, i = t.startOffset, l = t.endContainer, a = t.endOffset, r = e.docView.domAtPos(e.state.selection.main.anchor);
  return Cr(r.node, r.offset, l, a) && ([n, i, l, a] = [l, a, n, i]), { anchorNode: n, anchorOffset: i, focusNode: l, focusOffset: a };
}
function V$(e, t) {
  if (t.getComposedRanges) {
    let l = t.getComposedRanges(e.root)[0];
    if (l)
      return q0(e, l);
  }
  let n = null;
  function i(l) {
    l.preventDefault(), l.stopImmediatePropagation(), n = l.getTargetRanges()[0];
  }
  return e.contentDOM.addEventListener("beforeinput", i, !0), e.dom.ownerDocument.execCommand("indent"), e.contentDOM.removeEventListener("beforeinput", i, !0), n ? q0(e, n) : null;
}
class Q$ {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.resetRange(t.state);
    let n = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let { anchor: l } = t.state.selection.main, a = {
        from: this.toEditorPos(i.updateRangeStart),
        to: this.toEditorPos(i.updateRangeEnd),
        insert: Ne.of(i.text.split(`
`))
      };
      a.from == this.from && l < this.from ? a.from = l : a.to == this.to && l > this.to && (a.to = l), !(a.from == a.to && !a.insert.length) && (this.pendingContextChange = a, t.state.readOnly || dh(t, a, J.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd))), this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state)));
    }, this.handlers.characterboundsupdate = (i) => {
      let l = [], a = null;
      for (let r = this.toEditorPos(i.rangeStart), s = this.toEditorPos(i.rangeEnd); r < s; r++) {
        let o = t.coordsForChar(r);
        a = o && new DOMRect(o.left, o.top, o.right - o.left, o.bottom - o.top) || a || new DOMRect(), l.push(a);
      }
      n.updateCharacterBounds(i.rangeStart, l);
    }, this.handlers.textformatupdate = (i) => {
      let l = [];
      for (let a of i.getTextFormats()) {
        let r = a.underlineStyle, s = a.underlineThickness;
        if (r != "None" && s != "None") {
          let o = `text-decoration: underline ${r == "Dashed" ? "dashed " : r == "Squiggle" ? "wavy " : ""}${s == "Thin" ? 1 : 2}px`;
          l.push(Ce.mark({ attributes: { style: o } }).range(this.toEditorPos(a.rangeStart), this.toEditorPos(a.rangeEnd)));
        }
      }
      t.dispatch({ effects: tv.of(Ce.set(l)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      t.inputState.composing = -1, t.inputState.compositionFirstChange = null;
    };
    for (let i in this.handlers)
      n.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: (i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let l = Hr(i.root);
      l && l.rangeCount && this.editContext.updateSelectionBounds(l.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(t) {
    let n = 0, i = !1, l = this.pendingContextChange;
    return t.changes.iterChanges((a, r, s, o, u) => {
      if (i)
        return;
      let c = u.length - (r - a);
      if (l && r >= l.to)
        if (l.from == a && l.to == r && l.insert.eq(u)) {
          l = this.pendingContextChange = null, n += c, this.to += c;
          return;
        } else
          l = null, this.revertPending(t.state);
      if (a += n, r += n, r <= this.from)
        this.from += c, this.to += c;
      else if (a < this.to) {
        if (a < this.from || r > this.to || this.to - this.from + u.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(a), this.toContextPos(r), u.toString()), this.to += c;
      }
      n += c;
    }), l && !i && this.revertPending(t.state), !i;
  }
  update(t) {
    let n = this.pendingContextChange;
    !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.resetRange(t.state), this.editContext.updateText(0, this.editContext.text.length, t.state.doc.sliceString(this.from, this.to)), this.setSelection(t.state)) : (t.docChanged || t.selectionSet || n) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: n } = t.selection.main;
    this.from = Math.max(
      0,
      n - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      n + 1e4
      /* CxVp.Margin */
    );
  }
  revertPending(t) {
    let n = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), t.doc.sliceString(n.from, n.to));
  }
  setSelection(t) {
    let { main: n } = t.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), l = this.toContextPos(n.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != l) && this.editContext.updateSelection(i, l);
  }
  rangeIsValid(t) {
    let { head: n } = t.selection.main;
    return !(this.from > 0 && n - this.from < 500 || this.to < t.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t) {
    return t + this.from;
  }
  toContextPos(t) {
    return t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}
class me {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var n;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: i } = t;
    this.dispatchTransactions = t.dispatchTransactions || i && ((l) => l.forEach((a) => i(a, this))) || ((l) => this.update(l)), this.dispatch = this.dispatch.bind(this), this._root = t.root || fP(t.parent) || document, this.viewState = new j0(t.state || Re.create(t)), t.scrollTo && t.scrollTo.is(Is) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(hr).map((l) => new xc(l));
    for (let l of this.plugins)
      l.update(this);
    this.observer = new $$(this), this.inputState = new GP(this), this.inputState.ensureHandlers(this.plugins), this.docView = new k0(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...t) {
    let n = t.length == 1 && t[0] instanceof $t ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, i = !1, l, a = this.state;
    for (let f of t) {
      if (f.startState != a)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      a = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = a;
      return;
    }
    let r = this.hasFocus, s = 0, o = null;
    t.some((f) => f.annotation(gv)) ? (this.inputState.notifiedFocused = r, s = 1) : r != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = r, o = vv(a, r), o || (s = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(a.doc) || !this.state.selection.eq(a.selection)) && (c = null)) : this.observer.clear(), a.facet(Re.phrases) != this.state.facet(Re.phrases))
      return this.setState(a);
    l = Io.create(this, a, t), l.flags |= s;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of t) {
        if (d && (d = d.map(f.changes)), f.scrollIntoView) {
          let { main: h } = f.state.selection;
          d = new Ca(h.empty ? h : J.cursor(h.head, h.head > h.anchor ? -1 : 1));
        }
        for (let h of f.effects)
          h.is(Is) && (d = h.value.clip(this.state));
      }
      this.viewState.update(l, d), this.bidiCache = Bo.update(this.bidiCache, l.changes), l.empty || (this.updatePlugins(l), this.inputState.update(l)), n = this.docView.update(l), this.state.facet(mr) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(n, t.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (l.startState.facet(js) != l.state.facet(js) && (this.viewState.mustMeasureContent = !0), (n || i || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !l.empty)
      for (let f of this.state.facet(od))
        try {
          f(l);
        } catch (h) {
          sn(this.state, h, "update listener");
        }
    (o || c) && Promise.resolve().then(() => {
      o && this.state == o.startState && this.dispatch(o), c && !uv(this, c) && u.force && ba(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new j0(t), this.plugins = t.facet(hr).map((i) => new xc(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new k0(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let n = t.startState.facet(hr), i = t.state.facet(hr);
    if (n != i) {
      let l = [];
      for (let a of i) {
        let r = n.indexOf(a);
        if (r < 0)
          l.push(new xc(a));
        else {
          let s = this.plugins[r];
          s.mustUpdate = t, l.push(s);
        }
      }
      for (let a of this.plugins)
        a.mustUpdate != t && a.destroy(this);
      this.plugins = l, this.pluginMap.clear();
    } else
      for (let l of this.plugins)
        l.mustUpdate = t;
    for (let l = 0; l < this.plugins.length; l++)
      this.plugins[l].update(this);
    n != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let n = t.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (i) {
          sn(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let n = null, i = this.scrollDOM, l = i.scrollTop * this.scaleY, { scrollAnchorPos: a, scrollAnchorHeight: r } = this.viewState;
    Math.abs(l - this.viewState.scrollTop) > 1 && (r = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let s = 0; ; s++) {
        if (r < 0)
          if (Q3(i))
            a = -1, r = this.viewState.heightMap.height;
          else {
            let h = this.viewState.scrollAnchorAt(l);
            a = h.from, r = h.top;
          }
        this.updateState = 1;
        let o = this.viewState.measure(this);
        if (!o && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (s > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        o & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((h) => {
          try {
            return h.read(this);
          } catch (g) {
            return sn(this.state, g), Y0;
          }
        }), d = Io.create(this, this.state, []), f = !1;
        d.flags |= o, n ? n.flags |= o : n = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), f = this.docView.update(d), f && this.docViewUpdate());
        for (let h = 0; h < u.length; h++)
          if (c[h] != Y0)
            try {
              let g = u[h];
              g.write && g.write(c[h], this);
            } catch (g) {
              sn(this.state, g);
            }
        if (f && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, r = -1;
              continue;
            } else {
              let g = (a < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(a).top) - r;
              if (g > 1 || g < -1) {
                l = l + g, i.scrollTop = l / this.scaleY, r = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let s of this.state.facet(od))
        s(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return hd + " " + (this.state.facet(fd) ? bv : yv) + " " + this.state.facet(js);
  }
  updateAttrs() {
    let t = F0(this, nv, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(ji) ? "true" : "false",
      class: "cm-content",
      style: `${Oe.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), F0(this, uh, n);
    let i = this.observer.ignore(() => {
      let l = nd(this.contentDOM, this.contentAttrs, n), a = nd(this.dom, this.editorAttrs, t);
      return l || a;
    });
    return this.editorAttrs = t, this.contentAttrs = n, i;
  }
  showAnnouncements(t) {
    let n = !0;
    for (let i of t)
      for (let l of i.effects)
        if (l.is(me.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let a = this.announceDOM.appendChild(document.createElement("div"));
          a.textContent = l.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(mr);
    let t = this.state.facet(me.cspNonce);
    el.mount(this.root, this.styleModules.concat(x$).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === t.key) {
            this.measureRequests[n] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let n = this.pluginMap.get(t);
    return (n === void 0 || n && n.spec != t) && this.pluginMap.set(t, n = this.plugins.find((i) => i.spec == t) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, n, i) {
    return $c(this, t, Q0(this, t, n, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, n) {
    return $c(this, t, Q0(this, t, n, (i) => HP(this, t.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, n) {
    let i = this.bidiSpans(t), l = this.textDirectionAt(t.from), a = i[n ? i.length - 1 : 0];
    return J.cursor(a.side(n, l) + t.from, a.forward(!n, l) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, n, i = !0) {
    return zP(this, t, n, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, n, i) {
    return $c(this, t, jP(this, t, n, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, n = 0) {
    return this.docView.posFromDOM(t, n);
  }
  posAtCoords(t, n = !0) {
    return this.readMeasured(), ov(this, t, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, n = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, n);
    if (!i || i.left == i.right)
      return i;
    let l = this.state.doc.lineAt(t), a = this.bidiSpans(l), r = a[Yi.find(a, t - l.from, -1, n)];
    return vs(i, r.dir == ot.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(K3) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > L$)
      return X3(t.length);
    let n = this.textDirectionAt(t.from), i;
    for (let a of this.bidiCache)
      if (a.from == t.from && a.dir == n && (a.fresh || j3(a.isolates, i = w0(this, t))))
        return a.order;
    i || (i = w0(this, t));
    let l = xP(t.text, n, i);
    return this.bidiCache.push(new Bo(t.from, t.to, n, i, !0, l)), l;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || Oe.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      $3(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, n = {}) {
    return Is.of(new Ca(typeof t == "number" ? J.cursor(t) : t, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: n } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t);
    return Is.of(new Ca(J.cursor(i.from), "start", "start", i.top - t, n, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return yt.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return yt.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, n) {
    let i = el.newName(), l = [js.of(i), mr.of(md(`.${i}`, t))];
    return n && n.dark && l.push(fd.of(!0)), l;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return cl.lowest(mr.of(md("." + hd, t, Cv)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var n;
    let i = t.querySelector(".cm-content"), l = i && Ke.get(i) || Ke.get(t);
    return ((n = l == null ? void 0 : l.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
me.styleModule = mr;
me.inputHandler = U3;
me.clipboardInputFilter = sh;
me.clipboardOutputFilter = oh;
me.scrollHandler = ev;
me.focusChangeEffect = G3;
me.perLineTextDirection = K3;
me.exceptionSink = W3;
me.updateListener = od;
me.editable = ji;
me.mouseSelectionStyle = F3;
me.dragMovesSelection = Y3;
me.clickAddsSelectionRange = q3;
me.decorations = jr;
me.outerDecorations = iv;
me.atomicRanges = ch;
me.bidiIsolatedRanges = lv;
me.scrollMargins = av;
me.darkTheme = fd;
me.cspNonce = /* @__PURE__ */ ve.define({ combine: (e) => e.length ? e[0] : "" });
me.contentAttributes = uh;
me.editorAttributes = nv;
me.lineWrapping = /* @__PURE__ */ me.contentAttributes.of({ class: "cm-lineWrapping" });
me.announce = /* @__PURE__ */ Le.define();
const L$ = 4096, Y0 = {};
class Bo {
  constructor(t, n, i, l, a, r) {
    this.from = t, this.to = n, this.dir = i, this.isolates = l, this.fresh = a, this.order = r;
  }
  static update(t, n) {
    if (n.empty && !t.some((a) => a.fresh))
      return t;
    let i = [], l = t.length ? t[t.length - 1].dir : ot.LTR;
    for (let a = Math.max(0, t.length - 10); a < t.length; a++) {
      let r = t[a];
      r.dir == l && !n.touchesRange(r.from, r.to) && i.push(new Bo(n.mapPos(r.from, 1), n.mapPos(r.to, -1), r.dir, r.isolates, !1, r.order));
    }
    return i;
  }
}
function F0(e, t, n) {
  for (let i = e.state.facet(t), l = i.length - 1; l >= 0; l--) {
    let a = i[l], r = typeof a == "function" ? a(e) : a;
    r && td(r, n);
  }
  return n;
}
const M$ = Oe.mac ? "mac" : Oe.windows ? "win" : Oe.linux ? "linux" : "key";
function T$(e, t) {
  const n = e.split(/-(?!$)/);
  let i = n[n.length - 1];
  i == "Space" && (i = " ");
  let l, a, r, s;
  for (let o = 0; o < n.length - 1; ++o) {
    const u = n[o];
    if (/^(cmd|meta|m)$/i.test(u))
      s = !0;
    else if (/^a(lt)?$/i.test(u))
      l = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      a = !0;
    else if (/^s(hift)?$/i.test(u))
      r = !0;
    else if (/^mod$/i.test(u))
      t == "mac" ? s = !0 : a = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return l && (i = "Alt-" + i), a && (i = "Ctrl-" + i), s && (i = "Meta-" + i), r && (i = "Shift-" + i), i;
}
function Xs(e, t, n) {
  return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n !== !1 && t.shiftKey && (e = "Shift-" + e), e;
}
const _$ = /* @__PURE__ */ cl.default(/* @__PURE__ */ me.domEventHandlers({
  keydown(e, t) {
    return wv(Sv(t.state), e, t, "editor");
  }
})), il = /* @__PURE__ */ ve.define({ enables: _$ }), W0 = /* @__PURE__ */ new WeakMap();
function Sv(e) {
  let t = e.facet(il), n = W0.get(t);
  return n || W0.set(t, n = Z$(t.reduce((i, l) => i.concat(l), []))), n;
}
function A$(e, t, n) {
  return wv(Sv(e.state), t, e, n);
}
let Xi = null;
const R$ = 4e3;
function Z$(e, t = M$) {
  let n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), l = (r, s) => {
    let o = i[r];
    if (o == null)
      i[r] = s;
    else if (o != s)
      throw new Error("Key binding " + r + " is used both as a regular binding and as a multi-stroke prefix");
  }, a = (r, s, o, u, c) => {
    var d, f;
    let h = n[r] || (n[r] = /* @__PURE__ */ Object.create(null)), g = s.split(/ (?!$)/).map((O) => T$(O, t));
    for (let O = 1; O < g.length; O++) {
      let b = g.slice(0, O).join(" ");
      l(b, !0), h[b] || (h[b] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(V) => {
          let $ = Xi = { view: V, prefix: b, scope: r };
          return setTimeout(() => {
            Xi == $ && (Xi = null);
          }, R$), !0;
        }]
      });
    }
    let v = g.join(" ");
    l(v, !1);
    let p = h[v] || (h[v] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (d = h._any) === null || d === void 0 ? void 0 : d.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    o && p.run.push(o), u && (p.preventDefault = !0), c && (p.stopPropagation = !0);
  };
  for (let r of e) {
    let s = r.scope ? r.scope.split(" ") : ["editor"];
    if (r.any)
      for (let u of s) {
        let c = n[u] || (n[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: d } = r;
        for (let f in c)
          c[f].run.push((h) => d(h, gd));
      }
    let o = r[t] || r.key;
    if (o)
      for (let u of s)
        a(u, o, r.run, r.preventDefault, r.stopPropagation), r.shift && a(u, "Shift-" + o, r.shift, r.preventDefault, r.stopPropagation);
  }
  return n;
}
let gd = null;
function wv(e, t, n, i) {
  gd = t;
  let l = sP(t), a = Ht(l, 0), r = Ln(a) == l.length && l != " ", s = "", o = !1, u = !1, c = !1;
  Xi && Xi.view == n && Xi.scope == i && (s = Xi.prefix + " ", dv.indexOf(t.keyCode) < 0 && (u = !0, Xi = null));
  let d = /* @__PURE__ */ new Set(), f = (p) => {
    if (p) {
      for (let O of p.run)
        if (!d.has(O) && (d.add(O), O(n)))
          return p.stopPropagation && (c = !0), !0;
      p.preventDefault && (p.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, h = e[i], g, v;
  return h && (f(h[s + Xs(l, t, !r)]) ? o = !0 : r && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Oe.windows && t.ctrlKey && t.altKey) && (g = tl[t.keyCode]) && g != l ? (f(h[s + Xs(g, t, !0)]) || t.shiftKey && (v = zr[t.keyCode]) != l && v != g && f(h[s + Xs(v, t, !1)])) && (o = !0) : r && t.shiftKey && f(h[s + Xs(l, t, !0)]) && (o = !0), !o && f(h._any) && (o = !0)), u && (o = !0), o && c && t.stopPropagation(), gd = null, o;
}
class ys {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(t, n, i, l, a) {
    this.className = t, this.left = n, this.top = i, this.width = l, this.height = a;
  }
  draw() {
    let t = document.createElement("div");
    return t.className = this.className, this.adjust(t), t;
  }
  update(t, n) {
    return n.className != this.className ? !1 : (this.adjust(t), !0);
  }
  adjust(t) {
    t.style.left = this.left + "px", t.style.top = this.top + "px", this.width != null && (t.style.width = this.width + "px"), t.style.height = this.height + "px";
  }
  eq(t) {
    return this.left == t.left && this.top == t.top && this.width == t.width && this.height == t.height && this.className == t.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(t, n, i) {
    if (i.empty) {
      let l = t.coordsAtPos(i.head, i.assoc || 1);
      if (!l)
        return [];
      let a = kv(t);
      return [new ys(n, l.left - a.left, l.top - a.top, null, l.bottom - l.top)];
    } else
      return I$(t, n, i);
  }
}
function kv(e) {
  let t = e.scrollDOM.getBoundingClientRect();
  return { left: (e.textDirection == ot.LTR ? t.left : t.right - e.scrollDOM.clientWidth * e.scaleX) - e.scrollDOM.scrollLeft * e.scaleX, top: t.top - e.scrollDOM.scrollTop * e.scaleY };
}
function U0(e, t, n, i) {
  let l = e.coordsAtPos(t, n * 2);
  if (!l)
    return i;
  let a = e.dom.getBoundingClientRect(), r = (l.top + l.bottom) / 2, s = e.posAtCoords({ x: a.left + 1, y: r }), o = e.posAtCoords({ x: a.right - 1, y: r });
  return s == null || o == null ? i : { from: Math.max(i.from, Math.min(s, o)), to: Math.min(i.to, Math.max(s, o)) };
}
function I$(e, t, n) {
  if (n.to <= e.viewport.from || n.from >= e.viewport.to)
    return [];
  let i = Math.max(n.from, e.viewport.from), l = Math.min(n.to, e.viewport.to), a = e.textDirection == ot.LTR, r = e.contentDOM, s = r.getBoundingClientRect(), o = kv(e), u = r.querySelector(".cm-line"), c = u && window.getComputedStyle(u), d = s.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), f = s.right - (c ? parseInt(c.paddingRight) : 0), h = cd(e, i), g = cd(e, l), v = h.type == cn.Text ? h : null, p = g.type == cn.Text ? g : null;
  if (v && (e.lineWrapping || h.widgetLineBreaks) && (v = U0(e, i, 1, v)), p && (e.lineWrapping || g.widgetLineBreaks) && (p = U0(e, l, -1, p)), v && p && v.from == p.from && v.to == p.to)
    return b(V(n.from, n.to, v));
  {
    let x = v ? V(n.from, null, v) : $(h, !1), Q = p ? V(null, n.to, p) : $(g, !0), M = [];
    return (v || h).to < (p || g).from - (v && p ? 1 : 0) || h.widgetLineBreaks > 1 && x.bottom + e.defaultLineHeight / 2 < Q.top ? M.push(O(d, x.bottom, f, Q.top)) : x.bottom < Q.top && e.elementAtHeight((x.bottom + Q.top) / 2).type == cn.Text && (x.bottom = Q.top = (x.bottom + Q.top) / 2), b(x).concat(M).concat(b(Q));
  }
  function O(x, Q, M, w) {
    return new ys(
      t,
      x - o.left,
      Q - o.top - 0.01,
      M - x,
      w - Q + 0.01
      /* C.Epsilon */
    );
  }
  function b({ top: x, bottom: Q, horizontal: M }) {
    let w = [];
    for (let y = 0; y < M.length; y += 2)
      w.push(O(M[y], x, M[y + 1], Q));
    return w;
  }
  function V(x, Q, M) {
    let w = 1e9, y = -1e9, L = [];
    function k(T, _, D, N, K) {
      let E = e.coordsAtPos(T, T == M.to ? -2 : 2), I = e.coordsAtPos(D, D == M.from ? 2 : -2);
      !E || !I || (w = Math.min(E.top, I.top, w), y = Math.max(E.bottom, I.bottom, y), K == ot.LTR ? L.push(a && _ ? d : E.left, a && N ? f : I.right) : L.push(!a && N ? d : I.left, !a && _ ? f : E.right));
    }
    let S = x ?? M.from, P = Q ?? M.to;
    for (let T of e.visibleRanges)
      if (T.to > S && T.from < P)
        for (let _ = Math.max(T.from, S), D = Math.min(T.to, P); ; ) {
          let N = e.state.doc.lineAt(_);
          for (let K of e.bidiSpans(N)) {
            let E = K.from + N.from, I = K.to + N.from;
            if (E >= D)
              break;
            I > _ && k(Math.max(E, _), x == null && E <= S, Math.min(I, D), Q == null && I >= P, K.dir);
          }
          if (_ = N.to + 1, _ >= D)
            break;
        }
    return L.length == 0 && k(S, x == null, P, Q == null, e.textDirection), { top: w, bottom: y, horizontal: L };
  }
  function $(x, Q) {
    let M = s.top + (Q ? x.top : x.bottom);
    return { top: M, bottom: M, horizontal: [] };
  }
}
function D$(e, t) {
  return e.constructor == t.constructor && e.eq(t);
}
class B$ {
  constructor(t, n) {
    this.view = t, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = t.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(t.state), t.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, t);
  }
  update(t) {
    t.startState.facet(ho) != t.state.facet(ho) && this.setOrder(t.state), (this.layer.update(t, this.dom) || t.geometryChanged) && (this.scale(), t.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(t) {
    this.layer.updateOnDocViewUpdate !== !1 && t.requestMeasure(this.measureReq);
  }
  setOrder(t) {
    let n = 0, i = t.facet(ho);
    for (; n < i.length && i[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: t, scaleY: n } = this.view;
    (t != this.scaleX || n != this.scaleY) && (this.scaleX = t, this.scaleY = n, this.dom.style.transform = `scale(${1 / t}, ${1 / n})`);
  }
  draw(t) {
    if (t.length != this.drawn.length || t.some((n, i) => !D$(n, this.drawn[i]))) {
      let n = this.dom.firstChild, i = 0;
      for (let l of t)
        l.update && n && l.constructor && this.drawn[i].constructor && l.update(n, this.drawn[i]) ? (n = n.nextSibling, i++) : this.dom.insertBefore(l.draw(), n);
      for (; n; ) {
        let l = n.nextSibling;
        n.remove(), n = l;
      }
      this.drawn = t;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const ho = /* @__PURE__ */ ve.define();
function xv(e) {
  return [
    yt.define((t) => new B$(t, e)),
    ho.of(e)
  ];
}
const Pv = !Oe.ios, Xr = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (t, n) => Math.min(t, n),
      drawRangeCursor: (t, n) => t || n
    });
  }
});
function $v(e = {}) {
  return [
    Xr.of(e),
    E$,
    z$,
    H$,
    J3.of(!0)
  ];
}
function Vv(e) {
  return e.startState.facet(Xr) != e.state.facet(Xr);
}
const E$ = /* @__PURE__ */ xv({
  above: !0,
  markers(e) {
    let { state: t } = e, n = t.facet(Xr), i = [];
    for (let l of t.selection.ranges) {
      let a = l == t.selection.main;
      if (l.empty ? !a || Pv : n.drawRangeCursor) {
        let r = a ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", s = l.empty ? l : J.cursor(l.head, l.head > l.anchor ? -1 : 1);
        for (let o of ys.forRange(e, r, s))
          i.push(o);
      }
    }
    return i;
  },
  update(e, t) {
    e.transactions.some((i) => i.selection) && (t.style.animationName = t.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = Vv(e);
    return n && G0(e.state, t), e.docChanged || e.selectionSet || n;
  },
  mount(e, t) {
    G0(t.state, e);
  },
  class: "cm-cursorLayer"
});
function G0(e, t) {
  t.style.animationDuration = e.facet(Xr).cursorBlinkRate + "ms";
}
const z$ = /* @__PURE__ */ xv({
  above: !1,
  markers(e) {
    return e.state.selection.ranges.map((t) => t.empty ? [] : ys.forRange(e, "cm-selectionBackground", t)).reduce((t, n) => t.concat(n));
  },
  update(e, t) {
    return e.docChanged || e.selectionSet || e.viewportChanged || Vv(e);
  },
  class: "cm-selectionLayer"
}), vd = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
Pv && (vd[".cm-line"].caretColor = vd[".cm-content"].caretColor = "transparent !important");
const H$ = /* @__PURE__ */ cl.highest(/* @__PURE__ */ me.theme(vd)), Qv = /* @__PURE__ */ Le.define({
  map(e, t) {
    return e == null ? null : t.mapPos(e);
  }
}), pr = /* @__PURE__ */ Mt.define({
  create() {
    return null;
  },
  update(e, t) {
    return e != null && (e = t.changes.mapPos(e)), t.effects.reduce((n, i) => i.is(Qv) ? i.value : n, e);
  }
}), j$ = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.view = e, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(e) {
    var t;
    let n = e.state.field(pr);
    n == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (e.startState.field(pr) != n || e.docChanged || e.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: e } = this, t = e.state.field(pr), n = t != null && e.coordsAtPos(t);
    if (!n)
      return null;
    let i = e.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - i.left + e.scrollDOM.scrollLeft * e.scaleX,
      top: n.top - i.top + e.scrollDOM.scrollTop * e.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(e) {
    if (this.cursor) {
      let { scaleX: t, scaleY: n } = this.view;
      e ? (this.cursor.style.left = e.left / t + "px", this.cursor.style.top = e.top / n + "px", this.cursor.style.height = e.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(e) {
    this.view.state.field(pr) != e && this.view.dispatch({ effects: Qv.of(e) });
  }
}, {
  eventObservers: {
    dragover(e) {
      this.setDropPos(this.view.posAtCoords({ x: e.clientX, y: e.clientY }));
    },
    dragleave(e) {
      (e.target == this.view.contentDOM || !this.view.contentDOM.contains(e.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function X$() {
  return [pr, j$];
}
function K0(e, t, n, i, l) {
  t.lastIndex = 0;
  for (let a = e.iterRange(n, i), r = n, s; !a.next().done; r += a.value.length)
    if (!a.lineBreak)
      for (; s = t.exec(a.value); )
        l(r + s.index, s);
}
function N$(e, t) {
  let n = e.visibleRanges;
  if (n.length == 1 && n[0].from == e.viewport.from && n[0].to == e.viewport.to)
    return n;
  let i = [];
  for (let { from: l, to: a } of n)
    l = Math.max(e.state.doc.lineAt(l).from, l - t), a = Math.min(e.state.doc.lineAt(a).to, a + t), i.length && i[i.length - 1].to >= l ? i[i.length - 1].to = a : i.push({ from: l, to: a });
  return i;
}
class q$ {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: n, decoration: i, decorate: l, boundary: a, maxLength: r = 1e3 } = t;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, l)
      this.addMatch = (s, o, u, c) => l(c, u, u + s[0].length, s, o);
    else if (typeof i == "function")
      this.addMatch = (s, o, u, c) => {
        let d = i(s, o, u);
        d && c(u, u + s[0].length, d);
      };
    else if (i)
      this.addMatch = (s, o, u, c) => c(u, u + s[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = a, this.maxLength = r;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let n = new Ji(), i = n.add.bind(n);
    for (let { from: l, to: a } of N$(t, this.maxLength))
      K0(t.state.doc, this.regexp, l, a, (r, s) => this.addMatch(s, t, r, i));
    return n.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, n) {
    let i = 1e9, l = -1;
    return t.docChanged && t.changes.iterChanges((a, r, s, o) => {
      o > t.view.viewport.from && s < t.view.viewport.to && (i = Math.min(s, i), l = Math.max(o, l));
    }), t.viewportChanged || l - i > 1e3 ? this.createDeco(t.view) : l > -1 ? this.updateRange(t.view, n.map(t.changes), i, l) : n;
  }
  updateRange(t, n, i, l) {
    for (let a of t.visibleRanges) {
      let r = Math.max(a.from, i), s = Math.min(a.to, l);
      if (s > r) {
        let o = t.state.doc.lineAt(r), u = o.to < s ? t.state.doc.lineAt(s) : o, c = Math.max(a.from, o.from), d = Math.min(a.to, u.to);
        if (this.boundary) {
          for (; r > o.from; r--)
            if (this.boundary.test(o.text[r - 1 - o.from])) {
              c = r;
              break;
            }
          for (; s < u.to; s++)
            if (this.boundary.test(u.text[s - u.from])) {
              d = s;
              break;
            }
        }
        let f = [], h, g = (v, p, O) => f.push(O.range(v, p));
        if (o == u)
          for (this.regexp.lastIndex = c - o.from; (h = this.regexp.exec(o.text)) && h.index < d - o.from; )
            this.addMatch(h, t, h.index + o.from, g);
        else
          K0(t.state.doc, this.regexp, c, d, (v, p) => this.addMatch(p, t, v, g));
        n = n.update({ filterFrom: c, filterTo: d, filter: (v, p) => v < c || p > d, add: f });
      }
    }
    return n;
  }
}
const pd = /x/.unicode != null ? "gu" : "g", Y$ = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, pd), F$ = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Lc = null;
function W$() {
  var e;
  if (Lc == null && typeof document < "u" && document.body) {
    let t = document.body.style;
    Lc = ((e = t.tabSize) !== null && e !== void 0 ? e : t.MozTabSize) != null;
  }
  return Lc || !1;
}
const mo = /* @__PURE__ */ ve.define({
  combine(e) {
    let t = Kn(e, {
      render: null,
      specialChars: Y$,
      addSpecialChars: null
    });
    return (t.replaceTabs = !W$()) && (t.specialChars = new RegExp("	|" + t.specialChars.source, pd)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, pd)), t;
  }
});
function Lv(e = {}) {
  return [mo.of(e), U$()];
}
let J0 = null;
function U$() {
  return J0 || (J0 = yt.fromClass(class {
    constructor(e) {
      this.view = e, this.decorations = Ce.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(e.state.facet(mo)), this.decorations = this.decorator.createDeco(e);
    }
    makeDecorator(e) {
      return new q$({
        regexp: e.specialChars,
        decoration: (t, n, i) => {
          let { doc: l } = n.state, a = Ht(t[0], 0);
          if (a == 9) {
            let r = l.lineAt(i), s = n.state.tabSize, o = Ga(r.text, s, i - r.from);
            return Ce.replace({
              widget: new eV((s - o % s) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[a] || (this.decorationCache[a] = Ce.replace({ widget: new J$(e, a) }));
        },
        boundary: e.replaceTabs ? void 0 : /[^]/
      });
    }
    update(e) {
      let t = e.state.facet(mo);
      e.startState.facet(mo) != t ? (this.decorator = this.makeDecorator(t), this.decorations = this.decorator.createDeco(e.view)) : this.decorations = this.decorator.updateDeco(e, this.decorations);
    }
  }, {
    decorations: (e) => e.decorations
  }));
}
const G$ = "";
function K$(e) {
  return e >= 32 ? G$ : e == 10 ? "" : String.fromCharCode(9216 + e);
}
class J$ extends bi {
  constructor(t, n) {
    super(), this.options = t, this.code = n;
  }
  eq(t) {
    return t.code == this.code;
  }
  toDOM(t) {
    let n = K$(this.code), i = t.state.phrase("Control character") + " " + (F$[this.code] || "0x" + this.code.toString(16)), l = this.options.render && this.options.render(this.code, i, n);
    if (l)
      return l;
    let a = document.createElement("span");
    return a.textContent = n, a.title = i, a.setAttribute("aria-label", i), a.className = "cm-specialChar", a;
  }
  ignoreEvent() {
    return !1;
  }
}
class eV extends bi {
  constructor(t) {
    super(), this.width = t;
  }
  eq(t) {
    return t.width == this.width;
  }
  toDOM() {
    let t = document.createElement("span");
    return t.textContent = "	", t.className = "cm-tab", t.style.width = this.width + "px", t;
  }
  ignoreEvent() {
    return !1;
  }
}
function tV() {
  return iV;
}
const nV = /* @__PURE__ */ Ce.line({ class: "cm-activeLine" }), iV = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.decorations = this.getDeco(e);
  }
  update(e) {
    (e.docChanged || e.selectionSet) && (this.decorations = this.getDeco(e.view));
  }
  getDeco(e) {
    let t = -1, n = [];
    for (let i of e.state.selection.ranges) {
      let l = e.lineBlockAt(i.head);
      l.from > t && (n.push(nV.range(l.from)), t = l.from);
    }
    return Ce.set(n);
  }
}, {
  decorations: (e) => e.decorations
});
class lV extends bi {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM(t) {
    let n = document.createElement("span");
    return n.className = "cm-placeholder", n.style.pointerEvents = "none", n.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(t) : this.content.cloneNode(!0)), typeof this.content == "string" ? n.setAttribute("aria-label", "placeholder " + this.content) : n.setAttribute("aria-hidden", "true"), n;
  }
  coordsAt(t) {
    let n = t.firstChild ? _a(t.firstChild) : [];
    if (!n.length)
      return null;
    let i = window.getComputedStyle(t.parentNode), l = vs(n[0], i.direction != "rtl"), a = parseInt(i.lineHeight);
    return l.bottom - l.top > a * 1.5 ? { left: l.left, right: l.right, top: l.top, bottom: l.top + a } : l;
  }
  ignoreEvent() {
    return !1;
  }
}
function aV(e) {
  return yt.fromClass(class {
    constructor(t) {
      this.view = t, this.placeholder = e ? Ce.set([Ce.widget({ widget: new lV(e), side: 1 }).range(0)]) : Ce.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Ce.none : this.placeholder;
    }
  }, { decorations: (t) => t.decorations });
}
const Od = 2e3;
function rV(e, t, n) {
  let i = Math.min(t.line, n.line), l = Math.max(t.line, n.line), a = [];
  if (t.off > Od || n.off > Od || t.col < 0 || n.col < 0) {
    let r = Math.min(t.off, n.off), s = Math.max(t.off, n.off);
    for (let o = i; o <= l; o++) {
      let u = e.doc.line(o);
      u.length <= s && a.push(J.range(u.from + r, u.to + s));
    }
  } else {
    let r = Math.min(t.col, n.col), s = Math.max(t.col, n.col);
    for (let o = i; o <= l; o++) {
      let u = e.doc.line(o), c = F1(u.text, r, e.tabSize, !0);
      if (c < 0)
        a.push(J.cursor(u.to));
      else {
        let d = F1(u.text, s, e.tabSize);
        a.push(J.range(u.from + c, u.from + d));
      }
    }
  }
  return a;
}
function sV(e, t) {
  let n = e.coordsAtPos(e.viewport.from);
  return n ? Math.round(Math.abs((n.left - t) / e.defaultCharacterWidth)) : -1;
}
function em(e, t) {
  let n = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1), i = e.state.doc.lineAt(n), l = n - i.from, a = l > Od ? -1 : l == i.length ? sV(e, t.clientX) : Ga(i.text, e.state.tabSize, n - i.from);
  return { line: i.number, col: a, off: l };
}
function oV(e, t) {
  let n = em(e, t), i = e.state.selection;
  return n ? {
    update(l) {
      if (l.docChanged) {
        let a = l.changes.mapPos(l.startState.doc.line(n.line).from), r = l.state.doc.lineAt(a);
        n = { line: r.number, col: n.col, off: Math.min(n.off, r.length) }, i = i.map(l.changes);
      }
    },
    get(l, a, r) {
      let s = em(e, l);
      if (!s)
        return i;
      let o = rV(e.state, n, s);
      return o.length ? r ? J.create(o.concat(i.ranges)) : J.create(o) : i;
    }
  } : null;
}
function uV(e) {
  let t = (n) => n.altKey && n.button == 0;
  return me.mouseSelectionStyle.of((n, i) => t(i) ? oV(n, i) : null);
}
const cV = {
  Alt: [18, (e) => !!e.altKey],
  Control: [17, (e) => !!e.ctrlKey],
  Shift: [16, (e) => !!e.shiftKey],
  Meta: [91, (e) => !!e.metaKey]
}, dV = { style: "cursor: crosshair" };
function fV(e = {}) {
  let [t, n] = cV[e.key || "Alt"], i = yt.fromClass(class {
    constructor(l) {
      this.view = l, this.isDown = !1;
    }
    set(l) {
      this.isDown != l && (this.isDown = l, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(l) {
        this.set(l.keyCode == t || n(l));
      },
      keyup(l) {
        (l.keyCode == t || !n(l)) && this.set(!1);
      },
      mousemove(l) {
        this.set(n(l));
      }
    }
  });
  return [
    i,
    me.contentAttributes.of((l) => {
      var a;
      return !((a = l.plugin(i)) === null || a === void 0) && a.isDown ? dV : null;
    })
  ];
}
const rr = "-10000px";
class Mv {
  constructor(t, n, i, l) {
    this.facet = n, this.createTooltipView = i, this.removeTooltipView = l, this.input = t.state.facet(n), this.tooltips = this.input.filter((r) => r);
    let a = null;
    this.tooltipViews = this.tooltips.map((r) => a = i(r, a));
  }
  update(t, n) {
    var i;
    let l = t.state.facet(this.facet), a = l.filter((o) => o);
    if (l === this.input) {
      for (let o of this.tooltipViews)
        o.update && o.update(t);
      return !1;
    }
    let r = [], s = n ? [] : null;
    for (let o = 0; o < a.length; o++) {
      let u = a[o], c = -1;
      if (u) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let f = this.tooltips[d];
          f && f.create == u.create && (c = d);
        }
        if (c < 0)
          r[o] = this.createTooltipView(u, o ? r[o - 1] : null), s && (s[o] = !!u.above);
        else {
          let d = r[o] = this.tooltipViews[c];
          s && (s[o] = n[c]), d.update && d.update(t);
        }
      }
    }
    for (let o of this.tooltipViews)
      r.indexOf(o) < 0 && (this.removeTooltipView(o), (i = o.destroy) === null || i === void 0 || i.call(o));
    return n && (s.forEach((o, u) => n[u] = o), n.length = s.length), this.input = l, this.tooltips = a, this.tooltipViews = r, !0;
  }
}
function hV(e) {
  let { win: t } = e;
  return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth };
}
const Mc = /* @__PURE__ */ ve.define({
  combine: (e) => {
    var t, n, i;
    return {
      position: Oe.ios ? "absolute" : ((t = e.find((l) => l.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((n = e.find((l) => l.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((i = e.find((l) => l.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || hV
    };
  }
}), tm = /* @__PURE__ */ new WeakMap(), mh = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.view = e, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = e.state.facet(Mc);
    this.position = t.position, this.parent = t.parent, this.classes = e.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new Mv(e, Yu, (n, i) => this.createTooltip(n, i), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), e.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let e of this.manager.tooltipViews)
        this.intersectionObserver.observe(e.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(e) {
    e.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(e, this.above);
    t && this.observeIntersection();
    let n = t || e.geometryChanged, i = e.state.facet(Mc);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = this.position;
      n = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let l of this.manager.tooltipViews)
        this.container.appendChild(l.dom);
      n = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(e, t) {
    let n = e.create(this.view), i = t ? t.dom : null;
    if (n.dom.classList.add("cm-tooltip"), e.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let l = document.createElement("div");
      l.className = "cm-tooltip-arrow", n.dom.appendChild(l);
    }
    return n.dom.style.position = this.position, n.dom.style.top = rr, n.dom.style.left = "0px", this.container.insertBefore(n.dom, i), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var e, t, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (e = i.destroy) === null || e === void 0 || e.call(i);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let e = this.view.dom.getBoundingClientRect(), t = 1, n = 1, i = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: l } = this.manager.tooltipViews[0];
      if (Oe.gecko)
        i = l.offsetParent != this.container.ownerDocument.body;
      else if (l.style.top == rr && l.style.left == "0px") {
        let a = l.getBoundingClientRect();
        i = Math.abs(a.top + 1e4) > 1 || Math.abs(a.left) > 1;
      }
    }
    if (i || this.position == "absolute")
      if (this.parent) {
        let l = this.parent.getBoundingClientRect();
        l.width && l.height && (t = l.width / this.parent.offsetWidth, n = l.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: n } = this.view.viewState);
    return {
      editor: e,
      parent: this.parent ? this.container.getBoundingClientRect() : e,
      pos: this.manager.tooltips.map((l, a) => {
        let r = this.manager.tooltipViews[a];
        return r.getCoords ? r.getCoords(l.pos) : this.view.coordsAtPos(l.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: l }) => l.getBoundingClientRect()),
      space: this.view.state.facet(Mc).tooltipSpace(this.view),
      scaleX: t,
      scaleY: n,
      makeAbsolute: i
    };
  }
  writeMeasure(e) {
    var t;
    if (e.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = "absolute";
    }
    let { editor: n, space: i, scaleX: l, scaleY: a } = e, r = [];
    for (let s = 0; s < this.manager.tooltips.length; s++) {
      let o = this.manager.tooltips[s], u = this.manager.tooltipViews[s], { dom: c } = u, d = e.pos[s], f = e.size[s];
      if (!d || d.bottom <= Math.max(n.top, i.top) || d.top >= Math.min(n.bottom, i.bottom) || d.right < Math.max(n.left, i.left) - 0.1 || d.left > Math.min(n.right, i.right) + 0.1) {
        c.style.top = rr;
        continue;
      }
      let h = o.arrow ? u.dom.querySelector(".cm-tooltip-arrow") : null, g = h ? 7 : 0, v = f.right - f.left, p = (t = tm.get(u)) !== null && t !== void 0 ? t : f.bottom - f.top, O = u.offset || gV, b = this.view.textDirection == ot.LTR, V = f.width > i.right - i.left ? b ? i.left : i.right - f.width : b ? Math.max(i.left, Math.min(d.left - (h ? 14 : 0) + O.x, i.right - v)) : Math.min(Math.max(i.left, d.left - v + (h ? 14 : 0) - O.x), i.right - v), $ = this.above[s];
      !o.strictSide && ($ ? d.top - (f.bottom - f.top) - O.y < i.top : d.bottom + (f.bottom - f.top) + O.y > i.bottom) && $ == i.bottom - d.bottom > d.top - i.top && ($ = this.above[s] = !$);
      let x = ($ ? d.top - i.top : i.bottom - d.bottom) - g;
      if (x < p && u.resize !== !1) {
        if (x < this.view.defaultLineHeight) {
          c.style.top = rr;
          continue;
        }
        tm.set(u, p), c.style.height = (p = x) / a + "px";
      } else c.style.height && (c.style.height = "");
      let Q = $ ? d.top - p - g - O.y : d.bottom + g + O.y, M = V + v;
      if (u.overlap !== !0)
        for (let w of r)
          w.left < M && w.right > V && w.top < Q + p && w.bottom > Q && (Q = $ ? w.top - p - 2 - g : w.bottom + g + 2);
      if (this.position == "absolute" ? (c.style.top = (Q - e.parent.top) / a + "px", c.style.left = (V - e.parent.left) / l + "px") : (c.style.top = Q / a + "px", c.style.left = V / l + "px"), h) {
        let w = d.left + (b ? O.x : -O.x) - (V + 14 - 7);
        h.style.left = w / l + "px";
      }
      u.overlap !== !0 && r.push({ left: V, top: Q, right: M, bottom: Q + p }), c.classList.toggle("cm-tooltip-above", $), c.classList.toggle("cm-tooltip-below", !$), u.positioned && u.positioned(e.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let e of this.manager.tooltipViews)
        e.dom.style.top = rr;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), mV = /* @__PURE__ */ me.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), gV = { x: 0, y: 0 }, Yu = /* @__PURE__ */ ve.define({
  enables: [mh, mV]
}), Eo = /* @__PURE__ */ ve.define({
  combine: (e) => e.reduce((t, n) => t.concat(n), [])
});
class Fu {
  // Needs to be static so that host tooltip instances always match
  static create(t) {
    return new Fu(t);
  }
  constructor(t) {
    this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Mv(t, Eo, (n, i) => this.createHostedView(n, i), (n) => n.dom.remove());
  }
  createHostedView(t, n) {
    let i = t.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(t) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(t);
    this.mounted = !0;
  }
  positioned(t) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(t);
  }
  update(t) {
    this.manager.update(t);
  }
  destroy() {
    var t;
    for (let n of this.manager.tooltipViews)
      (t = n.destroy) === null || t === void 0 || t.call(n);
  }
  passProp(t) {
    let n;
    for (let i of this.manager.tooltipViews) {
      let l = i[t];
      if (l !== void 0) {
        if (n === void 0)
          n = l;
        else if (n !== l)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const vV = /* @__PURE__ */ Yu.compute([Eo], (e) => {
  let t = e.facet(Eo);
  return t.length === 0 ? null : {
    pos: Math.min(...t.map((n) => n.pos)),
    end: Math.max(...t.map((n) => {
      var i;
      return (i = n.end) !== null && i !== void 0 ? i : n.pos;
    })),
    create: Fu.create,
    above: t[0].above,
    arrow: t.some((n) => n.arrow)
  };
});
class pV {
  constructor(t, n, i, l, a) {
    this.view = t, this.source = n, this.field = i, this.setHover = l, this.hoverTime = a, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let t = Date.now() - this.lastMove.time;
    t < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: t, lastMove: n } = this, i = t.docView.nearest(n.target);
    if (!i)
      return;
    let l, a = 1;
    if (i instanceof qi)
      l = i.posAtStart;
    else {
      if (l = t.posAtCoords(n), l == null)
        return;
      let s = t.coordsAtPos(l);
      if (!s || n.y < s.top || n.y > s.bottom || n.x < s.left - t.defaultCharacterWidth || n.x > s.right + t.defaultCharacterWidth)
        return;
      let o = t.bidiSpans(t.state.doc.lineAt(l)).find((c) => c.from <= l && c.to >= l), u = o && o.dir == ot.RTL ? -1 : 1;
      a = n.x < s.left ? -u : u;
    }
    let r = this.source(t, l, a);
    if (r != null && r.then) {
      let s = this.pending = { pos: l };
      r.then((o) => {
        this.pending == s && (this.pending = null, o && !(Array.isArray(o) && !o.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) }));
      }, (o) => sn(t.state, o, "hover tooltip"));
    } else r && !(Array.isArray(r) && !r.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(r) ? r : [r]) });
  }
  get tooltip() {
    let t = this.view.plugin(mh), n = t ? t.manager.tooltips.findIndex((i) => i.create == Fu.create) : -1;
    return n > -1 ? t.manager.tooltipViews[n] : null;
  }
  mousemove(t) {
    var n, i;
    this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: l, tooltip: a } = this;
    if (l.length && a && !OV(a.dom, t) || this.pending) {
      let { pos: r } = l[0] || this.pending, s = (i = (n = l[0]) === null || n === void 0 ? void 0 : n.end) !== null && i !== void 0 ? i : r;
      (r == s ? this.view.posAtCoords(this.lastMove) != r : !yV(this.view, r, s, t.clientX, t.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(t) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(t.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(t) {
    let n = (i) => {
      t.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    t.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Ns = 4;
function OV(e, t) {
  let { left: n, right: i, top: l, bottom: a } = e.getBoundingClientRect(), r;
  if (r = e.querySelector(".cm-tooltip-arrow")) {
    let s = r.getBoundingClientRect();
    l = Math.min(s.top, l), a = Math.max(s.bottom, a);
  }
  return t.clientX >= n - Ns && t.clientX <= i + Ns && t.clientY >= l - Ns && t.clientY <= a + Ns;
}
function yV(e, t, n, i, l, a) {
  let r = e.scrollDOM.getBoundingClientRect(), s = e.documentTop + e.documentPadding.top + e.contentHeight;
  if (r.left > i || r.right < i || r.top > l || Math.min(r.bottom, s) < l)
    return !1;
  let o = e.posAtCoords({ x: i, y: l }, !1);
  return o >= t && o <= n;
}
function bV(e, t = {}) {
  let n = Le.define(), i = Mt.define({
    create() {
      return [];
    },
    update(l, a) {
      if (l.length && (t.hideOnChange && (a.docChanged || a.selection) ? l = [] : t.hideOn && (l = l.filter((r) => !t.hideOn(a, r))), a.docChanged)) {
        let r = [];
        for (let s of l) {
          let o = a.changes.mapPos(s.pos, -1, Nt.TrackDel);
          if (o != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), s);
            u.pos = o, u.end != null && (u.end = a.changes.mapPos(u.end)), r.push(u);
          }
        }
        l = r;
      }
      for (let r of a.effects)
        r.is(n) && (l = r.value), r.is(CV) && (l = []);
      return l;
    },
    provide: (l) => Eo.from(l)
  });
  return {
    active: i,
    extension: [
      i,
      yt.define((l) => new pV(
        l,
        e,
        i,
        n,
        t.hoverTime || 300
        /* Hover.Time */
      )),
      vV
    ]
  };
}
function Tv(e, t) {
  let n = e.plugin(mh);
  if (!n)
    return null;
  let i = n.manager.tooltips.indexOf(t);
  return i < 0 ? null : n.manager.tooltipViews[i];
}
const CV = /* @__PURE__ */ Le.define(), nm = /* @__PURE__ */ ve.define({
  combine(e) {
    let t, n;
    for (let i of e)
      t = t || i.topContainer, n = n || i.bottomContainer;
    return { topContainer: t, bottomContainer: n };
  }
});
function Nr(e, t) {
  let n = e.plugin(_v), i = n ? n.specs.indexOf(t) : -1;
  return i > -1 ? n.panels[i] : null;
}
const _v = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.input = e.state.facet(qr), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(e));
    let t = e.state.facet(nm);
    this.top = new qs(e, !0, t.topContainer), this.bottom = new qs(e, !1, t.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(e) {
    let t = e.state.facet(nm);
    this.top.container != t.topContainer && (this.top.sync([]), this.top = new qs(e.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new qs(e.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = e.state.facet(qr);
    if (n != this.input) {
      let i = n.filter((o) => o), l = [], a = [], r = [], s = [];
      for (let o of i) {
        let u = this.specs.indexOf(o), c;
        u < 0 ? (c = o(e.view), s.push(c)) : (c = this.panels[u], c.update && c.update(e)), l.push(c), (c.top ? a : r).push(c);
      }
      this.specs = i, this.panels = l, this.top.sync(a), this.bottom.sync(r);
      for (let o of s)
        o.dom.classList.add("cm-panel"), o.mount && o.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(e);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (e) => me.scrollMargins.of((t) => {
    let n = t.plugin(e);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class qs {
  constructor(t, n, i) {
    this.view = t, this.top = n, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(t) {
    for (let n of this.panels)
      n.destroy && t.indexOf(n) < 0 && n.destroy();
    this.panels = t, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let t = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; t != n.dom; )
          t = im(t);
        t = t.nextSibling;
      } else
        this.dom.insertBefore(n.dom, t);
    for (; t; )
      t = im(t);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let t of this.classes.split(" "))
        t && this.container.classList.remove(t);
      for (let t of (this.classes = this.view.themeClasses).split(" "))
        t && this.container.classList.add(t);
    }
  }
}
function im(e) {
  let t = e.nextSibling;
  return e.remove(), t;
}
const qr = /* @__PURE__ */ ve.define({
  enables: _v
});
class gi extends Bl {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}
gi.prototype.elementClass = "";
gi.prototype.toDOM = void 0;
gi.prototype.mapMode = Nt.TrackBefore;
gi.prototype.startSide = gi.prototype.endSide = -1;
gi.prototype.point = !0;
const go = /* @__PURE__ */ ve.define(), SV = /* @__PURE__ */ ve.define(), wV = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Ee.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, wr = /* @__PURE__ */ ve.define();
function Av(e) {
  return [Rv(), wr.of(Object.assign(Object.assign({}, wV), e))];
}
const lm = /* @__PURE__ */ ve.define({
  combine: (e) => e.some((t) => t)
});
function Rv(e) {
  return [
    kV
  ];
}
const kV = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.view = e, this.prevViewport = e.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = e.state.facet(wr).map((t) => new rm(e, t));
    for (let t of this.gutters)
      this.dom.appendChild(t.dom);
    this.fixed = !e.state.facet(lm), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), e.scrollDOM.insertBefore(this.dom, e.contentDOM);
  }
  update(e) {
    if (this.updateGutters(e)) {
      let t = this.prevViewport, n = e.view.viewport, i = Math.min(t.to, n.to) - Math.max(t.from, n.from);
      this.syncGutters(i < (n.to - n.from) * 0.8);
    }
    e.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(lm) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = e.view.viewport;
  }
  syncGutters(e) {
    let t = this.dom.nextSibling;
    e && this.dom.remove();
    let n = Ee.iter(this.view.state.facet(go), this.view.viewport.from), i = [], l = this.gutters.map((a) => new xV(a, this.view.viewport, -this.view.documentPadding.top));
    for (let a of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(a.type)) {
        let r = !0;
        for (let s of a.type)
          if (s.type == cn.Text && r) {
            yd(n, i, s.from);
            for (let o of l)
              o.line(this.view, s, i);
            r = !1;
          } else if (s.widget)
            for (let o of l)
              o.widget(this.view, s);
      } else if (a.type == cn.Text) {
        yd(n, i, a.from);
        for (let r of l)
          r.line(this.view, a, i);
      } else if (a.widget)
        for (let r of l)
          r.widget(this.view, a);
    for (let a of l)
      a.finish();
    e && this.view.scrollDOM.insertBefore(this.dom, t);
  }
  updateGutters(e) {
    let t = e.startState.facet(wr), n = e.state.facet(wr), i = e.docChanged || e.heightChanged || e.viewportChanged || !Ee.eq(e.startState.facet(go), e.state.facet(go), e.view.viewport.from, e.view.viewport.to);
    if (t == n)
      for (let l of this.gutters)
        l.update(e) && (i = !0);
    else {
      i = !0;
      let l = [];
      for (let a of n) {
        let r = t.indexOf(a);
        r < 0 ? l.push(new rm(this.view, a)) : (this.gutters[r].update(e), l.push(this.gutters[r]));
      }
      for (let a of this.gutters)
        a.dom.remove(), l.indexOf(a) < 0 && a.destroy();
      for (let a of l)
        this.dom.appendChild(a.dom);
      this.gutters = l;
    }
    return i;
  }
  destroy() {
    for (let e of this.gutters)
      e.destroy();
    this.dom.remove();
  }
}, {
  provide: (e) => me.scrollMargins.of((t) => {
    let n = t.plugin(e);
    return !n || n.gutters.length == 0 || !n.fixed ? null : t.textDirection == ot.LTR ? { left: n.dom.offsetWidth * t.scaleX } : { right: n.dom.offsetWidth * t.scaleX };
  })
});
function am(e) {
  return Array.isArray(e) ? e : [e];
}
function yd(e, t, n) {
  for (; e.value && e.from <= n; )
    e.from == n && t.push(e.value), e.next();
}
class xV {
  constructor(t, n, i) {
    this.gutter = t, this.height = i, this.i = 0, this.cursor = Ee.iter(t.markers, n.from);
  }
  addElement(t, n, i) {
    let { gutter: l } = this, a = (n.top - this.height) / t.scaleY, r = n.height / t.scaleY;
    if (this.i == l.elements.length) {
      let s = new Zv(t, r, a, i);
      l.elements.push(s), l.dom.appendChild(s.dom);
    } else
      l.elements[this.i].update(t, r, a, i);
    this.height = n.bottom, this.i++;
  }
  line(t, n, i) {
    let l = [];
    yd(this.cursor, l, n.from), i.length && (l = l.concat(i));
    let a = this.gutter.config.lineMarker(t, n, l);
    a && l.unshift(a);
    let r = this.gutter;
    l.length == 0 && !r.config.renderEmptyElements || this.addElement(t, n, l);
  }
  widget(t, n) {
    let i = this.gutter.config.widgetMarker(t, n.widget, n), l = i ? [i] : null;
    for (let a of t.state.facet(SV)) {
      let r = a(t, n.widget, n);
      r && (l || (l = [])).push(r);
    }
    l && this.addElement(t, n, l);
  }
  finish() {
    let t = this.gutter;
    for (; t.elements.length > this.i; ) {
      let n = t.elements.pop();
      t.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class rm {
  constructor(t, n) {
    this.view = t, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in n.domEventHandlers)
      this.dom.addEventListener(i, (l) => {
        let a = l.target, r;
        if (a != this.dom && this.dom.contains(a)) {
          for (; a.parentNode != this.dom; )
            a = a.parentNode;
          let o = a.getBoundingClientRect();
          r = (o.top + o.bottom) / 2;
        } else
          r = l.clientY;
        let s = t.lineBlockAtHeight(r - t.documentTop);
        n.domEventHandlers[i](t, s, l) && l.preventDefault();
      });
    this.markers = am(n.markers(t)), n.initialSpacer && (this.spacer = new Zv(t, 0, 0, [n.initialSpacer(t)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t) {
    let n = this.markers;
    if (this.markers = am(this.config.markers(t.view)), this.spacer && this.config.updateSpacer) {
      let l = this.config.updateSpacer(this.spacer.markers[0], t);
      l != this.spacer.markers[0] && this.spacer.update(t.view, 0, 0, [l]);
    }
    let i = t.view.viewport;
    return !Ee.eq(this.markers, n, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(t) : !1);
  }
  destroy() {
    for (let t of this.elements)
      t.destroy();
  }
}
class Zv {
  constructor(t, n, i, l) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t, n, i, l);
  }
  update(t, n, i, l) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), PV(this.markers, l) || this.setMarkers(t, l);
  }
  setMarkers(t, n) {
    let i = "cm-gutterElement", l = this.dom.firstChild;
    for (let a = 0, r = 0; ; ) {
      let s = r, o = a < n.length ? n[a++] : null, u = !1;
      if (o) {
        let c = o.elementClass;
        c && (i += " " + c);
        for (let d = r; d < this.markers.length; d++)
          if (this.markers[d].compare(o)) {
            s = d, u = !0;
            break;
          }
      } else
        s = this.markers.length;
      for (; r < s; ) {
        let c = this.markers[r++];
        if (c.toDOM) {
          c.destroy(l);
          let d = l.nextSibling;
          l.remove(), l = d;
        }
      }
      if (!o)
        break;
      o.toDOM && (u ? l = l.nextSibling : this.dom.insertBefore(o.toDOM(t), l)), u && r++;
    }
    this.dom.className = i, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function PV(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!e[n].compare(t[n]))
      return !1;
  return !0;
}
const $V = /* @__PURE__ */ ve.define(), VV = /* @__PURE__ */ ve.define(), ga = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(t, n) {
        let i = Object.assign({}, t);
        for (let l in n) {
          let a = i[l], r = n[l];
          i[l] = a ? (s, o, u) => a(s, o, u) || r(s, o, u) : r;
        }
        return i;
      }
    });
  }
});
class Tc extends gi {
  constructor(t) {
    super(), this.number = t;
  }
  eq(t) {
    return this.number == t.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function _c(e, t) {
  return e.state.facet(ga).formatNumber(t, e.state);
}
const QV = /* @__PURE__ */ wr.compute([ga], (e) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(t) {
    return t.state.facet($V);
  },
  lineMarker(t, n, i) {
    return i.some((l) => l.toDOM) ? null : new Tc(_c(t, t.state.doc.lineAt(n.from).number));
  },
  widgetMarker: (t, n, i) => {
    for (let l of t.state.facet(VV)) {
      let a = l(t, n, i);
      if (a)
        return a;
    }
    return null;
  },
  lineMarkerChange: (t) => t.startState.facet(ga) != t.state.facet(ga),
  initialSpacer(t) {
    return new Tc(_c(t, sm(t.state.doc.lines)));
  },
  updateSpacer(t, n) {
    let i = _c(n.view, sm(n.view.state.doc.lines));
    return i == t.number ? t : new Tc(i);
  },
  domEventHandlers: e.facet(ga).domEventHandlers
}));
function LV(e = {}) {
  return [
    ga.of(e),
    Rv(),
    QV
  ];
}
function sm(e) {
  let t = 9;
  for (; t < e; )
    t = t * 10 + 9;
  return t;
}
const MV = /* @__PURE__ */ new class extends gi {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), TV = /* @__PURE__ */ go.compute(["selection"], (e) => {
  let t = [], n = -1;
  for (let i of e.selection.ranges) {
    let l = e.doc.lineAt(i.head).from;
    l > n && (n = l, t.push(MV.range(l)));
  }
  return Ee.of(t);
});
function _V() {
  return TV;
}
const Iv = 1024;
let AV = 0;
class Ac {
  constructor(t, n) {
    this.from = t, this.to = n;
  }
}
class Ze {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = AV++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = On.match(t)), (n) => {
      let i = t(n);
      return i === void 0 ? null : [this, i];
    };
  }
}
Ze.closedBy = new Ze({ deserialize: (e) => e.split(" ") });
Ze.openedBy = new Ze({ deserialize: (e) => e.split(" ") });
Ze.group = new Ze({ deserialize: (e) => e.split(" ") });
Ze.isolate = new Ze({ deserialize: (e) => {
  if (e && e != "rtl" && e != "ltr" && e != "auto")
    throw new RangeError("Invalid value for isolate: " + e);
  return e || "auto";
} });
Ze.contextHash = new Ze({ perNode: !0 });
Ze.lookAhead = new Ze({ perNode: !0 });
Ze.mounted = new Ze({ perNode: !0 });
class zo {
  constructor(t, n, i) {
    this.tree = t, this.overlay = n, this.parser = i;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[Ze.mounted.id];
  }
}
const RV = /* @__PURE__ */ Object.create(null);
class On {
  /**
  @internal
  */
  constructor(t, n, i, l = 0) {
    this.name = t, this.props = n, this.id = i, this.flags = l;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let n = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : RV, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), l = new On(t.name || "", n, t.id, i);
    if (t.props) {
      for (let a of t.props)
        if (Array.isArray(a) || (a = a(l)), a) {
          if (a[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[a[0].id] = a[1];
        }
    }
    return l;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let n = this.prop(Ze.group);
      return n ? n.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let l of i.split(" "))
        n[l] = t[i];
    return (i) => {
      for (let l = i.prop(Ze.group), a = -1; a < (l ? l.length : 0); a++) {
        let r = n[a < 0 ? i.name : l[a]];
        if (r)
          return r;
      }
    };
  }
}
On.none = new On(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class gh {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let n = 0; n < t.length; n++)
      if (t[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let n = [];
    for (let i of this.types) {
      let l = null;
      for (let a of t) {
        let r = a(i);
        r && (l || (l = Object.assign({}, i.props)), l[r[0].id] = r[1]);
      }
      n.push(l ? new On(i.name, l, i.id, i.flags) : i);
    }
    return new gh(n);
  }
}
const Ys = /* @__PURE__ */ new WeakMap(), om = /* @__PURE__ */ new WeakMap();
var At;
(function(e) {
  e[e.ExcludeBuffers = 1] = "ExcludeBuffers", e[e.IncludeAnonymous = 2] = "IncludeAnonymous", e[e.IgnoreMounts = 4] = "IgnoreMounts", e[e.IgnoreOverlays = 8] = "IgnoreOverlays";
})(At || (At = {}));
class Vt {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, n, i, l, a) {
    if (this.type = t, this.children = n, this.positions = i, this.length = l, this.props = null, a && a.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [r, s] of a)
        this.props[typeof r == "number" ? r : r.id] = s;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = zo.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let n = "";
    for (let i of this.children) {
      let l = i.toString();
      l && (n && (n += ","), n += l);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new Cd(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, n = 0, i = 0) {
    let l = Ys.get(this) || this.topNode, a = new Cd(l);
    return a.moveTo(t, n), Ys.set(this, a._tree), a;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new pn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, n = 0) {
    let i = Yr(Ys.get(this) || this.topNode, t, n, !1);
    return Ys.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, n = 0) {
    let i = Yr(om.get(this) || this.topNode, t, n, !0);
    return om.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, n = 0) {
    return DV(this, t, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: n, leave: i, from: l = 0, to: a = this.length } = t, r = t.mode || 0, s = (r & At.IncludeAnonymous) > 0;
    for (let o = this.cursor(r | At.IncludeAnonymous); ; ) {
      let u = !1;
      if (o.from <= a && o.to >= l && (!s && o.type.isAnonymous || n(o) !== !1)) {
        if (o.firstChild())
          continue;
        u = !0;
      }
      for (; u && i && (s || !o.type.isAnonymous) && i(o), !o.nextSibling(); ) {
        if (!o.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let n in this.props)
        t.push([+n, this.props[n]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : Oh(On.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, i, l) => new Vt(this.type, n, i, l, this.propValues), t.makeTree || ((n, i, l) => new Vt(On.none, n, i, l)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return BV(t);
  }
}
Vt.empty = new Vt(On.none, [], [], 0);
class vh {
  constructor(t, n) {
    this.buffer = t, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new vh(this.buffer, this.index);
  }
}
class ll {
  /**
  Create a tree buffer.
  */
  constructor(t, n, i) {
    this.buffer = t, this.length = n, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return On.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let n = 0; n < this.buffer.length; )
      t.push(this.childString(n)), n = this.buffer[n + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let n = this.buffer[t], i = this.buffer[t + 3], l = this.set.types[n], a = l.name;
    if (/\W/.test(a) && !l.isError && (a = JSON.stringify(a)), t += 4, i == t)
      return a;
    let r = [];
    for (; t < i; )
      r.push(this.childString(t)), t = this.buffer[t + 3];
    return a + "(" + r.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, n, i, l, a) {
    let { buffer: r } = this, s = -1;
    for (let o = t; o != n && !(Dv(a, l, r[o + 1], r[o + 2]) && (s = o, i > 0)); o = r[o + 3])
      ;
    return s;
  }
  /**
  @internal
  */
  slice(t, n, i) {
    let l = this.buffer, a = new Uint16Array(n - t), r = 0;
    for (let s = t, o = 0; s < n; ) {
      a[o++] = l[s++], a[o++] = l[s++] - i;
      let u = a[o++] = l[s++] - i;
      a[o++] = l[s++] - t, r = Math.max(r, u);
    }
    return new ll(a, r, this.set);
  }
}
function Dv(e, t, n, i) {
  switch (e) {
    case -2:
      return n < t;
    case -1:
      return i >= t && n < t;
    case 0:
      return n < t && i > t;
    case 1:
      return n <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return !0;
  }
}
function Yr(e, t, n, i) {
  for (var l; e.from == e.to || (n < 1 ? e.from >= t : e.from > t) || (n > -1 ? e.to <= t : e.to < t); ) {
    let r = !i && e instanceof pn && e.index < 0 ? null : e.parent;
    if (!r)
      return e;
    e = r;
  }
  let a = i ? 0 : At.IgnoreOverlays;
  if (i)
    for (let r = e, s = r.parent; s; r = s, s = r.parent)
      r instanceof pn && r.index < 0 && ((l = s.enter(t, n, a)) === null || l === void 0 ? void 0 : l.from) != r.from && (e = s);
  for (; ; ) {
    let r = e.enter(t, n, a);
    if (!r)
      return e;
    e = r;
  }
}
class Bv {
  cursor(t = 0) {
    return new Cd(this, t);
  }
  getChild(t, n = null, i = null) {
    let l = um(this, t, n, i);
    return l.length ? l[0] : null;
  }
  getChildren(t, n = null, i = null) {
    return um(this, t, n, i);
  }
  resolve(t, n = 0) {
    return Yr(this, t, n, !1);
  }
  resolveInner(t, n = 0) {
    return Yr(this, t, n, !0);
  }
  matchContext(t) {
    return bd(this.parent, t);
  }
  enterUnfinishedNodesBefore(t) {
    let n = this.childBefore(t), i = this;
    for (; n; ) {
      let l = n.lastChild;
      if (!l || l.to != n.to)
        break;
      l.type.isError && l.from == l.to ? (i = n, n = l.prevSibling) : n = l;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class pn extends Bv {
  constructor(t, n, i, l) {
    super(), this._tree = t, this.from = n, this.index = i, this._parent = l;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, n, i, l, a = 0) {
    for (let r = this; ; ) {
      for (let { children: s, positions: o } = r._tree, u = n > 0 ? s.length : -1; t != u; t += n) {
        let c = s[t], d = o[t] + r.from;
        if (Dv(l, i, d, d + c.length)) {
          if (c instanceof ll) {
            if (a & At.ExcludeBuffers)
              continue;
            let f = c.findChild(0, c.buffer.length, n, i - d, l);
            if (f > -1)
              return new oi(new ZV(r, c, t, d), null, f);
          } else if (a & At.IncludeAnonymous || !c.type.isAnonymous || ph(c)) {
            let f;
            if (!(a & At.IgnoreMounts) && (f = zo.get(c)) && !f.overlay)
              return new pn(f.tree, d, t, r);
            let h = new pn(c, d, t, r);
            return a & At.IncludeAnonymous || !h.type.isAnonymous ? h : h.nextChild(n < 0 ? c.children.length - 1 : 0, n, i, l);
          }
        }
      }
      if (a & At.IncludeAnonymous || !r.type.isAnonymous || (r.index >= 0 ? t = r.index + n : t = n < 0 ? -1 : r._parent._tree.children.length, r = r._parent, !r))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, n, i = 0) {
    let l;
    if (!(i & At.IgnoreOverlays) && (l = zo.get(this._tree)) && l.overlay) {
      let a = t - this.from;
      for (let { from: r, to: s } of l.overlay)
        if ((n > 0 ? r <= a : r < a) && (n < 0 ? s >= a : s > a))
          return new pn(l.tree, l.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, n, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function um(e, t, n, i) {
  let l = e.cursor(), a = [];
  if (!l.firstChild())
    return a;
  if (n != null) {
    for (let r = !1; !r; )
      if (r = l.type.is(n), !l.nextSibling())
        return a;
  }
  for (; ; ) {
    if (i != null && l.type.is(i))
      return a;
    if (l.type.is(t) && a.push(l.node), !l.nextSibling())
      return i == null ? a : [];
  }
}
function bd(e, t, n = t.length - 1) {
  for (let i = e; n >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (t[n] && t[n] != i.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class ZV {
  constructor(t, n, i, l) {
    this.parent = t, this.buffer = n, this.index = i, this.start = l;
  }
}
class oi extends Bv {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, n, i) {
    super(), this.context = t, this._parent = n, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  child(t, n, i) {
    let { buffer: l } = this.context, a = l.findChild(this.index + 4, l.buffer[this.index + 3], t, n - this.context.start, i);
    return a < 0 ? null : new oi(this.context, this, a);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, n, i = 0) {
    if (i & At.ExcludeBuffers)
      return null;
    let { buffer: l } = this.context, a = l.findChild(this.index + 4, l.buffer[this.index + 3], n > 0 ? 1 : -1, t - this.context.start, n);
    return a < 0 ? null : new oi(this.context, this, a);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, n = t.buffer[this.index + 3];
    return n < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new oi(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new oi(this.context, this._parent, t.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], n = [], { buffer: i } = this.context, l = this.index + 4, a = i.buffer[this.index + 3];
    if (a > l) {
      let r = i.buffer[this.index + 1];
      t.push(i.slice(l, a, r)), n.push(0);
    }
    return new Vt(this.type, t, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function Ev(e) {
  if (!e.length)
    return null;
  let t = 0, n = e[0];
  for (let a = 1; a < e.length; a++) {
    let r = e[a];
    (r.from > n.from || r.to < n.to) && (n = r, t = a);
  }
  let i = n instanceof pn && n.index < 0 ? null : n.parent, l = e.slice();
  return i ? l[t] = i : l.splice(t, 1), new IV(l, n);
}
class IV {
  constructor(t, n) {
    this.heads = t, this.node = n;
  }
  get next() {
    return Ev(this.heads);
  }
}
function DV(e, t, n) {
  let i = e.resolveInner(t, n), l = null;
  for (let a = i instanceof pn ? i : i.context.parent; a; a = a.parent)
    if (a.index < 0) {
      let r = a.parent;
      (l || (l = [i])).push(r.resolve(t, n)), a = r;
    } else {
      let r = zo.get(a.tree);
      if (r && r.overlay && r.overlay[0].from <= t && r.overlay[r.overlay.length - 1].to >= t) {
        let s = new pn(r.tree, r.overlay[0].from + a.from, -1, a);
        (l || (l = [i])).push(Yr(s, t, n, !1));
      }
    }
  return l ? Ev(l) : i;
}
class Cd {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof pn)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, n) {
    this.index = t;
    let { start: i, buffer: l } = this.buffer;
    return this.type = n || l.set.types[l.buffer[t]], this.from = i + l.buffer[t + 1], this.to = i + l.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof pn ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, n, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, n, i, this.mode));
    let { buffer: l } = this.buffer, a = l.findChild(this.index + 4, l.buffer[this.index + 3], t, n - this.buffer.start, i);
    return a < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(a));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, n, i = this.mode) {
    return this.buffer ? i & At.ExcludeBuffers ? !1 : this.enterChild(1, t, n) : this.yield(this._tree.enter(t, n, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & At.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & At.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let l = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != l)
        return this.yieldBuf(n.findChild(
          l,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let l = n.buffer[this.index + 3];
      if (l < (i < 0 ? n.buffer.length : n.buffer[this.stack[i] + 3]))
        return this.yieldBuf(l);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let n, i, { buffer: l } = this;
    if (l) {
      if (t > 0) {
        if (this.index < l.buffer.buffer.length)
          return !1;
      } else
        for (let a = 0; a < this.index; a++)
          if (l.buffer.buffer[a + 3] < this.index)
            return !1;
      ({ index: n, parent: i } = l);
    } else
      ({ index: n, _parent: i } = this._tree);
    for (; i; { index: n, _parent: i } = i)
      if (n > -1)
        for (let a = n + t, r = t < 0 ? -1 : i._tree.children.length; a != r; a += t) {
          let s = i._tree.children[a];
          if (this.mode & At.IncludeAnonymous || s instanceof ll || !s.type.isAnonymous || ph(s))
            return !1;
        }
    return !0;
  }
  move(t, n) {
    if (n && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= t : this.from > t) || (n > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, n = null, i = 0;
    if (t && t.context == this.buffer)
      e: for (let l = this.index, a = this.stack.length; a >= 0; ) {
        for (let r = t; r; r = r._parent)
          if (r.index == l) {
            if (l == this.index)
              return r;
            n = r, i = a + 1;
            break e;
          }
        l = this.stack[--a];
      }
    for (let l = i; l < this.stack.length; l++)
      n = new oi(this.buffer, n, this.stack[l]);
    return this.bufferNode = new oi(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, n) {
    for (let i = 0; ; ) {
      let l = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (l = !0);
      }
      for (; ; ) {
        if (l && n && n(this), l = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, l = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return bd(this.node.parent, t);
    let { buffer: n } = this.buffer, { types: i } = n.set;
    for (let l = t.length - 1, a = this.stack.length - 1; l >= 0; a--) {
      if (a < 0)
        return bd(this._tree, t, l);
      let r = i[n.buffer[this.stack[a]]];
      if (!r.isAnonymous) {
        if (t[l] && t[l] != r.name)
          return !1;
        l--;
      }
    }
    return !0;
  }
}
function ph(e) {
  return e.children.some((t) => t instanceof ll || !t.type.isAnonymous || ph(t));
}
function BV(e) {
  var t;
  let { buffer: n, nodeSet: i, maxBufferLength: l = Iv, reused: a = [], minRepeatType: r = i.types.length } = e, s = Array.isArray(n) ? new vh(n, n.length) : n, o = i.types, u = 0, c = 0;
  function d(x, Q, M, w, y, L) {
    let { id: k, start: S, end: P, size: T } = s, _ = c, D = u;
    for (; T < 0; )
      if (s.next(), T == -1) {
        let Z = a[k];
        M.push(Z), w.push(S - x);
        return;
      } else if (T == -3) {
        u = k;
        return;
      } else if (T == -4) {
        c = k;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${T}`);
    let N = o[k], K, E, I = S - x;
    if (P - S <= l && (E = p(s.pos - Q, y))) {
      let Z = new Uint16Array(E.size - E.skip), Y = s.pos - E.size, ce = Z.length;
      for (; s.pos > Y; )
        ce = O(E.start, Z, ce);
      K = new ll(Z, P - E.start, i), I = E.start - x;
    } else {
      let Z = s.pos - T;
      s.next();
      let Y = [], ce = [], de = k >= r ? k : -1, ye = 0, U = P;
      for (; s.pos > Z; )
        de >= 0 && s.id == de && s.size >= 0 ? (s.end <= U - l && (g(Y, ce, S, ye, s.end, U, de, _, D), ye = Y.length, U = s.end), s.next()) : L > 2500 ? f(S, Z, Y, ce) : d(S, Z, Y, ce, de, L + 1);
      if (de >= 0 && ye > 0 && ye < Y.length && g(Y, ce, S, ye, S, U, de, _, D), Y.reverse(), ce.reverse(), de > -1 && ye > 0) {
        let ge = h(N, D);
        K = Oh(N, Y, ce, 0, Y.length, 0, P - S, ge, ge);
      } else
        K = v(N, Y, ce, P - S, _ - P, D);
    }
    M.push(K), w.push(I);
  }
  function f(x, Q, M, w) {
    let y = [], L = 0, k = -1;
    for (; s.pos > Q; ) {
      let { id: S, start: P, end: T, size: _ } = s;
      if (_ > 4)
        s.next();
      else {
        if (k > -1 && P < k)
          break;
        k < 0 && (k = T - l), y.push(S, P, T), L++, s.next();
      }
    }
    if (L) {
      let S = new Uint16Array(L * 4), P = y[y.length - 2];
      for (let T = y.length - 3, _ = 0; T >= 0; T -= 3)
        S[_++] = y[T], S[_++] = y[T + 1] - P, S[_++] = y[T + 2] - P, S[_++] = _;
      M.push(new ll(S, y[2] - P, i)), w.push(P - x);
    }
  }
  function h(x, Q) {
    return (M, w, y) => {
      let L = 0, k = M.length - 1, S, P;
      if (k >= 0 && (S = M[k]) instanceof Vt) {
        if (!k && S.type == x && S.length == y)
          return S;
        (P = S.prop(Ze.lookAhead)) && (L = w[k] + S.length + P);
      }
      return v(x, M, w, y, L, Q);
    };
  }
  function g(x, Q, M, w, y, L, k, S, P) {
    let T = [], _ = [];
    for (; x.length > w; )
      T.push(x.pop()), _.push(Q.pop() + M - y);
    x.push(v(i.types[k], T, _, L - y, S - L, P)), Q.push(y - M);
  }
  function v(x, Q, M, w, y, L, k) {
    if (L) {
      let S = [Ze.contextHash, L];
      k = k ? [S].concat(k) : [S];
    }
    if (y > 25) {
      let S = [Ze.lookAhead, y];
      k = k ? [S].concat(k) : [S];
    }
    return new Vt(x, Q, M, w, k);
  }
  function p(x, Q) {
    let M = s.fork(), w = 0, y = 0, L = 0, k = M.end - l, S = { size: 0, start: 0, skip: 0 };
    e: for (let P = M.pos - x; M.pos > P; ) {
      let T = M.size;
      if (M.id == Q && T >= 0) {
        S.size = w, S.start = y, S.skip = L, L += 4, w += 4, M.next();
        continue;
      }
      let _ = M.pos - T;
      if (T < 0 || _ < P || M.start < k)
        break;
      let D = M.id >= r ? 4 : 0, N = M.start;
      for (M.next(); M.pos > _; ) {
        if (M.size < 0)
          if (M.size == -3)
            D += 4;
          else
            break e;
        else M.id >= r && (D += 4);
        M.next();
      }
      y = N, w += T, L += D;
    }
    return (Q < 0 || w == x) && (S.size = w, S.start = y, S.skip = L), S.size > 4 ? S : void 0;
  }
  function O(x, Q, M) {
    let { id: w, start: y, end: L, size: k } = s;
    if (s.next(), k >= 0 && w < r) {
      let S = M;
      if (k > 4) {
        let P = s.pos - (k - 4);
        for (; s.pos > P; )
          M = O(x, Q, M);
      }
      Q[--M] = S, Q[--M] = L - x, Q[--M] = y - x, Q[--M] = w;
    } else k == -3 ? u = w : k == -4 && (c = w);
    return M;
  }
  let b = [], V = [];
  for (; s.pos > 0; )
    d(e.start || 0, e.bufferStart || 0, b, V, -1, 0);
  let $ = (t = e.length) !== null && t !== void 0 ? t : b.length ? V[0] + b[0].length : 0;
  return new Vt(o[e.topID], b.reverse(), V.reverse(), $);
}
const cm = /* @__PURE__ */ new WeakMap();
function vo(e, t) {
  if (!e.isAnonymous || t instanceof ll || t.type != e)
    return 1;
  let n = cm.get(t);
  if (n == null) {
    n = 1;
    for (let i of t.children) {
      if (i.type != e || !(i instanceof Vt)) {
        n = 1;
        break;
      }
      n += vo(e, i);
    }
    cm.set(t, n);
  }
  return n;
}
function Oh(e, t, n, i, l, a, r, s, o) {
  let u = 0;
  for (let g = i; g < l; g++)
    u += vo(e, t[g]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], f = [];
  function h(g, v, p, O, b) {
    for (let V = p; V < O; ) {
      let $ = V, x = v[V], Q = vo(e, g[V]);
      for (V++; V < O; V++) {
        let M = vo(e, g[V]);
        if (Q + M >= c)
          break;
        Q += M;
      }
      if (V == $ + 1) {
        if (Q > c) {
          let M = g[$];
          h(M.children, M.positions, 0, M.children.length, v[$] + b);
          continue;
        }
        d.push(g[$]);
      } else {
        let M = v[V - 1] + g[V - 1].length - x;
        d.push(Oh(e, g, v, $, V, x, M, null, o));
      }
      f.push(x + b - a);
    }
  }
  return h(t, n, i, l, 0), (s || o)(d, f, r);
}
class EV {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, n, i) {
    let l = this.map.get(t);
    l || this.map.set(t, l = /* @__PURE__ */ new Map()), l.set(n, i);
  }
  getBuffer(t, n) {
    let i = this.map.get(t);
    return i && i.get(n);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, n) {
    t instanceof oi ? this.setBuffer(t.context.buffer, t.index, n) : t instanceof pn && this.map.set(t.tree, n);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof oi ? this.getBuffer(t.context.buffer, t.index) : t instanceof pn ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, n) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, n) : this.map.set(t.tree, n);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}
class Ql {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, n, i, l, a = !1, r = !1) {
    this.from = t, this.to = n, this.tree = i, this.offset = l, this.open = (a ? 1 : 0) | (r ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, n = [], i = !1) {
    let l = [new Ql(0, t.length, t, 0, !1, i)];
    for (let a of n)
      a.to > t.length && l.push(a);
    return l;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, n, i = 128) {
    if (!n.length)
      return t;
    let l = [], a = 1, r = t.length ? t[0] : null;
    for (let s = 0, o = 0, u = 0; ; s++) {
      let c = s < n.length ? n[s] : null, d = c ? c.fromA : 1e9;
      if (d - o >= i)
        for (; r && r.from < d; ) {
          let f = r;
          if (o >= f.from || d <= f.to || u) {
            let h = Math.max(f.from, o) - u, g = Math.min(f.to, d) - u;
            f = h >= g ? null : new Ql(h, g, f.tree, f.offset + u, s > 0, !!c);
          }
          if (f && l.push(f), r.to > d)
            break;
          r = a < t.length ? t[a++] : null;
        }
      if (!c)
        break;
      o = c.toA, u = c.toA - c.toB;
    }
    return l;
  }
}
class zv {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, n, i) {
    return typeof t == "string" && (t = new zV(t)), i = i ? i.length ? i.map((l) => new Ac(l.from, l.to)) : [new Ac(0, 0)] : [new Ac(0, t.length)], this.createParse(t, n || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, n, i) {
    let l = this.startParse(t, n, i);
    for (; ; ) {
      let a = l.advance();
      if (a)
        return a;
    }
  }
}
class zV {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, n) {
    return this.string.slice(t, n);
  }
}
new Ze({ perNode: !0 });
let HV = 0, wi = class Sd {
  /**
  @internal
  */
  constructor(t, n, i, l) {
    this.name = t, this.set = n, this.base = i, this.modified = l, this.id = HV++;
  }
  toString() {
    let { name: t } = this;
    for (let n of this.modified)
      n.name && (t = `${n.name}(${t})`);
    return t;
  }
  static define(t, n) {
    let i = typeof t == "string" ? t : "?";
    if (t instanceof Sd && (n = t), n != null && n.base)
      throw new Error("Can not derive from a modified tag");
    let l = new Sd(i, [], null, []);
    if (l.set.push(l), n)
      for (let a of n.set)
        l.set.push(a);
    return l;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let n = new Ho(t);
    return (i) => i.modified.indexOf(n) > -1 ? i : Ho.get(i.base || i, i.modified.concat(n).sort((l, a) => l.id - a.id));
  }
}, jV = 0;
class Ho {
  constructor(t) {
    this.name = t, this.instances = [], this.id = jV++;
  }
  static get(t, n) {
    if (!n.length)
      return t;
    let i = n[0].instances.find((s) => s.base == t && XV(n, s.modified));
    if (i)
      return i;
    let l = [], a = new wi(t.name, l, t, n);
    for (let s of n)
      s.instances.push(a);
    let r = NV(n);
    for (let s of t.set)
      if (!s.modified.length)
        for (let o of r)
          l.push(Ho.get(s, o));
    return a;
  }
}
function XV(e, t) {
  return e.length == t.length && e.every((n, i) => n == t[i]);
}
function NV(e) {
  let t = [[]];
  for (let n = 0; n < e.length; n++)
    for (let i = 0, l = t.length; i < l; i++)
      t.push(t[i].concat(e[n]));
  return t.sort((n, i) => i.length - n.length);
}
function Wu(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e) {
    let i = e[n];
    Array.isArray(i) || (i = [i]);
    for (let l of n.split(" "))
      if (l) {
        let a = [], r = 2, s = l;
        for (let d = 0; ; ) {
          if (s == "..." && d > 0 && d + 3 == l.length) {
            r = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(s);
          if (!f)
            throw new RangeError("Invalid path: " + l);
          if (a.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), d += f[0].length, d == l.length)
            break;
          let h = l[d++];
          if (d == l.length && h == "!") {
            r = 0;
            break;
          }
          if (h != "/")
            throw new RangeError("Invalid path: " + l);
          s = l.slice(d);
        }
        let o = a.length - 1, u = a[o];
        if (!u)
          throw new RangeError("Invalid path: " + l);
        let c = new jo(i, r, o > 0 ? a.slice(0, o) : null);
        t[u] = c.sort(t[u]);
      }
  }
  return Hv.add(t);
}
const Hv = new Ze();
class jo {
  constructor(t, n, i, l) {
    this.tags = t, this.mode = n, this.context = i, this.next = l;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
jo.empty = new jo([], 2, null);
function jv(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let a of e)
    if (!Array.isArray(a.tag))
      n[a.tag.id] = a.class;
    else
      for (let r of a.tag)
        n[r.id] = a.class;
  let { scope: i, all: l = null } = t || {};
  return {
    style: (a) => {
      let r = l;
      for (let s of a)
        for (let o of s.set) {
          let u = n[o.id];
          if (u) {
            r = r ? r + " " + u : u;
            break;
          }
        }
      return r;
    },
    scope: i
  };
}
function qV(e, t) {
  let n = null;
  for (let i of e) {
    let l = i.style(t);
    l && (n = n ? n + " " + l : l);
  }
  return n;
}
function YV(e, t, n, i = 0, l = e.length) {
  let a = new FV(i, Array.isArray(t) ? t : [t], n);
  a.highlightRange(e.cursor(), i, l, "", a.highlighters), a.flush(l);
}
class FV {
  constructor(t, n, i) {
    this.at = t, this.highlighters = n, this.span = i, this.class = "";
  }
  startSpan(t, n) {
    n != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = n);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, n, i, l, a) {
    let { type: r, from: s, to: o } = t;
    if (s >= i || o <= n)
      return;
    r.isTop && (a = this.highlighters.filter((h) => !h.scope || h.scope(r)));
    let u = l, c = WV(t) || jo.empty, d = qV(a, c.tags);
    if (d && (u && (u += " "), u += d, c.mode == 1 && (l += (l ? " " : "") + d)), this.startSpan(Math.max(n, s), u), c.opaque)
      return;
    let f = t.tree && t.tree.prop(Ze.mounted);
    if (f && f.overlay) {
      let h = t.node.enter(f.overlay[0].from + s, 1), g = this.highlighters.filter((p) => !p.scope || p.scope(f.tree.type)), v = t.firstChild();
      for (let p = 0, O = s; ; p++) {
        let b = p < f.overlay.length ? f.overlay[p] : null, V = b ? b.from + s : o, $ = Math.max(n, O), x = Math.min(i, V);
        if ($ < x && v)
          for (; t.from < x && (this.highlightRange(t, $, x, l, a), this.startSpan(Math.min(x, t.to), u), !(t.to >= V || !t.nextSibling())); )
            ;
        if (!b || V > i)
          break;
        O = b.to + s, O > n && (this.highlightRange(h.cursor(), Math.max(n, b.from + s), Math.min(i, O), "", g), this.startSpan(Math.min(i, O), u));
      }
      v && t.parent();
    } else if (t.firstChild()) {
      f && (l = "");
      do
        if (!(t.to <= n)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, n, i, l, a), this.startSpan(Math.min(i, t.to), u);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}
function WV(e) {
  let t = e.type.prop(Hv);
  for (; t && t.context && !e.matchContext(t.context); )
    t = t.next;
  return t || null;
}
const fe = wi.define, Fs = fe(), Ei = fe(), dm = fe(Ei), fm = fe(Ei), zi = fe(), Ws = fe(zi), Rc = fe(zi), li = fe(), vl = fe(li), ni = fe(), ii = fe(), wd = fe(), sr = fe(wd), Us = fe(), R = {
  /**
  A comment.
  */
  comment: Fs,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: fe(Fs),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: fe(Fs),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: fe(Fs),
  /**
  Any kind of identifier.
  */
  name: Ei,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: fe(Ei),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: dm,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: fe(dm),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: fm,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: fe(fm),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: fe(Ei),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: fe(Ei),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: fe(Ei),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: fe(Ei),
  /**
  A literal value.
  */
  literal: zi,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Ws,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: fe(Ws),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: fe(Ws),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: fe(Ws),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Rc,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: fe(Rc),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: fe(Rc),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: fe(zi),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: fe(zi),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: fe(zi),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: fe(zi),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: fe(zi),
  /**
  A language keyword.
  */
  keyword: ni,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: fe(ni),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: fe(ni),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: fe(ni),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: fe(ni),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: fe(ni),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: fe(ni),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: fe(ni),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: fe(ni),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: fe(ni),
  /**
  An operator.
  */
  operator: ii,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: fe(ii),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: fe(ii),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: fe(ii),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: fe(ii),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: fe(ii),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: fe(ii),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: fe(ii),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: fe(ii),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: fe(ii),
  /**
  Program or markup punctuation.
  */
  punctuation: wd,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: fe(wd),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: sr,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: fe(sr),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: fe(sr),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: fe(sr),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: fe(sr),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: li,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: vl,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: fe(vl),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: fe(vl),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: fe(vl),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: fe(vl),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: fe(vl),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: fe(vl),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: fe(li),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: fe(li),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: fe(li),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: fe(li),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: fe(li),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: fe(li),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: fe(li),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: fe(li),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: fe(),
  /**
  Deleted text.
  */
  deleted: fe(),
  /**
  Changed text.
  */
  changed: fe(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: fe(),
  /**
  Metadata or meta-instruction.
  */
  meta: Us,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: fe(Us),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: fe(Us),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: fe(Us),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: wi.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: wi.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: wi.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: wi.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: wi.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: wi.defineModifier("special")
};
for (let e in R) {
  let t = R[e];
  t instanceof wi && (t.name = e);
}
jv([
  { tag: R.link, class: "tok-link" },
  { tag: R.heading, class: "tok-heading" },
  { tag: R.emphasis, class: "tok-emphasis" },
  { tag: R.strong, class: "tok-strong" },
  { tag: R.keyword, class: "tok-keyword" },
  { tag: R.atom, class: "tok-atom" },
  { tag: R.bool, class: "tok-bool" },
  { tag: R.url, class: "tok-url" },
  { tag: R.labelName, class: "tok-labelName" },
  { tag: R.inserted, class: "tok-inserted" },
  { tag: R.deleted, class: "tok-deleted" },
  { tag: R.literal, class: "tok-literal" },
  { tag: R.string, class: "tok-string" },
  { tag: R.number, class: "tok-number" },
  { tag: [R.regexp, R.escape, R.special(R.string)], class: "tok-string2" },
  { tag: R.variableName, class: "tok-variableName" },
  { tag: R.local(R.variableName), class: "tok-variableName tok-local" },
  { tag: R.definition(R.variableName), class: "tok-variableName tok-definition" },
  { tag: R.special(R.variableName), class: "tok-variableName2" },
  { tag: R.definition(R.propertyName), class: "tok-propertyName tok-definition" },
  { tag: R.typeName, class: "tok-typeName" },
  { tag: R.namespace, class: "tok-namespace" },
  { tag: R.className, class: "tok-className" },
  { tag: R.macroName, class: "tok-macroName" },
  { tag: R.propertyName, class: "tok-propertyName" },
  { tag: R.operator, class: "tok-operator" },
  { tag: R.comment, class: "tok-comment" },
  { tag: R.meta, class: "tok-meta" },
  { tag: R.invalid, class: "tok-invalid" },
  { tag: R.punctuation, class: "tok-punctuation" }
]);
var Zc;
const va = /* @__PURE__ */ new Ze();
function Xv(e) {
  return ve.define({
    combine: e ? (t) => t.concat(e) : void 0
  });
}
const yh = /* @__PURE__ */ new Ze();
class Nn {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, n, i = [], l = "") {
    this.data = t, this.name = l, Re.prototype.hasOwnProperty("tree") || Object.defineProperty(Re.prototype, "tree", { get() {
      return Rt(this);
    } }), this.parser = n, this.extension = [
      al.of(this),
      Re.languageData.of((a, r, s) => {
        let o = hm(a, r, s), u = o.type.prop(va);
        if (!u)
          return [];
        let c = a.facet(u), d = o.type.prop(yh);
        if (d) {
          let f = o.resolve(r - o.from, s);
          for (let h of d)
            if (h.test(f, a)) {
              let g = a.facet(h.facet);
              return h.type == "replace" ? g : g.concat(c);
            }
        }
        return c;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, n, i = -1) {
    return hm(t, n, i).type.prop(va) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let n = t.facet(al);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let i = [], l = (a, r) => {
      if (a.prop(va) == this.data) {
        i.push({ from: r, to: r + a.length });
        return;
      }
      let s = a.prop(Ze.mounted);
      if (s) {
        if (s.tree.prop(va) == this.data) {
          if (s.overlay)
            for (let o of s.overlay)
              i.push({ from: o.from + r, to: o.to + r });
          else
            i.push({ from: r, to: r + a.length });
          return;
        } else if (s.overlay) {
          let o = i.length;
          if (l(s.tree, s.overlay[0].from + r), i.length > o)
            return;
        }
      }
      for (let o = 0; o < a.children.length; o++) {
        let u = a.children[o];
        u instanceof Vt && l(u, a.positions[o] + r);
      }
    };
    return l(Rt(t), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Nn.setState = /* @__PURE__ */ Le.define();
function hm(e, t, n) {
  let i = e.facet(al), l = Rt(e).topNode;
  if (!i || i.allowsNesting)
    for (let a = l; a; a = a.enter(t, n, At.ExcludeBuffers))
      a.type.isTop && (l = a);
  return l;
}
class Ia extends Nn {
  constructor(t, n, i) {
    super(t, n, [], i), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let n = Xv(t.languageData);
    return new Ia(n, t.parser.configure({
      props: [va.add((i) => i.isTop ? n : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, n) {
    return new Ia(this.data, this.parser.configure(t), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Rt(e) {
  let t = e.field(Nn.state, !1);
  return t ? t.tree : Vt.empty;
}
class UV {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, n) {
    let i = this.cursorPos - this.string.length;
    return t < i || n >= this.cursorPos ? this.doc.sliceString(t, n) : this.string.slice(t - i, n - i);
  }
}
let or = null;
class Xo {
  constructor(t, n, i = [], l, a, r, s, o) {
    this.parser = t, this.state = n, this.fragments = i, this.tree = l, this.treeLen = a, this.viewport = r, this.skipped = s, this.scheduleOn = o, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, n, i) {
    return new Xo(t, n, [], Vt.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new UV(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != Vt.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let l = Date.now() + t;
        t = () => Date.now() > l;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let l = this.parse.advance();
        if (l)
          if (this.fragments = this.withoutTempSkipped(Ql.addTree(l, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = l, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, n;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = n, this.fragments = this.withoutTempSkipped(Ql.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let n = or;
    or = this;
    try {
      return t();
    } finally {
      or = n;
    }
  }
  withoutTempSkipped(t) {
    for (let n; n = this.tempSkipped.pop(); )
      t = mm(t, n.from, n.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, n) {
    let { fragments: i, tree: l, treeLen: a, viewport: r, skipped: s } = this;
    if (this.takeTree(), !t.empty) {
      let o = [];
      if (t.iterChangedRanges((u, c, d, f) => o.push({ fromA: u, toA: c, fromB: d, toB: f })), i = Ql.applyChanges(i, o), l = Vt.empty, a = 0, r = { from: t.mapPos(r.from, -1), to: t.mapPos(r.to, 1) }, this.skipped.length) {
        s = [];
        for (let u of this.skipped) {
          let c = t.mapPos(u.from, 1), d = t.mapPos(u.to, -1);
          c < d && s.push({ from: c, to: d });
        }
      }
    }
    return new Xo(this.parser, n, i, l, a, r, s, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let n = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: l, to: a } = this.skipped[i];
      l < t.to && a > t.from && (this.fragments = mm(this.fragments, l, a), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, n) {
    this.skipped.push({ from: t, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends zv {
      createParse(n, i, l) {
        let a = l[0].from, r = l[l.length - 1].to;
        return {
          parsedPos: a,
          advance() {
            let o = or;
            if (o) {
              for (let u of l)
                o.tempSkipped.push(u);
              t && (o.scheduleOn = o.scheduleOn ? Promise.all([o.scheduleOn, t]) : t);
            }
            return this.parsedPos = r, new Vt(On.none, [], [], r - a);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= t && n.length && n[0].from == 0 && n[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return or;
  }
}
function mm(e, t, n) {
  return Ql.applyChanges(e, [{ fromA: t, toA: n, fromB: t, toB: n }]);
}
class Da {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, i) || n.takeTree(), new Da(n);
  }
  static init(t) {
    let n = Math.min(3e3, t.doc.length), i = Xo.create(t.facet(al).parser, t, { from: 0, to: n });
    return i.work(20, n) || i.takeTree(), new Da(i);
  }
}
Nn.state = /* @__PURE__ */ Mt.define({
  create: Da.init,
  update(e, t) {
    for (let n of t.effects)
      if (n.is(Nn.setState))
        return n.value;
    return t.startState.facet(al) != t.state.facet(al) ? Da.init(t.state) : e.apply(t);
  }
});
let Nv = (e) => {
  let t = setTimeout(
    () => e(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
};
typeof requestIdleCallback < "u" && (Nv = (e) => {
  let t = -1, n = setTimeout(
    () => {
      t = requestIdleCallback(e, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(n) : cancelIdleCallback(t);
});
const Ic = typeof navigator < "u" && (!((Zc = navigator.scheduling) === null || Zc === void 0) && Zc.isInputPending) ? () => navigator.scheduling.isInputPending() : null, GV = /* @__PURE__ */ yt.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let n = this.view.state.field(Nn.state).context;
    (n.updateViewport(t.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, n = t.field(Nn.state);
    (n.tree != n.context.tree || !n.context.isDone(t.doc.length)) && (this.working = Nv(this.work));
  }
  work(t) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: l } } = this.view, a = i.field(Nn.state);
    if (a.tree == a.context.tree && a.context.isDone(
      l + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let r = Date.now() + Math.min(this.chunkBudget, 100, t && !Ic ? Math.max(25, t.timeRemaining() - 5) : 1e9), s = a.context.treeLen < l && i.doc.length > l + 1e3, o = a.context.work(() => Ic && Ic() || Date.now() > r, l + (s ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (o || this.chunkBudget <= 0) && (a.context.takeTree(), this.view.dispatch({ effects: Nn.setState.of(new Da(a.context)) })), this.chunkBudget > 0 && !(o && !s) && this.scheduleWork(), this.checkAsyncSchedule(a.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((n) => sn(this.view.state, n)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), al = /* @__PURE__ */ ve.define({
  combine(e) {
    return e.length ? e[0] : null;
  },
  enables: (e) => [
    Nn.state,
    GV,
    me.contentAttributes.compute([e], (t) => {
      let n = t.facet(e);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class qv {
  /**
  Create a language support object.
  */
  constructor(t, n = []) {
    this.language = t, this.support = n, this.extension = [t, n];
  }
}
const KV = /* @__PURE__ */ ve.define(), bs = /* @__PURE__ */ ve.define({
  combine: (e) => {
    if (!e.length)
      return "  ";
    let t = e[0];
    if (!t || /\S/.test(t) || Array.from(t).some((n) => n != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(e[0]));
    return t;
  }
});
function No(e) {
  let t = e.facet(bs);
  return t.charCodeAt(0) == 9 ? e.tabSize * t.length : t.length;
}
function Fr(e, t) {
  let n = "", i = e.tabSize, l = e.facet(bs)[0];
  if (l == "	") {
    for (; t >= i; )
      n += "	", t -= i;
    l = " ";
  }
  for (let a = 0; a < t; a++)
    n += l;
  return n;
}
function bh(e, t) {
  e instanceof Re && (e = new Uu(e));
  for (let i of e.state.facet(KV)) {
    let l = i(e, t);
    if (l !== void 0)
      return l;
  }
  let n = Rt(e.state);
  return n.length >= t ? JV(e, n, t) : null;
}
class Uu {
  /**
  Create an indent context.
  */
  constructor(t, n = {}) {
    this.state = t, this.options = n, this.unit = No(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, n = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: l, simulateDoubleBreak: a } = this.options;
    return l != null && l >= i.from && l <= i.to ? a && l == t ? { text: "", from: t } : (n < 0 ? l < t : l <= t) ? { text: i.text.slice(l - i.from), from: l } : { text: i.text.slice(0, l - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, n = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: l } = this.lineAt(t, n);
    return i.slice(t - l, Math.min(i.length, t + 100 - l));
  }
  /**
  Find the column for the given position.
  */
  column(t, n = 1) {
    let { text: i, from: l } = this.lineAt(t, n), a = this.countColumn(i, t - l), r = this.options.overrideIndentation ? this.options.overrideIndentation(l) : -1;
    return r > -1 && (a += r - this.countColumn(i, i.search(/\S|$/))), a;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, n = t.length) {
    return Ga(t, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, n = 1) {
    let { text: i, from: l } = this.lineAt(t, n), a = this.options.overrideIndentation;
    if (a) {
      let r = a(l);
      if (r > -1)
        return r;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Ch = /* @__PURE__ */ new Ze();
function JV(e, t, n) {
  let i = t.resolveStack(n), l = i.node.enterUnfinishedNodesBefore(n);
  if (l != i.node) {
    let a = [];
    for (let r = l; r != i.node; r = r.parent)
      a.push(r);
    for (let r = a.length - 1; r >= 0; r--)
      i = { node: a[r], next: i };
  }
  return Yv(i, e, n);
}
function Yv(e, t, n) {
  for (let i = e; i; i = i.next) {
    let l = tQ(i.node);
    if (l)
      return l(Sh.create(t, n, i));
  }
  return 0;
}
function eQ(e) {
  return e.pos == e.options.simulateBreak && e.options.simulateDoubleBreak;
}
function tQ(e) {
  let t = e.type.prop(Ch);
  if (t)
    return t;
  let n = e.firstChild, i;
  if (n && (i = n.type.prop(Ze.closedBy))) {
    let l = e.lastChild, a = l && i.indexOf(l.name) > -1;
    return (r) => Fv(r, !0, 1, void 0, a && !eQ(r) ? l.from : void 0);
  }
  return e.parent == null ? nQ : null;
}
function nQ() {
  return 0;
}
class Sh extends Uu {
  constructor(t, n, i) {
    super(t.state, t.options), this.base = t, this.pos = n, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, n, i) {
    return new Sh(t, n, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let n = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let i = t.resolve(n.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (iQ(i, t))
        break;
      n = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return Yv(this.context.next, this.base, this.pos);
  }
}
function iQ(e, t) {
  for (let n = t; n; n = n.parent)
    if (e == n)
      return !0;
  return !1;
}
function lQ(e) {
  let t = e.node, n = t.childAfter(t.from), i = t.lastChild;
  if (!n)
    return null;
  let l = e.options.simulateBreak, a = e.state.doc.lineAt(n.from), r = l == null || l <= a.from ? a.to : Math.min(a.to, l);
  for (let s = n.to; ; ) {
    let o = t.childAfter(s);
    if (!o || o == i)
      return null;
    if (!o.type.isSkipped) {
      if (o.from >= r)
        return null;
      let u = /^ */.exec(a.text.slice(n.to - a.from))[0].length;
      return { from: n.from, to: n.to + u };
    }
    s = o.to;
  }
}
function kd({ closing: e, align: t = !0, units: n = 1 }) {
  return (i) => Fv(i, t, n, e);
}
function Fv(e, t, n, i, l) {
  let a = e.textAfter, r = a.match(/^\s*/)[0].length, s = i && a.slice(r, r + i.length) == i || l == e.pos + r, o = t ? lQ(e) : null;
  return o ? s ? e.column(o.from) : e.column(o.to) : e.baseIndent + (s ? 0 : e.unit * n);
}
const aQ = (e) => e.baseIndent;
function Dc({ except: e, units: t = 1 } = {}) {
  return (n) => {
    let i = e && e.test(n.textAfter);
    return n.baseIndent + (i ? 0 : t * n.unit);
  };
}
const rQ = 200;
function sQ() {
  return Re.transactionFilter.of((e) => {
    if (!e.docChanged || !e.isUserEvent("input.type") && !e.isUserEvent("input.complete"))
      return e;
    let t = e.startState.languageDataAt("indentOnInput", e.startState.selection.main.head);
    if (!t.length)
      return e;
    let n = e.newDoc, { head: i } = e.newSelection.main, l = n.lineAt(i);
    if (i > l.from + rQ)
      return e;
    let a = n.sliceString(l.from, i);
    if (!t.some((u) => u.test(a)))
      return e;
    let { state: r } = e, s = -1, o = [];
    for (let { head: u } of r.selection.ranges) {
      let c = r.doc.lineAt(u);
      if (c.from == s)
        continue;
      s = c.from;
      let d = bh(r, c.from);
      if (d == null)
        continue;
      let f = /^\s*/.exec(c.text)[0], h = Fr(r, d);
      f != h && o.push({ from: c.from, to: c.from + f.length, insert: h });
    }
    return o.length ? [e, { changes: o, sequential: !0 }] : e;
  });
}
const oQ = /* @__PURE__ */ ve.define(), wh = /* @__PURE__ */ new Ze();
function Wv(e) {
  let t = e.firstChild, n = e.lastChild;
  return t && t.to < n.from ? { from: t.to, to: n.type.isError ? e.to : n.from } : null;
}
function uQ(e, t, n) {
  let i = Rt(e);
  if (i.length < n)
    return null;
  let l = i.resolveStack(n, 1), a = null;
  for (let r = l; r; r = r.next) {
    let s = r.node;
    if (s.to <= n || s.from > n)
      continue;
    if (a && s.from < t)
      break;
    let o = s.type.prop(wh);
    if (o && (s.to < i.length - 50 || i.length == e.doc.length || !cQ(s))) {
      let u = o(s, e);
      u && u.from <= n && u.from >= t && u.to > n && (a = u);
    }
  }
  return a;
}
function cQ(e) {
  let t = e.lastChild;
  return t && t.to == e.to && t.type.isError;
}
function qo(e, t, n) {
  for (let i of e.facet(oQ)) {
    let l = i(e, t, n);
    if (l)
      return l;
  }
  return uQ(e, t, n);
}
function Uv(e, t) {
  let n = t.mapPos(e.from, 1), i = t.mapPos(e.to, -1);
  return n >= i ? void 0 : { from: n, to: i };
}
const Gu = /* @__PURE__ */ Le.define({ map: Uv }), Cs = /* @__PURE__ */ Le.define({ map: Uv });
function Gv(e) {
  let t = [];
  for (let { head: n } of e.state.selection.ranges)
    t.some((i) => i.from <= n && i.to >= n) || t.push(e.lineBlockAt(n));
  return t;
}
const jl = /* @__PURE__ */ Mt.define({
  create() {
    return Ce.none;
  },
  update(e, t) {
    e = e.map(t.changes);
    for (let n of t.effects)
      if (n.is(Gu) && !dQ(e, n.value.from, n.value.to)) {
        let { preparePlaceholder: i } = t.state.facet(e8), l = i ? Ce.replace({ widget: new OQ(i(t.state, n.value)) }) : gm;
        e = e.update({ add: [l.range(n.value.from, n.value.to)] });
      } else n.is(Cs) && (e = e.update({
        filter: (i, l) => n.value.from != i || n.value.to != l,
        filterFrom: n.value.from,
        filterTo: n.value.to
      }));
    if (t.selection) {
      let n = !1, { head: i } = t.selection.main;
      e.between(i, i, (l, a) => {
        l < i && a > i && (n = !0);
      }), n && (e = e.update({
        filterFrom: i,
        filterTo: i,
        filter: (l, a) => a <= i || l >= i
      }));
    }
    return e;
  },
  provide: (e) => me.decorations.from(e),
  toJSON(e, t) {
    let n = [];
    return e.between(0, t.doc.length, (i, l) => {
      n.push(i, l);
    }), n;
  },
  fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let t = [];
    for (let n = 0; n < e.length; ) {
      let i = e[n++], l = e[n++];
      if (typeof i != "number" || typeof l != "number")
        throw new RangeError("Invalid JSON for fold state");
      t.push(gm.range(i, l));
    }
    return Ce.set(t, !0);
  }
});
function Yo(e, t, n) {
  var i;
  let l = null;
  return (i = e.field(jl, !1)) === null || i === void 0 || i.between(t, n, (a, r) => {
    (!l || l.from > a) && (l = { from: a, to: r });
  }), l;
}
function dQ(e, t, n) {
  let i = !1;
  return e.between(t, t, (l, a) => {
    l == t && a == n && (i = !0);
  }), i;
}
function Kv(e, t) {
  return e.field(jl, !1) ? t : t.concat(Le.appendConfig.of(t8()));
}
const fQ = (e) => {
  for (let t of Gv(e)) {
    let n = qo(e.state, t.from, t.to);
    if (n)
      return e.dispatch({ effects: Kv(e.state, [Gu.of(n), Jv(e, n)]) }), !0;
  }
  return !1;
}, hQ = (e) => {
  if (!e.state.field(jl, !1))
    return !1;
  let t = [];
  for (let n of Gv(e)) {
    let i = Yo(e.state, n.from, n.to);
    i && t.push(Cs.of(i), Jv(e, i, !1));
  }
  return t.length && e.dispatch({ effects: t }), t.length > 0;
};
function Jv(e, t, n = !0) {
  let i = e.state.doc.lineAt(t.from).number, l = e.state.doc.lineAt(t.to).number;
  return me.announce.of(`${e.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${i} ${e.state.phrase("to")} ${l}.`);
}
const mQ = (e) => {
  let { state: t } = e, n = [];
  for (let i = 0; i < t.doc.length; ) {
    let l = e.lineBlockAt(i), a = qo(t, l.from, l.to);
    a && n.push(Gu.of(a)), i = (a ? e.lineBlockAt(a.to) : l).to + 1;
  }
  return n.length && e.dispatch({ effects: Kv(e.state, n) }), !!n.length;
}, gQ = (e) => {
  let t = e.state.field(jl, !1);
  if (!t || !t.size)
    return !1;
  let n = [];
  return t.between(0, e.state.doc.length, (i, l) => {
    n.push(Cs.of({ from: i, to: l }));
  }), e.dispatch({ effects: n }), !0;
}, vQ = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: fQ },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: hQ },
  { key: "Ctrl-Alt-[", run: mQ },
  { key: "Ctrl-Alt-]", run: gQ }
], pQ = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, e8 = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, pQ);
  }
});
function t8(e) {
  return [jl, CQ];
}
function n8(e, t) {
  let { state: n } = e, i = n.facet(e8), l = (r) => {
    let s = e.lineBlockAt(e.posAtDOM(r.target)), o = Yo(e.state, s.from, s.to);
    o && e.dispatch({ effects: Cs.of(o) }), r.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(e, l, t);
  let a = document.createElement("span");
  return a.textContent = i.placeholderText, a.setAttribute("aria-label", n.phrase("folded code")), a.title = n.phrase("unfold"), a.className = "cm-foldPlaceholder", a.onclick = l, a;
}
const gm = /* @__PURE__ */ Ce.replace({ widget: /* @__PURE__ */ new class extends bi {
  toDOM(e) {
    return n8(e, null);
  }
}() });
class OQ extends bi {
  constructor(t) {
    super(), this.value = t;
  }
  eq(t) {
    return this.value == t.value;
  }
  toDOM(t) {
    return n8(t, this.value);
  }
}
const yQ = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Bc extends gi {
  constructor(t, n) {
    super(), this.config = t, this.open = n;
  }
  eq(t) {
    return this.config == t.config && this.open == t.open;
  }
  toDOM(t) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = t.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function bQ(e = {}) {
  let t = Object.assign(Object.assign({}, yQ), e), n = new Bc(t, !0), i = new Bc(t, !1), l = yt.fromClass(class {
    constructor(r) {
      this.from = r.viewport.from, this.markers = this.buildMarkers(r);
    }
    update(r) {
      (r.docChanged || r.viewportChanged || r.startState.facet(al) != r.state.facet(al) || r.startState.field(jl, !1) != r.state.field(jl, !1) || Rt(r.startState) != Rt(r.state) || t.foldingChanged(r)) && (this.markers = this.buildMarkers(r.view));
    }
    buildMarkers(r) {
      let s = new Ji();
      for (let o of r.viewportLineBlocks) {
        let u = Yo(r.state, o.from, o.to) ? i : qo(r.state, o.from, o.to) ? n : null;
        u && s.add(o.from, o.from, u);
      }
      return s.finish();
    }
  }), { domEventHandlers: a } = t;
  return [
    l,
    Av({
      class: "cm-foldGutter",
      markers(r) {
        var s;
        return ((s = r.plugin(l)) === null || s === void 0 ? void 0 : s.markers) || Ee.empty;
      },
      initialSpacer() {
        return new Bc(t, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, a), { click: (r, s, o) => {
        if (a.click && a.click(r, s, o))
          return !0;
        let u = Yo(r.state, s.from, s.to);
        if (u)
          return r.dispatch({ effects: Cs.of(u) }), !0;
        let c = qo(r.state, s.from, s.to);
        return c ? (r.dispatch({ effects: Gu.of(c) }), !0) : !1;
      } })
    }),
    t8()
  ];
}
const CQ = /* @__PURE__ */ me.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Ss {
  constructor(t, n) {
    this.specs = t;
    let i;
    function l(s) {
      let o = el.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + o] = s, o;
    }
    const a = typeof n.all == "string" ? n.all : n.all ? l(n.all) : void 0, r = n.scope;
    this.scope = r instanceof Nn ? (s) => s.prop(va) == r.data : r ? (s) => s == r : void 0, this.style = jv(t.map((s) => ({
      tag: s.tag,
      class: s.class || l(Object.assign({}, s, { tag: null }))
    })), {
      all: a
    }).style, this.module = i ? new el(i) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, n) {
    return new Ss(t, n || {});
  }
}
const xd = /* @__PURE__ */ ve.define(), i8 = /* @__PURE__ */ ve.define({
  combine(e) {
    return e.length ? [e[0]] : null;
  }
});
function Ec(e) {
  let t = e.facet(xd);
  return t.length ? t : e.facet(i8);
}
function kh(e, t) {
  let n = [wQ], i;
  return e instanceof Ss && (e.module && n.push(me.styleModule.of(e.module)), i = e.themeType), t != null && t.fallback ? n.push(i8.of(e)) : i ? n.push(xd.computeN([me.darkTheme], (l) => l.facet(me.darkTheme) == (i == "dark") ? [e] : [])) : n.push(xd.of(e)), n;
}
class SQ {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Rt(t.state), this.decorations = this.buildDeco(t, Ec(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let n = Rt(t.state), i = Ec(t.state), l = i != Ec(t.startState), { viewport: a } = t.view, r = t.changes.mapPos(this.decoratedTo, 1);
    n.length < a.to && !l && n.type == this.tree.type && r >= a.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = r) : (n != this.tree || t.viewportChanged || l) && (this.tree = n, this.decorations = this.buildDeco(t.view, i), this.decoratedTo = a.to);
  }
  buildDeco(t, n) {
    if (!n || !this.tree.length)
      return Ce.none;
    let i = new Ji();
    for (let { from: l, to: a } of t.visibleRanges)
      YV(this.tree, n, (r, s, o) => {
        i.add(r, s, this.markCache[o] || (this.markCache[o] = Ce.mark({ class: o })));
      }, l, a);
    return i.finish();
  }
}
const wQ = /* @__PURE__ */ cl.high(/* @__PURE__ */ yt.fromClass(SQ, {
  decorations: (e) => e.decorations
})), l8 = /* @__PURE__ */ Ss.define([
  {
    tag: R.meta,
    color: "#404740"
  },
  {
    tag: R.link,
    textDecoration: "underline"
  },
  {
    tag: R.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: R.emphasis,
    fontStyle: "italic"
  },
  {
    tag: R.strong,
    fontWeight: "bold"
  },
  {
    tag: R.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: R.keyword,
    color: "#708"
  },
  {
    tag: [R.atom, R.bool, R.url, R.contentSeparator, R.labelName],
    color: "#219"
  },
  {
    tag: [R.literal, R.inserted],
    color: "#164"
  },
  {
    tag: [R.string, R.deleted],
    color: "#a11"
  },
  {
    tag: [R.regexp, R.escape, /* @__PURE__ */ R.special(R.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ R.definition(R.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ R.local(R.variableName),
    color: "#30a"
  },
  {
    tag: [R.typeName, R.namespace],
    color: "#085"
  },
  {
    tag: R.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ R.special(R.variableName), R.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ R.definition(R.propertyName),
    color: "#00c"
  },
  {
    tag: R.comment,
    color: "#940"
  },
  {
    tag: R.invalid,
    color: "#f00"
  }
]), kQ = /* @__PURE__ */ me.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), a8 = 1e4, r8 = "()[]{}", s8 = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, {
      afterCursor: !0,
      brackets: r8,
      maxScanDistance: a8,
      renderMatch: $Q
    });
  }
}), xQ = /* @__PURE__ */ Ce.mark({ class: "cm-matchingBracket" }), PQ = /* @__PURE__ */ Ce.mark({ class: "cm-nonmatchingBracket" });
function $Q(e) {
  let t = [], n = e.matched ? xQ : PQ;
  return t.push(n.range(e.start.from, e.start.to)), e.end && t.push(n.range(e.end.from, e.end.to)), t;
}
const VQ = /* @__PURE__ */ Mt.define({
  create() {
    return Ce.none;
  },
  update(e, t) {
    if (!t.docChanged && !t.selection)
      return e;
    let n = [], i = t.state.facet(s8);
    for (let l of t.state.selection.ranges) {
      if (!l.empty)
        continue;
      let a = ui(t.state, l.head, -1, i) || l.head > 0 && ui(t.state, l.head - 1, 1, i) || i.afterCursor && (ui(t.state, l.head, 1, i) || l.head < t.state.doc.length && ui(t.state, l.head + 1, -1, i));
      a && (n = n.concat(i.renderMatch(a, t.state)));
    }
    return Ce.set(n, !0);
  },
  provide: (e) => me.decorations.from(e)
}), QQ = [
  VQ,
  kQ
];
function LQ(e = {}) {
  return [s8.of(e), QQ];
}
const MQ = /* @__PURE__ */ new Ze();
function Pd(e, t, n) {
  let i = e.prop(t < 0 ? Ze.openedBy : Ze.closedBy);
  if (i)
    return i;
  if (e.name.length == 1) {
    let l = n.indexOf(e.name);
    if (l > -1 && l % 2 == (t < 0 ? 1 : 0))
      return [n[l + t]];
  }
  return null;
}
function $d(e) {
  let t = e.type.prop(MQ);
  return t ? t(e.node) : e;
}
function ui(e, t, n, i = {}) {
  let l = i.maxScanDistance || a8, a = i.brackets || r8, r = Rt(e), s = r.resolveInner(t, n);
  for (let o = s; o; o = o.parent) {
    let u = Pd(o.type, n, a);
    if (u && o.from < o.to) {
      let c = $d(o);
      if (c && (n > 0 ? t >= c.from && t < c.to : t > c.from && t <= c.to))
        return TQ(e, t, n, o, c, u, a);
    }
  }
  return _Q(e, t, n, r, s.type, l, a);
}
function TQ(e, t, n, i, l, a, r) {
  let s = i.parent, o = { from: l.from, to: l.to }, u = 0, c = s == null ? void 0 : s.cursor();
  if (c && (n < 0 ? c.childBefore(i.from) : c.childAfter(i.to)))
    do
      if (n < 0 ? c.to <= i.from : c.from >= i.to) {
        if (u == 0 && a.indexOf(c.type.name) > -1 && c.from < c.to) {
          let d = $d(c);
          return { start: o, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (Pd(c.type, n, r))
          u++;
        else if (Pd(c.type, -n, r)) {
          if (u == 0) {
            let d = $d(c);
            return {
              start: o,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (n < 0 ? c.prevSibling() : c.nextSibling());
  return { start: o, matched: !1 };
}
function _Q(e, t, n, i, l, a, r) {
  let s = n < 0 ? e.sliceDoc(t - 1, t) : e.sliceDoc(t, t + 1), o = r.indexOf(s);
  if (o < 0 || o % 2 == 0 != n > 0)
    return null;
  let u = { from: n < 0 ? t - 1 : t, to: n > 0 ? t + 1 : t }, c = e.doc.iterRange(t, n > 0 ? e.doc.length : 0), d = 0;
  for (let f = 0; !c.next().done && f <= a; ) {
    let h = c.value;
    n < 0 && (f += h.length);
    let g = t + f * n;
    for (let v = n > 0 ? 0 : h.length - 1, p = n > 0 ? h.length : -1; v != p; v += n) {
      let O = r.indexOf(h[v]);
      if (!(O < 0 || i.resolveInner(g + v, 1).type != l))
        if (O % 2 == 0 == n > 0)
          d++;
        else {
          if (d == 1)
            return { start: u, end: { from: g + v, to: g + v + 1 }, matched: O >> 1 == o >> 1 };
          d--;
        }
    }
    n > 0 && (f += h.length);
  }
  return c.done ? { start: u, matched: !1 } : null;
}
const AQ = /* @__PURE__ */ Object.create(null), vm = [On.none], pm = [], Om = /* @__PURE__ */ Object.create(null), RQ = /* @__PURE__ */ Object.create(null);
for (let [e, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  RQ[e] = /* @__PURE__ */ ZQ(AQ, t);
function zc(e, t) {
  pm.indexOf(e) > -1 || (pm.push(e), console.warn(t));
}
function ZQ(e, t) {
  let n = [];
  for (let s of t.split(" ")) {
    let o = [];
    for (let u of s.split(".")) {
      let c = e[u] || R[u];
      c ? typeof c == "function" ? o.length ? o = o.map(c) : zc(u, `Modifier ${u} used at start of tag`) : o.length ? zc(u, `Tag ${u} used as modifier`) : o = Array.isArray(c) ? c : [c] : zc(u, `Unknown highlighting tag ${u}`);
    }
    for (let u of o)
      n.push(u);
  }
  if (!n.length)
    return 0;
  let i = t.replace(/ /g, "_"), l = i + " " + n.map((s) => s.id), a = Om[l];
  if (a)
    return a.id;
  let r = Om[l] = On.define({
    id: vm.length,
    name: i,
    props: [Wu({ [i]: n })]
  });
  return vm.push(r), r.id;
}
ot.RTL, ot.LTR;
const IQ = (e) => {
  let { state: t } = e, n = t.doc.lineAt(t.selection.main.from), i = Ph(e.state, n.from);
  return i.line ? DQ(e) : i.block ? EQ(e) : !1;
};
function xh(e, t) {
  return ({ state: n, dispatch: i }) => {
    if (n.readOnly)
      return !1;
    let l = e(t, n);
    return l ? (i(n.update(l)), !0) : !1;
  };
}
const DQ = /* @__PURE__ */ xh(
  jQ,
  0
  /* CommentOption.Toggle */
), BQ = /* @__PURE__ */ xh(
  o8,
  0
  /* CommentOption.Toggle */
), EQ = /* @__PURE__ */ xh(
  (e, t) => o8(e, t, HQ(t)),
  0
  /* CommentOption.Toggle */
);
function Ph(e, t) {
  let n = e.languageDataAt("commentTokens", t);
  return n.length ? n[0] : {};
}
const ur = 50;
function zQ(e, { open: t, close: n }, i, l) {
  let a = e.sliceDoc(i - ur, i), r = e.sliceDoc(l, l + ur), s = /\s*$/.exec(a)[0].length, o = /^\s*/.exec(r)[0].length, u = a.length - s;
  if (a.slice(u - t.length, u) == t && r.slice(o, o + n.length) == n)
    return {
      open: { pos: i - s, margin: s && 1 },
      close: { pos: l + o, margin: o && 1 }
    };
  let c, d;
  l - i <= 2 * ur ? c = d = e.sliceDoc(i, l) : (c = e.sliceDoc(i, i + ur), d = e.sliceDoc(l - ur, l));
  let f = /^\s*/.exec(c)[0].length, h = /\s*$/.exec(d)[0].length, g = d.length - h - n.length;
  return c.slice(f, f + t.length) == t && d.slice(g, g + n.length) == n ? {
    open: {
      pos: i + f + t.length,
      margin: /\s/.test(c.charAt(f + t.length)) ? 1 : 0
    },
    close: {
      pos: l - h - n.length,
      margin: /\s/.test(d.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
function HQ(e) {
  let t = [];
  for (let n of e.selection.ranges) {
    let i = e.doc.lineAt(n.from), l = n.to <= i.to ? i : e.doc.lineAt(n.to);
    l.from > i.from && l.from == n.to && (l = n.to == i.to + 1 ? i : e.doc.lineAt(n.to - 1));
    let a = t.length - 1;
    a >= 0 && t[a].to > i.from ? t[a].to = l.to : t.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: l.to });
  }
  return t;
}
function o8(e, t, n = t.selection.ranges) {
  let i = n.map((a) => Ph(t, a.from).block);
  if (!i.every((a) => a))
    return null;
  let l = n.map((a, r) => zQ(t, i[r], a.from, a.to));
  if (e != 2 && !l.every((a) => a))
    return { changes: t.changes(n.map((a, r) => l[r] ? [] : [{ from: a.from, insert: i[r].open + " " }, { from: a.to, insert: " " + i[r].close }])) };
  if (e != 1 && l.some((a) => a)) {
    let a = [];
    for (let r = 0, s; r < l.length; r++)
      if (s = l[r]) {
        let o = i[r], { open: u, close: c } = s;
        a.push({ from: u.pos - o.open.length, to: u.pos + u.margin }, { from: c.pos - c.margin, to: c.pos + o.close.length });
      }
    return { changes: a };
  }
  return null;
}
function jQ(e, t, n = t.selection.ranges) {
  let i = [], l = -1;
  for (let { from: a, to: r } of n) {
    let s = i.length, o = 1e9, u = Ph(t, a).line;
    if (u) {
      for (let c = a; c <= r; ) {
        let d = t.doc.lineAt(c);
        if (d.from > l && (a == r || r > d.from)) {
          l = d.from;
          let f = /^\s*/.exec(d.text)[0].length, h = f == d.length, g = d.text.slice(f, f + u.length) == u ? f : -1;
          f < d.text.length && f < o && (o = f), i.push({ line: d, comment: g, token: u, indent: f, empty: h, single: !1 });
        }
        c = d.to + 1;
      }
      if (o < 1e9)
        for (let c = s; c < i.length; c++)
          i[c].indent < i[c].line.text.length && (i[c].indent = o);
      i.length == s + 1 && (i[s].single = !0);
    }
  }
  if (e != 2 && i.some((a) => a.comment < 0 && (!a.empty || a.single))) {
    let a = [];
    for (let { line: s, token: o, indent: u, empty: c, single: d } of i)
      (d || !c) && a.push({ from: s.from + u, insert: o + " " });
    let r = t.changes(a);
    return { changes: r, selection: t.selection.map(r, 1) };
  } else if (e != 1 && i.some((a) => a.comment >= 0)) {
    let a = [];
    for (let { line: r, comment: s, token: o } of i)
      if (s >= 0) {
        let u = r.from + s, c = u + o.length;
        r.text[c - r.from] == " " && c++, a.push({ from: u, to: c });
      }
    return { changes: a };
  }
  return null;
}
const Vd = /* @__PURE__ */ Zi.define(), XQ = /* @__PURE__ */ Zi.define(), NQ = /* @__PURE__ */ ve.define(), u8 = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (t, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (t, n) => (i, l) => t(i, l) || n(i, l)
    });
  }
}), c8 = /* @__PURE__ */ Mt.define({
  create() {
    return ci.empty;
  },
  update(e, t) {
    let n = t.state.facet(u8), i = t.annotation(Vd);
    if (i) {
      let o = gn.fromTransaction(t, i.selection), u = i.side, c = u == 0 ? e.undone : e.done;
      return o ? c = Fo(c, c.length, n.minDepth, o) : c = m8(c, t.startState.selection), new ci(u == 0 ? i.rest : c, u == 0 ? c : i.rest);
    }
    let l = t.annotation(XQ);
    if ((l == "full" || l == "before") && (e = e.isolate()), t.annotation($t.addToHistory) === !1)
      return t.changes.empty ? e : e.addMapping(t.changes.desc);
    let a = gn.fromTransaction(t), r = t.annotation($t.time), s = t.annotation($t.userEvent);
    return a ? e = e.addChanges(a, r, s, n, t) : t.selection && (e = e.addSelection(t.startState.selection, r, s, n.newGroupDelay)), (l == "full" || l == "after") && (e = e.isolate()), e;
  },
  toJSON(e) {
    return { done: e.done.map((t) => t.toJSON()), undone: e.undone.map((t) => t.toJSON()) };
  },
  fromJSON(e) {
    return new ci(e.done.map(gn.fromJSON), e.undone.map(gn.fromJSON));
  }
});
function d8(e = {}) {
  return [
    c8,
    u8.of(e),
    me.domEventHandlers({
      beforeinput(t, n) {
        let i = t.inputType == "historyUndo" ? f8 : t.inputType == "historyRedo" ? Qd : null;
        return i ? (t.preventDefault(), i(n)) : !1;
      }
    })
  ];
}
function Ku(e, t) {
  return function({ state: n, dispatch: i }) {
    if (!t && n.readOnly)
      return !1;
    let l = n.field(c8, !1);
    if (!l)
      return !1;
    let a = l.pop(e, n, t);
    return a ? (i(a), !0) : !1;
  };
}
const f8 = /* @__PURE__ */ Ku(0, !1), Qd = /* @__PURE__ */ Ku(1, !1), qQ = /* @__PURE__ */ Ku(0, !0), YQ = /* @__PURE__ */ Ku(1, !0);
class gn {
  constructor(t, n, i, l, a) {
    this.changes = t, this.effects = n, this.mapped = i, this.startSelection = l, this.selectionsAfter = a;
  }
  setSelAfter(t) {
    return new gn(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, n, i;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((l) => l.toJSON())
    };
  }
  static fromJSON(t) {
    return new gn(t.changes && Tt.fromJSON(t.changes), [], t.mapped && fi.fromJSON(t.mapped), t.startSelection && J.fromJSON(t.startSelection), t.selectionsAfter.map(J.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, n) {
    let i = Tn;
    for (let l of t.startState.facet(NQ)) {
      let a = l(t);
      a.length && (i = i.concat(a));
    }
    return !i.length && t.changes.empty ? null : new gn(t.changes.invert(t.startState.doc), i, void 0, n || t.startState.selection, Tn);
  }
  static selection(t) {
    return new gn(void 0, Tn, void 0, void 0, t);
  }
}
function Fo(e, t, n, i) {
  let l = t + 1 > n + 20 ? t - n - 1 : 0, a = e.slice(l, t);
  return a.push(i), a;
}
function FQ(e, t) {
  let n = [], i = !1;
  return e.iterChangedRanges((l, a) => n.push(l, a)), t.iterChangedRanges((l, a, r, s) => {
    for (let o = 0; o < n.length; ) {
      let u = n[o++], c = n[o++];
      s >= u && r <= c && (i = !0);
    }
  }), i;
}
function WQ(e, t) {
  return e.ranges.length == t.ranges.length && e.ranges.filter((n, i) => n.empty != t.ranges[i].empty).length === 0;
}
function h8(e, t) {
  return e.length ? t.length ? e.concat(t) : e : t;
}
const Tn = [], UQ = 200;
function m8(e, t) {
  if (e.length) {
    let n = e[e.length - 1], i = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - UQ));
    return i.length && i[i.length - 1].eq(t) ? e : (i.push(t), Fo(e, e.length - 1, 1e9, n.setSelAfter(i)));
  } else
    return [gn.selection([t])];
}
function GQ(e) {
  let t = e[e.length - 1], n = e.slice();
  return n[e.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), n;
}
function Hc(e, t) {
  if (!e.length)
    return e;
  let n = e.length, i = Tn;
  for (; n; ) {
    let l = KQ(e[n - 1], t, i);
    if (l.changes && !l.changes.empty || l.effects.length) {
      let a = e.slice(0, n);
      return a[n - 1] = l, a;
    } else
      t = l.mapped, n--, i = l.selectionsAfter;
  }
  return i.length ? [gn.selection(i)] : Tn;
}
function KQ(e, t, n) {
  let i = h8(e.selectionsAfter.length ? e.selectionsAfter.map((s) => s.map(t)) : Tn, n);
  if (!e.changes)
    return gn.selection(i);
  let l = e.changes.map(t), a = t.mapDesc(e.changes, !0), r = e.mapped ? e.mapped.composeDesc(a) : a;
  return new gn(l, Le.mapEffects(e.effects, t), r, e.startSelection.map(a), i);
}
const JQ = /^(input\.type|delete)($|\.)/;
class ci {
  constructor(t, n, i = 0, l = void 0) {
    this.done = t, this.undone = n, this.prevTime = i, this.prevUserEvent = l;
  }
  isolate() {
    return this.prevTime ? new ci(this.done, this.undone) : this;
  }
  addChanges(t, n, i, l, a) {
    let r = this.done, s = r[r.length - 1];
    return s && s.changes && !s.changes.empty && t.changes && (!i || JQ.test(i)) && (!s.selectionsAfter.length && n - this.prevTime < l.newGroupDelay && l.joinToEvent(a, FQ(s.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? r = Fo(r, r.length - 1, l.minDepth, new gn(t.changes.compose(s.changes), h8(Le.mapEffects(t.effects, s.changes), s.effects), s.mapped, s.startSelection, Tn)) : r = Fo(r, r.length, l.minDepth, t), new ci(r, Tn, n, i);
  }
  addSelection(t, n, i, l) {
    let a = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Tn;
    return a.length > 0 && n - this.prevTime < l && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && WQ(a[a.length - 1], t) ? this : new ci(m8(this.done, t), this.undone, n, i);
  }
  addMapping(t) {
    return new ci(Hc(this.done, t), Hc(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, n, i) {
    let l = t == 0 ? this.done : this.undone;
    if (l.length == 0)
      return null;
    let a = l[l.length - 1], r = a.selectionsAfter[0] || n.selection;
    if (i && a.selectionsAfter.length)
      return n.update({
        selection: a.selectionsAfter[a.selectionsAfter.length - 1],
        annotations: Vd.of({ side: t, rest: GQ(l), selection: r }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (a.changes) {
      let s = l.length == 1 ? Tn : l.slice(0, l.length - 1);
      return a.mapped && (s = Hc(s, a.mapped)), n.update({
        changes: a.changes,
        selection: a.startSelection,
        effects: a.effects,
        annotations: Vd.of({ side: t, rest: s, selection: r }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
ci.empty = /* @__PURE__ */ new ci(Tn, Tn);
const g8 = [
  { key: "Mod-z", run: f8, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Qd, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Qd, preventDefault: !0 },
  { key: "Mod-u", run: qQ, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: YQ, preventDefault: !0 }
];
function Ka(e, t) {
  return J.create(e.ranges.map(t), e.mainIndex);
}
function Ci(e, t) {
  return e.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
function Jn({ state: e, dispatch: t }, n) {
  let i = Ka(e.selection, n);
  return i.eq(e.selection, !0) ? !1 : (t(Ci(e, i)), !0);
}
function Ju(e, t) {
  return J.cursor(t ? e.to : e.from);
}
function v8(e, t) {
  return Jn(e, (n) => n.empty ? e.moveByChar(n, t) : Ju(n, t));
}
function ln(e) {
  return e.textDirectionAt(e.state.selection.main.head) == ot.LTR;
}
const p8 = (e) => v8(e, !ln(e)), O8 = (e) => v8(e, ln(e));
function y8(e, t) {
  return Jn(e, (n) => n.empty ? e.moveByGroup(n, t) : Ju(n, t));
}
const eL = (e) => y8(e, !ln(e)), tL = (e) => y8(e, ln(e));
function nL(e, t, n) {
  if (t.type.prop(n))
    return !0;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(e.sliceDoc(t.from, t.to))) || t.firstChild;
}
function ec(e, t, n) {
  let i = Rt(e).resolveInner(t.head), l = n ? Ze.closedBy : Ze.openedBy;
  for (let o = t.head; ; ) {
    let u = n ? i.childAfter(o) : i.childBefore(o);
    if (!u)
      break;
    nL(e, u, l) ? i = u : o = n ? u.to : u.from;
  }
  let a = i.type.prop(l), r, s;
  return a && (r = n ? ui(e, i.from, 1) : ui(e, i.to, -1)) && r.matched ? s = n ? r.end.to : r.end.from : s = n ? i.to : i.from, J.cursor(s, n ? -1 : 1);
}
const iL = (e) => Jn(e, (t) => ec(e.state, t, !ln(e))), lL = (e) => Jn(e, (t) => ec(e.state, t, ln(e)));
function b8(e, t) {
  return Jn(e, (n) => {
    if (!n.empty)
      return Ju(n, t);
    let i = e.moveVertically(n, t);
    return i.head != n.head ? i : e.moveToLineBoundary(n, t);
  });
}
const C8 = (e) => b8(e, !1), S8 = (e) => b8(e, !0);
function w8(e) {
  let t = e.scrollDOM.clientHeight < e.scrollDOM.scrollHeight - 2, n = 0, i = 0, l;
  if (t) {
    for (let a of e.state.facet(me.scrollMargins)) {
      let r = a(e);
      r != null && r.top && (n = Math.max(r == null ? void 0 : r.top, n)), r != null && r.bottom && (i = Math.max(r == null ? void 0 : r.bottom, i));
    }
    l = e.scrollDOM.clientHeight - n - i;
  } else
    l = (e.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: i,
    selfScroll: t,
    height: Math.max(e.defaultLineHeight, l - 5)
  };
}
function k8(e, t) {
  let n = w8(e), { state: i } = e, l = Ka(i.selection, (r) => r.empty ? e.moveVertically(r, t, n.height) : Ju(r, t));
  if (l.eq(i.selection))
    return !1;
  let a;
  if (n.selfScroll) {
    let r = e.coordsAtPos(i.selection.main.head), s = e.scrollDOM.getBoundingClientRect(), o = s.top + n.marginTop, u = s.bottom - n.marginBottom;
    r && r.top > o && r.bottom < u && (a = me.scrollIntoView(l.main.head, { y: "start", yMargin: r.top - o }));
  }
  return e.dispatch(Ci(i, l), { effects: a }), !0;
}
const ym = (e) => k8(e, !1), Ld = (e) => k8(e, !0);
function dl(e, t, n) {
  let i = e.lineBlockAt(t.head), l = e.moveToLineBoundary(t, n);
  if (l.head == t.head && l.head != (n ? i.to : i.from) && (l = e.moveToLineBoundary(t, n, !1)), !n && l.head == i.from && i.length) {
    let a = /^\s*/.exec(e.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    a && t.head != i.from + a && (l = J.cursor(i.from + a));
  }
  return l;
}
const aL = (e) => Jn(e, (t) => dl(e, t, !0)), rL = (e) => Jn(e, (t) => dl(e, t, !1)), sL = (e) => Jn(e, (t) => dl(e, t, !ln(e))), oL = (e) => Jn(e, (t) => dl(e, t, ln(e))), uL = (e) => Jn(e, (t) => J.cursor(e.lineBlockAt(t.head).from, 1)), cL = (e) => Jn(e, (t) => J.cursor(e.lineBlockAt(t.head).to, -1));
function dL(e, t, n) {
  let i = !1, l = Ka(e.selection, (a) => {
    let r = ui(e, a.head, -1) || ui(e, a.head, 1) || a.head > 0 && ui(e, a.head - 1, 1) || a.head < e.doc.length && ui(e, a.head + 1, -1);
    if (!r || !r.end)
      return a;
    i = !0;
    let s = r.start.from == a.head ? r.end.to : r.end.from;
    return J.cursor(s);
  });
  return i ? (t(Ci(e, l)), !0) : !1;
}
const fL = ({ state: e, dispatch: t }) => dL(e, t);
function zn(e, t) {
  let n = Ka(e.state.selection, (i) => {
    let l = t(i);
    return J.range(i.anchor, l.head, l.goalColumn, l.bidiLevel || void 0);
  });
  return n.eq(e.state.selection) ? !1 : (e.dispatch(Ci(e.state, n)), !0);
}
function x8(e, t) {
  return zn(e, (n) => e.moveByChar(n, t));
}
const P8 = (e) => x8(e, !ln(e)), $8 = (e) => x8(e, ln(e));
function V8(e, t) {
  return zn(e, (n) => e.moveByGroup(n, t));
}
const hL = (e) => V8(e, !ln(e)), mL = (e) => V8(e, ln(e)), gL = (e) => zn(e, (t) => ec(e.state, t, !ln(e))), vL = (e) => zn(e, (t) => ec(e.state, t, ln(e)));
function Q8(e, t) {
  return zn(e, (n) => e.moveVertically(n, t));
}
const L8 = (e) => Q8(e, !1), M8 = (e) => Q8(e, !0);
function T8(e, t) {
  return zn(e, (n) => e.moveVertically(n, t, w8(e).height));
}
const bm = (e) => T8(e, !1), Cm = (e) => T8(e, !0), pL = (e) => zn(e, (t) => dl(e, t, !0)), OL = (e) => zn(e, (t) => dl(e, t, !1)), yL = (e) => zn(e, (t) => dl(e, t, !ln(e))), bL = (e) => zn(e, (t) => dl(e, t, ln(e))), CL = (e) => zn(e, (t) => J.cursor(e.lineBlockAt(t.head).from)), SL = (e) => zn(e, (t) => J.cursor(e.lineBlockAt(t.head).to)), Sm = ({ state: e, dispatch: t }) => (t(Ci(e, { anchor: 0 })), !0), wm = ({ state: e, dispatch: t }) => (t(Ci(e, { anchor: e.doc.length })), !0), km = ({ state: e, dispatch: t }) => (t(Ci(e, { anchor: e.selection.main.anchor, head: 0 })), !0), xm = ({ state: e, dispatch: t }) => (t(Ci(e, { anchor: e.selection.main.anchor, head: e.doc.length })), !0), wL = ({ state: e, dispatch: t }) => (t(e.update({ selection: { anchor: 0, head: e.doc.length }, userEvent: "select" })), !0), kL = ({ state: e, dispatch: t }) => {
  let n = tc(e).map(({ from: i, to: l }) => J.range(i, Math.min(l + 1, e.doc.length)));
  return t(e.update({ selection: J.create(n), userEvent: "select" })), !0;
}, xL = ({ state: e, dispatch: t }) => {
  let n = Ka(e.selection, (i) => {
    let l = Rt(e), a = l.resolveStack(i.from, 1);
    if (i.empty) {
      let r = l.resolveStack(i.from, -1);
      r.node.from >= a.node.from && r.node.to <= a.node.to && (a = r);
    }
    for (let r = a; r; r = r.next) {
      let { node: s } = r;
      if ((s.from < i.from && s.to >= i.to || s.to > i.to && s.from <= i.from) && r.next)
        return J.range(s.to, s.from);
    }
    return i;
  });
  return n.eq(e.selection) ? !1 : (t(Ci(e, n)), !0);
}, PL = ({ state: e, dispatch: t }) => {
  let n = e.selection, i = null;
  return n.ranges.length > 1 ? i = J.create([n.main]) : n.main.empty || (i = J.create([J.cursor(n.main.head)])), i ? (t(Ci(e, i)), !0) : !1;
};
function ws(e, t) {
  if (e.state.readOnly)
    return !1;
  let n = "delete.selection", { state: i } = e, l = i.changeByRange((a) => {
    let { from: r, to: s } = a;
    if (r == s) {
      let o = t(a);
      o < r ? (n = "delete.backward", o = Gs(e, o, !1)) : o > r && (n = "delete.forward", o = Gs(e, o, !0)), r = Math.min(r, o), s = Math.max(s, o);
    } else
      r = Gs(e, r, !1), s = Gs(e, s, !0);
    return r == s ? { range: a } : { changes: { from: r, to: s }, range: J.cursor(r, r < a.head ? -1 : 1) };
  });
  return l.changes.empty ? !1 : (e.dispatch(i.update(l, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? me.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Gs(e, t, n) {
  if (e instanceof me)
    for (let i of e.state.facet(me.atomicRanges).map((l) => l(e)))
      i.between(t, t, (l, a) => {
        l < t && a > t && (t = n ? a : l);
      });
  return t;
}
const _8 = (e, t, n) => ws(e, (i) => {
  let l = i.from, { state: a } = e, r = a.doc.lineAt(l), s, o;
  if (n && !t && l > r.from && l < r.from + 200 && !/[^ \t]/.test(s = r.text.slice(0, l - r.from))) {
    if (s[s.length - 1] == "	")
      return l - 1;
    let u = Ga(s, a.tabSize), c = u % No(a) || No(a);
    for (let d = 0; d < c && s[s.length - 1 - d] == " "; d++)
      l--;
    o = l;
  } else
    o = qt(r.text, l - r.from, t, t) + r.from, o == l && r.number != (t ? a.doc.lines : 1) ? o += t ? 1 : -1 : !t && /[\ufe00-\ufe0f]/.test(r.text.slice(o - r.from, l - r.from)) && (o = qt(r.text, o - r.from, !1, !1) + r.from);
  return o;
}), Md = (e) => _8(e, !1, !0), A8 = (e) => _8(e, !0, !1), R8 = (e, t) => ws(e, (n) => {
  let i = n.head, { state: l } = e, a = l.doc.lineAt(i), r = l.charCategorizer(i);
  for (let s = null; ; ) {
    if (i == (t ? a.to : a.from)) {
      i == n.head && a.number != (t ? l.doc.lines : 1) && (i += t ? 1 : -1);
      break;
    }
    let o = qt(a.text, i - a.from, t) + a.from, u = a.text.slice(Math.min(i, o) - a.from, Math.max(i, o) - a.from), c = r(u);
    if (s != null && c != s)
      break;
    (u != " " || i != n.head) && (s = c), i = o;
  }
  return i;
}), Z8 = (e) => R8(e, !1), $L = (e) => R8(e, !0), VL = (e) => ws(e, (t) => {
  let n = e.lineBlockAt(t.head).to;
  return t.head < n ? n : Math.min(e.state.doc.length, t.head + 1);
}), QL = (e) => ws(e, (t) => {
  let n = e.moveToLineBoundary(t, !1).head;
  return t.head > n ? n : Math.max(0, t.head - 1);
}), LL = (e) => ws(e, (t) => {
  let n = e.moveToLineBoundary(t, !0).head;
  return t.head < n ? n : Math.min(e.state.doc.length, t.head + 1);
}), ML = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = e.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: Ne.of(["", ""]) },
    range: J.cursor(i.from)
  }));
  return t(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, TL = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = e.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == e.doc.length)
      return { range: i };
    let l = i.from, a = e.doc.lineAt(l), r = l == a.from ? l - 1 : qt(a.text, l - a.from, !1) + a.from, s = l == a.to ? l + 1 : qt(a.text, l - a.from, !0) + a.from;
    return {
      changes: { from: r, to: s, insert: e.doc.slice(l, s).append(e.doc.slice(r, l)) },
      range: J.cursor(s)
    };
  });
  return n.changes.empty ? !1 : (t(e.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function tc(e) {
  let t = [], n = -1;
  for (let i of e.selection.ranges) {
    let l = e.doc.lineAt(i.from), a = e.doc.lineAt(i.to);
    if (!i.empty && i.to == a.from && (a = e.doc.lineAt(i.to - 1)), n >= l.number) {
      let r = t[t.length - 1];
      r.to = a.to, r.ranges.push(i);
    } else
      t.push({ from: l.from, to: a.to, ranges: [i] });
    n = a.number + 1;
  }
  return t;
}
function I8(e, t, n) {
  if (e.readOnly)
    return !1;
  let i = [], l = [];
  for (let a of tc(e)) {
    if (n ? a.to == e.doc.length : a.from == 0)
      continue;
    let r = e.doc.lineAt(n ? a.to + 1 : a.from - 1), s = r.length + 1;
    if (n) {
      i.push({ from: a.to, to: r.to }, { from: a.from, insert: r.text + e.lineBreak });
      for (let o of a.ranges)
        l.push(J.range(Math.min(e.doc.length, o.anchor + s), Math.min(e.doc.length, o.head + s)));
    } else {
      i.push({ from: r.from, to: a.from }, { from: a.to, insert: e.lineBreak + r.text });
      for (let o of a.ranges)
        l.push(J.range(o.anchor - s, o.head - s));
    }
  }
  return i.length ? (t(e.update({
    changes: i,
    scrollIntoView: !0,
    selection: J.create(l, e.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const _L = ({ state: e, dispatch: t }) => I8(e, t, !1), AL = ({ state: e, dispatch: t }) => I8(e, t, !0);
function D8(e, t, n) {
  if (e.readOnly)
    return !1;
  let i = [];
  for (let l of tc(e))
    n ? i.push({ from: l.from, insert: e.doc.slice(l.from, l.to) + e.lineBreak }) : i.push({ from: l.to, insert: e.lineBreak + e.doc.slice(l.from, l.to) });
  return t(e.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const RL = ({ state: e, dispatch: t }) => D8(e, t, !1), ZL = ({ state: e, dispatch: t }) => D8(e, t, !0), IL = (e) => {
  if (e.state.readOnly)
    return !1;
  let { state: t } = e, n = t.changes(tc(t).map(({ from: l, to: a }) => (l > 0 ? l-- : a < t.doc.length && a++, { from: l, to: a }))), i = Ka(t.selection, (l) => {
    let a;
    if (e.lineWrapping) {
      let r = e.lineBlockAt(l.head), s = e.coordsAtPos(l.head, l.assoc || 1);
      s && (a = r.bottom + e.documentTop - s.bottom + e.defaultLineHeight / 2);
    }
    return e.moveVertically(l, !0, a);
  }).map(n);
  return e.dispatch({ changes: n, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function DL(e, t) {
  if (/\(\)|\[\]|\{\}/.test(e.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let n = Rt(e).resolveInner(t), i = n.childBefore(t), l = n.childAfter(t), a;
  return i && l && i.to <= t && l.from >= t && (a = i.type.prop(Ze.closedBy)) && a.indexOf(l.name) > -1 && e.doc.lineAt(i.to).from == e.doc.lineAt(l.from).from && !/\S/.test(e.sliceDoc(i.to, l.from)) ? { from: i.to, to: l.from } : null;
}
const Pm = /* @__PURE__ */ B8(!1), BL = /* @__PURE__ */ B8(!0);
function B8(e) {
  return ({ state: t, dispatch: n }) => {
    if (t.readOnly)
      return !1;
    let i = t.changeByRange((l) => {
      let { from: a, to: r } = l, s = t.doc.lineAt(a), o = !e && a == r && DL(t, a);
      e && (a = r = (r <= s.to ? s : t.doc.lineAt(r)).to);
      let u = new Uu(t, { simulateBreak: a, simulateDoubleBreak: !!o }), c = bh(u, a);
      for (c == null && (c = Ga(/^\s*/.exec(t.doc.lineAt(a).text)[0], t.tabSize)); r < s.to && /\s/.test(s.text[r - s.from]); )
        r++;
      o ? { from: a, to: r } = o : a > s.from && a < s.from + 100 && !/\S/.test(s.text.slice(0, a)) && (a = s.from);
      let d = ["", Fr(t, c)];
      return o && d.push(Fr(t, u.lineIndent(s.from, -1))), {
        changes: { from: a, to: r, insert: Ne.of(d) },
        range: J.cursor(a + 1 + d[1].length)
      };
    });
    return n(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function $h(e, t) {
  let n = -1;
  return e.changeByRange((i) => {
    let l = [];
    for (let r = i.from; r <= i.to; ) {
      let s = e.doc.lineAt(r);
      s.number > n && (i.empty || i.to > s.from) && (t(s, l, i), n = s.number), r = s.to + 1;
    }
    let a = e.changes(l);
    return {
      changes: l,
      range: J.range(a.mapPos(i.anchor, 1), a.mapPos(i.head, 1))
    };
  });
}
const EL = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), i = new Uu(e, { overrideIndentation: (a) => {
    let r = n[a];
    return r ?? -1;
  } }), l = $h(e, (a, r, s) => {
    let o = bh(i, a.from);
    if (o == null)
      return;
    /\S/.test(a.text) || (o = 0);
    let u = /^\s*/.exec(a.text)[0], c = Fr(e, o);
    (u != c || s.from < a.from + u.length) && (n[a.from] = o, r.push({ from: a.from, to: a.from + u.length, insert: c }));
  });
  return l.changes.empty || t(e.update(l, { userEvent: "indent" })), !0;
}, E8 = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update($h(e, (n, i) => {
  i.push({ from: n.from, insert: e.facet(bs) });
}), { userEvent: "input.indent" })), !0), z8 = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update($h(e, (n, i) => {
  let l = /^\s*/.exec(n.text)[0];
  if (!l)
    return;
  let a = Ga(l, e.tabSize), r = 0, s = Fr(e, Math.max(0, a - No(e)));
  for (; r < l.length && r < s.length && l.charCodeAt(r) == s.charCodeAt(r); )
    r++;
  i.push({ from: n.from + r, to: n.from + l.length, insert: s.slice(r) });
}), { userEvent: "delete.dedent" })), !0), zL = (e) => (e.setTabFocusMode(), !0), HL = [
  { key: "Ctrl-b", run: p8, shift: P8, preventDefault: !0 },
  { key: "Ctrl-f", run: O8, shift: $8 },
  { key: "Ctrl-p", run: C8, shift: L8 },
  { key: "Ctrl-n", run: S8, shift: M8 },
  { key: "Ctrl-a", run: uL, shift: CL },
  { key: "Ctrl-e", run: cL, shift: SL },
  { key: "Ctrl-d", run: A8 },
  { key: "Ctrl-h", run: Md },
  { key: "Ctrl-k", run: VL },
  { key: "Ctrl-Alt-h", run: Z8 },
  { key: "Ctrl-o", run: ML },
  { key: "Ctrl-t", run: TL },
  { key: "Ctrl-v", run: Ld }
], jL = /* @__PURE__ */ [
  { key: "ArrowLeft", run: p8, shift: P8, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: eL, shift: hL, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: sL, shift: yL, preventDefault: !0 },
  { key: "ArrowRight", run: O8, shift: $8, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: tL, shift: mL, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: oL, shift: bL, preventDefault: !0 },
  { key: "ArrowUp", run: C8, shift: L8, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Sm, shift: km },
  { mac: "Ctrl-ArrowUp", run: ym, shift: bm },
  { key: "ArrowDown", run: S8, shift: M8, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: wm, shift: xm },
  { mac: "Ctrl-ArrowDown", run: Ld, shift: Cm },
  { key: "PageUp", run: ym, shift: bm },
  { key: "PageDown", run: Ld, shift: Cm },
  { key: "Home", run: rL, shift: OL, preventDefault: !0 },
  { key: "Mod-Home", run: Sm, shift: km },
  { key: "End", run: aL, shift: pL, preventDefault: !0 },
  { key: "Mod-End", run: wm, shift: xm },
  { key: "Enter", run: Pm, shift: Pm },
  { key: "Mod-a", run: wL },
  { key: "Backspace", run: Md, shift: Md },
  { key: "Delete", run: A8 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Z8 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: $L },
  { mac: "Mod-Backspace", run: QL },
  { mac: "Mod-Delete", run: LL }
].concat(/* @__PURE__ */ HL.map((e) => ({ mac: e.key, run: e.run, shift: e.shift }))), Wo = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: iL, shift: gL },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: lL, shift: vL },
  { key: "Alt-ArrowUp", run: _L },
  { key: "Shift-Alt-ArrowUp", run: RL },
  { key: "Alt-ArrowDown", run: AL },
  { key: "Shift-Alt-ArrowDown", run: ZL },
  { key: "Escape", run: PL },
  { key: "Mod-Enter", run: BL },
  { key: "Alt-l", mac: "Ctrl-l", run: kL },
  { key: "Mod-i", run: xL, preventDefault: !0 },
  { key: "Mod-[", run: z8 },
  { key: "Mod-]", run: E8 },
  { key: "Mod-Alt-\\", run: EL },
  { key: "Shift-Mod-k", run: IL },
  { key: "Shift-Mod-\\", run: fL },
  { key: "Mod-/", run: IQ },
  { key: "Alt-A", run: BQ },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: zL }
].concat(jL), XL = { key: "Tab", run: E8, shift: z8 };
function tt() {
  var e = arguments[0];
  typeof e == "string" && (e = document.createElement(e));
  var t = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var i in n) if (Object.prototype.hasOwnProperty.call(n, i)) {
      var l = n[i];
      typeof l == "string" ? e.setAttribute(i, l) : l != null && (e[i] = l);
    }
    t++;
  }
  for (; t < arguments.length; t++) H8(e, arguments[t]);
  return e;
}
function H8(e, t) {
  if (typeof t == "string")
    e.appendChild(document.createTextNode(t));
  else if (t != null) if (t.nodeType != null)
    e.appendChild(t);
  else if (Array.isArray(t))
    for (var n = 0; n < t.length; n++) H8(e, t[n]);
  else
    throw new RangeError("Unsupported child node: " + t);
}
class NL {
  constructor(t, n, i) {
    this.from = t, this.to = n, this.diagnostic = i;
  }
}
class Ol {
  constructor(t, n, i) {
    this.diagnostics = t, this.panel = n, this.selected = i;
  }
  static init(t, n, i) {
    let l = t, a = i.facet(di).markerFilter;
    a && (l = a(l, i));
    let r = Ce.set(l.map((s) => s.from == s.to || s.from == s.to - 1 && i.doc.lineAt(s.from).to == s.from ? Ce.widget({
      widget: new tM(s),
      diagnostic: s
    }).range(s.from) : Ce.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + s.severity + (s.markClass ? " " + s.markClass : "") },
      diagnostic: s
    }).range(s.from, s.to)), !0);
    return new Ol(r, n, Ba(r));
  }
}
function Ba(e, t = null, n = 0) {
  let i = null;
  return e.between(n, 1e9, (l, a, { spec: r }) => {
    if (!(t && r.diagnostic != t))
      return i = new NL(l, a, r.diagnostic), !1;
  }), i;
}
function j8(e, t) {
  let n = t.pos, i = t.end || n, l = e.state.facet(di).hideOn(e, n, i);
  if (l != null)
    return l;
  let a = e.startState.doc.lineAt(t.pos);
  return !!(e.effects.some((r) => r.is(nc)) || e.changes.touchesRange(a.from, Math.max(a.to, i)));
}
function X8(e, t) {
  return e.field(vn, !1) ? t : t.concat(Le.appendConfig.of(K8));
}
function qL(e, t) {
  return {
    effects: X8(e, [nc.of(t)])
  };
}
const nc = /* @__PURE__ */ Le.define(), Vh = /* @__PURE__ */ Le.define(), N8 = /* @__PURE__ */ Le.define(), vn = /* @__PURE__ */ Mt.define({
  create() {
    return new Ol(Ce.none, null, null);
  },
  update(e, t) {
    if (t.docChanged && e.diagnostics.size) {
      let n = e.diagnostics.map(t.changes), i = null, l = e.panel;
      if (e.selected) {
        let a = t.changes.mapPos(e.selected.from, 1);
        i = Ba(n, e.selected.diagnostic, a) || Ba(n, null, a);
      }
      !n.size && l && t.state.facet(di).autoPanel && (l = null), e = new Ol(n, l, i);
    }
    for (let n of t.effects)
      if (n.is(nc)) {
        let i = t.state.facet(di).autoPanel ? n.value.length ? Wr.open : null : e.panel;
        e = Ol.init(n.value, i, t.state);
      } else n.is(Vh) ? e = new Ol(e.diagnostics, n.value ? Wr.open : null, e.selected) : n.is(N8) && (e = new Ol(e.diagnostics, e.panel, n.value));
    return e;
  },
  provide: (e) => [
    qr.from(e, (t) => t.panel),
    me.decorations.from(e, (t) => t.diagnostics)
  ]
});
function YL(e) {
  let t = e.field(vn, !1);
  return t ? t.diagnostics.size : 0;
}
const FL = /* @__PURE__ */ Ce.mark({ class: "cm-lintRange cm-lintRange-active" });
function WL(e, t, n) {
  let { diagnostics: i } = e.state.field(vn), l = [], a = 2e8, r = 0;
  i.between(t - (n < 0 ? 1 : 0), t + (n > 0 ? 1 : 0), (o, u, { spec: c }) => {
    t >= o && t <= u && (o == u || (t > o || n > 0) && (t < u || n < 0)) && (l.push(c.diagnostic), a = Math.min(o, a), r = Math.max(u, r));
  });
  let s = e.state.facet(di).tooltipFilter;
  return s && (l = s(l, e.state)), l.length ? {
    pos: a,
    end: r,
    above: e.state.doc.lineAt(a).to < r,
    create() {
      return { dom: q8(e, l) };
    }
  } : null;
}
function q8(e, t) {
  return tt("ul", { class: "cm-tooltip-lint" }, t.map((n) => W8(e, n, !1)));
}
const UL = (e) => {
  let t = e.state.field(vn, !1);
  (!t || !t.panel) && e.dispatch({ effects: X8(e.state, [Vh.of(!0)]) });
  let n = Nr(e, Wr.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, $m = (e) => {
  let t = e.state.field(vn, !1);
  return !t || !t.panel ? !1 : (e.dispatch({ effects: Vh.of(!1) }), !0);
}, GL = (e) => {
  let t = e.state.field(vn, !1);
  if (!t)
    return !1;
  let n = e.state.selection.main, i = t.diagnostics.iter(n.to + 1);
  return !i.value && (i = t.diagnostics.iter(0), !i.value || i.from == n.from && i.to == n.to) ? !1 : (e.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, KL = [
  { key: "Mod-Shift-m", run: UL, preventDefault: !0 },
  { key: "F8", run: GL }
], Y8 = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.view = e, this.timeout = -1, this.set = !0;
    let { delay: t } = e.state.facet(di);
    this.lintTime = Date.now() + t, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, t);
  }
  run() {
    clearTimeout(this.timeout);
    let e = Date.now();
    if (e < this.lintTime - 10)
      this.timeout = setTimeout(this.run, this.lintTime - e);
    else {
      this.set = !1;
      let { state: t } = this.view, { sources: n } = t.facet(di);
      n.length && JL(n.map((i) => Promise.resolve(i(this.view))), (i) => {
        this.view.state.doc == t.doc && this.view.dispatch(qL(this.view.state, i.reduce((l, a) => l.concat(a))));
      }, (i) => {
        sn(this.view.state, i);
      });
    }
  }
  update(e) {
    let t = e.state.facet(di);
    (e.docChanged || t != e.startState.facet(di) || t.needsRefresh && t.needsRefresh(e)) && (this.lintTime = Date.now() + t.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, t.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function JL(e, t, n) {
  let i = [], l = -1;
  for (let a of e)
    a.then((r) => {
      i.push(r), clearTimeout(l), i.length == e.length ? t(i) : setTimeout(() => t(i), 200);
    }, n);
}
const di = /* @__PURE__ */ ve.define({
  combine(e) {
    return Object.assign({ sources: e.map((t) => t.source).filter((t) => t != null) }, Kn(e.map((t) => t.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (t, n) => t ? n ? (i) => t(i) || n(i) : t : n
    }));
  }
});
function eM(e, t = {}) {
  return [
    di.of({ source: e, config: t }),
    Y8,
    K8
  ];
}
function Vm(e) {
  let t = e.plugin(Y8);
  t && t.force();
}
function F8(e) {
  let t = [];
  if (e)
    e: for (let { name: n } of e) {
      for (let i = 0; i < n.length; i++) {
        let l = n[i];
        if (/[a-zA-Z]/.test(l) && !t.some((a) => a.toLowerCase() == l.toLowerCase())) {
          t.push(l);
          continue e;
        }
      }
      t.push("");
    }
  return t;
}
function W8(e, t, n) {
  var i;
  let l = n ? F8(t.actions) : [];
  return tt("li", { class: "cm-diagnostic cm-diagnostic-" + t.severity }, tt("span", { class: "cm-diagnosticText" }, t.renderMessage ? t.renderMessage(e) : t.message), (i = t.actions) === null || i === void 0 ? void 0 : i.map((a, r) => {
    let s = !1, o = (f) => {
      if (f.preventDefault(), s)
        return;
      s = !0;
      let h = Ba(e.state.field(vn).diagnostics, t);
      h && a.apply(e, h.from, h.to);
    }, { name: u } = a, c = l[r] ? u.indexOf(l[r]) : -1, d = c < 0 ? u : [
      u.slice(0, c),
      tt("u", u.slice(c, c + 1)),
      u.slice(c + 1)
    ];
    return tt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: o,
      onmousedown: o,
      "aria-label": ` Action: ${u}${c < 0 ? "" : ` (access key "${l[r]})"`}.`
    }, d);
  }), t.source && tt("div", { class: "cm-diagnosticSource" }, t.source));
}
class tM extends bi {
  constructor(t) {
    super(), this.diagnostic = t;
  }
  eq(t) {
    return t.diagnostic == this.diagnostic;
  }
  toDOM() {
    return tt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class Qm {
  constructor(t, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = W8(t, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Wr {
  constructor(t) {
    this.view = t, this.items = [];
    let n = (l) => {
      if (l.keyCode == 27)
        $m(this.view), this.view.focus();
      else if (l.keyCode == 38 || l.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (l.keyCode == 40 || l.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (l.keyCode == 36)
        this.moveSelection(0);
      else if (l.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (l.keyCode == 13)
        this.view.focus();
      else if (l.keyCode >= 65 && l.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: a } = this.items[this.selectedIndex], r = F8(a.actions);
        for (let s = 0; s < r.length; s++)
          if (r[s].toUpperCase().charCodeAt(0) == l.keyCode) {
            let o = Ba(this.view.state.field(vn).diagnostics, a);
            o && a.actions[s].apply(t, o.from, o.to);
          }
      } else
        return;
      l.preventDefault();
    }, i = (l) => {
      for (let a = 0; a < this.items.length; a++)
        this.items[a].dom.contains(l.target) && this.moveSelection(a);
    };
    this.list = tt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: i
    }), this.dom = tt("div", { class: "cm-panel-lint" }, this.list, tt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => $m(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let t = this.view.state.field(vn).selected;
    if (!t)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == t.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: t, selected: n } = this.view.state.field(vn), i = 0, l = !1, a = null;
    for (t.between(0, this.view.state.doc.length, (r, s, { spec: o }) => {
      let u = -1, c;
      for (let d = i; d < this.items.length; d++)
        if (this.items[d].diagnostic == o.diagnostic) {
          u = d;
          break;
        }
      u < 0 ? (c = new Qm(this.view, o.diagnostic), this.items.splice(i, 0, c), l = !0) : (c = this.items[u], u > i && (this.items.splice(i, u - i), l = !0)), n && c.diagnostic == n.diagnostic ? c.dom.hasAttribute("aria-selected") || (c.dom.setAttribute("aria-selected", "true"), a = c) : c.dom.hasAttribute("aria-selected") && c.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      l = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new Qm(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), l = !0), a ? (this.list.setAttribute("aria-activedescendant", a.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: a.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: r, panel: s }) => {
        let o = s.height / this.list.offsetHeight;
        r.top < s.top ? this.list.scrollTop -= (s.top - r.top) / o : r.bottom > s.bottom && (this.list.scrollTop += (r.bottom - s.bottom) / o);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), l && this.sync();
  }
  sync() {
    let t = this.list.firstChild;
    function n() {
      let i = t;
      t = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; t != i.dom; )
          n();
        t = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, t);
    for (; t; )
      n();
  }
  moveSelection(t) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(vn), i = Ba(n.diagnostics, this.items[t].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: N8.of(i)
    });
  }
  static open(t) {
    return new Wr(t);
  }
}
function po(e, t = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(e)}</svg>')`;
}
function Ks(e) {
  return po(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${e}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const nM = /* @__PURE__ */ me.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Ks("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Ks("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Ks("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Ks("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function Lm(e) {
  return e == "error" ? 4 : e == "warning" ? 3 : e == "info" ? 2 : 1;
}
class U8 extends gi {
  constructor(t) {
    super(), this.diagnostics = t, this.severity = t.reduce((n, i) => Lm(n) < Lm(i.severity) ? i.severity : n, "hint");
  }
  toDOM(t) {
    let n = document.createElement("div");
    n.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let i = this.diagnostics, l = t.state.facet(ic).tooltipFilter;
    return l && (i = l(i, t.state)), i.length && (n.onmouseover = () => lM(t, n, i)), n;
  }
}
function iM(e, t) {
  let n = (i) => {
    let l = t.getBoundingClientRect();
    if (!(i.clientX > l.left - 10 && i.clientX < l.right + 10 && i.clientY > l.top - 10 && i.clientY < l.bottom + 10)) {
      for (let a = i.target; a; a = a.parentNode)
        if (a.nodeType == 1 && a.classList.contains("cm-tooltip-lint"))
          return;
      window.removeEventListener("mousemove", n), e.state.field(G8) && e.dispatch({ effects: Qh.of(null) });
    }
  };
  window.addEventListener("mousemove", n);
}
function lM(e, t, n) {
  function i() {
    let r = e.elementAtHeight(t.getBoundingClientRect().top + 5 - e.documentTop);
    e.coordsAtPos(r.from) && e.dispatch({ effects: Qh.of({
      pos: r.from,
      above: !1,
      create() {
        return {
          dom: q8(e, n),
          getCoords: () => t.getBoundingClientRect()
        };
      }
    }) }), t.onmouseout = t.onmousemove = null, iM(e, t);
  }
  let { hoverTime: l } = e.state.facet(ic), a = setTimeout(i, l);
  t.onmouseout = () => {
    clearTimeout(a), t.onmouseout = t.onmousemove = null;
  }, t.onmousemove = () => {
    clearTimeout(a), a = setTimeout(i, l);
  };
}
function aM(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let l of t) {
    let a = e.lineAt(l.from);
    (n[a.from] || (n[a.from] = [])).push(l);
  }
  let i = [];
  for (let l in n)
    i.push(new U8(n[l]).range(+l));
  return Ee.of(i, !0);
}
const rM = /* @__PURE__ */ Av({
  class: "cm-gutter-lint",
  markers: (e) => e.state.field(Td),
  widgetMarker: (e, t, n) => {
    let i = [];
    return e.state.field(Td).between(n.from, n.to, (l, a, r) => {
      i.push(...r.diagnostics);
    }), i.length ? new U8(i) : null;
  }
}), Td = /* @__PURE__ */ Mt.define({
  create() {
    return Ee.empty;
  },
  update(e, t) {
    e = e.map(t.changes);
    let n = t.state.facet(ic).markerFilter;
    for (let i of t.effects)
      if (i.is(nc)) {
        let l = i.value;
        n && (l = n(l || [], t.state)), e = aM(t.state.doc, l.slice(0));
      }
    return e;
  }
}), Qh = /* @__PURE__ */ Le.define(), G8 = /* @__PURE__ */ Mt.define({
  create() {
    return null;
  },
  update(e, t) {
    return e && t.docChanged && (e = j8(t, e) ? null : Object.assign(Object.assign({}, e), { pos: t.changes.mapPos(e.pos) })), t.effects.reduce((n, i) => i.is(Qh) ? i.value : n, e);
  },
  provide: (e) => Yu.from(e)
}), sM = /* @__PURE__ */ me.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: /* @__PURE__ */ po('<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>')
  },
  ".cm-lint-marker-warning": {
    content: /* @__PURE__ */ po('<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>')
  },
  ".cm-lint-marker-error": {
    content: /* @__PURE__ */ po('<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>')
  }
}), K8 = [
  vn,
  /* @__PURE__ */ me.decorations.compute([vn], (e) => {
    let { selected: t, panel: n } = e.field(vn);
    return !t || !n || t.from == t.to ? Ce.none : Ce.set([
      FL.range(t.from, t.to)
    ]);
  }),
  /* @__PURE__ */ bV(WL, { hideOn: j8 }),
  nM
], ic = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});
function oM(e = {}) {
  return [ic.of(e), Td, rM, sM, G8];
}
const Mm = typeof String.prototype.normalize == "function" ? (e) => e.normalize("NFKD") : (e) => e;
class Ea {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(t, n, i = 0, l = t.length, a, r) {
    this.test = r, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = t.iterRange(i, l), this.bufferStart = i, this.normalize = a ? (s) => a(Mm(s)) : Mm, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Ht(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let t = this.peek();
      if (t < 0)
        return this.done = !0, this;
      let n = th(t), i = this.bufferStart + this.bufferPos;
      this.bufferPos += Ln(t);
      let l = this.normalize(n);
      if (l.length)
        for (let a = 0, r = i; ; a++) {
          let s = l.charCodeAt(a), o = this.match(s, r, this.bufferPos + this.bufferStart);
          if (a == l.length - 1) {
            if (o)
              return this.value = o, this;
            break;
          }
          r == i && a < n.length && n.charCodeAt(a) == s && r++;
        }
    }
  }
  match(t, n, i) {
    let l = null;
    for (let a = 0; a < this.matches.length; a += 2) {
      let r = this.matches[a], s = !1;
      this.query.charCodeAt(r) == t && (r == this.query.length - 1 ? l = { from: this.matches[a + 1], to: i } : (this.matches[a]++, s = !0)), s || (this.matches.splice(a, 2), a -= 2);
    }
    return this.query.charCodeAt(0) == t && (this.query.length == 1 ? l = { from: n, to: i } : this.matches.push(1, n)), l && this.test && !this.test(l.from, l.to, this.buffer, this.bufferStart) && (l = null), l;
  }
}
typeof Symbol < "u" && (Ea.prototype[Symbol.iterator] = function() {
  return this;
});
const J8 = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Lh = "gm" + (/x/.unicode == null ? "" : "u");
class e6 {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(t, n, i, l = 0, a = t.length) {
    if (this.text = t, this.to = a, this.curLine = "", this.done = !1, this.value = J8, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new t6(t, n, i, l, a);
    this.re = new RegExp(n, Lh + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = t.iter();
    let r = t.lineAt(l);
    this.curLineStart = r.from, this.matchPos = Uo(t, l), this.getLine(this.curLineStart);
  }
  getLine(t) {
    this.iter.next(t), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let t = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = t;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let i = this.curLineStart + n.index, l = i + n[0].length;
        if (this.matchPos = Uo(this.text, l + (i == l ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < l || i > this.value.to) && (!this.test || this.test(i, l, n)))
          return this.value = { from: i, to: l, match: n }, this;
        t = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), t = 0;
      else
        return this.done = !0, this;
    }
  }
}
const jc = /* @__PURE__ */ new WeakMap();
class Sa {
  constructor(t, n) {
    this.from = t, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(t, n, i) {
    let l = jc.get(t);
    if (!l || l.from >= i || l.to <= n) {
      let s = new Sa(n, t.sliceString(n, i));
      return jc.set(t, s), s;
    }
    if (l.from == n && l.to == i)
      return l;
    let { text: a, from: r } = l;
    return r > n && (a = t.sliceString(n, r) + a, r = n), l.to < i && (a += t.sliceString(l.to, i)), jc.set(t, new Sa(r, a)), new Sa(n, a.slice(n - r, i - r));
  }
}
class t6 {
  constructor(t, n, i, l, a) {
    this.text = t, this.to = a, this.done = !1, this.value = J8, this.matchPos = Uo(t, l), this.re = new RegExp(n, Lh + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = Sa.get(t, l, this.chunkEnd(
      l + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(t) {
    return t >= this.to ? this.to : this.text.lineAt(t).to;
  }
  next() {
    for (; ; ) {
      let t = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == t && (this.re.lastIndex = t + 1, n = this.re.exec(this.flat.text)), n) {
        let i = this.flat.from + n.index, l = i + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, l, n)))
          return this.value = { from: i, to: l, match: n }, this.matchPos = Uo(this.text, l + (i == l ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Sa.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (e6.prototype[Symbol.iterator] = t6.prototype[Symbol.iterator] = function() {
  return this;
});
function uM(e) {
  try {
    return new RegExp(e, Lh), !0;
  } catch {
    return !1;
  }
}
function Uo(e, t) {
  if (t >= e.length)
    return t;
  let n = e.lineAt(t), i;
  for (; t < n.to && (i = n.text.charCodeAt(t - n.from)) >= 56320 && i < 57344; )
    t++;
  return t;
}
function _d(e) {
  let t = String(e.state.doc.lineAt(e.state.selection.main.head).number), n = tt("input", { class: "cm-textfield", name: "line", value: t }), i = tt("form", {
    class: "cm-gotoLine",
    onkeydown: (a) => {
      a.keyCode == 27 ? (a.preventDefault(), e.dispatch({ effects: Go.of(!1) }), e.focus()) : a.keyCode == 13 && (a.preventDefault(), l());
    },
    onsubmit: (a) => {
      a.preventDefault(), l();
    }
  }, tt("label", e.state.phrase("Go to line"), ": ", n), " ", tt("button", { class: "cm-button", type: "submit" }, e.state.phrase("go")));
  function l() {
    let a = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!a)
      return;
    let { state: r } = e, s = r.doc.lineAt(r.selection.main.head), [, o, u, c, d] = a, f = c ? +c.slice(1) : 0, h = u ? +u : s.number;
    if (u && d) {
      let p = h / 100;
      o && (p = p * (o == "-" ? -1 : 1) + s.number / r.doc.lines), h = Math.round(r.doc.lines * p);
    } else u && o && (h = h * (o == "-" ? -1 : 1) + s.number);
    let g = r.doc.line(Math.max(1, Math.min(r.doc.lines, h))), v = J.cursor(g.from + Math.max(0, Math.min(f, g.length)));
    e.dispatch({
      effects: [Go.of(!1), me.scrollIntoView(v.from, { y: "center" })],
      selection: v
    }), e.focus();
  }
  return { dom: i };
}
const Go = /* @__PURE__ */ Le.define(), Tm = /* @__PURE__ */ Mt.define({
  create() {
    return !0;
  },
  update(e, t) {
    for (let n of t.effects)
      n.is(Go) && (e = n.value);
    return e;
  },
  provide: (e) => qr.from(e, (t) => t ? _d : null)
}), cM = (e) => {
  let t = Nr(e, _d);
  if (!t) {
    let n = [Go.of(!0)];
    e.state.field(Tm, !1) == null && n.push(Le.appendConfig.of([Tm, dM])), e.dispatch({ effects: n }), t = Nr(e, _d);
  }
  return t && t.dom.querySelector("input").select(), !0;
}, dM = /* @__PURE__ */ me.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), fM = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, hM = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, fM, {
      highlightWordAroundCursor: (t, n) => t || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function mM(e) {
  return [yM, OM];
}
const gM = /* @__PURE__ */ Ce.mark({ class: "cm-selectionMatch" }), vM = /* @__PURE__ */ Ce.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function _m(e, t, n, i) {
  return (n == 0 || e(t.sliceDoc(n - 1, n)) != dt.Word) && (i == t.doc.length || e(t.sliceDoc(i, i + 1)) != dt.Word);
}
function pM(e, t, n, i) {
  return e(t.sliceDoc(n, n + 1)) == dt.Word && e(t.sliceDoc(i - 1, i)) == dt.Word;
}
const OM = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.decorations = this.getDeco(e);
  }
  update(e) {
    (e.selectionSet || e.docChanged || e.viewportChanged) && (this.decorations = this.getDeco(e.view));
  }
  getDeco(e) {
    let t = e.state.facet(hM), { state: n } = e, i = n.selection;
    if (i.ranges.length > 1)
      return Ce.none;
    let l = i.main, a, r = null;
    if (l.empty) {
      if (!t.highlightWordAroundCursor)
        return Ce.none;
      let o = n.wordAt(l.head);
      if (!o)
        return Ce.none;
      r = n.charCategorizer(l.head), a = n.sliceDoc(o.from, o.to);
    } else {
      let o = l.to - l.from;
      if (o < t.minSelectionLength || o > 200)
        return Ce.none;
      if (t.wholeWords) {
        if (a = n.sliceDoc(l.from, l.to), r = n.charCategorizer(l.head), !(_m(r, n, l.from, l.to) && pM(r, n, l.from, l.to)))
          return Ce.none;
      } else if (a = n.sliceDoc(l.from, l.to), !a)
        return Ce.none;
    }
    let s = [];
    for (let o of e.visibleRanges) {
      let u = new Ea(n.doc, a, o.from, o.to);
      for (; !u.next().done; ) {
        let { from: c, to: d } = u.value;
        if ((!r || _m(r, n, c, d)) && (l.empty && c <= l.from && d >= l.to ? s.push(vM.range(c, d)) : (c >= l.to || d <= l.from) && s.push(gM.range(c, d)), s.length > t.maxMatches))
          return Ce.none;
      }
    }
    return Ce.set(s);
  }
}, {
  decorations: (e) => e.decorations
}), yM = /* @__PURE__ */ me.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), bM = ({ state: e, dispatch: t }) => {
  let { selection: n } = e, i = J.create(n.ranges.map((l) => e.wordAt(l.head) || J.cursor(l.head)), n.mainIndex);
  return i.eq(n) ? !1 : (t(e.update({ selection: i })), !0);
};
function CM(e, t) {
  let { main: n, ranges: i } = e.selection, l = e.wordAt(n.head), a = l && l.from == n.from && l.to == n.to;
  for (let r = !1, s = new Ea(e.doc, t, i[i.length - 1].to); ; )
    if (s.next(), s.done) {
      if (r)
        return null;
      s = new Ea(e.doc, t, 0, Math.max(0, i[i.length - 1].from - 1)), r = !0;
    } else {
      if (r && i.some((o) => o.from == s.value.from))
        continue;
      if (a) {
        let o = e.wordAt(s.value.from);
        if (!o || o.from != s.value.from || o.to != s.value.to)
          continue;
      }
      return s.value;
    }
}
const SM = ({ state: e, dispatch: t }) => {
  let { ranges: n } = e.selection;
  if (n.some((a) => a.from === a.to))
    return bM({ state: e, dispatch: t });
  let i = e.sliceDoc(n[0].from, n[0].to);
  if (e.selection.ranges.some((a) => e.sliceDoc(a.from, a.to) != i))
    return !1;
  let l = CM(e, i);
  return l ? (t(e.update({
    selection: e.selection.addRange(J.range(l.from, l.to), !1),
    effects: me.scrollIntoView(l.to)
  })), !0) : !1;
}, Ja = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (t) => new AM(t),
      scrollToMatch: (t) => me.scrollIntoView(t)
    });
  }
});
class n6 {
  /**
  Create a query object.
  */
  constructor(t) {
    this.search = t.search, this.caseSensitive = !!t.caseSensitive, this.literal = !!t.literal, this.regexp = !!t.regexp, this.replace = t.replace || "", this.valid = !!this.search && (!this.regexp || uM(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!t.wholeWord;
  }
  /**
  @internal
  */
  unquote(t) {
    return this.literal ? t : t.replace(/\\([nrt\\])/g, (n, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(t) {
    return this.search == t.search && this.replace == t.replace && this.caseSensitive == t.caseSensitive && this.regexp == t.regexp && this.wholeWord == t.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new PM(this) : new kM(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(t, n = 0, i) {
    let l = t.doc ? t : Re.create({ doc: t });
    return i == null && (i = l.doc.length), this.regexp ? da(this, l, n, i) : ca(this, l, n, i);
  }
}
class i6 {
  constructor(t) {
    this.spec = t;
  }
}
function ca(e, t, n, i) {
  return new Ea(t.doc, e.unquoted, n, i, e.caseSensitive ? void 0 : (l) => l.toLowerCase(), e.wholeWord ? wM(t.doc, t.charCategorizer(t.selection.main.head)) : void 0);
}
function wM(e, t) {
  return (n, i, l, a) => ((a > n || a + l.length < i) && (a = Math.max(0, n - 2), l = e.sliceString(a, Math.min(e.length, i + 2))), (t(Ko(l, n - a)) != dt.Word || t(Jo(l, n - a)) != dt.Word) && (t(Jo(l, i - a)) != dt.Word || t(Ko(l, i - a)) != dt.Word));
}
class kM extends i6 {
  constructor(t) {
    super(t);
  }
  nextMatch(t, n, i) {
    let l = ca(this.spec, t, i, t.doc.length).nextOverlapping();
    if (l.done) {
      let a = Math.min(t.doc.length, n + this.spec.unquoted.length);
      l = ca(this.spec, t, 0, a).nextOverlapping();
    }
    return l.done || l.value.from == n && l.value.to == i ? null : l.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(t, n, i) {
    for (let l = i; ; ) {
      let a = Math.max(n, l - 1e4 - this.spec.unquoted.length), r = ca(this.spec, t, a, l), s = null;
      for (; !r.nextOverlapping().done; )
        s = r.value;
      if (s)
        return s;
      if (a == n)
        return null;
      l -= 1e4;
    }
  }
  prevMatch(t, n, i) {
    let l = this.prevMatchInRange(t, 0, n);
    return l || (l = this.prevMatchInRange(t, Math.max(0, i - this.spec.unquoted.length), t.doc.length)), l && (l.from != n || l.to != i) ? l : null;
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(t, n) {
    let i = ca(this.spec, t, 0, t.doc.length), l = [];
    for (; !i.next().done; ) {
      if (l.length >= n)
        return null;
      l.push(i.value);
    }
    return l;
  }
  highlight(t, n, i, l) {
    let a = ca(this.spec, t, Math.max(0, n - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, t.doc.length));
    for (; !a.next().done; )
      l(a.value.from, a.value.to);
  }
}
function da(e, t, n, i) {
  return new e6(t.doc, e.search, {
    ignoreCase: !e.caseSensitive,
    test: e.wholeWord ? xM(t.charCategorizer(t.selection.main.head)) : void 0
  }, n, i);
}
function Ko(e, t) {
  return e.slice(qt(e, t, !1), t);
}
function Jo(e, t) {
  return e.slice(t, qt(e, t));
}
function xM(e) {
  return (t, n, i) => !i[0].length || (e(Ko(i.input, i.index)) != dt.Word || e(Jo(i.input, i.index)) != dt.Word) && (e(Jo(i.input, i.index + i[0].length)) != dt.Word || e(Ko(i.input, i.index + i[0].length)) != dt.Word);
}
class PM extends i6 {
  nextMatch(t, n, i) {
    let l = da(this.spec, t, i, t.doc.length).next();
    return l.done && (l = da(this.spec, t, 0, n).next()), l.done ? null : l.value;
  }
  prevMatchInRange(t, n, i) {
    for (let l = 1; ; l++) {
      let a = Math.max(
        n,
        i - l * 1e4
        /* FindPrev.ChunkSize */
      ), r = da(this.spec, t, a, i), s = null;
      for (; !r.next().done; )
        s = r.value;
      if (s && (a == n || s.from > a + 10))
        return s;
      if (a == n)
        return null;
    }
  }
  prevMatch(t, n, i) {
    return this.prevMatchInRange(t, 0, n) || this.prevMatchInRange(t, i, t.doc.length);
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, i) => i == "$" ? "$" : i == "&" ? t.match[0] : i != "0" && +i < t.match.length ? t.match[i] : n);
  }
  matchAll(t, n) {
    let i = da(this.spec, t, 0, t.doc.length), l = [];
    for (; !i.next().done; ) {
      if (l.length >= n)
        return null;
      l.push(i.value);
    }
    return l;
  }
  highlight(t, n, i, l) {
    let a = da(this.spec, t, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, t.doc.length));
    for (; !a.next().done; )
      l(a.value.from, a.value.to);
  }
}
const Ur = /* @__PURE__ */ Le.define(), Mh = /* @__PURE__ */ Le.define(), Fi = /* @__PURE__ */ Mt.define({
  create(e) {
    return new Xc(Ad(e).create(), null);
  },
  update(e, t) {
    for (let n of t.effects)
      n.is(Ur) ? e = new Xc(n.value.create(), e.panel) : n.is(Mh) && (e = new Xc(e.query, n.value ? Th : null));
    return e;
  },
  provide: (e) => qr.from(e, (t) => t.panel)
});
class Xc {
  constructor(t, n) {
    this.query = t, this.panel = n;
  }
}
const $M = /* @__PURE__ */ Ce.mark({ class: "cm-searchMatch" }), VM = /* @__PURE__ */ Ce.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), QM = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.view = e, this.decorations = this.highlight(e.state.field(Fi));
  }
  update(e) {
    let t = e.state.field(Fi);
    (t != e.startState.field(Fi) || e.docChanged || e.selectionSet || e.viewportChanged) && (this.decorations = this.highlight(t));
  }
  highlight({ query: e, panel: t }) {
    if (!t || !e.spec.valid)
      return Ce.none;
    let { view: n } = this, i = new Ji();
    for (let l = 0, a = n.visibleRanges, r = a.length; l < r; l++) {
      let { from: s, to: o } = a[l];
      for (; l < r - 1 && o > a[l + 1].from - 2 * 250; )
        o = a[++l].to;
      e.highlight(n.state, s, o, (u, c) => {
        let d = n.state.selection.ranges.some((f) => f.from == u && f.to == c);
        i.add(u, c, d ? VM : $M);
      });
    }
    return i.finish();
  }
}, {
  decorations: (e) => e.decorations
});
function ks(e) {
  return (t) => {
    let n = t.state.field(Fi, !1);
    return n && n.query.spec.valid ? e(t, n) : r6(t);
  };
}
const eu = /* @__PURE__ */ ks((e, { query: t }) => {
  let { to: n } = e.state.selection.main, i = t.nextMatch(e.state, n, n);
  if (!i)
    return !1;
  let l = J.single(i.from, i.to), a = e.state.facet(Ja);
  return e.dispatch({
    selection: l,
    effects: [_h(e, i), a.scrollToMatch(l.main, e)],
    userEvent: "select.search"
  }), a6(e), !0;
}), tu = /* @__PURE__ */ ks((e, { query: t }) => {
  let { state: n } = e, { from: i } = n.selection.main, l = t.prevMatch(n, i, i);
  if (!l)
    return !1;
  let a = J.single(l.from, l.to), r = e.state.facet(Ja);
  return e.dispatch({
    selection: a,
    effects: [_h(e, l), r.scrollToMatch(a.main, e)],
    userEvent: "select.search"
  }), a6(e), !0;
}), LM = /* @__PURE__ */ ks((e, { query: t }) => {
  let n = t.matchAll(e.state, 1e3);
  return !n || !n.length ? !1 : (e.dispatch({
    selection: J.create(n.map((i) => J.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), MM = ({ state: e, dispatch: t }) => {
  let n = e.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: i, to: l } = n.main, a = [], r = 0;
  for (let s = new Ea(e.doc, e.sliceDoc(i, l)); !s.next().done; ) {
    if (a.length > 1e3)
      return !1;
    s.value.from == i && (r = a.length), a.push(J.range(s.value.from, s.value.to));
  }
  return t(e.update({
    selection: J.create(a, r),
    userEvent: "select.search.matches"
  })), !0;
}, Am = /* @__PURE__ */ ks((e, { query: t }) => {
  let { state: n } = e, { from: i, to: l } = n.selection.main;
  if (n.readOnly)
    return !1;
  let a = t.nextMatch(n, i, i);
  if (!a)
    return !1;
  let r = [], s, o, u = [];
  if (a.from == i && a.to == l && (o = n.toText(t.getReplacement(a)), r.push({ from: a.from, to: a.to, insert: o }), a = t.nextMatch(n, a.from, a.to), u.push(me.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(i).number) + "."))), a) {
    let c = r.length == 0 || r[0].from >= a.to ? 0 : a.to - a.from - o.length;
    s = J.single(a.from - c, a.to - c), u.push(_h(e, a)), u.push(n.facet(Ja).scrollToMatch(s.main, e));
  }
  return e.dispatch({
    changes: r,
    selection: s,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), TM = /* @__PURE__ */ ks((e, { query: t }) => {
  if (e.state.readOnly)
    return !1;
  let n = t.matchAll(e.state, 1e9).map((l) => {
    let { from: a, to: r } = l;
    return { from: a, to: r, insert: t.getReplacement(l) };
  });
  if (!n.length)
    return !1;
  let i = e.state.phrase("replaced $ matches", n.length) + ".";
  return e.dispatch({
    changes: n,
    effects: me.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function Th(e) {
  return e.state.facet(Ja).createPanel(e);
}
function Ad(e, t) {
  var n, i, l, a, r;
  let s = e.selection.main, o = s.empty || s.to > s.from + 100 ? "" : e.sliceDoc(s.from, s.to);
  if (t && !o)
    return t;
  let u = e.facet(Ja);
  return new n6({
    search: ((n = t == null ? void 0 : t.literal) !== null && n !== void 0 ? n : u.literal) ? o : o.replace(/\n/g, "\\n"),
    caseSensitive: (i = t == null ? void 0 : t.caseSensitive) !== null && i !== void 0 ? i : u.caseSensitive,
    literal: (l = t == null ? void 0 : t.literal) !== null && l !== void 0 ? l : u.literal,
    regexp: (a = t == null ? void 0 : t.regexp) !== null && a !== void 0 ? a : u.regexp,
    wholeWord: (r = t == null ? void 0 : t.wholeWord) !== null && r !== void 0 ? r : u.wholeWord
  });
}
function l6(e) {
  let t = Nr(e, Th);
  return t && t.dom.querySelector("[main-field]");
}
function a6(e) {
  let t = l6(e);
  t && t == e.root.activeElement && t.select();
}
const r6 = (e) => {
  let t = e.state.field(Fi, !1);
  if (t && t.panel) {
    let n = l6(e);
    if (n && n != e.root.activeElement) {
      let i = Ad(e.state, t.query.spec);
      i.valid && e.dispatch({ effects: Ur.of(i) }), n.focus(), n.select();
    }
  } else
    e.dispatch({ effects: [
      Mh.of(!0),
      t ? Ur.of(Ad(e.state, t.query.spec)) : Le.appendConfig.of(ZM)
    ] });
  return !0;
}, s6 = (e) => {
  let t = e.state.field(Fi, !1);
  if (!t || !t.panel)
    return !1;
  let n = Nr(e, Th);
  return n && n.dom.contains(e.root.activeElement) && e.focus(), e.dispatch({ effects: Mh.of(!1) }), !0;
}, _M = [
  { key: "Mod-f", run: r6, scope: "editor search-panel" },
  { key: "F3", run: eu, shift: tu, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: eu, shift: tu, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: s6, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: MM },
  { key: "Mod-Alt-g", run: cM },
  { key: "Mod-d", run: SM, preventDefault: !0 }
];
class AM {
  constructor(t) {
    this.view = t;
    let n = this.query = t.state.field(Fi).query.spec;
    this.commit = this.commit.bind(this), this.searchField = tt("input", {
      value: n.search,
      placeholder: bn(t, "Find"),
      "aria-label": bn(t, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = tt("input", {
      value: n.replace,
      placeholder: bn(t, "Replace"),
      "aria-label": bn(t, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = tt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = tt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = tt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function i(l, a, r) {
      return tt("button", { class: "cm-button", name: l, onclick: a, type: "button" }, r);
    }
    this.dom = tt("div", { onkeydown: (l) => this.keydown(l), class: "cm-search" }, [
      this.searchField,
      i("next", () => eu(t), [bn(t, "next")]),
      i("prev", () => tu(t), [bn(t, "previous")]),
      i("select", () => LM(t), [bn(t, "all")]),
      tt("label", null, [this.caseField, bn(t, "match case")]),
      tt("label", null, [this.reField, bn(t, "regexp")]),
      tt("label", null, [this.wordField, bn(t, "by word")]),
      ...t.state.readOnly ? [] : [
        tt("br"),
        this.replaceField,
        i("replace", () => Am(t), [bn(t, "replace")]),
        i("replaceAll", () => TM(t), [bn(t, "replace all")])
      ],
      tt("button", {
        name: "close",
        onclick: () => s6(t),
        "aria-label": bn(t, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let t = new n6({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    t.eq(this.query) || (this.query = t, this.view.dispatch({ effects: Ur.of(t) }));
  }
  keydown(t) {
    A$(this.view, t, "search-panel") ? t.preventDefault() : t.keyCode == 13 && t.target == this.searchField ? (t.preventDefault(), (t.shiftKey ? tu : eu)(this.view)) : t.keyCode == 13 && t.target == this.replaceField && (t.preventDefault(), Am(this.view));
  }
  update(t) {
    for (let n of t.transactions)
      for (let i of n.effects)
        i.is(Ur) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(t) {
    this.query = t, this.searchField.value = t.search, this.replaceField.value = t.replace, this.caseField.checked = t.caseSensitive, this.reField.checked = t.regexp, this.wordField.checked = t.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Ja).top;
  }
}
function bn(e, t) {
  return e.state.phrase(t);
}
const Js = 30, eo = /[\s\.,:;?!]/;
function _h(e, { from: t, to: n }) {
  let i = e.state.doc.lineAt(t), l = e.state.doc.lineAt(n).to, a = Math.max(i.from, t - Js), r = Math.min(l, n + Js), s = e.state.sliceDoc(a, r);
  if (a != i.from) {
    for (let o = 0; o < Js; o++)
      if (!eo.test(s[o + 1]) && eo.test(s[o])) {
        s = s.slice(o);
        break;
      }
  }
  if (r != l) {
    for (let o = s.length - 1; o > s.length - Js; o--)
      if (!eo.test(s[o - 1]) && eo.test(s[o])) {
        s = s.slice(0, o);
        break;
      }
  }
  return me.announce.of(`${e.state.phrase("current match")}. ${s} ${e.state.phrase("on line")} ${i.number}.`);
}
const RM = /* @__PURE__ */ me.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), ZM = [
  Fi,
  /* @__PURE__ */ cl.low(QM),
  RM
];
class o6 {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(t, n, i, l) {
    this.state = t, this.pos = n, this.explicit = i, this.view = l, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let n = Rt(this.state).resolveInner(this.pos, -1);
    for (; n && t.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let n = this.state.doc.lineAt(this.pos), i = Math.max(n.from, this.pos - 250), l = n.text.slice(i - n.from, this.pos - n.from), a = l.search(c6(t, !1));
    return a < 0 ? null : { from: i + a, to: this.pos, text: l.slice(a) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(t, n, i) {
    t == "abort" && this.abortListeners && (this.abortListeners.push(n), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}
function Rm(e) {
  let t = Object.keys(e).join(""), n = /\w/.test(t);
  return n && (t = t.replace(/\w/g, "")), `[${n ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
function IM(e) {
  let t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: l } of e) {
    t[l[0]] = !0;
    for (let a = 1; a < l.length; a++)
      n[l[a]] = !0;
  }
  let i = Rm(t) + Rm(n) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function u6(e) {
  let t = e.map((l) => typeof l == "string" ? { label: l } : l), [n, i] = t.every((l) => /^\w+$/.test(l.label)) ? [/\w*$/, /\w+$/] : IM(t);
  return (l) => {
    let a = l.matchBefore(i);
    return a || l.explicit ? { from: a ? a.from : l.pos, options: t, validFor: n } : null;
  };
}
function DM(e, t) {
  return (n) => {
    for (let i = Rt(n.state).resolveInner(n.pos, -1); i; i = i.parent) {
      if (e.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return t(n);
  };
}
class Zm {
  constructor(t, n, i, l) {
    this.completion = t, this.source = n, this.match = i, this.score = l;
  }
}
function Wi(e) {
  return e.selection.main.from;
}
function c6(e, t) {
  var n;
  let { source: i } = e, l = t && i[0] != "^", a = i[i.length - 1] != "$";
  return !l && !a ? e : new RegExp(`${l ? "^" : ""}(?:${i})${a ? "$" : ""}`, (n = e.flags) !== null && n !== void 0 ? n : e.ignoreCase ? "i" : "");
}
const Ah = /* @__PURE__ */ Zi.define();
function BM(e, t, n, i) {
  let { main: l } = e.selection, a = n - l.from, r = i - l.from;
  return Object.assign(Object.assign({}, e.changeByRange((s) => {
    if (s != l && n != i && e.sliceDoc(s.from + a, s.from + r) != e.sliceDoc(n, i))
      return { range: s };
    let o = e.toText(t);
    return {
      changes: { from: s.from + a, to: i == l.from ? s.to : s.from + r, insert: o },
      range: J.cursor(s.from + a + o.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const Im = /* @__PURE__ */ new WeakMap();
function EM(e) {
  if (!Array.isArray(e))
    return e;
  let t = Im.get(e);
  return t || Im.set(e, t = u6(e)), t;
}
const nu = /* @__PURE__ */ Le.define(), Gr = /* @__PURE__ */ Le.define();
class zM {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < t.length; ) {
      let i = Ht(t, n), l = Ln(i);
      this.chars.push(i);
      let a = t.slice(n, n + l), r = a.toUpperCase();
      this.folded.push(Ht(r == a ? a.toLowerCase() : r, 0)), n += l;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, n) {
    return this.score = t, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: n, folded: i, any: l, precise: a, byWord: r } = this;
    if (n.length == 1) {
      let b = Ht(t, 0), V = Ln(b), $ = V == t.length ? 0 : -100;
      if (b != n[0]) if (b == i[0])
        $ += -200;
      else
        return null;
      return this.ret($, [0, V]);
    }
    let s = t.indexOf(this.pattern);
    if (s == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let o = n.length, u = 0;
    if (s < 0) {
      for (let b = 0, V = Math.min(t.length, 200); b < V && u < o; ) {
        let $ = Ht(t, b);
        ($ == n[u] || $ == i[u]) && (l[u++] = b), b += Ln($);
      }
      if (u < o)
        return null;
    }
    let c = 0, d = 0, f = !1, h = 0, g = -1, v = -1, p = /[a-z]/.test(t), O = !0;
    for (let b = 0, V = Math.min(t.length, 200), $ = 0; b < V && d < o; ) {
      let x = Ht(t, b);
      s < 0 && (c < o && x == n[c] && (a[c++] = b), h < o && (x == n[h] || x == i[h] ? (h == 0 && (g = b), v = b + 1, h++) : h = 0));
      let Q, M = x < 255 ? x >= 48 && x <= 57 || x >= 97 && x <= 122 ? 2 : x >= 65 && x <= 90 ? 1 : 0 : (Q = th(x)) != Q.toLowerCase() ? 1 : Q != Q.toUpperCase() ? 2 : 0;
      (!b || M == 1 && p || $ == 0 && M != 0) && (n[d] == x || i[d] == x && (f = !0) ? r[d++] = b : r.length && (O = !1)), $ = M, b += Ln(x);
    }
    return d == o && r[0] == 0 && O ? this.result(-100 + (f ? -200 : 0), r, t) : h == o && g == 0 ? this.ret(-200 - t.length + (v == t.length ? 0 : -100), [0, v]) : s > -1 ? this.ret(-700 - t.length, [s, s + this.pattern.length]) : h == o ? this.ret(-900 - t.length, [g, v]) : d == o ? this.result(-100 + (f ? -200 : 0) + -700 + (O ? 0 : -1100), r, t) : n.length == 2 ? null : this.result((l[0] ? -700 : 0) + -200 + -1100, l, t);
  }
  result(t, n, i) {
    let l = [], a = 0;
    for (let r of n) {
      let s = r + (this.astral ? Ln(Ht(i, r)) : 1);
      a && l[a - 1] == r ? l[a - 1] = s : (l[a++] = r, l[a++] = s);
    }
    return this.ret(t - i.length, l);
  }
}
class HM {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let n = t.slice(0, this.pattern.length), i = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, n.length], this.score = i + (t.length == this.pattern.length ? 0 : -100), this);
  }
}
const It = /* @__PURE__ */ ve.define({
  combine(e) {
    return Kn(e, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: jM,
      filterStrict: !1,
      compareCompletions: (t, n) => t.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (t, n) => t && n,
      closeOnBlur: (t, n) => t && n,
      icons: (t, n) => t && n,
      tooltipClass: (t, n) => (i) => Dm(t(i), n(i)),
      optionClass: (t, n) => (i) => Dm(t(i), n(i)),
      addToOptions: (t, n) => t.concat(n),
      filterStrict: (t, n) => t || n
    });
  }
});
function Dm(e, t) {
  return e ? t ? e + " " + t : e : t;
}
function jM(e, t, n, i, l, a) {
  let r = e.textDirection == ot.RTL, s = r, o = !1, u = "top", c, d, f = t.left - l.left, h = l.right - t.right, g = i.right - i.left, v = i.bottom - i.top;
  if (s && f < Math.min(g, h) ? s = !1 : !s && h < Math.min(g, f) && (s = !0), g <= (s ? f : h))
    c = Math.max(l.top, Math.min(n.top, l.bottom - v)) - t.top, d = Math.min(400, s ? f : h);
  else {
    o = !0, d = Math.min(
      400,
      (r ? t.right : l.right - t.left) - 30
      /* Info.Margin */
    );
    let b = l.bottom - t.bottom;
    b >= v || b > t.top ? c = n.bottom - t.top : (u = "bottom", c = t.bottom - n.top);
  }
  let p = (t.bottom - t.top) / a.offsetHeight, O = (t.right - t.left) / a.offsetWidth;
  return {
    style: `${u}: ${c / p}px; max-width: ${d / O}px`,
    class: "cm-completionInfo-" + (o ? r ? "left-narrow" : "right-narrow" : s ? "left" : "right")
  };
}
function XM(e) {
  let t = e.addToOptions.slice();
  return e.icons && t.push({
    render(n) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), n.type && i.classList.add(...n.type.split(/\s+/g).map((l) => "cm-completionIcon-" + l)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), t.push({
    render(n, i, l, a) {
      let r = document.createElement("span");
      r.className = "cm-completionLabel";
      let s = n.displayLabel || n.label, o = 0;
      for (let u = 0; u < a.length; ) {
        let c = a[u++], d = a[u++];
        c > o && r.appendChild(document.createTextNode(s.slice(o, c)));
        let f = r.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(s.slice(c, d))), f.className = "cm-completionMatchedText", o = d;
      }
      return o < s.length && r.appendChild(document.createTextNode(s.slice(o))), r;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = n.detail, i;
    },
    position: 80
  }), t.sort((n, i) => n.position - i.position).map((n) => n.render);
}
function Nc(e, t, n) {
  if (e <= n)
    return { from: 0, to: e };
  if (t < 0 && (t = 0), t <= e >> 1) {
    let l = Math.floor(t / n);
    return { from: l * n, to: (l + 1) * n };
  }
  let i = Math.floor((e - t) / n);
  return { from: e - (i + 1) * n, to: e - i * n };
}
class NM {
  constructor(t, n, i) {
    this.view = t, this.stateField = n, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (o) => this.placeInfo(o),
      key: this
    }, this.space = null, this.currentClass = "";
    let l = t.state.field(n), { options: a, selected: r } = l.open, s = t.state.facet(It);
    this.optionContent = XM(s), this.optionClass = s.optionClass, this.tooltipClass = s.tooltipClass, this.range = Nc(a.length, r, s.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (o) => {
      let { options: u } = t.state.field(n).open;
      for (let c = o.target, d; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (d = /-(\d+)$/.exec(c.id)) && +d[1] < u.length) {
          this.applyCompletion(t, u[+d[1]]), o.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (o) => {
      let u = t.state.field(this.stateField, !1);
      u && u.tooltip && t.state.facet(It).closeOnBlur && o.relatedTarget != t.contentDOM && t.dispatch({ effects: Gr.of(null) });
    }), this.showOptions(a, l.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var n;
    let i = t.state.field(this.stateField), l = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), i != l) {
      let { options: a, selected: r, disabled: s } = i.open;
      (!l.open || l.open.options != a) && (this.range = Nc(a.length, r, t.state.facet(It).maxRenderedOptions), this.showOptions(a, i.id)), this.updateSel(), s != ((n = l.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!s);
    }
  }
  updateTooltipClass(t) {
    let n = this.tooltipClass(t);
    if (n != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of n.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = n;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), n = t.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = Nc(n.options.length, n.selected, this.view.state.facet(It).maxRenderedOptions), this.showOptions(n.options, t.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: i } = n.options[n.selected], { info: l } = i;
      if (!l)
        return;
      let a = typeof l == "string" ? document.createTextNode(l) : l(i);
      if (!a)
        return;
      "then" in a ? a.then((r) => {
        r && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(r, i);
      }).catch((r) => sn(this.view.state, r, "completion info")) : this.addInfoPane(a, i);
    }
  }
  addInfoPane(t, n) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", t.nodeType != null)
      i.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: l, destroy: a } = t;
      i.appendChild(l), this.infoDestroy = a || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let n = null;
    for (let i = this.list.firstChild, l = this.range.from; i; i = i.nextSibling, l++)
      i.nodeName != "LI" || !i.id ? l-- : l == t ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), n = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return n && YM(this.list, n), n;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), l = t.getBoundingClientRect(), a = this.space;
    if (!a) {
      let r = this.dom.ownerDocument.defaultView || window;
      a = { left: 0, top: 0, right: r.innerWidth, bottom: r.innerHeight };
    }
    return l.top > Math.min(a.bottom, n.bottom) - 10 || l.bottom < Math.max(a.top, n.top) + 10 ? null : this.view.state.facet(It).positionInfo(this.view, n, l, i, a, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, n, i) {
    const l = document.createElement("ul");
    l.id = n, l.setAttribute("role", "listbox"), l.setAttribute("aria-expanded", "true"), l.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let a = null;
    for (let r = i.from; r < i.to; r++) {
      let { completion: s, match: o } = t[r], { section: u } = s;
      if (u) {
        let f = typeof u == "string" ? u : u.name;
        if (f != a && (r > i.from || i.from == 0))
          if (a = f, typeof u != "string" && u.header)
            l.appendChild(u.header(u));
          else {
            let h = l.appendChild(document.createElement("completion-section"));
            h.textContent = f;
          }
      }
      const c = l.appendChild(document.createElement("li"));
      c.id = n + "-" + r, c.setAttribute("role", "option");
      let d = this.optionClass(s);
      d && (c.className = d);
      for (let f of this.optionContent) {
        let h = f(s, this.view.state, this.view, o);
        h && c.appendChild(h);
      }
    }
    return i.from && l.classList.add("cm-completionListIncompleteTop"), i.to < t.length && l.classList.add("cm-completionListIncompleteBottom"), l;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function qM(e, t) {
  return (n) => new NM(n, e, t);
}
function YM(e, t) {
  let n = e.getBoundingClientRect(), i = t.getBoundingClientRect(), l = n.height / e.offsetHeight;
  i.top < n.top ? e.scrollTop -= (n.top - i.top) / l : i.bottom > n.bottom && (e.scrollTop += (i.bottom - n.bottom) / l);
}
function Bm(e) {
  return (e.boost || 0) * 100 + (e.apply ? 10 : 0) + (e.info ? 5 : 0) + (e.type ? 1 : 0);
}
function FM(e, t) {
  let n = [], i = null, l = (u) => {
    n.push(u);
    let { section: c } = u.completion;
    if (c) {
      i || (i = []);
      let d = typeof c == "string" ? c : c.name;
      i.some((f) => f.name == d) || i.push(typeof c == "string" ? { name: d } : c);
    }
  }, a = t.facet(It);
  for (let u of e)
    if (u.hasResult()) {
      let c = u.result.getMatch;
      if (u.result.filter === !1)
        for (let d of u.result.options)
          l(new Zm(d, u.source, c ? c(d) : [], 1e9 - n.length));
      else {
        let d = t.sliceDoc(u.from, u.to), f, h = a.filterStrict ? new HM(d) : new zM(d);
        for (let g of u.result.options)
          if (f = h.match(g.label)) {
            let v = g.displayLabel ? c ? c(g, f.matched) : [] : f.matched;
            l(new Zm(g, u.source, v, f.score + (g.boost || 0)));
          }
      }
    }
  if (i) {
    let u = /* @__PURE__ */ Object.create(null), c = 0, d = (f, h) => {
      var g, v;
      return ((g = f.rank) !== null && g !== void 0 ? g : 1e9) - ((v = h.rank) !== null && v !== void 0 ? v : 1e9) || (f.name < h.name ? -1 : 1);
    };
    for (let f of i.sort(d))
      c -= 1e5, u[f.name] = c;
    for (let f of n) {
      let { section: h } = f.completion;
      h && (f.score += u[typeof h == "string" ? h : h.name]);
    }
  }
  let r = [], s = null, o = a.compareCompletions;
  for (let u of n.sort((c, d) => d.score - c.score || o(c.completion, d.completion))) {
    let c = u.completion;
    !s || s.label != c.label || s.detail != c.detail || s.type != null && c.type != null && s.type != c.type || s.apply != c.apply || s.boost != c.boost ? r.push(u) : Bm(u.completion) > Bm(s) && (r[r.length - 1] = u), s = u.completion;
  }
  return r;
}
class pa {
  constructor(t, n, i, l, a, r) {
    this.options = t, this.attrs = n, this.tooltip = i, this.timestamp = l, this.selected = a, this.disabled = r;
  }
  setSelected(t, n) {
    return t == this.selected || t >= this.options.length ? this : new pa(this.options, Em(n, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, n, i, l, a, r) {
    if (l && !r && t.some(
      (u) => u.state == 1
      /* State.Pending */
    ))
      return l.setDisabled();
    let s = FM(t, n);
    if (!s.length)
      return l && t.some(
        (u) => u.state == 1
        /* State.Pending */
      ) ? l.setDisabled() : null;
    let o = n.facet(It).selectOnOpen ? 0 : -1;
    if (l && l.selected != o && l.selected != -1) {
      let u = l.options[l.selected].completion;
      for (let c = 0; c < s.length; c++)
        if (s[c].completion == u) {
          o = c;
          break;
        }
    }
    return new pa(s, Em(i, o), {
      pos: t.reduce((u, c) => c.hasResult() ? Math.min(u, c.from) : u, 1e8),
      create: eT,
      above: a.aboveCursor
    }, l ? l.timestamp : Date.now(), o, !1);
  }
  map(t) {
    return new pa(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new pa(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class iu {
  constructor(t, n, i) {
    this.active = t, this.id = n, this.open = i;
  }
  static start() {
    return new iu(KM, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: n } = t, i = n.facet(It), a = (i.override || n.languageDataAt("autocomplete", Wi(n)).map(EM)).map((o) => (this.active.find((c) => c.source == o) || new kn(
      o,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, i));
    a.length == this.active.length && a.every((o, u) => o == this.active[u]) && (a = this.active);
    let r = this.open, s = t.effects.some((o) => o.is(Rh));
    r && t.docChanged && (r = r.map(t.changes)), t.selection || a.some((o) => o.hasResult() && t.changes.touchesRange(o.from, o.to)) || !WM(a, this.active) || s ? r = pa.build(a, n, this.id, r, i, s) : r && r.disabled && !a.some(
      (o) => o.state == 1
      /* State.Pending */
    ) && (r = null), !r && a.every(
      (o) => o.state != 1
      /* State.Pending */
    ) && a.some((o) => o.hasResult()) && (a = a.map((o) => o.hasResult() ? new kn(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of t.effects)
      o.is(f6) && (r = r && r.setSelected(o.value, this.id));
    return a == this.active && r == this.open ? this : new iu(a, this.id, r);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? UM : GM;
  }
}
function WM(e, t) {
  if (e == t)
    return !0;
  for (let n = 0, i = 0; ; ) {
    for (; n < e.length && !e[n].hasResult; )
      n++;
    for (; i < t.length && !t[i].hasResult; )
      i++;
    let l = n == e.length, a = i == t.length;
    if (l || a)
      return l == a;
    if (e[n++].result != t[i++].result)
      return !1;
  }
}
const UM = {
  "aria-autocomplete": "list"
}, GM = {};
function Em(e, t) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": e
  };
  return t > -1 && (n["aria-activedescendant"] = e + "-" + t), n;
}
const KM = [];
function d6(e, t) {
  if (e.isUserEvent("input.complete")) {
    let i = e.annotation(Ah);
    if (i && t.activateOnCompletion(i))
      return 12;
  }
  let n = e.isUserEvent("input.type");
  return n && t.activateOnTyping ? 5 : n ? 1 : e.isUserEvent("delete.backward") ? 2 : e.selection ? 8 : e.docChanged ? 16 : 0;
}
class kn {
  constructor(t, n, i = -1) {
    this.source = t, this.state = n, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(t, n) {
    let i = d6(t, n), l = this;
    (i & 8 || i & 16 && this.touches(t)) && (l = new kn(
      l.source,
      0
      /* State.Inactive */
    )), i & 4 && l.state == 0 && (l = new kn(
      this.source,
      1
      /* State.Pending */
    )), l = l.updateFor(t, i);
    for (let a of t.effects)
      if (a.is(nu))
        l = new kn(l.source, 1, a.value ? Wi(t.state) : -1);
      else if (a.is(Gr))
        l = new kn(
          l.source,
          0
          /* State.Inactive */
        );
      else if (a.is(Rh))
        for (let r of a.value)
          r.source == l.source && (l = r);
    return l;
  }
  updateFor(t, n) {
    return this.map(t.changes);
  }
  map(t) {
    return t.empty || this.explicitPos < 0 ? this : new kn(this.source, this.state, t.mapPos(this.explicitPos));
  }
  touches(t) {
    return t.changes.touchesRange(Wi(t.state));
  }
}
class wa extends kn {
  constructor(t, n, i, l, a) {
    super(t, 2, n), this.result = i, this.from = l, this.to = a;
  }
  hasResult() {
    return !0;
  }
  updateFor(t, n) {
    var i;
    if (!(n & 3))
      return this.map(t.changes);
    let l = this.result;
    l.map && !t.changes.empty && (l = l.map(l, t.changes));
    let a = t.changes.mapPos(this.from), r = t.changes.mapPos(this.to, 1), s = Wi(t.state);
    if ((this.explicitPos < 0 ? s <= a : s < this.from) || s > r || !l || n & 2 && Wi(t.startState) == this.from)
      return new kn(
        this.source,
        n & 4 ? 1 : 0
        /* State.Inactive */
      );
    let o = this.explicitPos < 0 ? -1 : t.changes.mapPos(this.explicitPos);
    return JM(l.validFor, t.state, a, r) ? new wa(this.source, o, l, a, r) : l.update && (l = l.update(l, a, r, new o6(t.state, s, o >= 0))) ? new wa(this.source, o, l, l.from, (i = l.to) !== null && i !== void 0 ? i : Wi(t.state)) : new kn(this.source, 1, o);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new wa(this.source, this.explicitPos < 0 ? -1 : t.mapPos(this.explicitPos), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new kn(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(t) {
    return t.changes.touchesRange(this.from, this.to);
  }
}
function JM(e, t, n, i) {
  if (!e)
    return !1;
  let l = t.sliceDoc(n, i);
  return typeof e == "function" ? e(l, n, i, t) : c6(e, !0).test(l);
}
const Rh = /* @__PURE__ */ Le.define({
  map(e, t) {
    return e.map((n) => n.map(t));
  }
}), f6 = /* @__PURE__ */ Le.define(), mn = /* @__PURE__ */ Mt.define({
  create() {
    return iu.start();
  },
  update(e, t) {
    return e.update(t);
  },
  provide: (e) => [
    Yu.from(e, (t) => t.tooltip),
    me.contentAttributes.from(e, (t) => t.attrs)
  ]
});
function Zh(e, t) {
  const n = t.completion.apply || t.completion.label;
  let i = e.state.field(mn).active.find((l) => l.source == t.source);
  return i instanceof wa ? (typeof n == "string" ? e.dispatch(Object.assign(Object.assign({}, BM(e.state, n, i.from, i.to)), { annotations: Ah.of(t.completion) })) : n(e, t.completion, i.from, i.to), !0) : !1;
}
const eT = /* @__PURE__ */ qM(mn, Zh);
function to(e, t = "option") {
  return (n) => {
    let i = n.state.field(mn, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < n.state.facet(It).interactionDelay)
      return !1;
    let l = 1, a;
    t == "page" && (a = Tv(n, i.open.tooltip)) && (l = Math.max(2, Math.floor(a.dom.offsetHeight / a.dom.querySelector("li").offsetHeight) - 1));
    let { length: r } = i.open.options, s = i.open.selected > -1 ? i.open.selected + l * (e ? 1 : -1) : e ? 0 : r - 1;
    return s < 0 ? s = t == "page" ? 0 : r - 1 : s >= r && (s = t == "page" ? r - 1 : 0), n.dispatch({ effects: f6.of(s) }), !0;
  };
}
const tT = (e) => {
  let t = e.state.field(mn, !1);
  return e.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < e.state.facet(It).interactionDelay ? !1 : Zh(e, t.open.options[t.open.selected]);
}, zm = (e) => e.state.field(mn, !1) ? (e.dispatch({ effects: nu.of(!0) }), !0) : !1, nT = (e) => {
  let t = e.state.field(mn, !1);
  return !t || !t.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (e.dispatch({ effects: Gr.of(null) }), !0);
};
class iT {
  constructor(t, n) {
    this.active = t, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const lT = 50, aT = 1e3, rT = /* @__PURE__ */ yt.fromClass(class {
  constructor(e) {
    this.view = e, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of e.state.field(mn).active)
      t.state == 1 && this.startQuery(t);
  }
  update(e) {
    let t = e.state.field(mn), n = e.state.facet(It);
    if (!e.selectionSet && !e.docChanged && e.startState.field(mn) == t)
      return;
    let i = e.transactions.some((a) => {
      let r = d6(a, n);
      return r & 8 || (a.selection || a.docChanged) && !(r & 3);
    });
    for (let a = 0; a < this.running.length; a++) {
      let r = this.running[a];
      if (i || r.context.abortOnDocChange && e.docChanged || r.updates.length + e.transactions.length > lT && Date.now() - r.time > aT) {
        for (let s of r.context.abortListeners)
          try {
            s();
          } catch (o) {
            sn(this.view.state, o);
          }
        r.context.abortListeners = null, this.running.splice(a--, 1);
      } else
        r.updates.push(...e.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), e.transactions.some((a) => a.effects.some((r) => r.is(nu))) && (this.pendingStart = !0);
    let l = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((a) => a.state == 1 && !this.running.some((r) => r.active.source == a.source)) ? setTimeout(() => this.startUpdate(), l) : -1, this.composing != 0)
      for (let a of e.transactions)
        a.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && a.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: e } = this.view, t = e.field(mn);
    for (let n of t.active)
      n.state == 1 && !this.running.some((i) => i.active.source == n.source) && this.startQuery(n);
    this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(It).updateSyncTime));
  }
  startQuery(e) {
    let { state: t } = this.view, n = Wi(t), i = new o6(t, n, e.explicitPos == n, this.view), l = new iT(e, i);
    this.running.push(l), Promise.resolve(e.source(i)).then((a) => {
      l.context.aborted || (l.done = a || null, this.scheduleAccept());
    }, (a) => {
      this.view.dispatch({ effects: Gr.of(null) }), sn(this.view.state, a);
    });
  }
  scheduleAccept() {
    this.running.every((e) => e.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(It).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var e;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], n = this.view.state.facet(It), i = this.view.state.field(mn);
    for (let l = 0; l < this.running.length; l++) {
      let a = this.running[l];
      if (a.done === void 0)
        continue;
      if (this.running.splice(l--, 1), a.done) {
        let s = new wa(a.active.source, a.active.explicitPos, a.done, a.done.from, (e = a.done.to) !== null && e !== void 0 ? e : Wi(a.updates.length ? a.updates[0].startState : this.view.state));
        for (let o of a.updates)
          s = s.update(o, n);
        if (s.hasResult()) {
          t.push(s);
          continue;
        }
      }
      let r = i.active.find((s) => s.source == a.active.source);
      if (r && r.state == 1)
        if (a.done == null) {
          let s = new kn(
            a.active.source,
            0
            /* State.Inactive */
          );
          for (let o of a.updates)
            s = s.update(o, n);
          s.state != 1 && t.push(s);
        } else
          this.startQuery(r);
    }
    (t.length || i.open && i.open.disabled) && this.view.dispatch({ effects: Rh.of(t) });
  }
}, {
  eventHandlers: {
    blur(e) {
      let t = this.view.state.field(mn, !1);
      if (t && t.tooltip && this.view.state.facet(It).closeOnBlur) {
        let n = t.open && Tv(this.view, t.open.tooltip);
        (!n || !n.dom.contains(e.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Gr.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: nu.of(!1) }), 20), this.composing = 0;
    }
  }
}), sT = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), oT = /* @__PURE__ */ cl.highest(/* @__PURE__ */ me.domEventHandlers({
  keydown(e, t) {
    let n = t.state.field(mn, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || e.key.length > 1 || e.ctrlKey && !(sT && e.altKey) || e.metaKey)
      return !1;
    let i = n.open.options[n.open.selected], l = n.active.find((r) => r.source == i.source), a = i.completion.commitCharacters || l.result.commitCharacters;
    return a && a.indexOf(e.key) > -1 && Zh(t, i), !1;
  }
})), h6 = /* @__PURE__ */ me.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class uT {
  constructor(t, n, i, l) {
    this.field = t, this.line = n, this.from = i, this.to = l;
  }
}
class Ih {
  constructor(t, n, i) {
    this.field = t, this.from = n, this.to = i;
  }
  map(t) {
    let n = t.mapPos(this.from, -1, Nt.TrackDel), i = t.mapPos(this.to, 1, Nt.TrackDel);
    return n == null || i == null ? null : new Ih(this.field, n, i);
  }
}
class Dh {
  constructor(t, n) {
    this.lines = t, this.fieldPositions = n;
  }
  instantiate(t, n) {
    let i = [], l = [n], a = t.doc.lineAt(n), r = /^\s*/.exec(a.text)[0];
    for (let o of this.lines) {
      if (i.length) {
        let u = r, c = /^\t*/.exec(o)[0].length;
        for (let d = 0; d < c; d++)
          u += t.facet(bs);
        l.push(n + u.length - c), o = u + o.slice(c);
      }
      i.push(o), n += o.length + 1;
    }
    let s = this.fieldPositions.map((o) => new Ih(o.field, l[o.line] + o.from, l[o.line] + o.to));
    return { text: i, ranges: s };
  }
  static parse(t) {
    let n = [], i = [], l = [], a;
    for (let r of t.split(/\r\n?|\n/)) {
      for (; a = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(r); ) {
        let s = a[1] ? +a[1] : null, o = a[2] || a[3] || "", u = -1, c = o.replace(/\\[{}]/g, (d) => d[1]);
        for (let d = 0; d < n.length; d++)
          (s != null ? n[d].seq == s : c && n[d].name == c) && (u = d);
        if (u < 0) {
          let d = 0;
          for (; d < n.length && (s == null || n[d].seq != null && n[d].seq < s); )
            d++;
          n.splice(d, 0, { seq: s, name: c }), u = d;
          for (let f of l)
            f.field >= u && f.field++;
        }
        l.push(new uT(u, i.length, a.index, a.index + c.length)), r = r.slice(0, a.index) + o + r.slice(a.index + a[0].length);
      }
      r = r.replace(/\\([{}])/g, (s, o, u) => {
        for (let c of l)
          c.line == i.length && c.from > u && (c.from--, c.to--);
        return o;
      }), i.push(r);
    }
    return new Dh(i, l);
  }
}
let cT = /* @__PURE__ */ Ce.widget({ widget: /* @__PURE__ */ new class extends bi {
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-snippetFieldPosition", e;
  }
  ignoreEvent() {
    return !1;
  }
}() }), dT = /* @__PURE__ */ Ce.mark({ class: "cm-snippetField" });
class er {
  constructor(t, n) {
    this.ranges = t, this.active = n, this.deco = Ce.set(t.map((i) => (i.from == i.to ? cT : dT).range(i.from, i.to)));
  }
  map(t) {
    let n = [];
    for (let i of this.ranges) {
      let l = i.map(t);
      if (!l)
        return null;
      n.push(l);
    }
    return new er(n, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((n) => this.ranges.some((i) => i.field == this.active && i.from <= n.from && i.to >= n.to));
  }
}
const xs = /* @__PURE__ */ Le.define({
  map(e, t) {
    return e && e.map(t);
  }
}), fT = /* @__PURE__ */ Le.define(), Kr = /* @__PURE__ */ Mt.define({
  create() {
    return null;
  },
  update(e, t) {
    for (let n of t.effects) {
      if (n.is(xs))
        return n.value;
      if (n.is(fT) && e)
        return new er(e.ranges, n.value);
    }
    return e && t.docChanged && (e = e.map(t.changes)), e && t.selection && !e.selectionInsideField(t.selection) && (e = null), e;
  },
  provide: (e) => me.decorations.from(e, (t) => t ? t.deco : Ce.none)
});
function Bh(e, t) {
  return J.create(e.filter((n) => n.field == t).map((n) => J.range(n.from, n.to)));
}
function hT(e) {
  let t = Dh.parse(e);
  return (n, i, l, a) => {
    let { text: r, ranges: s } = t.instantiate(n.state, l), o = {
      changes: { from: l, to: a, insert: Ne.of(r) },
      scrollIntoView: !0,
      annotations: i ? [Ah.of(i), $t.userEvent.of("input.complete")] : void 0
    };
    if (s.length && (o.selection = Bh(s, 0)), s.some((u) => u.field > 0)) {
      let u = new er(s, 0), c = o.effects = [xs.of(u)];
      n.state.field(Kr, !1) === void 0 && c.push(Le.appendConfig.of([Kr, OT, yT, h6]));
    }
    n.dispatch(n.state.update(o));
  };
}
function m6(e) {
  return ({ state: t, dispatch: n }) => {
    let i = t.field(Kr, !1);
    if (!i || e < 0 && i.active == 0)
      return !1;
    let l = i.active + e, a = e > 0 && !i.ranges.some((r) => r.field == l + e);
    return n(t.update({
      selection: Bh(i.ranges, l),
      effects: xs.of(a ? null : new er(i.ranges, l)),
      scrollIntoView: !0
    })), !0;
  };
}
const mT = ({ state: e, dispatch: t }) => e.field(Kr, !1) ? (t(e.update({ effects: xs.of(null) })), !0) : !1, gT = /* @__PURE__ */ m6(1), vT = /* @__PURE__ */ m6(-1), pT = [
  { key: "Tab", run: gT, shift: vT },
  { key: "Escape", run: mT }
], Hm = /* @__PURE__ */ ve.define({
  combine(e) {
    return e.length ? e[0] : pT;
  }
}), OT = /* @__PURE__ */ cl.highest(/* @__PURE__ */ il.compute([Hm], (e) => e.facet(Hm)));
function fn(e, t) {
  return Object.assign(Object.assign({}, t), { apply: hT(e) });
}
const yT = /* @__PURE__ */ me.domEventHandlers({
  mousedown(e, t) {
    let n = t.state.field(Kr, !1), i;
    if (!n || (i = t.posAtCoords({ x: e.clientX, y: e.clientY })) == null)
      return !1;
    let l = n.ranges.find((a) => a.from <= i && a.to >= i);
    return !l || l.field == n.active ? !1 : (t.dispatch({
      selection: Bh(n.ranges, l.field),
      effects: xs.of(n.ranges.some((a) => a.field > l.field) ? new er(n.ranges, l.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Jr = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, wl = /* @__PURE__ */ Le.define({
  map(e, t) {
    let n = t.mapPos(e, -1, Nt.TrackAfter);
    return n ?? void 0;
  }
}), Eh = /* @__PURE__ */ new class extends Bl {
}();
Eh.startSide = 1;
Eh.endSide = -1;
const g6 = /* @__PURE__ */ Mt.define({
  create() {
    return Ee.empty;
  },
  update(e, t) {
    if (e = e.map(t.changes), t.selection) {
      let n = t.state.doc.lineAt(t.selection.main.head);
      e = e.update({ filter: (i) => i >= n.from && i <= n.to });
    }
    for (let n of t.effects)
      n.is(wl) && (e = e.update({ add: [Eh.range(n.value, n.value + 1)] }));
    return e;
  }
});
function bT() {
  return [ST, g6];
}
const qc = "()[]{}<>";
function v6(e) {
  for (let t = 0; t < qc.length; t += 2)
    if (qc.charCodeAt(t) == e)
      return qc.charAt(t + 1);
  return th(e < 128 ? e : e + 1);
}
function p6(e, t) {
  return e.languageDataAt("closeBrackets", t)[0] || Jr;
}
const CT = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), ST = /* @__PURE__ */ me.inputHandler.of((e, t, n, i) => {
  if ((CT ? e.composing : e.compositionStarted) || e.state.readOnly)
    return !1;
  let l = e.state.selection.main;
  if (i.length > 2 || i.length == 2 && Ln(Ht(i, 0)) == 1 || t != l.from || n != l.to)
    return !1;
  let a = xT(e.state, i);
  return a ? (e.dispatch(a), !0) : !1;
}), wT = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let i = p6(e, e.selection.main.head).brackets || Jr.brackets, l = null, a = e.changeByRange((r) => {
    if (r.empty) {
      let s = PT(e.doc, r.head);
      for (let o of i)
        if (o == s && lc(e.doc, r.head) == v6(Ht(o, 0)))
          return {
            changes: { from: r.head - o.length, to: r.head + o.length },
            range: J.cursor(r.head - o.length)
          };
    }
    return { range: l = r };
  });
  return l || t(e.update(a, { scrollIntoView: !0, userEvent: "delete.backward" })), !l;
}, kT = [
  { key: "Backspace", run: wT }
];
function xT(e, t) {
  let n = p6(e, e.selection.main.head), i = n.brackets || Jr.brackets;
  for (let l of i) {
    let a = v6(Ht(l, 0));
    if (t == l)
      return a == l ? QT(e, l, i.indexOf(l + l + l) > -1, n) : $T(e, l, a, n.before || Jr.before);
    if (t == a && O6(e, e.selection.main.from))
      return VT(e, l, a);
  }
  return null;
}
function O6(e, t) {
  let n = !1;
  return e.field(g6).between(0, e.doc.length, (i) => {
    i == t && (n = !0);
  }), n;
}
function lc(e, t) {
  let n = e.sliceString(t, t + 2);
  return n.slice(0, Ln(Ht(n, 0)));
}
function PT(e, t) {
  let n = e.sliceString(t - 2, t);
  return Ln(Ht(n, 0)) == n.length ? n : n.slice(1);
}
function $T(e, t, n, i) {
  let l = null, a = e.changeByRange((r) => {
    if (!r.empty)
      return {
        changes: [{ insert: t, from: r.from }, { insert: n, from: r.to }],
        effects: wl.of(r.to + t.length),
        range: J.range(r.anchor + t.length, r.head + t.length)
      };
    let s = lc(e.doc, r.head);
    return !s || /\s/.test(s) || i.indexOf(s) > -1 ? {
      changes: { insert: t + n, from: r.head },
      effects: wl.of(r.head + t.length),
      range: J.cursor(r.head + t.length)
    } : { range: l = r };
  });
  return l ? null : e.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function VT(e, t, n) {
  let i = null, l = e.changeByRange((a) => a.empty && lc(e.doc, a.head) == n ? {
    changes: { from: a.head, to: a.head + n.length, insert: n },
    range: J.cursor(a.head + n.length)
  } : i = { range: a });
  return i ? null : e.update(l, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function QT(e, t, n, i) {
  let l = i.stringPrefixes || Jr.stringPrefixes, a = null, r = e.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: t, from: s.from }, { insert: t, from: s.to }],
        effects: wl.of(s.to + t.length),
        range: J.range(s.anchor + t.length, s.head + t.length)
      };
    let o = s.head, u = lc(e.doc, o), c;
    if (u == t) {
      if (jm(e, o))
        return {
          changes: { insert: t + t, from: o },
          effects: wl.of(o + t.length),
          range: J.cursor(o + t.length)
        };
      if (O6(e, o)) {
        let f = n && e.sliceDoc(o, o + t.length * 3) == t + t + t ? t + t + t : t;
        return {
          changes: { from: o, to: o + f.length, insert: f },
          range: J.cursor(o + f.length)
        };
      }
    } else {
      if (n && e.sliceDoc(o - 2 * t.length, o) == t + t && (c = Xm(e, o - 2 * t.length, l)) > -1 && jm(e, c))
        return {
          changes: { insert: t + t + t + t, from: o },
          effects: wl.of(o + t.length),
          range: J.cursor(o + t.length)
        };
      if (e.charCategorizer(o)(u) != dt.Word && Xm(e, o, l) > -1 && !LT(e, o, t, l))
        return {
          changes: { insert: t + t, from: o },
          effects: wl.of(o + t.length),
          range: J.cursor(o + t.length)
        };
    }
    return { range: a = s };
  });
  return a ? null : e.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function jm(e, t) {
  let n = Rt(e).resolveInner(t + 1);
  return n.parent && n.from == t;
}
function LT(e, t, n, i) {
  let l = Rt(e).resolveInner(t, -1), a = i.reduce((r, s) => Math.max(r, s.length), 0);
  for (let r = 0; r < 5; r++) {
    let s = e.sliceDoc(l.from, Math.min(l.to, l.from + n.length + a)), o = s.indexOf(n);
    if (!o || o > -1 && i.indexOf(s.slice(0, o)) > -1) {
      let c = l.firstChild;
      for (; c && c.from == l.from && c.to - c.from > n.length + o; ) {
        if (e.sliceDoc(c.to - n.length, c.to) == n)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = l.to == t && l.parent;
    if (!u)
      break;
    l = u;
  }
  return !1;
}
function Xm(e, t, n) {
  let i = e.charCategorizer(t);
  if (i(e.sliceDoc(t - 1, t)) != dt.Word)
    return t;
  for (let l of n) {
    let a = t - l.length;
    if (e.sliceDoc(a, t) == l && i(e.sliceDoc(a - 1, a)) != dt.Word)
      return a;
  }
  return -1;
}
function MT(e = {}) {
  return [
    oT,
    mn,
    It.of(e),
    rT,
    TT,
    h6
  ];
}
const y6 = [
  { key: "Ctrl-Space", run: zm },
  { mac: "Alt-`", run: zm },
  { key: "Escape", run: nT },
  { key: "ArrowDown", run: /* @__PURE__ */ to(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ to(!1) },
  { key: "PageDown", run: /* @__PURE__ */ to(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ to(!1, "page") },
  { key: "Enter", run: tT }
], TT = /* @__PURE__ */ cl.highest(/* @__PURE__ */ il.computeN([It], (e) => e.facet(It).defaultKeymap ? [y6] : [])), Rd = [
  LV(),
  _V(),
  Lv(),
  d8(),
  bQ(),
  $v(),
  X$(),
  Re.allowMultipleSelections.of(!0),
  sQ(),
  kh(l8, { fallback: !0 }),
  LQ(),
  bT(),
  MT(),
  uV(),
  fV(),
  tV(),
  mM(),
  il.of([
    ...kT,
    ...Wo,
    ..._M,
    ...g8,
    ...vQ,
    ...y6,
    ...KL
  ])
], _T = [
  Lv(),
  d8(),
  $v(),
  kh(l8, { fallback: !0 }),
  il.of([
    ...Wo,
    ...g8
  ])
];
/**
 * vue-codemirror6
 *
 * @description CodeMirror6 Component for vue2 and vue3.
 * @author Logue <logue@hotmail.co.jp>
 * @copyright 2022-2024 By Masashi Yoshikawa All rights reserved.
 * @license MIT
 * @version 1.3.4
 * @see {@link https://github.com/logue/vue-codemirror6}
 */
const AT = (e) => e ? Object.entries(e).reduce((t, [n, i]) => (n = n.charAt(0).toUpperCase() + n.slice(1), n = `on${n}`, { ...t, [n]: i }), {}) : {};
function Nm(e, t = {}, n) {
  const { props: i, domProps: l, on: a, ...r } = t, s = a ? AT(a) : {};
  return A(
    e,
    { ...r, ...i, ...l, ...s },
    n
  );
}
const RT = (e) => typeof e == "function" ? e() : e;
var ZT = E9({
  /** Component Name */
  name: "CodeMirror",
  /** Model Definition */
  model: {
    prop: "modelValue",
    event: "update:modelValue"
  },
  /** Props Definition */
  props: {
    /** Model value */
    modelValue: {
      type: String,
      default: ""
    },
    /**
     * Theme
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView^theme}
     */
    theme: {
      type: Object,
      default: () => ({})
    },
    /** Dark Mode */
    dark: {
      type: Boolean,
      default: !1
    },
    /**
     * Use Basic Setup
     *
     * @see {@link https://codemirror.net/docs/ref/#codemirror.basicSetup}
     */
    basic: {
      type: Boolean,
      default: !1
    },
    /**
     * Use Minimal Setup (The basic setting has priority.)
     *
     * @see {@link https://codemirror.net/docs/ref/#codemirror.minimalSetup}
     */
    minimal: {
      type: Boolean,
      default: !1
    },
    /**
     * Placeholder
     *
     * @see {@link https://codemirror.net/docs/ref/#view.placeholder}
     */
    placeholder: {
      type: String,
      default: void 0
    },
    /**
     * Line wrapping
     *
     * An extension that enables line wrapping in the editor (by setting CSS white-space to pre-wrap in the content).
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView%5ElineWrapping}
     */
    wrap: {
      type: Boolean,
      default: !1
    },
    /**
     * Allow tab key indent.
     *
     * @see {@link https://codemirror.net/examples/tab/}
     */
    tab: {
      type: Boolean,
      default: !1
    },
    /**
     * Tab character
     */
    indentUnit: {
      type: String,
      default: void 0
    },
    /**
     * Allow Multiple Selection.
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^allowMultipleSelections}
     */
    allowMultipleSelections: {
      type: Boolean,
      default: !1
    },
    /**
     * Tab size
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^tabSize}
     */
    tabSize: {
      type: Number,
      default: void 0
    },
    /**
     * Set line break (separetor) char.
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^lineSeparator}
     */
    lineSeparator: {
      type: String,
      default: void 0
    },
    /**
     * Readonly
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^readOnly}
     */
    readonly: {
      type: Boolean,
      default: !1
    },
    /**
     * Disable input.
     *
     * This is the reversed value of the CodeMirror editable.
     * Similar to `readonly`, but setting this value to true disables dragging.
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView^editable}
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Additional Extension
     *
     * @see {@link https://codemirror.net/docs/ref/#state.Extension}
     */
    extensions: {
      type: Array,
      default: () => []
    },
    /**
     * Language Phreses
     *
     * @see {@link https://codemirror.net/examples/translate/}
     */
    phrases: {
      type: Object,
      default: () => {
      }
    },
    /**
     * CodeMirror Language
     *
     * @see {@link https://codemirror.net/docs/ref/#language}
     */
    lang: {
      type: Object,
      default: () => {
      }
    },
    /**
     * CodeMirror Linter
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.linter}
     */
    linter: {
      type: Function,
      default: void 0
    },
    /**
     * Linter Config
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.linter^config}
     */
    linterConfig: {
      type: Object,
      default: () => ({})
    },
    /**
     * Forces any linters configured to run when the editor is idle to run right away.
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.forceLinting}
     */
    forceLinting: {
      type: Boolean,
      default: !1
    },
    /**
     * Show Linter Gutter
     *
     * An area to  the lines with errors will be displayed.
     * This feature is not enabled if `linter` is not specified.
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.lintGutter}
     */
    gutter: {
      type: Boolean,
      default: !1
    },
    /**
     * Gutter Config
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.lintGutter^config}
     */
    gutterConfig: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Using tag
     */
    tag: {
      type: String,
      default: "div"
    }
  },
  /** Emits */
  emits: {
    /** Model Update */
    "update:modelValue": (e = "") => !0,
    /** CodeMirror ViewUpdate */
    update: (e) => !0,
    /** CodeMirror onReady */
    ready: (e) => !0,
    /** CodeMirror onFocus */
    focus: (e) => !0,
    /** State Changed */
    change: (e) => !0,
    /** CodeMirror onDestroy */
    destroy: () => !0
  },
  /**
   * Setup
   *
   * @param props  - Props
   * @param context - Context
   */
  setup(e, t) {
    const n = z(), i = z(e.modelValue), l = ie(new me()), a = C({
      get: () => l.value.hasFocus,
      set: (P) => {
        P && l.value.focus();
      }
    }), r = C({
      get: () => l.value.state.selection,
      set: (P) => l.value.dispatch({ selection: P })
    }), s = C({
      get: () => l.value.state.selection.main.head,
      set: (P) => l.value.dispatch({ selection: { anchor: P } })
    }), o = C(
      {
        get: () => l.value.state.toJSON(),
        set: (P) => l.value.setState(Re.fromJSON(P))
      }
    ), u = z(0), c = z(0), d = C(() => {
      const P = new Ta(), T = new Ta();
      if (e.basic && e.minimal)
        throw "[Vue CodeMirror] Both basic and minimal cannot be specified.";
      return [
        // Toggle basic setup
        e.basic && !e.minimal ? Rd : void 0,
        // Toggle minimal setup
        e.minimal && !e.basic ? _T : void 0,
        // ViewUpdate event listener
        me.updateListener.of((_) => {
          var D;
          t.emit("focus", l.value.hasFocus), u.value = (D = l.value.state.doc) == null ? void 0 : D.length, !(_.changes.empty || !_.docChanged) && (e.linter && (e.forceLinting && Vm(l.value), c.value = e.linter(l.value).length), t.emit("update", _));
        }),
        // Toggle light/dark mode.
        me.theme(e.theme, { dark: e.dark }),
        // Toggle line wrapping
        e.wrap ? me.lineWrapping : void 0,
        // Indent with tab
        e.tab ? il.of([XL]) : void 0,
        // Tab character
        e.indentUnit ? bs.of(e.indentUnit) : void 0,
        // Allow Multiple Selections
        Re.allowMultipleSelections.of(e.allowMultipleSelections),
        // Indent tab size
        e.tabSize ? T.of(Re.tabSize.of(e.tabSize)) : void 0,
        // locale settings
        e.phrases ? Re.phrases.of(e.phrases) : void 0,
        // Readonly option
        Re.readOnly.of(e.readonly),
        // Editable option
        me.editable.of(!e.disabled),
        // Set Line break char
        e.lineSeparator ? Re.lineSeparator.of(e.lineSeparator) : void 0,
        // Lang
        e.lang ? P.of(e.lang) : void 0,
        // Append Linter settings
        e.linter ? eM(e.linter, e.linterConfig) : void 0,
        // Show  to error line when linter enabled.
        e.linter && e.gutter ? oM(e.gutterConfig) : void 0,
        // Placeholder
        e.placeholder ? aV(e.placeholder) : void 0,
        // Append Extensions
        ...e.extensions
      ].filter((_) => !!_);
    });
    ee(
      d,
      (P) => {
        var T;
        (T = l.value) == null || T.dispatch({
          effects: Le.reconfigure.of(P)
        });
      },
      { immediate: !0 }
    ), ee(
      () => e.modelValue,
      async (P) => {
        if (l.value.composing || // IME fix
        l.value.state.doc.toJSON().join(e.lineSeparator ?? `
`) === P)
          return;
        const T = !l.value.state.selection.ranges.every(
          (_) => _.anchor < P.length && _.head < P.length
        );
        l.value.dispatch({
          changes: { from: 0, to: l.value.state.doc.length, insert: P },
          selection: T ? { anchor: 0, head: 0 } : l.value.state.selection,
          scrollIntoView: !0
        });
      },
      { immediate: !0 }
    ), it(async () => {
      let P = i.value;
      n.value && (n.value.childNodes[0] && (i.value !== "" && console.warn(
        "[CodeMirror.vue] The <code-mirror> tag contains child elements that overwrite the `v-model` values."
      ), P = n.value.childNodes[0].innerText.trim()), l.value = new me({
        parent: n.value,
        state: Re.create({ doc: P, extensions: d.value }),
        dispatch: (T) => {
          l.value.update([T]), !(T.changes.empty || !T.docChanged) && (t.emit("update:modelValue", T.state.doc.toString() ?? ""), t.emit("change", T.state));
        }
      }), await He(), t.emit("ready", {
        view: l.value,
        state: l.value.state,
        container: n.value
      }));
    }), ef(() => {
      l.value.destroy(), t.emit("destroy");
    });
    const f = () => {
      !e.linter || !l.value || (e.forceLinting && Vm(l.value), c.value = YL(l.value.state));
    }, h = () => {
      var P, T;
      (P = l.value) == null || P.dispatch({
        effects: Le.reconfigure.of([])
      }), (T = l.value) == null || T.dispatch({
        effects: Le.appendConfig.of(d.value)
      });
    }, g = (P, T) => l.value.state.sliceDoc(P, T), v = (P) => l.value.state.doc.line(P + 1).text, p = () => l.value.state.doc.lines, O = () => l.value.state.selection.main.head, b = () => {
      let P;
      return (P = l.value.state.selection.ranges) !== null && P !== void 0 ? P : [];
    }, V = () => {
      let P;
      return (P = l.value.state.sliceDoc(
        l.value.state.selection.main.from,
        l.value.state.selection.main.to
      )) !== null && P !== void 0 ? P : "";
    }, $ = () => {
      const P = l.value.state;
      return P ? P.selection.ranges.map(
        (T) => P.sliceDoc(T.from, T.to)
      ) : [];
    }, x = () => l.value.state.selection.ranges.some(
      (P) => !P.empty
    ), Q = (P, T, _) => l.value.dispatch({
      changes: { from: T, to: _, insert: P }
    }), M = (P) => l.value.dispatch(l.value.state.replaceSelection(P)), w = (P) => l.value.dispatch({ selection: { anchor: P } }), y = (P, T) => l.value.dispatch({ selection: { anchor: P, head: T } }), L = (P, T) => l.value.dispatch({
      selection: J.create(P, T)
    }), k = (P) => l.value.dispatch({
      selection: J.create(
        r.value.ranges.map((T) => T.extend(P(T)))
      )
    }), S = {
      editor: n,
      view: l,
      cursor: s,
      selection: r,
      focus: a,
      length: u,
      json: o,
      diagnosticCount: c,
      dom: l.value.contentDOM,
      lint: f,
      forceReconfigure: h,
      // Bellow is CodeMirror5's function
      getRange: g,
      getLine: v,
      lineCount: p,
      getCursor: O,
      listSelections: b,
      getSelection: V,
      getSelections: $,
      somethingSelected: x,
      replaceRange: Q,
      replaceSelection: M,
      setCursor: w,
      setSelection: y,
      setSelections: L,
      extendSelectionsBy: k
    };
    return t.expose(S), S;
  },
  render() {
    return Nm(
      this.$props.tag,
      {
        ref: "editor",
        class: "vue-codemirror"
      },
      this.$slots.default ? (
        // Hide original content
        Nm(
          "aside",
          { style: "display: none;", "aria-hidden": "true" },
          RT(this.$slots.default)
        )
      ) : void 0
    );
  }
});
let IT = class Zd {
  /**
  @internal
  */
  constructor(t, n, i, l, a, r, s, o, u, c = 0, d) {
    this.p = t, this.stack = n, this.state = i, this.reducePos = l, this.pos = a, this.score = r, this.buffer = s, this.bufferBase = o, this.curContext = u, this.lookAhead = c, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, n, i = 0) {
    let l = t.parser.context;
    return new Zd(t, [], n, i, i, 0, [], 0, l ? new qm(l, l.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var n;
    let i = t >> 19, l = t & 65535, { parser: a } = this.p, r = this.reducePos < this.pos - 25;
    r && this.setLookAhead(this.pos);
    let s = a.dynamicPrecedence(l);
    if (s && (this.score += s), i == 0) {
      this.pushState(a.getGoto(this.state, l, !0), this.reducePos), l < a.minRepeatTerm && this.storeNode(l, this.reducePos, this.reducePos, r ? 8 : 4, !0), this.reduceContext(l, this.reducePos);
      return;
    }
    let o = this.stack.length - (i - 1) * 3 - (t & 262144 ? 6 : 0), u = o ? this.stack[o - 2] : this.p.ranges[0].from, c = this.reducePos - u;
    c >= 2e3 && !(!((n = this.p.parser.nodeSet.types[l]) === null || n === void 0) && n.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = c));
    let d = o ? this.stack[o - 1] : 0, f = this.bufferBase + this.buffer.length - d;
    if (l < a.minRepeatTerm || t & 131072) {
      let h = a.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(l, u, h, f + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[o];
    else {
      let h = this.stack[o - 3];
      this.state = a.getGoto(h, l, !0);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(l, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, n, i, l = 4, a = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let r = this, s = this.buffer.length;
      if (s == 0 && r.parent && (s = r.bufferBase - r.parent.bufferBase, r = r.parent), s > 0 && r.buffer[s - 4] == 0 && r.buffer[s - 1] > -1) {
        if (n == i)
          return;
        if (r.buffer[s - 2] >= n) {
          r.buffer[s - 2] = i;
          return;
        }
      }
    }
    if (!a || this.pos == i)
      this.buffer.push(t, n, i, l);
    else {
      let r = this.buffer.length;
      if (r > 0 && this.buffer[r - 4] != 0) {
        let s = !1;
        for (let o = r; o > 0 && this.buffer[o - 2] > i; o -= 4)
          if (this.buffer[o - 1] >= 0) {
            s = !0;
            break;
          }
        if (s)
          for (; r > 0 && this.buffer[r - 2] > i; )
            this.buffer[r] = this.buffer[r - 4], this.buffer[r + 1] = this.buffer[r - 3], this.buffer[r + 2] = this.buffer[r - 2], this.buffer[r + 3] = this.buffer[r - 1], r -= 4, l > 4 && (l -= 4);
      }
      this.buffer[r] = t, this.buffer[r + 1] = n, this.buffer[r + 2] = i, this.buffer[r + 3] = l;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, n, i, l) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if (t & 262144)
      this.pos = l, this.shiftContext(n, i), n <= this.p.parser.maxNode && this.buffer.push(n, i, l, 4);
    else {
      let a = t, { parser: r } = this.p;
      (l > this.pos || n <= r.maxNode) && (this.pos = l, r.stateFlag(
        a,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = l)), this.pushState(a, i), this.shiftContext(n, i), n <= r.maxNode && this.buffer.push(n, i, l, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, n, i, l) {
    t & 65536 ? this.reduce(t) : this.shift(t, n, i, l);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, n) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let l = this.pos;
    this.reducePos = this.pos = l + t.length, this.pushState(n, l), this.buffer.push(
      i,
      l,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, n = t.buffer.length;
    for (; n > 0 && t.buffer[n - 2] > t.reducePos; )
      n -= 4;
    let i = t.buffer.slice(n), l = t.bufferBase + n;
    for (; t && l == t.bufferBase; )
      t = t.parent;
    return new Zd(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, l, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, n) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, n, 4), this.storeNode(0, this.pos, n, i ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let n = new DT(this); ; ) {
      let i = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, t);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      n.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let l = [];
      for (let a = 0, r; a < n.length; a += 2)
        (r = n[a + 1]) != this.state && this.p.parser.hasAction(r, t) && l.push(n[a], r);
      if (this.stack.length < 120)
        for (let a = 0; l.length < 8 && a < n.length; a += 2) {
          let r = n[a + 1];
          l.some((s, o) => o & 1 && s == r) || l.push(n[a], r);
        }
      n = l;
    }
    let i = [];
    for (let l = 0; l < n.length && i.length < 4; l += 2) {
      let a = n[l + 1];
      if (a == this.state)
        continue;
      let r = this.split();
      r.pushState(a, this.pos), r.storeNode(0, r.pos, r.pos, 4, !0), r.shiftContext(n[l], this.pos), r.reducePos = this.pos, r.score -= 200, i.push(r);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, n = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(n & 65536))
      return !1;
    if (!t.validAction(this.state, n)) {
      let i = n >> 19, l = n & 65535, a = this.stack.length - i * 3;
      if (a < 0 || t.getGoto(this.stack[a], l, !1) < 0) {
        let r = this.findForcedReduction();
        if (r == null)
          return !1;
        n = r;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, n = [], i = (l, a) => {
      if (!n.includes(l))
        return n.push(l), t.allActions(l, (r) => {
          if (!(r & 393216)) if (r & 65536) {
            let s = (r >> 19) - a;
            if (s > 1) {
              let o = r & 65535, u = this.stack.length - s * 3;
              if (u >= 0 && t.getGoto(this.stack[u], o, !1) >= 0)
                return s << 19 | 65536 | o;
            }
          } else {
            let s = i(r, a + 1);
            if (s != null)
              return s;
          }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != t.stack[n])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(n)));
  }
  reduceContext(t, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let n = new qm(this.curContext.tracker, t);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
class qm {
  constructor(t, n) {
    this.tracker = t, this.context = n, this.hash = t.strict ? t.hash(n) : 0;
  }
}
class DT {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let n = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let l = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = l;
  }
}
class lu {
  constructor(t, n, i) {
    this.stack = t, this.pos = n, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, n = t.bufferBase + t.buffer.length) {
    return new lu(t, n, n - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new lu(this.stack, this.pos, this.index);
  }
}
function Or(e, t = Uint16Array) {
  if (typeof e != "string")
    return e;
  let n = null;
  for (let i = 0, l = 0; i < e.length; ) {
    let a = 0;
    for (; ; ) {
      let r = e.charCodeAt(i++), s = !1;
      if (r == 126) {
        a = 65535;
        break;
      }
      r >= 92 && r--, r >= 34 && r--;
      let o = r - 32;
      if (o >= 46 && (o -= 46, s = !0), a += o, s)
        break;
      a *= 46;
    }
    n ? n[l++] = a : n = new t(a);
  }
  return n;
}
class Oo {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const Ym = new Oo();
class BT {
  /**
  @internal
  */
  constructor(t, n) {
    this.input = t, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Ym, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, n) {
    let i = this.range, l = this.rangeIndex, a = this.pos + t;
    for (; a < i.from; ) {
      if (!l)
        return null;
      let r = this.ranges[--l];
      a -= i.from - r.to, i = r;
    }
    for (; n < 0 ? a > i.to : a >= i.to; ) {
      if (l == this.ranges.length - 1)
        return null;
      let r = this.ranges[++l];
      a += r.from - i.to, i = r;
    }
    return a;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let n of this.ranges)
      if (n.to > t)
        return Math.max(t, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let n = this.chunkOff + t, i, l;
    if (n >= 0 && n < this.chunk.length)
      i = this.pos + t, l = this.chunk.charCodeAt(n);
    else {
      let a = this.resolveOffset(t, 1);
      if (a == null)
        return -1;
      if (i = a, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        l = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let r = this.rangeIndex, s = this.range;
        for (; s.to <= i; )
          s = this.ranges[++r];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > s.to && (this.chunk2 = this.chunk2.slice(0, s.to - i)), l = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), l;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, n = 0) {
    let i = n ? this.resolveOffset(n, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, n) {
    this.token.value = t, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), n = this.pos + t.length;
      this.chunk = n > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, n) {
    if (n ? (this.token = n, n.start = t, n.lookAhead = t + 1, n.value = n.extended = -1) : this.token = Ym, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, n) {
    if (t >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, n - this.chunkPos);
    if (t >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, n - this.chunk2Pos);
    if (t >= this.range.from && n <= this.range.to)
      return this.input.read(t, n);
    let i = "";
    for (let l of this.ranges) {
      if (l.from >= n)
        break;
      l.to > t && (i += this.input.read(Math.max(l.from, t), Math.min(l.to, n)));
    }
    return i;
  }
}
class ka {
  constructor(t, n) {
    this.data = t, this.id = n;
  }
  token(t, n) {
    let { parser: i } = n.p;
    b6(this.data, t, n, this.id, i.data, i.tokenPrecTable);
  }
}
ka.prototype.contextual = ka.prototype.fallback = ka.prototype.extend = !1;
class Id {
  constructor(t, n, i) {
    this.precTable = n, this.elseToken = i, this.data = typeof t == "string" ? Or(t) : t;
  }
  token(t, n) {
    let i = t.pos, l = 0;
    for (; ; ) {
      let a = t.next < 0, r = t.resolveOffset(1, 1);
      if (b6(this.data, t, n, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (a || l++, r == null)
        break;
      t.reset(r, t.token);
    }
    l && (t.reset(i, t.token), t.acceptToken(this.elseToken, l));
  }
}
Id.prototype.contextual = ka.prototype.fallback = ka.prototype.extend = !1;
class Ii {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, n = {}) {
    this.token = t, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
}
function b6(e, t, n, i, l, a) {
  let r = 0, s = 1 << i, { dialect: o } = n.p.parser;
  e: for (; s & e[r]; ) {
    let u = e[r + 1];
    for (let h = r + 3; h < u; h += 2)
      if ((e[h + 1] & s) > 0) {
        let g = e[h];
        if (o.allows(g) && (t.token.value == -1 || t.token.value == g || ET(g, t.token.value, l, a))) {
          t.acceptToken(g);
          break;
        }
      }
    let c = t.next, d = 0, f = e[r + 2];
    if (t.next < 0 && f > d && e[u + f * 3 - 3] == 65535) {
      r = e[u + f * 3 - 1];
      continue e;
    }
    for (; d < f; ) {
      let h = d + f >> 1, g = u + h + (h << 1), v = e[g], p = e[g + 1] || 65536;
      if (c < v)
        f = h;
      else if (c >= p)
        d = h + 1;
      else {
        r = e[g + 2], t.advance();
        continue e;
      }
    }
    break;
  }
}
function Fm(e, t, n) {
  for (let i = t, l; (l = e[i]) != 65535; i++)
    if (l == n)
      return i - t;
  return -1;
}
function ET(e, t, n, i) {
  let l = Fm(n, i, t);
  return l < 0 || Fm(n, i, e) < l;
}
const Cn = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Yc = null;
function Wm(e, t, n) {
  let i = e.cursor(At.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(n < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((n < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            i.to - 1,
            t - 25
            /* Lookahead.Margin */
          )) : Math.min(e.length, Math.max(
            i.from + 1,
            t + 25
            /* Lookahead.Margin */
          ));
        if (n < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return n < 0 ? 0 : e.length;
      }
}
class zT {
  constructor(t, n) {
    this.fragments = t, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? Wm(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? Wm(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let i = this.trees[n], l = this.index[n];
      if (l == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let a = i.children[l], r = this.start[n] + i.positions[l];
      if (r > t)
        return this.nextStart = r, null;
      if (a instanceof Vt) {
        if (r == t) {
          if (r < this.safeFrom)
            return null;
          let s = r + a.length;
          if (s <= this.safeTo) {
            let o = a.prop(Ze.lookAhead);
            if (!o || s + o < this.fragment.to)
              return a;
          }
        }
        this.index[n]++, r + a.length >= Math.max(this.safeFrom, t) && (this.trees.push(a), this.start.push(r), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = r + a.length;
    }
  }
}
class HT {
  constructor(t, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new Oo());
  }
  getActions(t) {
    let n = 0, i = null, { parser: l } = t.p, { tokenizers: a } = l, r = l.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), s = t.curContext ? t.curContext.hash : 0, o = 0;
    for (let u = 0; u < a.length; u++) {
      if (!(1 << u & r))
        continue;
      let c = a[u], d = this.tokens[u];
      if (!(i && !c.fallback) && ((c.contextual || d.start != t.pos || d.mask != r || d.context != s) && (this.updateCachedToken(d, c, t), d.mask = r, d.context = s), d.lookAhead > d.end + 25 && (o = Math.max(d.lookAhead, o)), d.value != 0)) {
        let f = n;
        if (d.extended > -1 && (n = this.addActions(t, d.extended, d.end, n)), n = this.addActions(t, d.value, d.end, n), !c.extend && (i = d, n > f))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return o && t.setLookAhead(o), !i && t.pos == this.stream.end && (i = new Oo(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, n = this.addActions(t, i.value, i.end, n)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let n = new Oo(), { pos: i, p: l } = t;
    return n.start = i, n.end = Math.min(i + 1, l.stream.end), n.value = i == l.stream.end ? l.parser.eofTerm : 0, n;
  }
  updateCachedToken(t, n, i) {
    let l = this.stream.clipPos(i.pos);
    if (n.token(this.stream.reset(l, t), i), t.value > -1) {
      let { parser: a } = i.p;
      for (let r = 0; r < a.specialized.length; r++)
        if (a.specialized[r] == t.value) {
          let s = a.specializers[r](this.stream.read(t.start, t.end), i);
          if (s >= 0 && i.p.parser.dialect.allows(s >> 1)) {
            s & 1 ? t.extended = s >> 1 : t.value = s >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(l + 1);
  }
  putAction(t, n, i, l) {
    for (let a = 0; a < l; a += 3)
      if (this.actions[a] == t)
        return l;
    return this.actions[l++] = t, this.actions[l++] = n, this.actions[l++] = i, l;
  }
  addActions(t, n, i, l) {
    let { state: a } = t, { parser: r } = t.p, { data: s } = r;
    for (let o = 0; o < 2; o++)
      for (let u = r.stateSlot(
        a,
        o ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (s[u] == 65535)
          if (s[u + 1] == 1)
            u = ki(s, u + 2);
          else {
            l == 0 && s[u + 1] == 2 && (l = this.putAction(ki(s, u + 2), n, i, l));
            break;
          }
        s[u] == n && (l = this.putAction(ki(s, u + 1), n, i, l));
      }
    return l;
  }
}
class jT {
  constructor(t, n, i, l) {
    this.parser = t, this.input = n, this.ranges = l, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new BT(n, l), this.tokens = new HT(t, this.stream), this.topTerm = t.top[1];
    let { from: a } = l[0];
    this.stacks = [IT.start(this, t.top[0], a)], this.fragments = i.length && this.stream.end - a > t.bufferLength * 4 ? new zT(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, n = this.minStackPos, i = this.stacks = [], l, a;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [r] = t;
      for (; r.forceReduce() && r.stack.length && r.stack[r.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let r = 0; r < t.length; r++) {
      let s = t[r];
      for (; ; ) {
        if (this.tokens.mainToken = null, s.pos > n)
          i.push(s);
        else {
          if (this.advanceStack(s, i, t))
            continue;
          {
            l || (l = [], a = []), l.push(s);
            let o = this.tokens.getMainToken(s);
            a.push(o.value, o.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let r = l && NT(l);
      if (r)
        return Cn && console.log("Finish with " + this.stackID(r)), this.stackToTree(r);
      if (this.parser.strict)
        throw Cn && l && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && l) {
      let r = this.stoppedAt != null && l[0].pos > this.stoppedAt ? l[0] : this.runRecovery(l, a, i);
      if (r)
        return Cn && console.log("Force-finish " + this.stackID(r)), this.stackToTree(r.forceAll());
    }
    if (this.recovering) {
      let r = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > r)
        for (i.sort((s, o) => o.score - s.score); i.length > r; )
          i.pop();
      i.some((s) => s.reducePos > n) && this.recovering--;
    } else if (i.length > 1) {
      e: for (let r = 0; r < i.length - 1; r++) {
        let s = i[r];
        for (let o = r + 1; o < i.length; o++) {
          let u = i[o];
          if (s.sameState(u) || s.buffer.length > 500 && u.buffer.length > 500)
            if ((s.score - u.score || s.buffer.length - u.buffer.length) > 0)
              i.splice(o--, 1);
            else {
              i.splice(r--, 1);
              continue e;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let r = 1; r < i.length; r++)
      i[r].pos < this.minStackPos && (this.minStackPos = i[r].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, n, i) {
    let l = t.pos, { parser: a } = this, r = Cn ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && l > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let u = t.curContext && t.curContext.tracker.strict, c = u ? t.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(l); d; ) {
        let f = this.parser.nodeSet.types[d.type.id] == d.type ? a.getGoto(t.state, d.type.id) : -1;
        if (f > -1 && d.length && (!u || (d.prop(Ze.contextHash) || 0) == c))
          return t.useNode(d, f), Cn && console.log(r + this.stackID(t) + ` (via reuse of ${a.getName(d.type.id)})`), !0;
        if (!(d instanceof Vt) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let h = d.children[0];
        if (h instanceof Vt && d.positions[0] == 0)
          d = h;
        else
          break;
      }
    }
    let s = a.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (s > 0)
      return t.reduce(s), Cn && console.log(r + this.stackID(t) + ` (via always-reduce ${a.getName(
        s & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let o = this.tokens.getActions(t);
    for (let u = 0; u < o.length; ) {
      let c = o[u++], d = o[u++], f = o[u++], h = u == o.length || !i, g = h ? t : t.split(), v = this.tokens.mainToken;
      if (g.apply(c, d, v ? v.start : g.pos, f), Cn && console.log(r + this.stackID(g) + ` (via ${c & 65536 ? `reduce of ${a.getName(
        c & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${a.getName(d)} @ ${l}${g == t ? "" : ", split"})`), h)
        return !0;
      g.pos > l ? n.push(g) : i.push(g);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, n) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > i)
        return Um(t, n), !0;
    }
  }
  runRecovery(t, n, i) {
    let l = null, a = !1;
    for (let r = 0; r < t.length; r++) {
      let s = t[r], o = n[r << 1], u = n[(r << 1) + 1], c = Cn ? this.stackID(s) + " -> " : "";
      if (s.deadEnd && (a || (a = !0, s.restart(), Cn && console.log(c + this.stackID(s) + " (restarted)"), this.advanceFully(s, i))))
        continue;
      let d = s.split(), f = c;
      for (let h = 0; d.forceReduce() && h < 10 && (Cn && console.log(f + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, i)); h++)
        Cn && (f = this.stackID(d) + " -> ");
      for (let h of s.recoverByInsert(o))
        Cn && console.log(c + this.stackID(h) + " (via recover-insert)"), this.advanceFully(h, i);
      this.stream.end > s.pos ? (u == s.pos && (u++, o = 0), s.recoverByDelete(o, u), Cn && console.log(c + this.stackID(s) + ` (via recover-delete ${this.parser.getName(o)})`), Um(s, i)) : (!l || l.score < s.score) && (l = s);
    }
    return l;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), Vt.build({
      buffer: lu.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let n = (Yc || (Yc = /* @__PURE__ */ new WeakMap())).get(t);
    return n || Yc.set(t, n = String.fromCodePoint(this.nextStackID++)), n + t;
  }
}
function Um(e, t) {
  for (let n = 0; n < t.length; n++) {
    let i = t[n];
    if (i.pos == e.pos && i.sameState(e)) {
      t[n].score < e.score && (t[n] = e);
      return;
    }
  }
  t.push(e);
}
class XT {
  constructor(t, n, i) {
    this.source = t, this.flags = n, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}
const Fc = (e) => e;
class C6 {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || Fc, this.reduce = t.reduce || Fc, this.reuse = t.reuse || Fc, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}
class za extends zv {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let n = t.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let s = 0; s < t.repeatNodeCount; s++)
      n.push("");
    let i = Object.keys(t.topRules).map((s) => t.topRules[s][1]), l = [];
    for (let s = 0; s < n.length; s++)
      l.push([]);
    function a(s, o, u) {
      l[s].push([o, o.deserialize(String(u))]);
    }
    if (t.nodeProps)
      for (let s of t.nodeProps) {
        let o = s[0];
        typeof o == "string" && (o = Ze[o]);
        for (let u = 1; u < s.length; ) {
          let c = s[u++];
          if (c >= 0)
            a(c, o, s[u++]);
          else {
            let d = s[u + -c];
            for (let f = -c; f > 0; f--)
              a(s[u++], o, d);
            u++;
          }
        }
      }
    this.nodeSet = new gh(n.map((s, o) => On.define({
      name: o >= this.minRepeatTerm ? void 0 : s,
      id: o,
      props: l[o],
      top: i.indexOf(o) > -1,
      error: o == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(o) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = Iv;
    let r = Or(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let s = 0; s < this.specializerSpecs.length; s++)
      this.specialized[s] = this.specializerSpecs[s].term;
    this.specializers = this.specializerSpecs.map(Gm), this.states = Or(t.states, Uint32Array), this.data = Or(t.stateData), this.goto = Or(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((s) => typeof s == "number" ? new ka(r, s) : s), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, n, i) {
    let l = new jT(this, t, n, i);
    for (let a of this.wrappers)
      l = a(l, t, n, i);
    return l;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, n, i = !1) {
    let l = this.goto;
    if (n >= l[0])
      return -1;
    for (let a = l[n + 1]; ; ) {
      let r = l[a++], s = r & 1, o = l[a++];
      if (s && i)
        return o;
      for (let u = a + (r >> 1); a < u; a++)
        if (l[a] == t)
          return o;
      if (s)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, n) {
    let i = this.data;
    for (let l = 0; l < 2; l++)
      for (let a = this.stateSlot(
        t,
        l ? 2 : 1
        /* ParseState.Actions */
      ), r; ; a += 3) {
        if ((r = i[a]) == 65535)
          if (i[a + 1] == 1)
            r = i[a = ki(i, a + 2)];
          else {
            if (i[a + 1] == 2)
              return ki(i, a + 2);
            break;
          }
        if (r == n || r == 0)
          return ki(i, a + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, n) {
    return this.states[t * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(t, n) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(t, n) {
    return !!this.allActions(t, (i) => i == n ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, n) {
    let i = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), l = i ? n(i) : void 0;
    for (let a = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); l == null; a += 3) {
      if (this.data[a] == 65535)
        if (this.data[a + 1] == 1)
          a = ki(this.data, a + 2);
        else
          break;
      l = n(ki(this.data, a + 1));
    }
    return l;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let n = [];
    for (let i = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = ki(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let l = this.data[i + 1];
        n.some((a, r) => r & 1 && a == l) || n.push(this.data[i], l);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let n = Object.assign(Object.create(za.prototype), this);
    if (t.props && (n.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      n.top = i;
    }
    return t.tokenizers && (n.tokenizers = this.tokenizers.map((i) => {
      let l = t.tokenizers.find((a) => a.from == i);
      return l ? l.to : i;
    })), t.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((i, l) => {
      let a = t.specializers.find((s) => s.from == i.external);
      if (!a)
        return i;
      let r = Object.assign(Object.assign({}, i), { external: a.to });
      return n.specializers[l] = Gm(r), r;
    })), t.contextTracker && (n.context = t.contextTracker), t.dialect && (n.dialect = this.parseDialect(t.dialect)), t.strict != null && (n.strict = t.strict), t.wrap && (n.wrappers = n.wrappers.concat(t.wrap)), t.bufferLength != null && (n.bufferLength = t.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let n = Object.keys(this.dialects), i = n.map(() => !1);
    if (t)
      for (let a of t.split(" ")) {
        let r = n.indexOf(a);
        r >= 0 && (i[r] = !0);
      }
    let l = null;
    for (let a = 0; a < n.length; a++)
      if (!i[a])
        for (let r = this.dialects[n[a]], s; (s = this.data[r++]) != 65535; )
          (l || (l = new Uint8Array(this.maxTerm + 1)))[s] = 1;
    return new XT(t, i, l);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new za(t);
  }
}
function ki(e, t) {
  return e[t] | e[t + 1] << 16;
}
function NT(e) {
  let t = null;
  for (let n of e) {
    let i = n.p.stoppedAt;
    (n.pos == n.p.stream.end || i != null && n.pos > i) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < n.score) && (t = n);
  }
  return t;
}
function Gm(e) {
  if (e.external) {
    let t = e.extend ? 1 : 0;
    return (n, i) => e.external(n, i) << 1 | t;
  }
  return e.get;
}
const qT = 312, YT = 313, Km = 1, FT = 2, WT = 3, UT = 4, GT = 314, KT = 316, JT = 317, e_ = 5, t_ = 6, n_ = 0, Dd = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], S6 = 125, i_ = 59, Bd = 47, l_ = 42, a_ = 43, r_ = 45, s_ = 60, o_ = 44, u_ = 63, c_ = 46, d_ = 91, f_ = new C6({
  start: !1,
  shift(e, t) {
    return t == e_ || t == t_ || t == KT ? e : t == JT;
  },
  strict: !1
}), h_ = new Ii((e, t) => {
  let { next: n } = e;
  (n == S6 || n == -1 || t.context) && e.acceptToken(GT);
}, { contextual: !0, fallback: !0 }), m_ = new Ii((e, t) => {
  let { next: n } = e, i;
  Dd.indexOf(n) > -1 || n == Bd && ((i = e.peek(1)) == Bd || i == l_) || n != S6 && n != i_ && n != -1 && !t.context && e.acceptToken(qT);
}, { contextual: !0 }), g_ = new Ii((e, t) => {
  e.next == d_ && !t.context && e.acceptToken(YT);
}, { contextual: !0 }), v_ = new Ii((e, t) => {
  let { next: n } = e;
  if (n == a_ || n == r_) {
    if (e.advance(), n == e.next) {
      e.advance();
      let i = !t.context && t.canShift(Km);
      e.acceptToken(i ? Km : FT);
    }
  } else n == u_ && e.peek(1) == c_ && (e.advance(), e.advance(), (e.next < 48 || e.next > 57) && e.acceptToken(WT));
}, { contextual: !0 });
function Wc(e, t) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e == 95 || e >= 192 || !t && e >= 48 && e <= 57;
}
const p_ = new Ii((e, t) => {
  if (e.next != s_ || !t.dialectEnabled(n_) || (e.advance(), e.next == Bd)) return;
  let n = 0;
  for (; Dd.indexOf(e.next) > -1; )
    e.advance(), n++;
  if (Wc(e.next, !0)) {
    for (e.advance(), n++; Wc(e.next, !1); )
      e.advance(), n++;
    for (; Dd.indexOf(e.next) > -1; )
      e.advance(), n++;
    if (e.next == o_) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!Wc(e.next, !0)) return;
        break;
      }
      if (e.next != "extends".charCodeAt(i)) break;
      e.advance(), n++;
    }
  }
  e.acceptToken(UT, -n);
}), O_ = Wu({
  "get set async static": R.modifier,
  "for while do if else switch try catch finally return throw break continue default case": R.controlKeyword,
  "in of await yield void typeof delete instanceof": R.operatorKeyword,
  "let var const using function class extends": R.definitionKeyword,
  "import export from": R.moduleKeyword,
  "with debugger as new": R.keyword,
  TemplateString: R.special(R.string),
  super: R.atom,
  BooleanLiteral: R.bool,
  this: R.self,
  null: R.null,
  Star: R.modifier,
  VariableName: R.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": R.function(R.variableName),
  VariableDefinition: R.definition(R.variableName),
  Label: R.labelName,
  PropertyName: R.propertyName,
  PrivatePropertyName: R.special(R.propertyName),
  "CallExpression/MemberExpression/PropertyName": R.function(R.propertyName),
  "FunctionDeclaration/VariableDefinition": R.function(R.definition(R.variableName)),
  "ClassDeclaration/VariableDefinition": R.definition(R.className),
  PropertyDefinition: R.definition(R.propertyName),
  PrivatePropertyDefinition: R.definition(R.special(R.propertyName)),
  UpdateOp: R.updateOperator,
  "LineComment Hashbang": R.lineComment,
  BlockComment: R.blockComment,
  Number: R.number,
  String: R.string,
  Escape: R.escape,
  ArithOp: R.arithmeticOperator,
  LogicOp: R.logicOperator,
  BitOp: R.bitwiseOperator,
  CompareOp: R.compareOperator,
  RegExp: R.regexp,
  Equals: R.definitionOperator,
  Arrow: R.function(R.punctuation),
  ": Spread": R.punctuation,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace,
  "InterpolationStart InterpolationEnd": R.special(R.brace),
  ".": R.derefOperator,
  ", ;": R.separator,
  "@": R.meta,
  TypeName: R.typeName,
  TypeDefinition: R.definition(R.typeName),
  "type enum interface implements namespace module declare": R.definitionKeyword,
  "abstract global Privacy readonly override": R.modifier,
  "is keyof unique infer": R.operatorKeyword,
  JSXAttributeValue: R.attributeValue,
  JSXText: R.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": R.angleBracket,
  "JSXIdentifier JSXNameSpacedName": R.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": R.attributeName,
  "JSXBuiltin/JSXIdentifier": R.standard(R.tagName)
}), y_ = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, extends: 54, this: 58, true: 66, false: 66, null: 78, void: 82, typeof: 86, super: 102, new: 136, delete: 148, yield: 157, await: 161, class: 166, public: 229, private: 229, protected: 229, readonly: 231, instanceof: 250, satisfies: 253, in: 254, const: 256, import: 290, keyof: 345, unique: 349, infer: 355, is: 391, abstract: 411, implements: 413, type: 415, let: 418, var: 420, using: 423, interface: 429, enum: 433, namespace: 439, module: 441, declare: 445, global: 449, for: 468, of: 477, while: 480, with: 484, do: 488, if: 492, else: 494, switch: 498, case: 504, try: 510, catch: 514, finally: 518, return: 522, throw: 526, break: 530, continue: 534, debugger: 538 }, b_ = { __proto__: null, async: 123, get: 125, set: 127, declare: 189, public: 191, private: 191, protected: 191, static: 193, abstract: 195, override: 197, readonly: 203, accessor: 205, new: 395 }, C_ = { __proto__: null, "<": 187 }, S_ = za.deserialize({
  version: 14,
  states: "$CdQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D^O.QQlO'#DdO.bQlO'#DoO%[QlO'#DwO0fQlO'#EPOOQ!0Lf'#EX'#EXO1PQ`O'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQ`O'#GpO1dQ`O'#ElO1iQ`O'#ElO3hQ!0MxO'#JnO6[Q!0MxO'#JoO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#FzO9RQ`O'#FyOOQ!0Lf'#Jo'#JoOOQ!0Lb'#Jn'#JnO9WQ`O'#GtOOQ['#K['#K[O9cQ`O'#IUO9hQ!0LrO'#IVOOQ['#J['#J[OOQ['#IZ'#IZQ`QlOOQ`QlOOO9pQ!L^O'#DsO9wQlO'#D{O:OQlO'#D}O9^Q`O'#GpO:VQMhO'#CoO:eQ`O'#EkO:pQ`O'#EvO:uQMhO'#FdO;dQ`O'#GpOOQO'#K]'#K]O;iQ`O'#K]O;wQ`O'#GxO;wQ`O'#GyO;wQ`O'#G{O9^Q`O'#HOO<nQ`O'#HRO>VQ`O'#CeO>gQ`O'#H_O>oQ`O'#HeO>oQ`O'#HgO`QlO'#HiO>oQ`O'#HkO>oQ`O'#HnO>tQ`O'#HtO>yQ!0LsO'#HzO%[QlO'#H|O?UQ!0LsO'#IOO?aQ!0LsO'#IQO9hQ!0LrO'#ISO?lQ!0MxO'#CiO@nQpO'#DiQOQ`OOO%[QlO'#D}OAUQ`O'#EQO:VQMhO'#EkOAaQ`O'#EkOAlQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Dn'#DnOOQ!0Lb'#Jr'#JrO%[QlO'#JrOOQO'#Ju'#JuOOQO'#Id'#IdOBlQpO'#EdOOQ!0Lb'#Ec'#EcOOQ!0Lb'#Jy'#JyOChQ!0MSO'#EdOCrQpO'#ETOOQO'#Jt'#JtODWQpO'#JuOEeQpO'#ETOCrQpO'#EdPErO&2DjO'#CbPOOO)CDy)CDyOOOO'#I['#I[OE}O#tO,59UOOQ!0Lh,59U,59UOOOO'#I]'#I]OF]O&jO,59UOFkQ!L^O'#D`OOOO'#I_'#I_OFrO#@ItO,59xOOQ!0Lf,59x,59xOGQQlO'#I`OGeQ`O'#JpOIdQ!fO'#JpO+}QlO'#JpOIkQ`O,5:OOJRQ`O'#EmOJ`Q`O'#KPOJkQ`O'#KOOJkQ`O'#KOOJsQ`O,5;ZOJxQ`O'#J}OOQ!0Ln,5:Z,5:ZOKPQlO,5:ZOL}Q!0MxO,5:cOMnQ`O,5:kONXQ!0LrO'#J|ON`Q`O'#J{O9WQ`O'#J{ONtQ`O'#J{ON|Q`O,5;YO! RQ`O'#J{O!#WQ!fO'#JoOOQ!0Lh'#Ci'#CiO%[QlO'#EPO!#vQ!fO,5:pOOQS'#Jv'#JvOOQO-E<f-E<fO9^Q`O,5=[O!$^Q`O,5=[O!$cQlO,5;WO!&fQMhO'#EhO!(PQ`O,5;WO!(UQlO'#DvO!(`QpO,5;aO!(hQpO,5;aO%[QlO,5;aOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bOOQ['#FY'#FYO!(vQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#IlO!*yQ!0LrO,5<gO%[QlO,5;bO!&fQMhO,5;bO!+hQMhO,5;bO!-YQMhO'#EZO%[QlO,5;vOOQ!0Lf,5;z,5;zO!-aQ,UO'#FiO!.^Q,UO'#KTO!-xQ,UO'#KTO!.eQ,UO'#KTOOQO'#KT'#KTO!.yQ,UO,5<ROOOW,5<_,5<_O!/[QlO'#FuOOOW'#Ik'#IkO7VO7dO,5<PO!/cQ,UO'#FwOOQ!0Lf,5<P,5<PO!0SQ$IUO'#CvOOQ!0Lh'#Cz'#CzO!0gO#@ItO'#DOO!1TQMjO,5<dO!1[Q`O,5<fO!2wQ(CWO'#GVO!3UQ`O'#GWO!3ZQ`O'#GWO!4yQ(CWO'#G[O!6OQpO'#G`OOQO'#Gk'#GkO!+oQMhO'#GjOOQO'#Gm'#GmO!+oQMhO'#GlO!6qQ$IUO'#JhOOQ!0Lh'#Jh'#JhO!6{Q`O'#JgO!7ZQ`O'#JfO!7cQ`O'#CuOOQ!0Lh'#Cx'#CxO!7kQ`O'#CzOOQ!0Lh'#DS'#DSOOQ!0Lh'#DU'#DUO1SQ`O'#DWO!+oQMhO'#F}O!+oQMhO'#GPO!7pQ`O'#GRO!7uQ`O'#GSO!3ZQ`O'#GYO!+oQMhO'#G_O!7zQ`O'#EnO!8iQ`O,5<eOOQ!0Lb'#Cr'#CrO!8qQ`O'#EoO!9kQpO'#EpOOQ!0Lb'#J}'#J}O!9rQ!0LrO'#K^O9hQ!0LrO,5=`O`QlO,5>pOOQ['#Jd'#JdOOQ[,5>q,5>qOOQ[-E<X-E<XO!;qQ!0MxO,5:_O!9fQpO,5:]O!>[Q!0MxO,5:gO%[QlO,5:gO!@rQ!0MxO,5:iOOQO,5@w,5@wO!AcQMhO,5=[O!AqQ!0LrO'#JeO9RQ`O'#JeO!BSQ!0LrO,59ZO!B_QpO,59ZO!BgQMhO,59ZO:VQMhO,59ZO!BrQ`O,5;WO!BzQ`O'#H^O!C`Q`O'#KaO%[QlO,5;|O!9fQpO,5<OO!ChQ`O,5=wO!CmQ`O,5=wO!CrQ`O,5=wO9hQ!0LrO,5=wO;wQ`O,5=gOOQO'#Cv'#CvO!DQQpO,5=dO!DYQMhO,5=eO!DeQ`O,5=gO!DjQ!bO,5=jO!DrQ`O'#K]O>tQ`O'#HTO9^Q`O'#HVO!DwQ`O'#HVO:VQMhO'#HXO!D|Q`O'#HXOOQ[,5=m,5=mO!ERQ`O'#HYO!EdQ`O'#CoO!EiQ`O,59PO!EsQ`O,59PO!GxQlO,59POOQ[,59P,59PO!HYQ!0LrO,59PO%[QlO,59PO!JeQlO'#HaOOQ['#Hb'#HbOOQ['#Hc'#HcO`QlO,5=yO!J{Q`O,5=yO`QlO,5>PO`QlO,5>RO!KQQ`O,5>TO`QlO,5>VO!KVQ`O,5>YO!K[QlO,5>`OOQ[,5>f,5>fO%[QlO,5>fO9hQ!0LrO,5>hOOQ[,5>j,5>jO# fQ`O,5>jOOQ[,5>l,5>lO# fQ`O,5>lOOQ[,5>n,5>nO#!SQpO'#D[O%[QlO'#JrO#!uQpO'#JrO##PQpO'#DjO##bQpO'#DjO#%sQlO'#DjO#%zQ`O'#JqO#&SQ`O,5:TO#&XQ`O'#EqO#&gQ`O'#KQO#&oQ`O,5;[O#&tQpO'#DjO#'RQpO'#ESOOQ!0Lf,5:l,5:lO%[QlO,5:lO#'YQ`O,5:lO>tQ`O,5;VO!B_QpO,5;VO!BgQMhO,5;VO:VQMhO,5;VO#'bQ`O,5@^O#'gQ07dO,5:pOOQO-E<b-E<bO#(mQ!0MSO,5;OOCrQpO,5:oO#(wQpO,5:oOCrQpO,5;OO!BSQ!0LrO,5:oOOQ!0Lb'#Eg'#EgOOQO,5;O,5;OO%[QlO,5;OO#)UQ!0LrO,5;OO#)aQ!0LrO,5;OO!B_QpO,5:oOOQO,5;U,5;UO#)oQ!0LrO,5;OPOOO'#IY'#IYP#*TO&2DjO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ!0Lh1G.p1G.pOOOO-E<Z-E<ZOOOO,59z,59zO#*`Q!bO,59zOOOO-E<]-E<]OOQ!0Lf1G/d1G/dO#*eQ!fO,5>zO+}QlO,5>zOOQO,5?Q,5?QO#*oQlO'#I`OOQO-E<^-E<^O#*|Q`O,5@[O#+UQ!fO,5@[O#+]Q`O,5@jOOQ!0Lf1G/j1G/jO%[QlO,5@kO#+eQ`O'#IfOOQO-E<d-E<dO#+]Q`O,5@jOOQ!0Lb1G0u1G0uOOQ!0Ln1G/u1G/uOOQ!0Ln1G0V1G0VO%[QlO,5@hO#+yQ!0LrO,5@hO#,[Q!0LrO,5@hO#,cQ`O,5@gO9WQ`O,5@gO#,kQ`O,5@gO#,yQ`O'#IiO#,cQ`O,5@gOOQ!0Lb1G0t1G0tO!(`QpO,5:rO!(kQpO,5:rOOQS,5:t,5:tO#-kQdO,5:tO#-sQMhO1G2vO9^Q`O1G2vOOQ!0Lf1G0r1G0rO#.RQ!0MxO1G0rO#/WQ!0MvO,5;SOOQ!0Lh'#GU'#GUO#/tQ!0MzO'#JhO!$cQlO1G0rO#2PQ!fO'#JsO%[QlO'#JsO#2ZQ`O,5:bOOQ!0Lh'#D['#D[OOQ!0Lf1G0{1G0{O%[QlO1G0{OOQ!0Lf1G1e1G1eO#2`Q`O1G0{O#4tQ!0MxO1G0|O#4{Q!0MxO1G0|O#7cQ!0MxO1G0|O#7jQ!0MxO1G0|O#:QQ!0MxO1G0|O#<hQ!0MxO1G0|O#<oQ!0MxO1G0|O#<vQ!0MxO1G0|O#?^Q!0MxO1G0|O#?eQ!0MxO1G0|O#ArQ?MtO'#CiO#CmQ?MtO1G1_O#CtQ?MtO'#JoO#DXQ!0MxO,5?WOOQ!0Lb-E<j-E<jO#FfQ!0MxO1G0|O#GcQ!0MzO1G0|OOQ!0Lf1G0|1G0|O#HfQMjO'#JxO#HpQ`O,5:uO#HuQ!0MxO1G1bO#IiQ,UO,5<VO#IqQ,UO,5<WO#IyQ,UO'#FnO#JbQ`O'#FmOOQO'#KU'#KUOOQO'#Ij'#IjO#JgQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#JxQ?MtO'#JnO#KSQ`O,5<aO!(vQlO,5<aOOOW-E<i-E<iOOQ!0Lf1G1k1G1kO#KXQpO'#KTOOQ!0Lf,5<c,5<cO#KaQpO,5<cO#KfQMhO'#DQOOOO'#I^'#I^O#KmO#@ItO,59jOOQ!0Lh,59j,59jO%[QlO1G2OO!7uQ`O'#InO#KxQ`O,5<xOOQ!0Lh,5<u,5<uO!+oQMhO'#IqO#LfQMjO,5=UO!+oQMhO'#IsO#MXQMjO,5=WO!&fQMhO,5=YOOQO1G2Q1G2QO#McQ!dO'#CrO#MvQ(CWO'#EoO#N{QpO'#G`O$ cQ!dO,5<qO$ jQ`O'#KXO9WQ`O'#KXO$ xQ`O,5<sO!+oQMhO,5<rO$ }Q`O'#GXO$!`Q`O,5<rO$!eQ!dO'#GUO$!rQ!dO'#KYO$!|Q`O'#KYO!&fQMhO'#KYO$#RQ`O,5<vO$#WQlO'#JrO$#bQpO'#GaO##bQpO'#GaO$#sQ`O'#GeO!3ZQ`O'#GhO$#xQ!0LrO'#IpO$$TQpO,5<zOOQ!0Lp,5<z,5<zO$$[QpO'#GaO$$iQpO'#GbO$$zQpO'#GbO$%PQMjO,5=UO$%aQMjO,5=WOOQ!0Lh,5=Z,5=ZO!+oQMhO,5@RO!+oQMhO,5@RO$%qQ`O'#IuO$%|Q`O,5@QO$&UQ`O,59aOOQ!0Lh,59f,59fO$&{Q$IYO,59rOOQ!0Lh'#Jl'#JlO$'nQMjO,5<iO$(aQMjO,5<kO@fQ`O,5<mOOQ!0Lh,5<n,5<nO$(kQ`O,5<tO$(pQMjO,5<yO$)QQ`O'#J{O!$cQlO1G2PO$)VQ`O1G2PO9WQ`O'#KOO9WQ`O'#EqO%[QlO'#EqO9WQ`O'#IwO$)[Q!0LrO,5@xOOQ[1G2z1G2zOOQ[1G4[1G4[OOQ!0Lf1G/y1G/yOOQ!0Lf1G/w1G/wO$+^Q!0MxO1G0ROOQ[1G2v1G2vO!&fQMhO1G2vO%[QlO1G2vO#-vQ`O1G2vO$-bQMhO'#EhOOQ!0Lb,5@P,5@PO$-lQ!0LrO,5@POOQ[1G.u1G.uO!BSQ!0LrO1G.uO!B_QpO1G.uO!BgQMhO1G.uO$-}Q`O1G0rO$.SQ`O'#CiO$._Q`O'#KbO$.gQ`O,5=xO$.lQ`O'#KbO$.qQ`O'#KbO$/PQ`O'#I}O$/_Q`O,5@{O$/gQ!fO1G1hOOQ!0Lf1G1j1G1jO9^Q`O1G3cO@fQ`O1G3cO$/nQ`O1G3cO$/sQ`O1G3cOOQ[1G3c1G3cO!DeQ`O1G3RO!&fQMhO1G3OO$/xQ`O1G3OOOQ[1G3P1G3PO!&fQMhO1G3PO$/}Q`O1G3PO$0VQpO'#G}OOQ[1G3R1G3RO!5yQpO'#IyO!DjQ!bO1G3UOOQ[1G3U1G3UOOQ[,5=o,5=oO$0_QMhO,5=qO9^Q`O,5=qO$#sQ`O,5=sO9RQ`O,5=sO!B_QpO,5=sO!BgQMhO,5=sO:VQMhO,5=sO$0mQ`O'#K`O$0xQ`O,5=tOOQ[1G.k1G.kO$0}Q!0LrO1G.kO@fQ`O1G.kO$1YQ`O1G.kO9hQ!0LrO1G.kO$3bQ!fO,5@}O$3oQ`O,5@}O9WQ`O,5@}O$3zQlO,5={O$4RQ`O,5={OOQ[1G3e1G3eO`QlO1G3eOOQ[1G3k1G3kOOQ[1G3m1G3mO>oQ`O1G3oO$4WQlO1G3qO$8[QlO'#HpOOQ[1G3t1G3tO$8iQ`O'#HvO>tQ`O'#HxOOQ[1G3z1G3zO$8qQlO1G3zO9hQ!0LrO1G4QOOQ[1G4S1G4SOOQ!0Lb'#G]'#G]O9hQ!0LrO1G4UO9hQ!0LrO1G4WO$<xQ`O,5@^O!(vQlO,5;]O9WQ`O,5;]O>tQ`O,5:UO!(vQlO,5:UO!B_QpO,5:UO$<}Q?MtO,5:UOOQO,5;],5;]O$=XQpO'#IaO$=oQ`O,5@]OOQ!0Lf1G/o1G/oO$=wQpO'#IgO$>RQ`O,5@lOOQ!0Lb1G0v1G0vO##bQpO,5:UOOQO'#Ic'#IcO$>ZQpO,5:nOOQ!0Ln,5:n,5:nO#']Q`O1G0WOOQ!0Lf1G0W1G0WO%[QlO1G0WOOQ!0Lf1G0q1G0qO>tQ`O1G0qO!B_QpO1G0qO!BgQMhO1G0qOOQ!0Lb1G5x1G5xO!BSQ!0LrO1G0ZOOQO1G0j1G0jO%[QlO1G0jO$>bQ!0LrO1G0jO$>mQ!0LrO1G0jO!B_QpO1G0ZOCrQpO1G0ZO$>{Q!0LrO1G0jOOQO1G0Z1G0ZO$?aQ!0MxO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$?kQ!bO,5<gO$?sQ!fO1G4fOOQO1G4l1G4lO%[QlO,5>zO$?}Q`O1G5vO$@VQ`O1G6UO$@_Q!fO1G6VO9WQ`O,5?QO$@iQ!0MxO1G6SO%[QlO1G6SO$@yQ!0LrO1G6SO$A[Q`O1G6RO$A[Q`O1G6RO9WQ`O1G6RO$AdQ`O,5?TO9WQ`O,5?TOOQO,5?T,5?TO$AxQ`O,5?TO$)QQ`O,5?TOOQO-E<g-E<gOOQS1G0^1G0^OOQS1G0`1G0`O#-nQ`O1G0`OOQ[7+(b7+(bO!&fQMhO7+(bO%[QlO7+(bO$BWQ`O7+(bO$BcQMhO7+(bO$BqQ!0MzO,5=UO$D|Q!0MzO,5=WO$GXQ!0MzO,5=UO$IjQ!0MzO,5=WO$K{Q!0MzO,59rO$NQQ!0MzO,5<iO%!]Q!0MzO,5<kO%$hQ!0MzO,5<yOOQ!0Lf7+&^7+&^O%&yQ!0MxO7+&^O%'mQlO'#IbO%'zQ`O,5@_O%(SQ!fO,5@_OOQ!0Lf1G/|1G/|O%(^Q`O7+&gOOQ!0Lf7+&g7+&gO%(cQ?MtO,5:cO%[QlO7+&yO%(mQ?MtO,5:_O%(zQ?MtO,5:gO%)UQ?MtO,5:iO%)`QMhO'#IeO%)jQ`O,5@dOOQ!0Lh1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%)rQ!jO,5<YO!(vQlO,5<XOOQO-E<h-E<hOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%)}Q`O1G1{OOQ!0Lf1G1}1G1}OOOO,59l,59lO%*SQ!dO,59lOOOO-E<[-E<[OOQ!0Lh1G/U1G/UO%*ZQ!0MxO7+'jOOQ!0Lh,5?Y,5?YO%*}QMhO1G2dP%+UQ`O'#InPOQ!0Lh-E<l-E<lO%+rQMjO,5?]OOQ!0Lh-E<o-E<oO%,eQMjO,5?_OOQ!0Lh-E<q-E<qO%,oQ!dO1G2tO%,vQ!dO'#CrO%-^QMhO'#KOO$#WQlO'#JrOOQ!0Lh1G2]1G2]O%-eQ`O'#ImO%-yQ`O,5@sO%-yQ`O,5@sO%.RQ`O,5@sO%.^Q`O,5@sOOQO1G2_1G2_O%.lQMjO1G2^O!+oQMhO1G2^O%.|Q(CWO'#IoO%/ZQ`O,5@tO!&fQMhO,5@tO%/cQ!dO,5@tOOQ!0Lh1G2b1G2bO%1sQ!fO'#CiO%1}Q`O,5<}OOQ!0Lb,5<{,5<{O%2VQpO,5<{OOQ!0Lb,5<|,5<|OCcQ`O,5<{O%2bQpO,5<{OOQ!0Lb,5=P,5=PO$)QQ`O,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ!0Lp1G2f1G2fO##bQpO,5<{O$#WQlO,5<}O%2pQ`O,5<|O%2{QpO,5<|O!+oQMhO'#IqO%3uQMjO1G2pO!+oQMhO'#IsO%4hQMjO1G2rO%4rQMjO1G5mO%4|QMjO1G5mOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9fQpO,59tO%[QlO,59tOOQ!0Lh,5<h,5<hO%5ZQ`O1G2XO!+oQMhO1G2`O%5`Q!0MxO7+'kOOQ!0Lf7+'k7+'kO!$cQlO7+'kO%6SQ`O,5;]OOQ!0Lb,5?c,5?cOOQ!0Lb-E<u-E<uO%6XQ!dO'#KZO#']Q`O7+(bO4UQ!fO7+(bO$BZQ`O7+(bO%6cQ!0MvO'#CiO%6vQ!0MvO,5=QO%7hQ`O,5=QOOQ!0Lb1G5k1G5kOOQ[7+$a7+$aO!BSQ!0LrO7+$aO!B_QpO7+$aO!$cQlO7+&^O%7mQ`O'#I|O%8UQ`O,5@|OOQO1G3d1G3dO9^Q`O,5@|O%8UQ`O,5@|O%8^Q`O,5@|OOQO,5?i,5?iOOQO-E<{-E<{OOQ!0Lf7+'S7+'SO%8cQ`O7+(}O9hQ!0LrO7+(}O9^Q`O7+(}O@fQ`O7+(}OOQ[7+(m7+(mO%8hQ!0MvO7+(jO!&fQMhO7+(jO!D`Q`O7+(kOOQ[7+(k7+(kO!&fQMhO7+(kO%8rQ`O'#K_O%8}Q`O,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQ[7+(p7+(pO%:aQpO'#HWOOQ[1G3]1G3]O!&fQMhO1G3]O%[QlO1G3]O%:hQ`O1G3]O%:sQMhO1G3]O9hQ!0LrO1G3_O$#sQ`O1G3_O9RQ`O1G3_O!B_QpO1G3_O!BgQMhO1G3_O%;RQ`O'#I{O%;gQ`O,5@zO%;oQpO,5@zOOQ!0Lb1G3`1G3`OOQ[7+$V7+$VO@fQ`O7+$VO9hQ!0LrO7+$VO%;zQ`O7+$VO%[QlO1G6iO%[QlO1G6jO%<PQ!0LrO1G6iO%<ZQlO1G3gO%<bQ`O1G3gO%<gQlO1G3gOOQ[7+)P7+)PO9hQ!0LrO7+)ZO`QlO7+)]OOQ['#Ke'#KeOOQ['#JO'#JOO%<nQlO,5>[OOQ[,5>[,5>[O%[QlO'#HqO%<{Q`O'#HsOOQ[,5>b,5>bO9WQ`O,5>bOOQ[,5>d,5>dOOQ[7+)f7+)fOOQ[7+)l7+)lOOQ[7+)p7+)pOOQ[7+)r7+)rO%=QQpO1G5xO%=lQ?MtO1G0wO%=vQ`O1G0wOOQO1G/p1G/pO%>RQ?MtO1G/pO>tQ`O1G/pO!(vQlO'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!B_QpO1G/pOOQO-E<a-E<aOOQ!0Ln1G0Y1G0YOOQ!0Lf7+%r7+%rO#']Q`O7+%rOOQ!0Lf7+&]7+&]O>tQ`O7+&]O!B_QpO7+&]OOQO7+%u7+%uO$?aQ!0MxO7+&UOOQO7+&U7+&UO%[QlO7+&UO%>]Q!0LrO7+&UO!BSQ!0LrO7+%uO!B_QpO7+%uO%>hQ!0LrO7+&UO%>vQ!0MxO7++nO%[QlO7++nO%?WQ`O7++mO%?WQ`O7++mOOQO1G4o1G4oO9WQ`O1G4oO%?`Q`O1G4oOOQS7+%z7+%zO#']Q`O<<K|O4UQ!fO<<K|O%?nQ`O<<K|OOQ[<<K|<<K|O!&fQMhO<<K|O%[QlO<<K|O%?vQ`O<<K|O%@RQ!0MzO,5?]O%B^Q!0MzO,5?_O%DiQ!0MzO1G2^O%FzQ!0MzO1G2pO%IVQ!0MzO1G2rO%KbQ!fO,5>|O%[QlO,5>|OOQO-E<`-E<`O%KlQ`O1G5yOOQ!0Lf<<JR<<JRO%KtQ?MtO1G0rO%M{Q?MtO1G0|O%NSQ?MtO1G0|O&!TQ?MtO1G0|O&![Q?MtO1G0|O&$]Q?MtO1G0|O&&^Q?MtO1G0|O&&eQ?MtO1G0|O&&lQ?MtO1G0|O&(mQ?MtO1G0|O&(tQ?MtO1G0|O&({Q!0MxO<<JeO&*sQ?MtO1G0|O&+pQ?MvO1G0|O&,sQ?MvO'#JhO&.yQ?MtO1G1bO&/WQ?MtO1G0RO&/bQMjO,5?POOQO-E<c-E<cO!(vQlO'#FpOOQO'#KV'#KVOOQO1G1t1G1tO&/lQ`O1G1sO&/qQ?MtO,5?WOOOW7+'g7+'gOOOO1G/W1G/WO&/{Q!dO1G4tOOQ!0Lh7+(O7+(OP!&fQMhO,5?YO!+oQMhO7+(`O&0SQ`O,5?XO9WQ`O,5?XOOQO-E<k-E<kO&0bQ`O1G6_O&0bQ`O1G6_O&0jQ`O1G6_O&0uQMjO7+'xO&1VQ!dO,5?ZO&1aQ`O,5?ZO!&fQMhO,5?ZOOQO-E<m-E<mO&1fQ!dO1G6`O&1pQ`O1G6`O&1xQ`O1G2iO!&fQMhO1G2iOOQ!0Lb1G2g1G2gOOQ!0Lb1G2h1G2hO%2VQpO1G2gO!B_QpO1G2gOCcQ`O1G2gOOQ!0Lb1G2n1G2nO&1}QpO1G2gO&2]Q`O1G2iO$)QQ`O1G2hOCcQ`O1G2hO$#WQlO1G2iO&2eQ`O1G2hO&3XQMjO,5?]OOQ!0Lh-E<p-E<pO&3zQMjO,5?_OOQ!0Lh-E<r-E<rO!+oQMhO7++XOOQ!0Lh1G/`1G/`O&4UQ`O1G/`OOQ!0Lh7+'s7+'sO&4ZQMjO7+'zO&4kQ!0MxO<<KVOOQ!0Lf<<KV<<KVO&5_Q`O1G0wO!&fQMhO'#IvO&5dQ`O,5@uO&7fQ!fO<<K|O!&fQMhO1G2lOOQ[<<G{<<G{O!BSQ!0LrO<<G{O&7mQ!0MxO<<IxOOQ!0Lf<<Ix<<IxOOQO,5?h,5?hO&8aQ`O,5?hO&8fQ`O,5?hOOQO-E<z-E<zO&8tQ`O1G6hO&8tQ`O1G6hO9^Q`O1G6hO@fQ`O<<LiOOQ[<<Li<<LiO&8|Q`O<<LiO9hQ!0LrO<<LiOOQ[<<LU<<LUO%8hQ!0MvO<<LUOOQ[<<LV<<LVO!D`Q`O<<LVO&9RQpO'#IxO&9^Q`O,5@yO!(vQlO,5@yOOQ[1G3T1G3TOOQO'#Iz'#IzO9hQ!0LrO'#IzO&9fQpO,5=rOOQ[,5=r,5=rO&9mQpO'#EdO&9tQpO'#GcO&9yQ`O7+(wO&:OQ`O7+(wOOQ[7+(w7+(wO!&fQMhO7+(wO%[QlO7+(wO&:WQ`O7+(wOOQ[7+(y7+(yO9hQ!0LrO7+(yO$#sQ`O7+(yO9RQ`O7+(yO!B_QpO7+(yO&:cQ`O,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&:nQ`O1G6fO9hQ!0LrO<<GqOOQ[<<Gq<<GqO@fQ`O<<GqO&:vQ`O7+,TO&:{Q`O7+,UO%[QlO7+,TO%[QlO7+,UOOQ[7+)R7+)RO&;QQ`O7+)RO&;VQlO7+)RO&;^Q`O7+)ROOQ[<<Lu<<LuOOQ[<<Lw<<LwOOQ[-E<|-E<|OOQ[1G3v1G3vO&;cQ`O,5>]OOQ[,5>_,5>_O&;hQ`O1G3|O9WQ`O7+&cO!(vQlO7+&cOOQO7+%[7+%[O&;mQ?MtO1G6VO>tQ`O7+%[OOQ!0Lf<<I^<<I^OOQ!0Lf<<Iw<<IwO>tQ`O<<IwOOQO<<Ip<<IpO$?aQ!0MxO<<IpO%[QlO<<IpOOQO<<Ia<<IaO!BSQ!0LrO<<IaO&;wQ!0LrO<<IpO&<SQ!0MxO<= YO&<dQ`O<= XOOQO7+*Z7+*ZO9WQ`O7+*ZOOQ[ANAhANAhO&<lQ!fOANAhO!&fQMhOANAhO#']Q`OANAhO4UQ!fOANAhO&<sQ`OANAhO%[QlOANAhO&<{Q!0MzO7+'xO&?^Q!0MzO,5?]O&AiQ!0MzO,5?_O&CtQ!0MzO7+'zO&FVQ!fO1G4hO&FaQ?MtO7+&^O&HeQ?MvO,5=UO&JlQ?MvO,5=WO&J|Q?MvO,5=UO&K^Q?MvO,5=WO&KnQ?MvO,59rO&MtQ?MvO,5<iO' wQ?MvO,5<kO'$]Q?MvO,5<yO'&RQ?MtO7+'jO'&`Q?MtO7+'kO'&mQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*`7+*`O'&rQMjO<<KzOOQO1G4s1G4sO'&yQ`O1G4sO''UQ`O1G4sO''dQ`O7++yO''dQ`O7++yO!&fQMhO1G4uO''lQ!dO1G4uO''vQ`O7++zO'(OQ`O7+(TO'(ZQ!dO7+(TOOQ!0Lb7+(R7+(ROOQ!0Lb7+(S7+(SO!B_QpO7+(ROCcQ`O7+(RO'(eQ`O7+(TO!&fQMhO7+(TO$)QQ`O7+(SO'(jQ`O7+(TOCcQ`O7+(SO'(rQMjO<<NsOOQ!0Lh7+$z7+$zO'(|Q!dO,5?bOOQO-E<t-E<tO')WQ!0MvO7+(WOOQ[AN=gAN=gO9^Q`O1G5SOOQO1G5S1G5SO')hQ`O1G5SO')mQ`O7+,SO')mQ`O7+,SO9hQ!0LrOANBTO@fQ`OANBTOOQ[ANBTANBTOOQ[ANApANApOOQ[ANAqANAqO')uQ`O,5?dOOQO-E<v-E<vO'*QQ?MtO1G6eOOQO,5?f,5?fOOQO-E<x-E<xOOQ[1G3^1G3^O'*[Q`O,5<}OOQ[<<Lc<<LcO!&fQMhO<<LcO&9yQ`O<<LcO'*aQ`O<<LcO%[QlO<<LcOOQ[<<Le<<LeO9hQ!0LrO<<LeO$#sQ`O<<LeO9RQ`O<<LeO'*iQpO1G5RO'*tQ`O7+,QOOQ[AN=]AN=]O9hQ!0LrOAN=]OOQ[<= o<= oOOQ[<= p<= pO'*|Q`O<= oO'+RQ`O<= pOOQ[<<Lm<<LmO'+WQ`O<<LmO'+]QlO<<LmOOQ[1G3w1G3wO>tQ`O7+)hO'+dQ`O<<I}O'+oQ?MtO<<I}OOQO<<Hv<<HvOOQ!0LfAN?cAN?cOOQOAN?[AN?[O$?aQ!0MxOAN?[OOQOAN>{AN>{O%[QlOAN?[OOQO<<Mu<<MuOOQ[G27SG27SO!&fQMhOG27SO#']Q`OG27SO'+yQ!fOG27SO4UQ!fOG27SO',QQ`OG27SO',YQ?MtO<<JeO',gQ?MvO1G2^O'.]Q?MvO,5?]O'0`Q?MvO,5?_O'2cQ?MvO1G2pO'4fQ?MvO1G2rO'6iQ?MtO<<KVO'6vQ?MtO<<IxOOQO1G1v1G1vO!+oQMhOANAfOOQO7+*_7+*_O'7TQ`O7+*_O'7`Q`O<= eO'7hQ!dO7+*aOOQ!0Lb<<Ko<<KoO$)QQ`O<<KoOCcQ`O<<KoO'7rQ`O<<KoO!&fQMhO<<KoOOQ!0Lb<<Km<<KmO!B_QpO<<KmO'7}Q!dO<<KoOOQ!0Lb<<Kn<<KnO'8XQ`O<<KoO!&fQMhO<<KoO$)QQ`O<<KnOOQO7+*n7+*nO9^Q`O7+*nO'8^Q`O<= nOOQ[G27oG27oO9hQ!0LrOG27oO!(vQlO1G5OO'8fQ`O7+,PO'8nQ`O1G2iO&9yQ`OANA}OOQ[ANA}ANA}O!&fQMhOANA}O'8sQ`OANA}OOQ[ANBPANBPO9hQ!0LrOANBPO$#sQ`OANBPOOQO'#H['#H[OOQO7+*m7+*mOOQ[G22wG22wOOQ[ANEZANEZOOQ[ANE[ANE[OOQ[ANBXANBXO'8{Q`OANBXOOQ[<<MS<<MSO!(vQlOAN?iOOQOG24vG24vO$?aQ!0MxOG24vO#']Q`OLD,nOOQ[LD,nLD,nO!&fQMhOLD,nO'9QQ!fOLD,nO'9XQ?MvO7+'xO':}Q?MvO,5?]O'=QQ?MvO,5?_O'?TQ?MvO7+'zO'@yQMjOG27QOOQO<<My<<MyOOQ!0LbANAZANAZO$)QQ`OANAZOCcQ`OANAZO'AZQ!dOANAZOOQ!0LbANAXANAXO'AbQ`OANAZO!&fQMhOANAZO'AmQ!dOANAZOOQ!0LbANAYANAYOOQO<<NY<<NYOOQ[LD-ZLD-ZO'AwQ?MtO7+*jOOQO'#Gd'#GdOOQ[G27iG27iO&9yQ`OG27iO!&fQMhOG27iOOQ[G27kG27kO9hQ!0LrOG27kOOQ[G27sG27sO'BRQ?MtOG25TOOQOLD*bLD*bOOQ[!$(!Y!$(!YO#']Q`O!$(!YO!&fQMhO!$(!YO'B]Q!0MzOG27QOOQ!0LbG26uG26uO$)QQ`OG26uO'DnQ`OG26uOCcQ`OG26uO'DyQ!dOG26uO!&fQMhOG26uOOQ[LD-TLD-TO&9yQ`OLD-TOOQ[LD-VLD-VOOQ[!)9Et!)9EtO#']Q`O!)9EtOOQ!0LbLD,aLD,aO$)QQ`OLD,aOCcQ`OLD,aO'EQQ`OLD,aO'E]Q!dOLD,aOOQ[!$(!o!$(!oOOQ[!.K;`!.K;`O'EdQ?MvOG27QOOQ!0Lb!$( {!$( {O$)QQ`O!$( {OCcQ`O!$( {O'GYQ`O!$( {OOQ!0Lb!)9Eg!)9EgO$)QQ`O!)9EgOCcQ`O!)9EgOOQ!0Lb!.K;R!.K;RO$)QQ`O!.K;ROOQ!0Lb!4/0m!4/0mO!(vQlO'#DwO1PQ`O'#EUO'GeQ!fO'#JnO'GlQ!L^O'#DsO'GsQlO'#D{O'GzQ!fO'#CiO'JbQ!fO'#CiO!(vQlO'#D}O'JrQlO,5;WO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO'#IlO'LuQ`O,5<gO!(vQlO,5;bO'L}QMhO,5;bO'NhQMhO,5;bO!(vQlO,5;vO!&fQMhO'#GjO'L}QMhO'#GjO!&fQMhO'#GlO'L}QMhO'#GlO1SQ`O'#DWO1SQ`O'#DWO!&fQMhO'#F}O'L}QMhO'#F}O!&fQMhO'#GPO'L}QMhO'#GPO!&fQMhO'#G_O'L}QMhO'#G_O!(vQlO,5:gO'NoQpO'#D[O'NyQpO'#JrO!(vQlO,5@kO'JrQlO1G0rO( TQ?MtO'#CiO!(vQlO1G2OO!&fQMhO'#IqO'L}QMhO'#IqO!&fQMhO'#IsO'L}QMhO'#IsO( _Q!dO'#CrO!&fQMhO,5<rO'L}QMhO,5<rO'JrQlO1G2PO!(vQlO7+&yO!&fQMhO1G2^O'L}QMhO1G2^O!&fQMhO'#IqO'L}QMhO'#IqO!&fQMhO'#IsO'L}QMhO'#IsO!&fQMhO1G2`O'L}QMhO1G2`O'JrQlO7+'kO'JrQlO7+&^O!&fQMhOANAfO'L}QMhOANAfO( rQ`O'#ElO( wQ`O'#ElO(!PQ`O'#F[O(!UQ`O'#EvO(!ZQ`O'#KPO(!fQ`O'#J}O(!qQ`O,5;WO(!vQMjO,5<dO(!}Q`O'#GWO(#SQ`O'#GWO(#XQ`O,5<eO(#aQ`O,5;WO(#iQ?MtO1G1_O(#pQ`O,5<rO(#uQ`O,5<rO(#zQ`O,5<tO($PQ`O,5<tO($UQ`O1G2PO($ZQ`O1G0rO($`QMjO<<KzO($gQMjO<<KzO7eQMhO'#FzO9RQ`O'#FyOAaQ`O'#EkO!(vQlO,5;sO!3ZQ`O'#GWO!3ZQ`O'#GWO!3ZQ`O'#GYO!3ZQ`O'#GYO!+oQMhO7+(`O!+oQMhO7+(`O%,oQ!dO1G2tO%,oQ!dO1G2tO!&fQMhO,5=YO!&fQMhO,5=Y",
  stateData: "(%k~O'xOS'yOSTOS'zRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(PSO(RTO(UUO(]VO(k[O(ziO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;kO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(Q!lO(RTO(UUO(a!mO(k!sO~O'z!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'v]X(]]X(n]X(u]X(v]X~O!d%PX~P(qO_!}O(R#PO(S!}O(T#PO~O_#QO(T#PO(U#PO(V#QO~Ou#SO!R#TO(^#TO(_#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P;oO(RTO(UUO(]VO(k[O(ziO~O!X#ZO!Y#WO!V(dP!V(rP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(RTO(UUO(]VO(k[O(ziO~Om#mO!X#iO!y]O#f#lO#g#iO(P;pO!h(oP~P.iO!i#oO(P#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~Oa(bX'v(bX's(bX!h(bX!V(bX![(bX%f(bX!d(bX~P1qO#P$dO#]$eO$P$eOP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#s(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX![(cX%f(cX~Oa(cX'v(cX's(cX!V(cX!h(cXs(cX!d(cX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(P$sO(RTO(UUO(]$uO(u$}O(v%POg(YP~O!i%cO~O!P%fO![%gO(P%eO~O!d%kO~Oa%lO'v%lO~O}%pO~P%[O(Q!lO~P%[O%k%tO~P%[Oh%VO!i%cO(P%eO(Q!lO~Oe%{O!i%cO(P%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(P%eO(Q!lO(RTO(UUO`)TP~O!u#sO~O%p&VO!P)PX![)PX(P)PX~O(P&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(Q!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'v%lO~Oa%lO't&{O'v%lO~Oa%lO't&}O'v%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(Q!lO(RTO(UUO~Op'RO!P'QO!X'UO(a'PO!Z(eP!Z(tP~P@YOk'_O![']O(P%eO~Oe'dO!i%cO(P%eO~O}&QO!i&PO~Op!nO!P!oO!y;kO#Q!pO#R!pO#T!pO#U!pO(Q!lO(RTO(UUO(a!mO(k!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'v%lO(n'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(RTO(UUO(a!mO(k!sO~O![XOp(iX!P(iX!_(iX!`(iX!a(iX!y(iX#Q(iX#R(iX#S(iX#T(iX#U(iX#X(iX#Y(iX(Q(iX(R(iX(U(iX(a(iX(k(iX~O!`'iO!a'iO(Q!lO~PCrO'{'uO'|'uO'}'wO~O_!}O(R'yO(S!}O(T'yO~O_#QO(T'yO(U'yO(V#QO~Os'{O~P%[Ou#SO!R#TO(^#TO(_(OO~O!X(QO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(SO!V(dX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(SO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~O!V(dX~PGmO!V(XO~O!V(qX!Y(qX!d(qX!h(qX(n(qX~O#](qX#h#aX!Z(qX~PIpO#](YO!V(sX!Y(sX~O!Y(ZO!V(rX~O!V(^O~O#]$eO~PIpO!Z(_O~P`OR#zO}#yO!P#{O!i#xO(]VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(n!ka(u!ka(v!ka~Oa!ka'v!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKWO!h(`O~O!d#vO#](aO(n'mO!Y(pXa(pX'v(pX~O!h(pX~PMsO!P%fO![%gO!y]O#f(fO#g(eO(P%eO~O!Y(gO!h(oX~O!h(iO~O!P%fO![%gO#g(eO(P%eO~OP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#s(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX~O!d#vO!h(cX~P! aOR(kO}(jO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(P!xa~P!#bO!u(oO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~O#h(uO~O!X(wO!h(gP~P%[O(a(yO(k[O~O!P({O!i#xO(a(yO(k[O~OP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![!eO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(P)YO(RTO(UUO(]VO(k[O(z=dO~O!Y$_Oa$oa'v$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)aO~P!&fOh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~Og(lP~P!+oO})fO!d)eO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)eO![(wX$Y(wX$[(wX$^(wX$e(wX~O})fO~P!-xO})fO![(wX$Y(wX$[(wX$^(wX$e(wX~O![)hO$Y)lO$[)gO$^)gO$e)mO~O!X)pO~P!(vO$[$hO$^$gO$e)tO~Ok$xX}$xX#P$xX'u$xX(u$xX(v$xX~OgjXg$xXkjX!YjX#]jX~P!/nOu)vO(^)wO(_)yO~Ok*SO}){O'u)|O(u$}O(v%PO~Og)zO~P!0rOg*TO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P*VO![*WO!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(RTO(UUO(]$uO(u$}O(v%PO~O!X*ZO(P*UO!h({P~P!1aO#h*]O~O!i*^O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(P*`O(RTO(UUO(]$uO(u$}O(v%PO~O!X*cO!V(|P~P!3`Oo*oOp!nO!P*eO!_*mO!`*gO!a*gO!i*^O#X*nO%]*iO(Q!lO(RTO(UUO(a!mO~O!Z*lO~P!5TO#P$dOk([X}([X'u([X(u([X(v([X!Y([X#]([X~Og([X#}([X~P!6VOk*tO#]*sOg(ZX!Y(ZX~O!Y*uOg(YX~O(P&WOg(YP~Op*xO~O!i*}O~O(P(sO~Om+RO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(P%eO!h(oP~O!d#vO#h+SO~O!P%fO!X+UO!Y(ZO![%gO(P%eO!V(rP~Op'XO!P+WO!X+VO(RTO(UUO(a(yO~O!Z(tP~P!9VO!Y+XOa)QX'v)QX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~Oa!ga!Y!ga'v!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9}OR#zO}#yO!P#{O!i#xO(]VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(n!oa(u!oa(v!oa~Oa!oa'v!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<eOR#zO}#yO!P#{O!i#xO(]VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(n!qa(u!qa(v!qa~Oa!qa'v!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>{Oh%VOk+bO![']O%f+aO~O!d+dOa(XX![(XX'v(XX!Y(XX~Oa%lO![XO'v%lO~Oh%VO!i%cO~Oh%VO!i%cO(P%eO~O!d#vO#h(uO~Ob+oO%g+pO(P+lO(RTO(UUO!Z)UP~O!Y+qO`)TX~O[+uO~O`+vO~O![%}O(P%eO(Q!lO`)TP~Oh%VO#]+{O~Oh%VOk,OO![$|O~O![,QO~O},SO![XO~O%k%tO~O!u,XO~Oe,^O~Ob,_O(P#nO(RTO(UUO!Z)SP~Oe%{O~O%g!QO(P&WO~P=RO[,dO`,cO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(RTO(UUO(]VO(k[O(ziO~O![!eO!r!gO$V!kO(P!dO~P!E{O`,cOa%lO'v%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oa,iO!rwO#t!OO%i!OO%j!OO%k!OO~P!HeO!i&lO~O&Y,oO~O![,qO~O&k,sO&m,tOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(P&ha(R&ha(U&ha(]&ha(k&ha(z&ha!Z&ha&a&hab&ha&f&ha~O(P,yO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# kO!d-OO#],}Oh(fX!Y#eX!Z#eX!d(fX!i(fX~O!Y(fX!Z(fX~P#!^Oh%VO!d-QO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(RTO(UUO(a!mO~OP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![!eO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(RTO(UUO(]VO(k[O(z=dO~O(P<fO~P##sO!Y-UO!Z(eX~O!Z-WO~O!d-OO#],}O!Y#eX!Z#eX~O!Y-XO!Z(tX~O!Z-ZO~O!`-[O!a-[O(Q!lO~P##bO!Z-_O~P'_Ok-bO![']O~O!V-gO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(Q!xa(R!xa(U!xa(a!xa(k!xa~P!#bO!m-lO#]-jO~PCSO!`-nO!a-nO(Q!lO~PCrOa%lO#]-jO'v%lO~Oa%lO!d#vO#]-jO'v%lO~Oa%lO!d#vO!m-lO#]-jO'v%lO(n'mO~O'{'uO'|'uO'}-sO~Os-tO~O!V'Sa!Y'Sa~P!9}O!X-xO!V'SX!Y'SX~P%[O!Y(SO!V(da~O!V(da~PGmO!Y(ZO!V(ra~O!P%fO!X-|O![%gO(P%eO!V'YX!Y'YX~O#].OO!Y(pa!h(paa(pa'v(pa~O!d#vO~P#+yO!Y(gO!h(oa~O!P%fO![%gO#g.SO(P%eO~Om.XO!P%fO!X.UO![%gO!y]O#f.WO#g.UO(P%eO!Y']X!h']X~OR.]O!i#xO~Oh%VOk.`O![']O%f._O~Oa#`i!Y#`i'v#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9}Ok=pO}){O'u)|O(u$}O(v%PO~O#h#[aa#[a#]#[a'v#[a!Y#[a!h#[a![#[a!V#[a~P#.uO#h([XP([XR([X[([Xa([Xo([X!P([X!i([X!m([X#O([X#k([X#l([X#m([X#n([X#o([X#p([X#q([X#r([X#s([X#u([X#w([X#y([X#z([X'v([X(]([X(n([X!h([X!V([X's([Xs([X![([X%f([X!d([X~P!6VO!Y.mO!h(gX~P!9}O!h.pO~O!V.rO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O(]VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#2eO#k$OO~P#2eOP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO(]VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#5SO#o$QO~P#5SOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO(]VOa#ji!Y#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7qOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO(]VO(v#}Oa#ji!Y#ji#y#ji#z#ji'v#ji(n#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#:XO#w#ji~P#:XO#u$SO~P#7qOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO(]VO(u#|O(v#}Oa#ji!Y#ji#z#ji'v#ji(n#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<}O#y$WO~P#<}OP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X!Y]X!Z]X~O#}]X~P#?lOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO#w;yO#y;{O#z;|O(]VO(n$YO(u#|O(v#}O~O#}.tO~P#AyO#P$dO#]<SO$P<SO#}(cX!Z(cX~P! aOa'`a!Y'`a'v'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9}O[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO(]VO(u#ji(v#ji~P#D{Ok=pO}){O'u)|O(u$}O(v%POP#jiR#ji!P#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji(]#ji~P#D{O!Y.xOg(lX~P!0rOg.zO~Oa$Oi!Y$Oi'v$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9}O$[.{O$^.{O~O$[.|O$^.|O~O!d)eO#].}O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X/OO~O![)hO$Y/QO$[)gO$^)gO$e/RO~O!Y;}O!Z(bX~P#AyO!Z/SO~O!d)eO$e(wX~O$e/UO~Os/VO~P!&fOu)vO(^)wO(_/YO~O!P/]O~O(u$}Ok%^a}%^a'u%^a(v%^a!Y%^a#]%^a~Og%^a#}%^a~P#K}O(v%POk%`a}%`a'u%`a(u%`a!Y%`a#]%`a~Og%`a#}%`a~P#LpO!YfX!dfX!hfX!h$xX(nfX~P!/nO!X/fO!Y(ZO(P/eO!V(rP!V(|P~P!1aOo*oO!_*mO!`*gO!a*gO!i*^O#X*nO%]*iO(Q!lO(RTO(UUO~Op<cO!P/gO!X+VO!Z*lO(a<bO!Z(tP~P#NZO!h/hO~P#.uO!Y/iO!d#vO(n'mO!h({X~O!h/nO~O!P%fO!X*ZO![%gO(P%eO!h({P~O#h/pO~O!V$xX!Y$xX!d%PX~P!/nO!Y/qO!V(|X~P#.uO!d/sO~O!V/uO~OmkO(P/vO~P.iOh%VOo/{O!d#vO!i%cO(n'mO~O!d+dO~Oa%lO!Y0PO'v%lO~O!Z0RO~P!5TO!`0SO!a0SO(Q!lO~P##bOp!nO!P0TO(RTO(UUO(a!mO~O#X0VO~Og%^a!Y%^a#]%^a#}%^a~P!0rOg%`a!Y%`a#]%`a#}%`a~P!0rO(P&WOg'iX!Y'iX~O!Y*uOg(Ya~Og0`O~OR0aO}0aO!P0bO#P$dOkza'uza(uza(vza!Yza#]za~Ogza#}za~P$&ZO}){O'u)|Ok$qa(u$qa(v$qa!Y$qa#]$qa~Og$qa#}$qa~P$'VO}){O'u)|Ok$sa(u$sa(v$sa!Y$sa#]$sa~Og$sa#}$sa~P$'xO#h0eO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0rO!d#vO~O#h0hO~O!Y+XOa)Qa'v)Qa~OR#zO}#yO!P#{O!i#xO(]VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(n!oi(u!oi(v!oi~Oa!oi'v!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$)gOh%VOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(RTO(UUO(]$uO(u$}O(v%PO~Om0qO(P0pO~P$+}O!d+dOa(Xa![(Xa'v(Xa!Y(Xa~O#h0wO~O[]X!YfX!ZfX~O!Y0xO!Z)UX~O!Z0zO~O[0{O~Ob0}O(P+lO(RTO(UUO~O![%}O(P%eO`'qX!Y'qX~O!Y+qO`)Ta~O!h1QO~P!9}O[1TO~O`1UO~O#]1XO~Ok1[O![$|O~O(a(yO!Z)RP~Oh%VOk1eO![1bO%f1dO~O[1oO!Y1mO!Z)SX~O!Z1pO~O`1rOa%lO'v%lO~O(P#nO(RTO(UUO~O#P$dO#]$eO$P$eOP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX~O#s1uO&W1vOa(cX~P$1eO#]$eO#s1uO&W1vO~Oa1xO~P%[Oa1zO~O&a1}OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(P&_i(R&_i(U&_i(]&_i(k&_i(z&_i!Z&_ib&_i&f&_i~Ob2TO!Z2RO&f2SO~P`O![XO!i2VO~O&m,tOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(P&hi(R&hi(U&hi(]&hi(k&hi(z&hi!Z&hi&a&hib&hi&f&hi~O!V2]O~O!Y!^a!Z!^a~P#AyOp!nO!P!oO!X2cO(a!mO!Y'TX!Z'TX~P@YO!Y-UO!Z(ea~O!Y'ZX!Z'ZX~P!9VO!Y-XO!Z(ta~O!Z2jO~P'_Oa%lO#]2sO'v%lO~Oa%lO!d#vO#]2sO'v%lO~Oa%lO!d#vO!m2wO#]2sO'v%lO(n'mO~Oa%lO'v%lO~P!9}O!Y$_Os$oa~O!V'Si!Y'Si~P!9}O!Y(SO!V(di~O!Y(ZO!V(ri~O!V(si!Y(si~P!9}O!Y(pi!h(pia(pi'v(pi~P!9}O#]2yO!Y(pi!h(pia(pi'v(pi~O!Y(gO!h(oi~O!P%fO![%gO!y]O#f3OO#g2}O(P%eO~O!P%fO![%gO#g2}O(P%eO~Ok3VO![']O%f3UO~Oh%VOk3VO![']O%f3UO~O#h%^aP%^aR%^a[%^aa%^ao%^a!P%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'v%^a(]%^a(n%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K}O#h%`aP%`aR%`a[%`aa%`ao%`a!P%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'v%`a(]%`a(n%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LpO#h%^aP%^aR%^a[%^aa%^ao%^a!P%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'v%^a(]%^a(n%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.uO#h%`aP%`aR%`a[%`aa%`ao%`a!P%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'v%`a(]%`a(n%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.uO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'vza(]za(nza!hza!Vza'szasza![za%fza!dza~P$&ZO#h$qaP$qaR$qa[$qaa$qao$qa!P$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'v$qa(]$qa(n$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$'VO#h$saP$saR$sa[$saa$sao$sa!P$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'v$sa(]$sa(n$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$'xO#h%RaP%RaR%Ra[%Raa%Rao%Ra!P%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'v%Ra(]%Ra(n%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.uOa#`q!Y#`q'v#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9}O!X3_O!Y'UX!h'UX~P%[O!Y.mO!h(ga~O!Y.mO!h(ga~P!9}O!V3bO~O#}!ka!Z!ka~PKWO#}!ga!Y!ga!Z!ga~P#AyO#}!oa!Z!oa~P!<eO#}!qa!Z!qa~P!>{Og'XX!Y'XX~P!+oO!Y.xOg(la~OSfO![3vO$c3wO~O!Z3{O~Os3|O~P#.uOa$lq!Y$lq'v$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9}O!V4OO~P!&fO!P4PO~O}){O'u)|O(v%POk'ea(u'ea!Y'ea#]'ea~Og'ea#}'ea~P%+ZO}){O'u)|Ok'ga(u'ga(v'ga!Y'ga#]'ga~Og'ga#}'ga~P%+|O(n$YO~P#.uO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/nO(P<lO~P!1aO!P%fO!X4SO![%gO(P%eO!Y'aX!h'aX~O!Y/iO!h({a~O!Y/iO!d#vO!h({a~O!Y/iO!d#vO(n'mO!h({a~Og$zi!Y$zi#]$zi#}$zi~P!0rO!X4[O!V'cX!Y'cX~P!3`O!Y/qO!V(|a~O!Y/qO!V(|a~P#.uOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X~O!d%WX#s%WX~P%/mO!d#vO#s4aO~Oh%VO!d#vO!i%cO~Oh%VOo4fO!i%cO(n'mO~Oo4kO!d#vO(n'mO~Op!nO!P4lO(RTO(UUO(a!mO~O(u$}Ok%^i}%^i'u%^i(v%^i!Y%^i#]%^i~Og%^i#}%^i~P%3^O(v%POk%`i}%`i'u%`i(u%`i!Y%`i#]%`i~Og%`i#}%`i~P%4POg(Zi!Y(Zi~P!0rO#]4rOg(Zi!Y(Zi~P!0rO!h4uO~Oa$mq!Y$mq'v$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9}O!V4yO~O!Y4zO![(}X~P#.uOa$xX![$xX%Z]X'v$xX!Y$xX~P!/nO%Z4}OalXklX}lX![lX'ulX'vlX(ulX(vlX!YlX~O%Z4}O~Ob5TO%g5UO(P+lO(RTO(UUO!Y'pX!Z'pX~O!Y0xO!Z)Ua~O[5YO~O`5ZO~Oa%lO'v%lO~P#.uO!Y5cO#]5eO!Z)RX~O!Z5fO~Oo5lOp!nO!P*eO!_!yO!`!vO!a!vO!y;kO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5kO#Y!zO(Q!lO(RTO(UUO(a!mO(k!sO~O!Z5jO~P%9SOk5qO![1bO%f5pO~Oh%VOk5qO![1bO%f5pO~Ob5xO(P#nO(RTO(UUO!Y'oX!Z'oX~O!Y1mO!Z)Sa~O(RTO(UUO(a5zO~O`6OO~O#s6RO&W6SO~PMsO!h6TO~P%[Oa6VO~Oa6VO~P%[Ob2TO!Z6[O&f2SO~P`O!d6^O~O!d6`Oh(fi!Y(fi!Z(fi!d(fi!i(fio(fi(n(fi~O!Y#ei!Z#ei~P#AyO#]6aO!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AyOa%lO#]6jO'v%lO~Oa%lO!d#vO#]6jO'v%lO~O!Y(pq!h(pqa(pq'v(pq~P!9}O!Y(gO!h(oq~O!P%fO![%gO#g6qO(P%eO~O![']O%f6tO~Ok6xO![']O%f6tO~O#h'eaP'eaR'ea['eaa'eao'ea!P'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'v'ea(]'ea(n'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%+ZO#h'gaP'gaR'ga['gaa'gao'ga!P'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'v'ga(]'ga(n'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%+|O#h$ziP$ziR$zi[$zia$zio$zi!P$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'v$zi(]$zi(n$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.uO#h%^iP%^iR%^i[%^ia%^io%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'v%^i(]%^i(n%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%3^O#h%`iP%`iR%`i[%`ia%`io%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'v%`i(]%`i(n%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%4PO!Y'Ua!h'Ua~P!9}O!Y.mO!h(gi~O#}#`i!Y#`i!Z#`i~P#AyOP$[OR#zO}#yO!P#{O!i#xO!m$[O(]VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#k#ji~P%LRO#k;sO~P%LROP$[OR#zOo<PO}#yO!P#{O!i#xO!m$[O#k;sO#l;tO#m;tO#n;tO(]VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#o#ji~P%NZO#o;uO~P%NZOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO(]VO#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#u#ji~P&!cOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO(]VO(v#}O#y#ji#z#ji#}#ji(n#ji(u#ji!Y#ji!Z#ji~O#w;yO~P&$dO#w#ji~P&$dO#u;wO~P&!cOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO#w;yO(]VO(u#|O(v#}O#z#ji#}#ji(n#ji!Y#ji!Z#ji~O#y#ji~P&&sO#y;{O~P&&sOa#{y!Y#{y'v#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9}O[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;sO#l;tO#m;tO#n;tO(]VO(u#ji(v#ji~P&)oOk=qO}){O'u)|O(u$}O(v%POP#jiR#ji!P#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji(]#ji~P&)oO#P$dOP([XR([X[([Xk([Xo([X}([X!P([X!i([X!m([X#O([X#k([X#l([X#m([X#n([X#o([X#p([X#q([X#r([X#s([X#u([X#w([X#y([X#z([X#}([X'u([X(]([X(n([X(u([X(v([X!Y([X!Z([X~O#}$Oi!Y$Oi!Z$Oi~P#AyO#}!oi!Z!oi~P$)gOg'Xa!Y'Xa~P!0rO!Z7[O~O!Y'`a!Z'`a~P#AyO!V7]O~P#.uO!d#vO(n'mO!Y'aa!h'aa~O!Y/iO!h({i~O!Y/iO!d#vO!h({i~Og$zq!Y$zq#]$zq#}$zq~P!0rO!V'ca!Y'ca~P#.uO!d7dO~O!Y/qO!V(|i~P#.uO!Y/qO!V(|i~O!V7gO~Oh%VOo7lO!i%cO(n'mO~O!d#vO#s7nO~Oo7qO!d#vO(n'mO~O}){O'u)|O(v%POk'fa(u'fa!Y'fa#]'fa~Og'fa#}'fa~P&2pO}){O'u)|Ok'ha(u'ha(v'ha!Y'ha#]'ha~Og'ha#}'ha~P&3cO!V7sO~Og$|q!Y$|q#]$|q#}$|q~P!0rOa$my!Y$my'v$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9}O!d6`O~O!Y4zO![(}a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa(]$Sa(n$Sa(u$Sa(v$Sa~O%f6tO~P&5lOa#`y!Y#`y'v#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9}O[7xO~Ob7zO(P+lO(RTO(UUO~O!Y0xO!Z)Ui~O`8OO~O(a(yO!Y'lX!Z'lX~O!Y5cO!Z)Ra~O!Z8XO~P%9SO(k!sO~P$$iO#X8YO~O![1bO~O![1bO%f8[O~Ok8_O![1bO%f8[O~O[8dO!Y'oa!Z'oa~O!Y1mO!Z)Si~O!h8hO~O!h8iO~O!h8lO~O!h8lO~P%[Oa8nO~O!d8oO~O!h8pO~O!Y(si!Z(si~P#AyOa%lO#]8xO'v%lO~O!Y(py!h(pya(py'v(py~P!9}O!Y(gO!h(oy~O%f8{O~P&5lO![']O%f8{O~O#h$zqP$zqR$zq[$zqa$zqo$zq!P$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'v$zq(]$zq(n$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.uO#h'faP'faR'fa['faa'fao'fa!P'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'v'fa(]'fa(n'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&2pO#h'haP'haR'ha['haa'hao'ha!P'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'v'ha(]'ha(n'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&3cO#h$|qP$|qR$|q[$|qa$|qo$|q!P$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'v$|q(]$|q(n$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.uO!Y'Ui!h'Ui~P!9}O#}#`q!Y#`q!Z#`q~P#AyO(u$}OP%^aR%^a[%^ao%^a!P%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a(]%^a(n%^a!Y%^a!Z%^a~Ok%^a}%^a'u%^a(v%^a~P&FnO(v%POP%`aR%`a[%`ao%`a!P%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a(]%`a(n%`a!Y%`a!Z%`a~Ok%`a}%`a'u%`a(u%`a~P&HuOk=qO}){O'u)|O(v%PO~P&FnOk=qO}){O'u)|O(u$}O~P&HuOR0aO}0aO!P0bO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za'uza(]za(nza(uza(vza!Yza!Zza~O}){O'u)|OP$qaR$qa[$qak$qao$qa!P$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa(]$qa(n$qa(u$qa(v$qa!Y$qa!Z$qa~O}){O'u)|OP$saR$sa[$sak$sao$sa!P$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa(]$sa(n$sa(u$sa(v$sa!Y$sa!Z$sa~Ok=qO}){O'u)|O(u$}O(v%PO~OP%RaR%Ra[%Rao%Ra!P%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra(]%Ra(n%Ra!Y%Ra!Z%Ra~P'#zO#}$lq!Y$lq!Z$lq~P#AyO#}$mq!Y$mq!Z$mq~P#AyO!Z9YO~O#}9ZO~P!0rO!d#vO!Y'ai!h'ai~O!d#vO(n'mO!Y'ai!h'ai~O!Y/iO!h({q~O!V'ci!Y'ci~P#.uO!Y/qO!V(|q~Oo9bO!d#vO(n'mO~O[9dO!V9cO~P#.uO!V9cO~O!d#vO#s9jO~Og(Zy!Y(Zy~P!0rO!Y'ja!['ja~P#.uOa%Yq![%Yq'v%Yq!Y%Yq~P#.uO[9mO~O!Y0xO!Z)Uq~O#]9qO!Y'la!Z'la~O!Y5cO!Z)Ri~P#AyO!P9sO~O![1bO%f9vO~O(RTO(UUO(a9{O~O!Y1mO!Z)Sq~O!h:OO~O!h:PO~O!h:QO~O!h:QO~P%[O#]:TO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AyO%f:YO~P&5lO![']O%f:YO~O#}#{y!Y#{y!Z#{y~P#AyOP$ziR$zi[$zio$zi!P$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi(]$zi(n$zi!Y$zi!Z$zi~P'#zO}){O'u)|O(v%POP'eaR'ea['eak'eao'ea!P'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(]'ea(n'ea(u'ea!Y'ea!Z'ea~O}){O'u)|OP'gaR'ga['gak'gao'ga!P'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(]'ga(n'ga(u'ga(v'ga!Y'ga!Z'ga~O(u$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i'u%^i(]%^i(n%^i(v%^i!Y%^i!Z%^i~O(v%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i'u%`i(]%`i(n%`i(u%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AyO#}#`y!Y#`y!Z#`y~P#AyO!d#vO!Y'aq!h'aq~O!Y/iO!h({y~O!V'cq!Y'cq~P#.uOo:dO!d#vO(n'mO~O[:hO!V:gO~P#.uO!V:gO~O!Y0xO!Z)Uy~O!Y5cO!Z)Rq~O(P:nO~O![1bO%f:qO~O!h:tO~O%f:yO~P&5lOP$zqR$zq[$zqo$zq!P$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq(]$zq(n$zq!Y$zq!Z$zq~P'#zO}){O'u)|O(v%POP'faR'fa['fak'fao'fa!P'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(]'fa(n'fa(u'fa!Y'fa!Z'fa~O}){O'u)|OP'haR'ha['hak'hao'ha!P'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(]'ha(n'ha(u'ha(v'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!P$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q(]$|q(n$|q!Y$|q!Z$|q~P'#zOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0rO!V:}O~P#.uOo;OO!d#vO(n'mO~O[;QO!V:}O~P#.uO!Y'lq!Z'lq~P#AyO!Y#e!Z!Z#e!Z~P#AyO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!P%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'v%b!Z(]%b!Z(n%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.uOo;YO!d#vO(n'mO~O!V;ZO~P#.uOo;bO!d#vO(n'mO~O!V;cO~P#.uOP%b!ZR%b!Z[%b!Zo%b!Z!P%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z(]%b!Z(n%b!Z!Y%b!Z!Z%b!Z~P'#zOo;fO!d#vO(n'mO~Os(bX~P1qO}%pO~P!(vO(Q!lO~P!(vO!VfX!YfX#]fX~P%/mOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X~O!dfX!h]X!hfX(nfX~P'HXOP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![XO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(P)YO(RTO(UUO(]VO(k[O(z=dO~O!Y;}O!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<YO!P${O![$|O!f=kO!i$xO#g<`O$V%_O$r<[O$t<^O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~O#t)aO~P'L}Oo!bX(n!bX~P# kOo(fX(n(fX~P#!^O!Z]X!ZfX~P'HXO!VfX!V$xX!YfX!Y$xX#]fX~P!/nO#h;rO~O!d#vO#h;rO~O#]<SO~O#s;vO~O#]<dO!Y(sX!Z(sX~O#]<SO!Y(qX!Z(qX~O#h<eO~Og<gO~P!0rO#h<mO~O#h<nO~O!d#vO#h<oO~O!d#vO#h<eO~O#}<pO~P#AyO#h<qO~O#h<rO~O#h<wO~O#h<xO~O#h<yO~O#h<zO~O#}<{O~P!0rO#}<|O~P!0rO#P#Q#R#T#U#X#f#g#r(z$r$t$w%Z%e%f%g%n%p%s%t%v%x~'zT#l!U'x(Q#mp#k#no}'y$['y(P$^(a~",
  goto: "$6w)YPPPPPP)ZPP)^P)oP+P/RPPPP6XPP6oPP<g@VP@jP@jPPP@jPBnP@jP@jP@jPBrPBwPCfPH`PPPHdPPPPHdKgPPPKmL_PHdPHdPPNmHdPPPHdPHdP!!tHdP!&[!'a!'jP!(^!(b!(^!+oPPPPPPP!,`!'aPP!,p!.bP!1nHdHd!1s!5P!9m!9m!=lPPP!=tHdPPPPPPPPPPP!ATP!BbPPHd!CsPHdPHdHdHdHdHdPHd!EVP!HaP!KgP!Kk!Ku!Ky!KyP!H^P!K}!K}P# TP# XHdHd# _#$dBr@jP@jP@j@jP#%q@j@j#(P@j#*s@j#,{@j@j#-k#/{#/{#0Q#0Z#/{#0fP#/{P@j#1O@j#4u@j@j6XPPP#8rPPP#9]#9]P#9]P#9s#9]PP#9yP#9pP#9p#:^#9p#:x#;O#;R)^#;U)^P#;]#;]#;]P)^P)^P)^P)^PP)^P#;c#;fP#;f)^P#;jP#;mP)^P)^P)^P)^P)^P)^)^PP#;s#;y#<U#<[#<b#<h#<n#<|#=S#=^#=d#=n#=t#>U#>[#>|#?`#?f#?l#?z#@a#BQ#B`#Bg#C}#D]#Ey#FX#F_#Fe#Fk#Fu#F{#GR#G]#Go#GuPPPPPPPPPPP#G{PPPPPPP#Hp#Kw#Ma#Mh#MpPPP$%OP$%X$(Q$.k$.n$.q$/p$/s$/z$0SP$0Y$0]P$0y$0}$1u$3T$3Y$3pPP$3u$3{$4PP$4S$4W$4[$5W$5o$6W$6[$6_$6b$6h$6k$6o$6sR!|RoqOXst!Z#d%k&o&q&r&t,l,q1}2QY!vQ']-^1b5iQ%rvQ%zyQ&R|Q&g!VS'T!e-UQ'c!iS'i!r!yU*g$|*W*kQ+j%{Q+w&TQ,]&aQ-['[Q-f'dQ-n'jQ0S*mQ1l,^R<a;n%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W,i,l,q-b-j-x.O.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3_4l5q6R6S6V6j8_8n8xS#q];k!r)[$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gU*z%[<X<YQ+o%}Q,_&dQ,f&lQ0n+bQ0r+dQ0}+pQ1t,dQ3R.`Q5T0xQ5x1mQ6v3VQ7z5UR9O6x'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g!S!nQ!r!v!y!z$|'T'[']'i'j'k*g*k*m*n-U-[-^-n0S0V1b5i5k%S$ti#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qQ&U|Q'R!eS'X%g-XQ+o%}Q,_&dQ0d*}Q0}+pQ1S+vQ1s,cQ1t,dQ5T0xQ5^1UQ5x1mQ5{1oQ5|1rQ7z5UQ7}5ZQ8g6OQ9p8OQ9|8dR<c*WrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QR,a&h&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=f=g[#]WZ#W#Z'U(Q!b%hm#h#i#l$x%c%f(Z(e(f(g*V*Z*^+U+V+X,h-O-|.S.T.U.W/f/i2V2}3O4S6`6qQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(n#sS+i%z%{Q+m%}Q,W&_Q,[&aS-e'c'dQ.b(oQ0v+jQ0|+pQ1O+qQ1R+uQ1g,XS1k,],^Q2o-fQ5S0xQ5W0{Q5]1TQ5w1lQ7y5UQ7|5YQ9l7xR:k9m!O$zi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m!^%wy!i!u%y%z%{'S'b'c'd'h'r*f+i+j-R-e-f-m/y/|0v2h2o2v4d4e4h7k9fQ+c%uQ+|&XQ,P&YQ,Z&aQ.a(nQ1f,WU1j,[,],^Q3W.bQ5r1gS5v1k1lQ8c5w#d=h#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qo=i<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|W%Ti%V*u=dS&X!Q&fQ&Y!RQ&Z!SR+z&V%T%Si#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qT)w$u)xV*z%[<X<YW'X!e%g*W-XS(z#y#zQ+^%pQ+t&QS.Z(j(kQ1],QQ4s0aR8S5c'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g$i$^c#Y#e%o%q%s(P(V(q(v)O)P)Q)R)S)T)U)V)W)X)Z)])_)d)n+_+s-S-q-v-{-}.l.o.s.u.v.w/Z0f2^2a2q2x3^3c3d3e3f3g3h3i3j3k3l3m3n3o3r3s3z4w5Q6c6i6n6}7O7X7Y8U8r8v9Q9W9X:V:m:u;l=ZT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ'V!eR2d-U!W!nQ!e!r!v!y!z$|'T'[']'i'j'k*W*g*k*m*n-U-[-^-n0S0V1b5i5kR1_,SnqOXst!Z#d%k&o&q&r&t,l,q1}2QQ&v!^Q's!xS(p#u;rQ+g%xQ,U&[Q,V&^Q-c'aQ-p'lS.k(u<eS0g+S<oQ0t+hQ1a,TQ2U,sQ2W,tQ2`-PQ2m-dQ2p-hS4x0h<yQ5O0uS5R0w<zQ6b2bQ6f2nQ6k2uQ7w5PQ8s6dQ8t6gQ8w6lR:S8p$d$]c#Y#e%q%s(P(V(q(v)O)P)Q)R)S)T)U)V)W)X)Z)])_)d)n+_+s-S-q-v-{-}.l.o.s.v.w/Z0f2^2a2q2x3^3c3d3e3f3g3h3i3j3k3l3m3n3o3r3s3z4w5Q6c6i6n6}7O7X7Y8U8r8v9Q9W9X:V:m:u;l=ZS(l#p'fQ(|#zS+]%o.uS.[(k(mR3P.]'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gS#q];kQ&q!XQ&r!YQ&t![Q&u!]R1|,oQ'^!hQ+`%uQ-a'`S.^(n+cQ2k-`W3T.a.b0m0oQ6e2lW6r3Q3S3W4|U8z6s6u6wU:X8|8}9PS:w:W:ZQ;U:xR;^;VU!wQ']-^T5g1b5i!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(g,l,q.T1}2Q]!pQ!r']-^1b5iT#q];k%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xS(z#y#zS.Z(j(k!s=Q$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gU$fd)[,fS(m#p'fU*r%R(t3qU0c*y.g7TQ4|0nQ6s3RQ8}6vR:Z9Om!tQ!r!v!y!z']'i'j'k-^-n1b5i5kQ'q!uS(c#g1wS-l'h'tQ/l*YQ/y*fQ2w-oQ4W/mQ4d/{Q4e/|Q4j0UQ7`4RS7k4f4hS7o4k4mQ9]7aQ9a7gQ9f7lQ9k7qS:c9b9cS:|:d:gS;X:};OS;a;Y;ZS;e;b;cR;h;fQ#wbQ'p!uS(b#g1wS(d#m+RQ+T%dQ+e%vQ+k%|U-k'h'q'tQ.P(cQ/k*YQ/z*fQ/}*hQ0s+fQ1h,YS2t-l-oQ2|.XS4V/l/mQ4`/wS4c/y0UQ4g0OQ5t1iQ6m2wQ7_4RQ7c4WU7j4d4j4mQ7m4iQ8a5uS9[7`7aQ9`7gQ9h7oQ9i7pQ9y8bQ:a9]S:b9a9cQ:j9kQ:s9zS:{:c:gS;W:|:}S;`;X;ZS;d;a;cQ;g;eQ;i;hQ=T=OQ=`=XR=a=YV!wQ']-^%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xS#wz!j!r<}$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gR=T=f%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xQ%dj!^%vy!i!u%y%z%{'S'b'c'd'h'r*f+i+j-R-e-f-m/y/|0v2h2o2v4d4e4h7k9fS%|z!jQ+f%wQ,Y&aW1i,Z,[,],^U5u1j1k1lS8b5v5wQ9z8c!r=O$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ=X=eR=Y=f%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xY#bWZ#W#Z(Q!b%hm#h#i#l$x%c%f(Z(e(f(g*V*Z*^+U+V+X,h-O-|.S.T.U.W/f/i2V2}3O4S6`6qQ,g&l!p=P$Z$n)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gR=S'UU'Y!e%g*WR2f-X%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W,i,l,q-b-j-x.O.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3_4l5q6R6S6V6j8_8n8x!r)[$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ,f&lQ0n+bQ3R.`Q6v3VR9O6x!b$Tc#Y%o(P(V(q(v)W)X)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;l!P;x)Z)n-S.u2^2a3c3l3m3r3z6c7O7X7Y8U8r9Q9W9X:m:u=Z!f$Vc#Y%o(P(V(q(v)T)U)W)X)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;l!T;z)Z)n-S.u2^2a3c3i3j3l3m3r3z6c7O7X7Y8U8r9Q9W9X:m:u=Z!^$Zc#Y%o(P(V(q(v)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;lQ4Q/dz=g)Z)n-S.u2^2a3c3r3z6c7O7X7Y8U8r9Q9W9X:m:u=ZQ=l=nR=m=o'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gS$oh$pR3w.}'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t.}/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gT$kf$qQ$ifS)g$l)kR)s$qT$jf$qT)i$l)k'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t.}/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gT$oh$pQ$rhR)r$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8x!s=e$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g#glOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_({)p*e+W+b,i,l,q-b.`/O/g0T0b1e1u1v1x1z1}2Q2S3V3v4l5q6R6S6V6x8_8n!O%Ri$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m#d(t#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qQ+O%`Q/[){o3q<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!O$yi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mQ*_$zU*h$|*W*kQ+P%aQ0O*i#d=V#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn=W<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|Q=[=hQ=]=iQ=^=jR=_=k!O%Ri$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m#d(t#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qo3q<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|noOXst!Z#d%k&o&q&r&t,l,q1}2QS*b${*VQ,z&{Q,{&}R4Z/q%S%Si#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qQ+}&YQ1Z,PQ5a1YR8R5bV*j$|*W*kU*j$|*W*kT5h1b5iS/w*e/gQ4i0TT7p4l9sQ+e%vQ/}*hQ0s+fQ1h,YQ5t1iQ8a5uQ9y8bR:s9z!O%Oi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mr*O$v)b*P*q+Q/o0[0]3t4X4v7^7r:`=U=b=cS0W*p0X#d<T#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn<U<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!b<h(r)`*X*a.c.f.j/W/d/t0l1W3Z3}4Y4^5`6y6|7e7h7t7v9_9g:e:i:z;P;[=n=o`<i3p7P7S7W9R:[:_;_S<s.e3[T<t7R9U!O%Qi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mv*Q$v)b*R*p+Q/`/o0[0]3t4X4n4v7^7r:`=U=b=cS0Y*q0Z#d<V#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn<W<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!f<j(r)`*X*a.d.e.j/W/d/t0l1W3X3Z3}4Y4^5`6y6z6|7e7h7t7v9_9g:e:i:z;P;[=n=od<k3p7Q7R7W9R9S:[:]:_;_S<u.f3]T<v7S9VrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QQ&c!UR,i&lrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QR&c!UQ,R&ZR1V+zsnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QQ1c,WS5o1f1gU8Z5m5n5rS9u8]8^S:o9t9wQ;R:pR;];SQ&j!VR,b&fR5{1oR9|8dS&O|&TR1O+qQ&o!WR,l&pR,r&uT2O,q2QR,v&vQ,u&vR2X,vQ'v!{R-r'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)x$uR/X)xQ#UVR'}#UQ#XWU(T#X(U-yQ(U#YR-y(VQ-V'VR2e-VQ.n(vS3`.n3aR3a.oQ-^']R2i-^Y!rQ']-^1b5iR'g!rQ.y)bR3u.yU#_W%f*VU([#_(]-zQ(]#`R-z(WQ-Y'YR2g-Yt`OXst!V!Z#d%k&f&h&o&q&r&t,l,q1}2QS#hZ%cU#r`#h.TR.T(gQ(h#jQ.Q(dW.Y(h.Q2z6oQ2z.RR6o2{Q)k$lR/P)kQ$phR)q$pQ$`cU)^$`-u<OQ-u;lR<O)nQ/j*YW4T/j4U7b9^U4U/k/l/mS7b4V4WR9^7c$])}$v(r)`)b*X*a*p*q*{*|+Q.e.f.h.i.j/W/`/b/d/o/t0[0]0l1W3X3Y3Z3p3t3}4X4Y4^4n4p4v5`6y6z6{6|7R7S7U7V7W7^7e7h7r7t7v9R9S9T9_9g:[:]:^:_:`:e:i:z;P;[;_=U=b=c=n=oQ/r*aU4]/r4_7fQ4_/tR7f4^S*k$|*WR0Q*kr*P$v)b*p*q+Q/o0[0]3t4X4v7^7r:`=U=b=c!b.c(r)`*X*a.e.f.j/W/d/t0l1W3Z3}4Y4^5`6y6|7e7h7t7v9_9g:e:i:z;P;[=n=oU/a*P.c7Pa7P3p7R7S7W9R:[:_;_Q0X*pQ3[.eU4o0X3[9UR9U7Rv*R$v)b*p*q+Q/`/o0[0]3t4X4n4v7^7r:`=U=b=c!f.d(r)`*X*a.e.f.j/W/d/t0l1W3X3Z3}4Y4^5`6y6z6|7e7h7t7v9_9g:e:i:z;P;[=n=oU/c*R.d7Qe7Q3p7R7S7W9R9S:[:]:_;_Q0Z*qQ3].fU4q0Z3]9VR9V7SQ*v%UR0_*vQ4{0lR7u4{Q+Y%iR0k+YQ5d1]S8T5d9rR9r8UQ,T&[R1`,TQ5i1bR8W5iQ1n,_S5y1n8eR8e5{Q0y+mW5V0y5X7{9nQ5X0|Q7{5WR9n7|Q+r&OR1P+rQ2Q,qR6Z2QYrOXst#dQ&s!ZQ+[%kQ,k&oQ,m&qQ,n&rQ,p&tQ1{,lS2O,q2QR6Y1}Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Z%jQ+g%xQ+y&UQ,a&jQ,x&yW-i'h'p'q'tQ-p'lQ0P*jQ0t+hS1q,b,eQ2Y,wQ2Z,zQ2[,{Q2p-hW2r-k-l-o-qQ5O0uQ5[1SQ5_1WQ5s1hQ5}1sQ6X1|U6h2q2t2wQ6k2uQ7w5PQ8P5^Q8Q5`Q8V5hQ8`5tQ8f5|S8u6i6mQ8w6lQ9o7}Q9x8aQ9}8gQ:U8vQ:l9pQ:r9yQ:v:VR;T:sQ%xyQ'a!iQ'l!uU+h%y%z%{Q-P'SU-d'b'c'dS-h'h'rQ/x*fS0u+i+jQ2b-RS2n-e-fQ2u-mS4b/y/|Q5P0vQ6d2hQ6g2oQ6l2vU7i4d4e4hQ9e7kR:f9fS$wi=dR*w%VU%Ui%V=dR0^*uQ$viS(r#v+dS)`$b$cQ)b$dQ*X$xS*a${*VQ*p%OQ*q%QQ*{%]Q*|%^Q+Q%bQ.e<TQ.f<VQ.h<ZQ.i<]Q.j<_Q/W)vQ/`*OQ/b*QQ/d*SQ/o*]S/t*c/fQ0[*sQ0]*tl0l+a,O._1[1d3U5p6t8[8{9v:Y:q:yQ1W+{Q3X<hQ3Y<jQ3Z<mS3p<Q<RQ3t.xS3}/]4PQ4X/pQ4Y/qQ4^/sQ4n0WQ4p0YQ4v0eQ5`1XQ6y<qQ6z<sQ6{<uQ6|<wQ7R<UQ7S<WQ7U<[Q7V<^Q7W<`Q7^4QQ7e4[Q7h4aQ7r4rQ7t4zQ7v4}Q9R<nQ9S<iQ9T<kQ9_7dQ9g7nQ:[<rQ:]<tQ:^<vQ:_<xQ:`9ZQ:e9dQ:i9jQ:z<{Q;P:hQ;[;QQ;_<|Q=U=dQ=b=lQ=c=mQ=n=pR=o=qQ*y%[Q.g<XR7T<YnpOXst!Z#d%k&o&q&r&t,l,q1}2QQ!fPS#fZ#oQ&y!`W'e!o*e0T4lQ'|#SQ(}#{Q)o$nS,e&h&kQ,j&lQ,w&xS,|'Q/gQ-`'_Q.q({Q/T)pQ0i+WQ0o+bQ1y,iQ2l-bQ3S.`Q3y/OQ4t0bQ5n1eQ6P1uQ6Q1vQ6U1xQ6W1zQ6]2SQ6w3VQ7Z3vQ8^5qQ8j6RQ8k6SQ8m6VQ9P6xQ9w8_R:R8n#[cOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_({*e+W+b,i,l,q-b.`/g0T0b1e1u1v1x1z1}2Q2S3V4l5q6R6S6V6x8_8nQ#YWQ#eYQ%ouQ%qvS%sw!gS(P#W(SQ(V#ZQ(q#uQ(v#xQ)O$OQ)P$PQ)Q$QQ)R$RQ)S$SQ)T$TQ)U$UQ)V$VQ)W$WQ)X$XQ)Z$ZQ)]$_Q)_$aQ)d$eW)n$n)p/O3vQ+_%rQ+s&PS-S'U2cQ-q'oS-v(Q-xQ-{(YQ-}(aQ.l(uQ.o(wQ.s;jQ.u;mQ.v;nQ.w;qQ/Z)zQ0f+SQ2^,}Q2a-QQ2q-jQ2x.OQ3^.mQ3c;rQ3d;sQ3e;tQ3f;uQ3g;vQ3h;wQ3i;xQ3j;yQ3k;zQ3l;{Q3m;|Q3n.tQ3o<PQ3r<SQ3s<aQ3z;}Q4w0hQ5Q0wQ6c<dQ6i2sQ6n2yQ6}3_Q7O<eQ7X<gQ7Y<oQ8U5eQ8r6aQ8v6jQ9Q<pQ9W<yQ9X<zQ:V8xQ:m9qQ:u:TQ;l#SR=Z=gR#[WR'W!el!tQ!r!v!y!z']'i'j'k-^-n1b5i5kS'S!e-UU*f$|*W*kS-R'T'[S/|*g*mQ0U*nQ2h-[Q4h0SR4m0VR(x#xQ!fQT-]']-^]!qQ!r']-^1b5iQ#p]R'f;kR)c$dY!uQ']-^1b5iQ'h!rS'r!v!yS't!z5kS-m'i'jQ-o'kR2v-nT#kZ%cS#jZ%cS%im,hU(d#h#i#lS.R(e(fQ.V(gQ0j+XQ2{.SU2|.T.U.WS6p2}3OR8y6qd#^W#W#Z%f(Q(Z*V+U-|/fr#gZm#h#i#l%c(e(f(g+X.S.T.U.W2}3O6qS*Y$x*^Q/m*ZQ1w,hQ2_-OQ4R/iQ6_2VQ7a4SQ8q6`T=R'U+VV#aW%f*VU#`W%f*VS(R#W(ZU(W#Z+U/fS-T'U+VT-w(Q-|V'Z!e%g*WQ$lfR)u$qT)j$l)kR3x.}T*[$x*^T*d${*VQ0m+aQ1Y,OQ3Q._Q5b1[Q5m1dQ6u3UQ8]5pQ8|6tQ9t8[Q:W8{Q:p9vQ:x:YQ;S:qR;V:ynqOXst!Z#d%k&o&q&r&t,l,q1}2QQ&i!VR,a&ftmOXst!U!V!Z#d%k&f&o&q&r&t,l,q1}2QR,h&lT%jm,hR1^,QR,`&dQ&S|R+x&TR+n%}T&m!W&pT&n!W&pT2P,q2Q",
  nodeNames: " ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 377,
  context: f_,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
    ["group", -26, 9, 17, 19, 65, 204, 208, 212, 213, 215, 218, 221, 231, 233, 239, 241, 243, 245, 248, 254, 260, 262, 264, 266, 268, 270, 271, "Statement", -34, 13, 14, 29, 32, 33, 39, 48, 51, 52, 54, 59, 67, 69, 73, 77, 79, 81, 82, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 167, 169, "Expression", -23, 28, 30, 34, 38, 40, 42, 171, 173, 175, 176, 178, 179, 180, 182, 183, 184, 186, 187, 188, 198, 200, 202, 203, "Type", -3, 85, 100, 106, "ClassItem"],
    ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
    ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"]
  ],
  propSources: [O_],
  skippedNodes: [0, 5, 6, 274],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(V!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(V!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(SpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(SpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Sp(V!b'x0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(T#S$h&j'y0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Sp(V!b'y0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(R':f$h&j(V!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(V!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(V!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(V!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(V!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Sp(V!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Sp(V!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(V!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(V!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(SpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(SpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Sp(V!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(k%1l(Sp(V!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Sp(V!b$[#t(P,2j(a$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Sp(V!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Sp(V!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(v+JY$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(U';W$h&j(SpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(SpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(SpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(SpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(SpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Sp(V!b(Q%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Sp(V!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Sp(V!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Sp(V!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Sp(V!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(V!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(V!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(V!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(V!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(V!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(V!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Sp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Sp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Sp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Sp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(SpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(SpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Sp(V!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Sp(V!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Sp(V!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Sp(V!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Sp(V!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Sp(V!b'z0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Sp(V!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(V!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(V!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(SpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(SpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Sp(V!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Sp(V!b(z7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(n(Ct$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Sp(V!b(]+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Sp(V!b(P,2j$^#t(a$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Sp(V!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(u+JY$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!Z(CdsBr$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Sp(V!b'x0/l$[#t(P,2j(a$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Sp(V!b'y0/l$[#t(P,2j(a$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [m_, g_, v_, p_, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, h_, new Id("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(_~~", 141, 336), new Id("j~RQYZXz{^~^O'|~~aP!P!Qd~iO'}~~", 25, 319)],
  topRules: { Script: [0, 7], SingleExpression: [1, 272], SingleClassItem: [2, 273] },
  dialects: { jsx: 0, ts: 14980 },
  dynamicPrecedences: { 77: 1, 79: 1, 91: 1, 167: 1, 196: 1 },
  specialized: [{ term: 323, get: (e) => y_[e] || -1 }, { term: 339, get: (e) => b_[e] || -1 }, { term: 92, get: (e) => C_[e] || -1 }],
  tokenPrec: 15004
}), w6 = [
  /* @__PURE__ */ fn("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fn("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fn("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fn("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fn("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fn(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ fn("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ fn(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ fn(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fn('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ fn('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], w_ = /* @__PURE__ */ w6.concat([
  /* @__PURE__ */ fn("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fn("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fn("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), Jm = /* @__PURE__ */ new EV(), k6 = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function cr(e) {
  return (t, n) => {
    let i = t.node.getChild("VariableDefinition");
    return i && n(i, e), !0;
  };
}
const k_ = ["FunctionDeclaration"], x_ = {
  FunctionDeclaration: /* @__PURE__ */ cr("function"),
  ClassDeclaration: /* @__PURE__ */ cr("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ cr("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ cr("type"),
  NamespaceDeclaration: /* @__PURE__ */ cr("namespace"),
  VariableDefinition(e, t) {
    e.matchContext(k_) || t(e, "variable");
  },
  TypeDefinition(e, t) {
    t(e, "type");
  },
  __proto__: null
};
function x6(e, t) {
  let n = Jm.get(t);
  if (n)
    return n;
  let i = [], l = !0;
  function a(r, s) {
    let o = e.sliceString(r.from, r.to);
    i.push({ label: o, type: s });
  }
  return t.cursor(At.IncludeAnonymous).iterate((r) => {
    if (l)
      l = !1;
    else if (r.name) {
      let s = x_[r.name];
      if (s && s(r, a) || k6.has(r.name))
        return !1;
    } else if (r.to - r.from > 8192) {
      for (let s of x6(e, r.node))
        i.push(s);
      return !1;
    }
  }), Jm.set(t, i), i;
}
const e9 = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, P6 = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function P_(e) {
  let t = Rt(e.state).resolveInner(e.pos, -1);
  if (P6.indexOf(t.name) > -1)
    return null;
  let n = t.name == "VariableName" || t.to - t.from < 20 && e9.test(e.state.sliceDoc(t.from, t.to));
  if (!n && !e.explicit)
    return null;
  let i = [];
  for (let l = t; l; l = l.parent)
    k6.has(l.name) && (i = i.concat(x6(e.state.doc, l)));
  return {
    options: i,
    from: n ? t.from : e.pos,
    validFor: e9
  };
}
const Ll = /* @__PURE__ */ Ia.define({
  name: "javascript",
  parser: /* @__PURE__ */ S_.configure({
    props: [
      /* @__PURE__ */ Ch.add({
        IfStatement: /* @__PURE__ */ Dc({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Dc({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: aQ,
        SwitchBody: (e) => {
          let t = e.textAfter, n = /^\s*\}/.test(t), i = /^\s*(case|default)\b/.test(t);
          return e.baseIndent + (n ? 0 : i ? 1 : 2) * e.unit;
        },
        Block: /* @__PURE__ */ kd({ closing: "}" }),
        ArrowFunction: (e) => e.baseIndent + e.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Dc({ except: /^{/ }),
        JSXElement(e) {
          let t = /^\s*<\//.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        JSXEscape(e) {
          let t = /\s*\}/.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(e) {
          return e.column(e.node.from) + e.unit;
        }
      }),
      /* @__PURE__ */ wh.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Wv,
        BlockComment(e) {
          return { from: e.from + 2, to: e.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), $6 = {
  test: (e) => /^JSX/.test(e.name),
  facet: /* @__PURE__ */ Xv({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, $_ = /* @__PURE__ */ Ll.configure({ dialect: "ts" }, "typescript"), V_ = /* @__PURE__ */ Ll.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ yh.add((e) => e.isTop ? [$6] : void 0)]
}), Q_ = /* @__PURE__ */ Ll.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ yh.add((e) => e.isTop ? [$6] : void 0)]
}, "typescript");
let V6 = (e) => ({ label: e, type: "keyword" });
const Q6 = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(V6), L_ = /* @__PURE__ */ Q6.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(V6));
function t9(e = {}) {
  let t = e.jsx ? e.typescript ? Q_ : V_ : e.typescript ? $_ : Ll, n = e.typescript ? w_.concat(L_) : w6.concat(Q6);
  return new qv(t, [
    Ll.data.of({
      autocomplete: DM(P6, u6(n))
    }),
    Ll.data.of({
      autocomplete: P_
    }),
    e.jsx ? __ : []
  ]);
}
function M_(e) {
  for (; ; ) {
    if (e.name == "JSXOpenTag" || e.name == "JSXSelfClosingTag" || e.name == "JSXFragmentTag")
      return e;
    if (e.name == "JSXEscape" || !e.parent)
      return null;
    e = e.parent;
  }
}
function n9(e, t, n = e.length) {
  for (let i = t == null ? void 0 : t.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return e.sliceString(i.from, Math.min(i.to, n));
  return "";
}
const T_ = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), __ = /* @__PURE__ */ me.inputHandler.of((e, t, n, i, l) => {
  if ((T_ ? e.composing : e.compositionStarted) || e.state.readOnly || t != n || i != ">" && i != "/" || !Ll.isActiveAt(e.state, t, -1))
    return !1;
  let a = l(), { state: r } = a, s = r.changeByRange((o) => {
    var u;
    let { head: c } = o, d = Rt(r).resolveInner(c - 1, -1), f;
    if (d.name == "JSXStartTag" && (d = d.parent), !(r.doc.sliceString(c - 1, c) != i || d.name == "JSXAttributeValue" && d.to > c)) {
      if (i == ">" && d.name == "JSXFragmentTag")
        return { range: o, changes: { from: c, insert: "</>" } };
      if (i == "/" && d.name == "JSXStartCloseTag") {
        let h = d.parent, g = h.parent;
        if (g && h.from == c - 2 && ((f = n9(r.doc, g.firstChild, c)) || ((u = g.firstChild) === null || u === void 0 ? void 0 : u.name) == "JSXFragmentTag")) {
          let v = `${f}>`;
          return { range: J.cursor(c + v.length, -1), changes: { from: c, insert: v } };
        }
      } else if (i == ">") {
        let h = M_(d);
        if (h && h.name == "JSXOpenTag" && !/^\/?>|^<\//.test(r.doc.sliceString(c, c + 2)) && (f = n9(r.doc, h, c)))
          return { range: o, changes: { from: c, insert: `</${f}>` } };
      }
    }
    return { range: o };
  });
  return s.changes.empty ? !1 : (e.dispatch([
    a,
    r.update(s, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), A_ = "#e5c07b", i9 = "#e06c75", R_ = "#56b6c2", Z_ = "#ffffff", yo = "#abb2bf", Ed = "#7d8799", I_ = "#61afef", D_ = "#98c379", l9 = "#d19a66", B_ = "#c678dd", E_ = "#21252b", a9 = "#2c313a", r9 = "#282c34", Uc = "#353a42", z_ = "#3E4451", s9 = "#528bff", H_ = /* @__PURE__ */ me.theme({
  "&": {
    color: yo,
    backgroundColor: r9
  },
  ".cm-content": {
    caretColor: s9
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: s9 },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: z_ },
  ".cm-panels": { backgroundColor: E_, color: yo },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: r9,
    color: Ed,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: a9
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Uc
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Uc,
    borderBottomColor: Uc
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: a9,
      color: yo
    }
  }
}, { dark: !0 }), j_ = /* @__PURE__ */ Ss.define([
  {
    tag: R.keyword,
    color: B_
  },
  {
    tag: [R.name, R.deleted, R.character, R.propertyName, R.macroName],
    color: i9
  },
  {
    tag: [/* @__PURE__ */ R.function(R.variableName), R.labelName],
    color: I_
  },
  {
    tag: [R.color, /* @__PURE__ */ R.constant(R.name), /* @__PURE__ */ R.standard(R.name)],
    color: l9
  },
  {
    tag: [/* @__PURE__ */ R.definition(R.name), R.separator],
    color: yo
  },
  {
    tag: [R.typeName, R.className, R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace],
    color: A_
  },
  {
    tag: [R.operator, R.operatorKeyword, R.url, R.escape, R.regexp, R.link, /* @__PURE__ */ R.special(R.string)],
    color: R_
  },
  {
    tag: [R.meta, R.comment],
    color: Ed
  },
  {
    tag: R.strong,
    fontWeight: "bold"
  },
  {
    tag: R.emphasis,
    fontStyle: "italic"
  },
  {
    tag: R.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: R.link,
    color: Ed,
    textDecoration: "underline"
  },
  {
    tag: R.heading,
    fontWeight: "bold",
    color: i9
  },
  {
    tag: [R.atom, R.bool, /* @__PURE__ */ R.special(R.variableName)],
    color: l9
  },
  {
    tag: [R.processingInstruction, R.string, R.inserted],
    color: D_
  },
  {
    tag: R.invalid,
    color: Z_
  }
]), X_ = [H_, /* @__PURE__ */ kh(j_)], fa = 63, o9 = 64, N_ = 1, q_ = 2, L6 = 3, Y_ = 4, M6 = 5, F_ = 6, W_ = 7, T6 = 65, U_ = 66, G_ = 8, K_ = 9, J_ = 10, eA = 11, tA = 12, _6 = 13, nA = 19, iA = 20, lA = 29, aA = 33, rA = 34, sA = 47, oA = 0, zh = 1, zd = 2, es = 3, Hd = 4;
class yl {
  constructor(t, n, i) {
    this.parent = t, this.depth = n, this.type = i, this.hash = (t ? t.hash + t.hash << 8 : 0) + n + (n << 4) + i;
  }
}
yl.top = new yl(null, -1, oA);
function kr(e, t) {
  for (let n = 0, i = t - e.pos - 1; ; i--, n++) {
    let l = e.peek(i);
    if (Mi(l) || l == -1) return n;
  }
}
function jd(e) {
  return e == 32 || e == 9;
}
function Mi(e) {
  return e == 10 || e == 13;
}
function A6(e) {
  return jd(e) || Mi(e);
}
function kl(e) {
  return e < 0 || A6(e);
}
const uA = new C6({
  start: yl.top,
  reduce(e, t) {
    return e.type == es && (t == iA || t == rA) ? e.parent : e;
  },
  shift(e, t, n, i) {
    if (t == L6)
      return new yl(e, kr(i, i.pos), zh);
    if (t == T6 || t == M6)
      return new yl(e, kr(i, i.pos), zd);
    if (t == fa)
      return e.parent;
    if (t == nA || t == aA)
      return new yl(e, 0, es);
    if (t == _6 && e.type == Hd)
      return e.parent;
    if (t == sA) {
      let l = /[1-9]/.exec(i.read(i.pos, n.pos));
      if (l) return new yl(e, e.depth + +l[0], Hd);
    }
    return e;
  },
  hash(e) {
    return e.hash;
  }
});
function Ha(e, t, n = 0) {
  return e.peek(n) == t && e.peek(n + 1) == t && e.peek(n + 2) == t && kl(e.peek(n + 3));
}
const cA = new Ii((e, t) => {
  if (e.next == -1 && t.canShift(o9))
    return e.acceptToken(o9);
  let n = e.peek(-1);
  if ((Mi(n) || n < 0) && t.context.type != es) {
    if (Ha(
      e,
      45
      /* '-' */
    ))
      if (t.canShift(fa)) e.acceptToken(fa);
      else return e.acceptToken(N_, 3);
    if (Ha(
      e,
      46
      /* '.' */
    ))
      if (t.canShift(fa)) e.acceptToken(fa);
      else return e.acceptToken(q_, 3);
    let i = 0;
    for (; e.next == 32; )
      i++, e.advance();
    (i < t.context.depth || i == t.context.depth && t.context.type == zh && (e.next != 45 || !kl(e.peek(1)))) && // Not blank
    e.next != -1 && !Mi(e.next) && e.next != 35 && e.acceptToken(fa, -i);
  }
}, { contextual: !0 }), dA = new Ii((e, t) => {
  if (t.context.type == es) {
    e.next == 63 && (e.advance(), kl(e.next) && e.acceptToken(W_));
    return;
  }
  if (e.next == 45)
    e.advance(), kl(e.next) && e.acceptToken(t.context.type == zh && t.context.depth == kr(e, e.pos - 1) ? Y_ : L6);
  else if (e.next == 63)
    e.advance(), kl(e.next) && e.acceptToken(t.context.type == zd && t.context.depth == kr(e, e.pos - 1) ? F_ : M6);
  else {
    let n = e.pos;
    for (; ; )
      if (jd(e.next)) {
        if (e.pos == n) return;
        e.advance();
      } else if (e.next == 33)
        R6(e);
      else if (e.next == 38)
        Xd(e);
      else if (e.next == 42) {
        Xd(e);
        break;
      } else if (e.next == 39 || e.next == 34) {
        if (Hh(e, !0)) break;
        return;
      } else if (e.next == 91 || e.next == 123) {
        if (!hA(e)) return;
        break;
      } else {
        Z6(e, !0, !1, 0);
        break;
      }
    for (; jd(e.next); ) e.advance();
    if (e.next == 58) {
      if (e.pos == n && t.canShift(lA)) return;
      let i = e.peek(1);
      kl(i) && e.acceptTokenTo(t.context.type == zd && t.context.depth == kr(e, n) ? U_ : T6, n);
    }
  }
}, { contextual: !0 });
function fA(e) {
  return e > 32 && e < 127 && e != 34 && e != 37 && e != 44 && e != 60 && e != 62 && e != 92 && e != 94 && e != 96 && e != 123 && e != 124 && e != 125;
}
function u9(e) {
  return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70;
}
function c9(e, t) {
  return e.next == 37 ? (e.advance(), u9(e.next) && e.advance(), u9(e.next) && e.advance(), !0) : fA(e.next) || t && e.next == 44 ? (e.advance(), !0) : !1;
}
function R6(e) {
  if (e.advance(), e.next == 60) {
    for (e.advance(); ; )
      if (!c9(e, !0)) {
        e.next == 62 && e.advance();
        break;
      }
  } else
    for (; c9(e, !1); )
      ;
}
function Xd(e) {
  for (e.advance(); !kl(e.next) && au(e.tag) != "f"; ) e.advance();
}
function Hh(e, t) {
  let n = e.next, i = !1, l = e.pos;
  for (e.advance(); ; ) {
    let a = e.next;
    if (a < 0) break;
    if (e.advance(), a == n)
      if (a == 39)
        if (e.next == 39) e.advance();
        else break;
      else
        break;
    else if (a == 92 && n == 34)
      e.next >= 0 && e.advance();
    else if (Mi(a)) {
      if (t) return !1;
      i = !0;
    } else if (t && e.pos >= l + 1024)
      return !1;
  }
  return !i;
}
function hA(e) {
  for (let t = [], n = e.pos + 1024; ; )
    if (e.next == 91 || e.next == 123)
      t.push(e.next), e.advance();
    else if (e.next == 39 || e.next == 34) {
      if (!Hh(e, !0)) return !1;
    } else if (e.next == 93 || e.next == 125) {
      if (t[t.length - 1] != e.next - 2) return !1;
      if (t.pop(), e.advance(), !t.length) return !0;
    } else {
      if (e.next < 0 || e.pos > n || Mi(e.next))
        return !1;
      e.advance();
    }
}
const mA = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
function au(e) {
  return e < 33 ? "u" : e > 125 ? "s" : mA[e - 33];
}
function Gc(e, t) {
  let n = au(e);
  return n != "u" && !(t && n == "f");
}
function Z6(e, t, n, i) {
  if (au(e.next) == "s" || (e.next == 63 || e.next == 58 || e.next == 45) && Gc(e.peek(1), n))
    e.advance();
  else
    return !1;
  let l = e.pos;
  for (; ; ) {
    let a = e.next, r = 0, s = i + 1;
    for (; A6(a); ) {
      if (Mi(a)) {
        if (t) return !1;
        s = 0;
      } else
        s++;
      a = e.peek(++r);
    }
    if (!(a >= 0 && (a == 58 ? Gc(e.peek(r + 1), n) : a == 35 ? e.peek(r - 1) != 32 : Gc(a, n))) || !n && s <= i || s == 0 && !n && (Ha(e, 45, r) || Ha(e, 46, r)))
      break;
    if (t && au(a) == "f") return !1;
    for (let u = r; u >= 0; u--) e.advance();
    if (t && e.pos > l + 1024) return !1;
  }
  return !0;
}
const gA = new Ii((e, t) => {
  if (e.next == 33)
    R6(e), e.acceptToken(tA);
  else if (e.next == 38 || e.next == 42) {
    let n = e.next == 38 ? J_ : eA;
    Xd(e), e.acceptToken(n);
  } else e.next == 39 || e.next == 34 ? (Hh(e, !1), e.acceptToken(K_)) : Z6(e, !1, t.context.type == es, t.context.depth) && e.acceptToken(G_);
}), vA = new Ii((e, t) => {
  let n = t.context.type == Hd ? t.context.depth : -1, i = e.pos;
  e: for (; ; ) {
    let l = 0, a = e.next;
    for (; a == 32; ) a = e.peek(++l);
    if (!l && (Ha(e, 45, l) || Ha(e, 46, l)) || !Mi(a) && (n < 0 && (n = Math.max(t.context.depth + 1, l)), l < n))
      break;
    for (; ; ) {
      if (e.next < 0) break e;
      let r = Mi(e.next);
      if (e.advance(), r) continue e;
      i = e.pos;
    }
  }
  e.acceptTokenTo(_6, i);
}), pA = Wu({
  DirectiveName: R.keyword,
  DirectiveContent: R.attributeValue,
  "DirectiveEnd DocEnd": R.meta,
  QuotedLiteral: R.string,
  BlockLiteralHeader: R.special(R.string),
  BlockLiteralContent: R.content,
  Literal: R.content,
  "Key/Literal Key/QuotedLiteral": R.definition(R.propertyName),
  "Anchor Alias": R.labelName,
  Tag: R.typeName,
  Comment: R.lineComment,
  ": , -": R.separator,
  "?": R.punctuation,
  "[ ]": R.squareBracket,
  "{ }": R.brace
}), OA = za.deserialize({
  version: 14,
  states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
  stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
  goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
  nodeNames: " DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 74,
  context: uA,
  nodeProps: [
    ["isolate", -3, 8, 9, 14, ""],
    ["openedBy", 18, "[", 32, "{"],
    ["closedBy", 19, "]", 33, "}"]
  ],
  propSources: [pA],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [cA, dA, gA, vA, 0, 1],
  topRules: { Stream: [0, 15] },
  tokenPrec: 0
}), yA = /* @__PURE__ */ za.deserialize({
  version: 14,
  states: "!vOQOPOOO]OPO'#C_OhOPO'#C^OOOO'#Cc'#CcOpOPO'#CaQOOOOOO{OPOOOOOO'#Cb'#CbO!WOPO'#C`O!`OPO,58xOOOO-E6a-E6aOOOO-E6`-E6`OOOO'#C_'#C_OOOO1G.d1G.d",
  stateData: "!h~OXPOYROWTP~OWVXXRXYRX~OYVOXSP~OXROYROWTX~OXROYROWTP~OYVOXSX~OX[O~OXY~",
  goto: "vWPPX[beioRUOQQOR]XRXQTTOUQWQRZWSSOURYS",
  nodeNames: " Document Frontmatter DashLine FrontmatterContent Body",
  maxTerm: 10,
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "$z~RXOYnYZ!^Z]n]^!^^}n}!O!i!O;'Sn;'S;=`!c<%lOn~qXOYnYZ!^Z]n]^!^^;'Sn;'S;=`!c<%l~n~On~~!^~!cOY~~!fP;=`<%ln~!lZOYnYZ!^Z]n]^!^^}n}!O#_!O;'Sn;'S;=`!c<%l~n~On~~!^~#bZOYnYZ!^Z]n]^!^^}n}!O$T!O;'Sn;'S;=`!c<%l~n~On~~!^~$WXOYnYZ$sZ]n]^$s^;'Sn;'S;=`!c<%l~n~On~~$s~$zOX~Y~",
  tokenizers: [0],
  topRules: { Document: [0, 1] },
  tokenPrec: 67
}), bA = /* @__PURE__ */ Ia.define({
  name: "yaml",
  parser: /* @__PURE__ */ OA.configure({
    props: [
      /* @__PURE__ */ Ch.add({
        Stream: (e) => {
          for (let t = e.node.resolve(e.pos, -1); t && t.to >= e.pos; t = t.parent) {
            if (t.name == "BlockLiteralContent" && t.from < t.to)
              return e.baseIndentFor(t);
            if (t.name == "BlockLiteral")
              return e.baseIndentFor(t) + e.unit;
            if (t.name == "BlockSequence" || t.name == "BlockMapping")
              return e.column(t.from, 1);
            if (t.name == "QuotedLiteral")
              return null;
            if (t.name == "Literal") {
              let n = e.column(t.from, 1);
              if (n == e.lineIndent(t.from, 1))
                return n;
              if (t.to > e.pos)
                return null;
            }
          }
          return null;
        },
        FlowMapping: /* @__PURE__ */ kd({ closing: "}" }),
        FlowSequence: /* @__PURE__ */ kd({ closing: "]" })
      }),
      /* @__PURE__ */ wh.add({
        "FlowMapping FlowSequence": Wv,
        "Item Pair BlockLiteral": (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to })
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*[\]\}]$/
  }
});
function CA() {
  return new qv(bA);
}
R.meta;
const SA = { class: "editor-wrapper" }, wA = {
  __name: "SScriptEditor",
  props: /* @__PURE__ */ So({
    height: {
      type: [String, Number],
      default: 0
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    lang: {
      type: String,
      default: null
    }
  }, {
    modelValue: {
      type: String,
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = tf(e, "modelValue"), n = e, i = C(() => {
      const r = n.readonly ? [Rd, t9(), il.of(Wo)] : [Rd, t9(), X_, il.of(Wo)];
      return n.lang === "yaml" && r.push(CA()), r;
    }), l = z(null), a = C(() => {
      const r = n.height ? { height: `${n.height}px` } : {}, s = n.readonly ? { backgroundColor: "transparent" } : { backgroundColor: "#282c34" };
      return { ...r, ...s };
    });
    return (r, s) => (j(), ne("div", SA, [
      m(Me(ZT), {
        ref_key: "editor",
        ref: l,
        modelValue: t.value,
        "onUpdate:modelValue": s[0] || (s[0] = (o) => t.value = o),
        class: "script-editor",
        autofocus: !0,
        "indent-with-tab": !0,
        "tab-size": 2,
        extensions: i.value,
        readonly: e.readonly,
        style: on(a.value)
      }, null, 8, ["modelValue", "extensions", "readonly", "style"])
    ]));
  }
}, kA = {}, xA = { class: "s-table__form" };
function PA(e, t) {
  return j(), ne("div", xA, [
    Ae(e.$slots, "default")
  ]);
}
const $A = /* @__PURE__ */ bt(kA, [["render", PA]]), VA = {
  key: 0,
  class: "s-form__item-label"
}, QA = {
  key: 0,
  class: "required"
}, LA = { class: "s-form__item-content-item" }, MA = {
  key: 0,
  class: "s-form__item-append"
}, TA = {
  __name: "SFormItem",
  props: {
    className: {
      type: String,
      default: "",
      description: ""
    },
    contentClass: {
      type: String,
      default: "",
      description: "  "
    },
    label: { type: String, required: !0, default: "", description: "" },
    showLabel: { type: Boolean, required: !1, default: !0, description: "  " },
    name: { type: String, default: "", description: "validation    " },
    required: { type: Boolean, default: !1, description: "" }
  },
  setup(e) {
    return (t, n) => (j(), ne("div", {
      class: ct(["s-form__item", e.className])
    }, [
      e.showLabel ? (j(), ne("div", VA, [
        G("span", null, he(e.label), 1),
        e.required ? (j(), ne("span", QA, "*")) : _e("", !0)
      ])) : _e("", !0),
      G("div", {
        class: ct(["s-form__item-content", [e.contentClass]])
      }, [
        G("div", LA, [
          Ae(t.$slots, "default", {}, void 0, !0)
        ]),
        t.$slots["outer-append"] ? (j(), ne("div", MA, [
          Ae(t.$slots, "outer-append", {}, void 0, !0)
        ])) : _e("", !0)
      ], 2)
    ], 2));
  }
}, _A = /* @__PURE__ */ bt(TA, [["__scopeId", "data-v-608bf814"]]), AA = { class: "s-avatar" }, RA = {
  __name: "SAvatar",
  props: {
    user: {
      type: Object,
      default: () => {
      },
      description: ""
    },
    menuItems: {
      type: Array,
      default: () => [],
      description: " "
    },
    className: {
      type: Object,
      default: () => {
      },
      description: "custom class"
    }
  },
  emits: ["click:menu-item"],
  setup(e) {
    const t = e, n = C(() => {
      var i;
      return (i = t.className) == null ? void 0 : i.fontWhite;
    });
    return (i, l) => {
      const a = ae("v-list-item-title"), r = ae("v-list-item"), s = ae("v-list"), o = ae("v-menu");
      return j(), ne("div", AA, [
        m(o, { offset: [5, 0] }, {
          activator: W(({ props: u }) => [
            G("div", q({ class: "s-user-name" }, u), [
              G("div", {
                class: ct(["s-user-name__text", { fontWhite: n.value }])
              }, he(e.user.name), 3)
            ], 16)
          ]),
          default: W(() => [
            m(s, { class: "s-avatar-menu__list" }, {
              default: W(() => [
                (j(!0), ne(le, null, vt(e.menuItems, (u, c) => (j(), ne(le, { key: c }, [
                  u.visable ? _e("", !0) : (j(), xe(r, {
                    key: 0,
                    value: u.value,
                    onClick: (d) => i.$emit("click:menu-item", u.value)
                  }, {
                    default: W(() => [
                      m(a, null, {
                        default: W(() => [
                          ke(he(u.title), 1)
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["value", "onClick"]))
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Ae(i.$slots, "badge", {}, void 0, !0)
      ]);
    };
  }
}, I6 = /* @__PURE__ */ bt(RA, [["__scopeId", "data-v-28ffadb1"]]), ZA = "[Image]", Nd = {
  __name: "SImg",
  props: {
    /*
      @brief    
      @date 2021/11/04
      @example
      {
            : {
          : '',
          : Boolean
          : 
          }
      }
      */
    bind: {
      type: Object,
      default: void 0,
      description: "v-bind "
    },
    onProps: {
      type: Object,
      default: void 0,
      description: "v-on "
    },
    className: {
      type: Object,
      description: "   ",
      isActive: {
        type: Boolean,
        description: " "
      },
      default: void 0
    },
    alt: {
      type: String,
      default: void 0,
      description: "   "
    },
    aspectRatio: {
      type: [String, Number],
      default: void 0,
      description: "/  1920x1080px   1.7778 .   "
    },
    // contain: {
    //   type: Boolean,
    //   default: false,
    //   description: '   .',
    // },
    // contentClass: {
    //   type: String,
    //   default: undefined,
    //   description: '  div    ',
    // },
    cover: {
      type: Boolean,
      default: !1,
      description: "      ."
    },
    // dark: {
    //   type: Boolean,
    //   default: false,
    //   description: '     ',
    // },
    eager: {
      type: Boolean,
      default: !1,
      description: "      "
    },
    gradient: {
      type: String,
      default: void 0,
      description: "  . linear-gradient  "
    },
    lazySrc: {
      type: String,
      default: void 0,
      description: "        base64   "
    },
    lazySrcUrl: {
      type: String,
      default: void 0,
      description: "     lazyload  "
    },
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      }),
      description: "Intersection ovserver   "
    },
    sizes: {
      type: String,
      default: void 0,
      description: "srcset  ."
    },
    src: {
      type: [String, Object],
      default: "",
      // { src: String, srcset: String, lazySrc: String, aspect: Number }
      description: " url"
    },
    srcUrl: {
      type: String,
      default: void 0,
      description: "      "
    },
    srcset: {
      type: String,
      default: void 0,
      description: "     "
    },
    transition: {
      type: String,
      default: "fade-transition",
      description: "lazy-src src    "
    },
    width: {
      type: [String, Number],
      default: void 0,
      description: "   "
    },
    publicPath: {
      type: String,
      default: "",
      description: "/public  "
    }
  },
  emits: ["error"],
  setup(e, { emit: t }) {
    const n = t, i = (r) => {
      console.log(ZA, "onError"), n("error", r);
    }, l = () => {
    }, a = () => {
    };
    return (r, s) => {
      const o = ae("v-img");
      return j(), xe(o, q({
        class: ["s-img", { ...e.className }],
        alt: e.alt,
        "aspect-ratio": e.aspectRatio,
        cover: e.cover,
        eager: e.eager,
        gradient: e.gradient,
        "lazy-src": e.lazySrc && "/assets/images/" + e.lazySrc || e.lazySrcUrl,
        options: e.options,
        sizes: e.sizes,
        src: e.src && "/assets/images/" + e.src || e.srcUrl,
        srcset: e.srcset,
        transition: e.transition,
        width: e.width
      }, e.bind, {
        onError: i,
        onLoad: l,
        onLoadstart: a
      }), {
        default: W(() => [
          Ae(r.$slots, "default")
        ]),
        placeholder: W(() => [
          Ae(r.$slots, "placeholder")
        ]),
        _: 3
      }, 16, ["class", "alt", "aspect-ratio", "cover", "eager", "gradient", "lazy-src", "options", "sizes", "src", "srcset", "transition", "width"]);
    };
  }
}, Kc = {
  save: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M7.17739 2H5.16881C3.55139 2 2.24023 3.31115 2.24023 4.92857V19.0714C2.24023 20.6888 3.55139 22 5.16881 22H19.3117C20.9291 22 22.2402 20.6888 22.2402 19.0714V8.29883C22.2402 7.52212 21.9317 6.77723 21.3825 6.22802L18.0122 2.85777C17.463 2.30855 16.7181 2 15.9414 2L7.17773 2C7.17762 2 7.1775 2 7.17739 2ZM6.17773 4L6.17773 6.375C6.17773 7.5486 7.12913 8.5 8.30273 8.5L16.1777 8.5C17.3513 8.5 18.3027 7.5486 18.3027 6.375V5.97671L19.9683 7.64224L20.6754 6.93513L19.9683 7.64224C20.1424 7.81638 20.2402 8.05256 20.2402 8.29884V19.0714C20.2402 19.5843 19.8245 20 19.3117 20H18.3027V14.8125C18.3027 13.6389 17.3513 12.6875 16.1777 12.6875H8.30273C7.12913 12.6875 6.17773 13.6389 6.17773 14.8125V19.875C6.17773 19.9173 6.18036 19.9591 6.18547 20H5.16881C4.65596 20 4.24023 19.5843 4.24023 19.0714V4.92857C4.24023 4.41572 4.65596 4 5.16881 4H6.17773ZM8.17 20H16.3027V14.8125C16.3027 14.7435 16.2468 14.6875 16.1777 14.6875H8.30273C8.2337 14.6875 8.17773 14.7435 8.17773 14.8125V19.875C8.17773 19.9173 8.1751 19.9591 8.17 20ZM16.304 4.07374C16.3032 4.09071 16.3027 4.10781 16.3027 4.125V6.375C16.3027 6.44404 16.2468 6.5 16.1777 6.5L8.30273 6.5C8.2337 6.5 8.17773 6.44403 8.17773 6.375L8.17773 4H15.9414C16.0672 4 16.1904 4.02554 16.304 4.07374Z",
      fill: "currentColor"
    })
  ]),
  delete: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.24023 4.05882C8.24023 2.97639 9.08258 2 10.2402 2H14.2402C15.3979 2 16.2402 2.97639 16.2402 4.05882V5.11765C16.2402 5.13729 16.24 5.1569 16.2394 5.17647H20.2402C20.7925 5.17647 21.2402 5.62419 21.2402 6.17647C21.2402 6.72876 20.7925 7.17647 20.2402 7.17647H19.2394C19.24 7.19604 19.2402 7.21565 19.2402 7.23529V18.8824C19.2402 20.5496 17.9502 22 16.2402 22H8.24023C6.5303 22 5.24023 20.5496 5.24023 18.8824V7.23529C5.24023 7.21565 5.24051 7.19604 5.24106 7.17647H4.24023C3.68795 7.17647 3.24023 6.72876 3.24023 6.17647C3.24023 5.62419 3.68795 5.17647 4.24023 5.17647H8.24106C8.24051 5.1569 8.24023 5.13729 8.24023 5.11765V4.05882ZM7.25735 7.17647C7.25006 7.18579 7.24023 7.2047 7.24023 7.23529V18.8824C7.24023 19.5542 7.74103 20 8.24023 20H16.2402C16.7394 20 17.2402 19.5542 17.2402 18.8824V7.23529C17.2402 7.2047 17.2304 7.18579 17.2231 7.17647H7.25735ZM10.2574 4C10.2501 4.00932 10.2402 4.02823 10.2402 4.05882V5.11765C10.2402 5.14824 10.2501 5.16715 10.2574 5.17647H14.2231C14.2304 5.16715 14.2402 5.14824 14.2402 5.11765V4.05882C14.2402 4.02823 14.2304 4.00932 14.2231 4H10.2574ZM10.2402 9.41177C10.7925 9.41177 11.2402 9.85948 11.2402 10.4118V16.7647C11.2402 17.317 10.7925 17.7647 10.2402 17.7647C9.68795 17.7647 9.24023 17.317 9.24023 16.7647V10.4118C9.24023 9.85948 9.68795 9.41177 10.2402 9.41177ZM14.2402 9.41177C14.7925 9.41177 15.2402 9.85948 15.2402 10.4118V16.7647C15.2402 17.317 14.7925 17.7647 14.2402 17.7647C13.6879 17.7647 13.2402 17.317 13.2402 16.7647V10.4118C13.2402 9.85948 13.6879 9.41177 14.2402 9.41177Z",
      fill: "currentColor"
    })
  ]),
  excel: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M23.4921 19.1996C23.4921 21.0774 21.9699 22.5996 20.0921 22.5996L9.29183 22.5996C7.41406 22.5996 5.89182 21.0774 5.89182 19.1996L5.89182 18.529C5.89182 17.9767 6.33954 17.529 6.89182 17.529C7.44411 17.529 7.89182 17.9767 7.89182 18.529L7.89182 19.1996C7.89182 19.9728 8.51863 20.5996 9.29183 20.5996L20.0921 20.5996C20.8653 20.5996 21.4921 19.9728 21.4921 19.1996L21.4922 4.79967C21.4922 4.02647 20.8654 3.39967 20.0922 3.39967L9.29184 3.39967C8.51863 3.39967 7.89182 4.02647 7.89182 4.79968L7.89182 5.60181C7.89182 6.1541 7.44411 6.60181 6.89182 6.60181C6.33954 6.60181 5.89182 6.1541 5.89182 5.60181L5.89182 4.79968C5.89182 2.9219 7.41406 1.39967 9.29184 1.39967L20.0922 1.39967C21.97 1.39967 23.4922 2.92191 23.4922 4.79968L23.4921 19.1996Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M11.8008 15.8601L11.8008 8.22372C11.8008 7.62372 11.3099 7.13281 10.7099 7.13281L3.07351 7.13281C2.47351 7.13281 1.9826 7.62372 1.9826 8.22372L1.9826 15.8601C1.9826 16.4601 2.47351 16.951 3.07351 16.951L10.7099 16.951C11.3099 16.951 11.8008 16.4601 11.8008 15.8601ZM3.07351 15.8601L3.07351 8.22372L10.7099 8.22372L10.7099 15.8601L3.07351 15.8601Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.1016 8.22392L12.1016 15.8603C12.1016 16.626 11.4763 17.2512 10.7107 17.2512L3.07429 17.2512C2.3086 17.2512 1.68338 16.626 1.68338 15.8603L1.68338 8.22392C1.68338 7.45823 2.3086 6.83301 3.07429 6.83301L10.7107 6.83301C11.4763 6.83301 12.1016 7.45823 12.1016 8.22392ZM3.37429 8.52392L3.37429 15.5603L10.4107 15.5603L10.4107 8.52392L3.37429 8.52392ZM11.8016 8.22392L11.8016 15.8603C11.8016 16.4603 11.3107 16.9512 10.7107 16.9512L3.07429 16.9512C2.47429 16.9512 1.98338 16.4603 1.98338 15.8603L1.98338 8.22392C1.98338 7.62392 2.47429 7.13301 3.07429 7.13301L10.7107 7.13301C11.3107 7.13301 11.8016 7.62392 11.8016 8.22392ZM3.07429 15.8603L10.7107 15.8603L10.7107 8.22392L3.07429 8.22392L3.07429 15.8603Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M9.18174 9.75452C9.03994 9.61272 8.81087 9.61272 8.66907 9.75452L6.89111 11.5288L5.11315 9.75088C4.97135 9.60908 4.74229 9.60908 4.60049 9.75088C4.45869 9.89268 4.45869 10.1217 4.60049 10.2635L6.37845 12.0415L4.60049 13.8195C4.45869 13.9613 4.45869 14.1903 4.60049 14.3321C4.74229 14.4739 4.97135 14.4739 5.11315 14.3321L6.89111 12.5542L8.66907 14.3321C8.81087 14.4739 9.03994 14.4739 9.18174 14.3321C9.32354 14.1903 9.32354 13.9613 9.18174 13.8195L7.40378 12.0415L9.18174 10.2635C9.3199 10.1254 9.3199 9.89268 9.18174 9.75452Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.31588 9.4006C8.65297 9.0639 9.19835 9.06402 9.53529 9.40096C9.86872 9.73439 9.86872 10.2837 9.53529 10.6171L8.11088 12.0415L9.53529 13.4659C9.87235 13.803 9.87235 14.3486 9.53529 14.6857C9.19823 15.0227 8.65258 15.0227 8.31552 14.6857L6.89111 13.2613L5.46671 14.6857C5.12964 15.0227 4.584 15.0227 4.24694 14.6857C3.90987 14.3486 3.90987 13.803 4.24694 13.4659L5.67134 12.0415L4.24694 10.6171C3.90987 10.28 3.90987 9.73439 4.24694 9.39733C4.584 9.06027 5.12964 9.06027 5.46671 9.39733L6.89147 10.8221L8.31588 9.4006ZM8.66907 9.75452C8.81087 9.61272 9.03994 9.61272 9.18174 9.75452C9.3199 9.89268 9.3199 10.1254 9.18174 10.2635L7.40378 12.0415L9.18174 13.8195C9.32354 13.9613 9.32354 14.1903 9.18174 14.3321C9.03994 14.4739 8.81087 14.4739 8.66907 14.3321L6.89111 12.5542L5.11315 14.3321C4.97135 14.4739 4.74229 14.4739 4.60049 14.3321C4.45869 14.1903 4.45869 13.9613 4.60049 13.8195L6.37845 12.0415L4.60049 10.2635C4.45869 10.1217 4.45869 9.89268 4.60049 9.75088C4.74229 9.60908 4.97135 9.60908 5.11315 9.75088L6.89108 11.5288L8.66907 9.75452Z",
      fill: "currentColor"
    })
  ]),
  register: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.33994 4.79988C2.33995 2.92212 3.86218 1.3999 5.73994 1.3999H16.5402C18.418 1.3999 19.9402 2.92213 19.9402 4.7999V11.3999C19.9402 11.9522 19.4925 12.3999 18.9402 12.3999C18.3879 12.3999 17.9402 11.9522 17.9402 11.3999V4.7999C17.9402 4.0267 17.3134 3.3999 16.5402 3.3999H5.73994C4.96674 3.3999 4.33994 4.0267 4.33994 4.7999L4.33984 19.1998C4.33984 19.973 4.96664 20.5998 5.73984 20.5998H10.5398C11.0921 20.5998 11.5398 21.0476 11.5398 21.5998C11.5398 22.1521 11.0921 22.5998 10.5398 22.5998H5.73983C3.86206 22.5998 2.33983 21.0776 2.33984 19.1998L2.33994 4.79988ZM6.54022 7.1999C6.54022 6.64762 6.98793 6.1999 7.54022 6.1999H14.7402C15.2925 6.1999 15.7402 6.64762 15.7402 7.1999C15.7402 7.75219 15.2925 8.1999 14.7402 8.1999H7.54022C6.98793 8.1999 6.54022 7.75219 6.54022 7.1999ZM6.54022 10.7999C6.54022 10.2476 6.98793 9.7999 7.54022 9.7999H14.7402C15.2925 9.7999 15.7402 10.2476 15.7402 10.7999C15.7402 11.3522 15.2925 11.7999 14.7402 11.7999H7.54022C6.98793 11.7999 6.54022 11.3522 6.54022 10.7999ZM6.54022 14.3999C6.54022 13.8476 6.98793 13.3999 7.54022 13.3999H11.1402C11.6925 13.3999 12.1402 13.8476 12.1402 14.3999C12.1402 14.9522 11.6925 15.3999 11.1402 15.3999H7.54022C6.98793 15.3999 6.54022 14.9522 6.54022 14.3999ZM21.8473 14.8926C22.2378 15.2831 22.2379 15.9163 21.8473 16.3068L17.0473 21.107C16.8598 21.2945 16.6054 21.3999 16.3402 21.3999C16.075 21.3999 15.8207 21.2945 15.6331 21.107L13.4331 18.907C13.0426 18.5165 13.0426 17.8833 13.4331 17.4928C13.8236 17.1023 14.4568 17.1023 14.8473 17.4928L16.3402 18.9857L20.4331 14.8926C20.8236 14.5021 21.4568 14.5021 21.8473 14.8926Z",
      fill: "currentColor"
    })
  ]),
  edit: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.59775 4.7574C1.59776 2.87964 3.11999 1.35742 4.99775 1.35742H15.798C17.6758 1.35742 19.198 2.87965 19.198 4.75742V9.55742C19.198 10.1097 18.7503 10.5574 18.198 10.5574C17.6457 10.5574 17.198 10.1097 17.198 9.55742V4.75742C17.198 3.98422 16.5712 3.35742 15.798 3.35742H4.99775C4.22456 3.35742 3.59775 3.98422 3.59775 4.75741L3.59766 19.1574C3.59765 19.9306 4.22445 20.5574 4.99765 20.5574H9.79766C10.3499 20.5574 10.7977 21.0051 10.7977 21.5574C10.7977 22.1096 10.3499 22.5574 9.79766 22.5574H4.99764C3.11987 22.5574 1.59764 21.0351 1.59766 19.1573L1.59775 4.7574ZM5.79803 7.15742C5.79803 6.60514 6.24575 6.15742 6.79803 6.15742H13.998C14.5503 6.15742 14.998 6.60514 14.998 7.15742C14.998 7.70971 14.5503 8.15742 13.998 8.15742H6.79803C6.24575 8.15742 5.79803 7.70971 5.79803 7.15742ZM5.79803 10.7574C5.79803 10.2051 6.24575 9.75742 6.79803 9.75742H13.998C14.5503 9.75742 14.998 10.2051 14.998 10.7574C14.998 11.3097 14.5503 11.7574 13.998 11.7574H6.79803C6.24575 11.7574 5.79803 11.3097 5.79803 10.7574ZM17.7819 12.4502C18.1724 12.0597 18.8056 12.0597 19.1961 12.4502L22.5902 15.8443C22.7778 16.0318 22.8831 16.2862 22.8831 16.5514C22.8831 16.8166 22.7778 17.071 22.5902 17.2585L17.4991 22.3497C17.3115 22.5372 17.0572 22.6426 16.792 22.6426H13.3979C12.8456 22.6426 12.3979 22.1948 12.3979 21.6426V18.2484C12.3979 17.9832 12.5032 17.7289 12.6907 17.5413L17.7819 12.4502ZM18.489 14.5715L14.3979 18.6627V20.6426H16.3778L20.4689 16.5514L18.489 14.5715ZM5.79803 14.3574C5.79803 13.8051 6.24575 13.3574 6.79803 13.3574H10.398C10.9503 13.3574 11.398 13.8051 11.398 14.3574C11.398 14.9097 10.9503 15.3574 10.398 15.3574H6.79803C6.24575 15.3574 5.79803 14.9097 5.79803 14.3574Z",
      fill: "currentColor"
    })
  ]),
  settings: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M19.673 12.98C19.713 12.66 19.743 12.34 19.743 12C19.743 11.66 19.713 11.34 19.673 11.02L21.783 9.37C21.973 9.22 22.023 8.95 21.903 8.73L19.903 5.27C19.813 5.11 19.643 5.02 19.463 5.02C19.403 5.02 19.343 5.03 19.293 5.05L16.803 6.05C16.283 5.65 15.723 5.32 15.113 5.07L14.733 2.42C14.703 2.18 14.493 2 14.243 2H10.243C9.993 2 9.783 2.18 9.753 2.42L9.373 5.07C8.763 5.32 8.203 5.66 7.683 6.05L5.193 5.05C5.133 5.03 5.073 5.02 5.013 5.02C4.843 5.02 4.673 5.11 4.583 5.27L2.583 8.73C2.453 8.95 2.513 9.22 2.703 9.37L4.813 11.02C4.773 11.34 4.743 11.67 4.743 12C4.743 12.33 4.773 12.66 4.813 12.98L2.703 14.63C2.513 14.78 2.463 15.05 2.583 15.27L4.583 18.73C4.673 18.89 4.843 18.98 5.023 18.98C5.083 18.98 5.143 18.97 5.193 18.95L7.683 17.95C8.203 18.35 8.763 18.68 9.373 18.93L9.753 21.58C9.783 21.82 9.993 22 10.243 22H14.243C14.493 22 14.703 21.82 14.733 21.58L15.113 18.93C15.723 18.68 16.283 18.34 16.803 17.95L19.293 18.95C19.353 18.97 19.413 18.98 19.473 18.98C19.643 18.98 19.813 18.89 19.903 18.73L21.903 15.27C22.023 15.05 21.973 14.78 21.783 14.63L19.673 12.98ZM17.693 11.27C17.733 11.58 17.743 11.79 17.743 12C17.743 12.21 17.723 12.43 17.693 12.73L17.553 13.86L18.443 14.56L19.523 15.4L18.823 16.61L17.553 16.1L16.513 15.68L15.613 16.36C15.183 16.68 14.773 16.92 14.363 17.09L13.303 17.52L13.143 18.65L12.943 20H11.543L11.193 17.52L10.133 17.09C9.703 16.91 9.303 16.68 8.903 16.38L7.993 15.68L6.933 16.11L5.663 16.62L4.963 15.41L6.043 14.57L6.933 13.87L6.793 12.74C6.763 12.43 6.743 12.2 6.743 12C6.743 11.8 6.763 11.57 6.793 11.27L6.933 10.14L6.043 9.44L4.963 8.6L5.663 7.39L6.933 7.9L7.973 8.32L8.873 7.64C9.303 7.32 9.713 7.08 10.123 6.91L11.183 6.48L11.343 5.35L11.543 4H12.933L13.283 6.48L14.343 6.91C14.773 7.09 15.173 7.32 15.573 7.62L16.483 8.32L17.543 7.89L18.813 7.38L19.513 8.59L18.443 9.44L17.553 10.14L17.693 11.27ZM12.243 8C10.033 8 8.243 9.79 8.243 12C8.243 14.21 10.033 16 12.243 16C14.453 16 16.243 14.21 16.243 12C16.243 9.79 14.453 8 12.243 8ZM12.243 14C11.143 14 10.243 13.1 10.243 12C10.243 10.9 11.143 10 12.243 10C13.343 10 14.243 10.9 14.243 12C14.243 13.1 13.343 14 12.243 14Z",
      fill: "currentColor"
    })
  ]),
  branch: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.94882 5.45605C5.1972 5.45605 4.58789 6.06536 4.58789 6.81698C4.58789 7.56853 5.19721 8.17786 5.9489 8.17786C6.70051 8.17786 7.30975 7.56862 7.30975 6.81698C7.30975 6.06536 6.70044 5.45605 5.94882 5.45605ZM2.58789 6.81698C2.58789 4.96079 4.09263 3.45605 5.94882 3.45605C7.46185 3.45605 8.74137 4.45585 9.16275 5.83083C9.21699 5.82173 9.27272 5.81698 9.32955 5.81698H15.819C15.827 5.81698 15.8349 5.81708 15.8428 5.81727C16.2707 4.45309 17.5449 3.46344 19.0502 3.46344C20.9064 3.46344 22.4111 4.96817 22.4111 6.82437C22.4111 8.68056 20.9064 10.1853 19.0502 10.1853C17.5395 10.1853 16.2616 9.18855 15.8382 7.8168C15.8318 7.81693 15.8254 7.81699 15.819 7.81699H11.1624C11.337 8.26098 11.44 8.78987 11.44 9.41393V14.5931C11.44 15.5551 11.8042 15.8705 12.0245 16.0044C12.1667 16.0908 12.3166 16.1379 12.4359 16.1621C12.4938 16.1738 12.5392 16.1791 12.5652 16.1813C12.5734 16.182 12.5794 16.1824 12.583 16.1826H15.4268C15.5194 16.1826 15.6091 16.1952 15.6942 16.2188C16.1085 14.8323 17.3937 13.8217 18.9149 13.8217C20.771 13.8217 22.2758 15.3264 22.2758 17.1826C22.2758 19.0388 20.771 20.5436 18.9149 20.5436C17.3937 20.5436 16.1085 19.5329 15.6942 18.1465C15.6091 18.17 15.5194 18.1826 15.4268 18.1826H12.5702V17.1826C12.5702 18.1826 12.5696 18.1826 12.569 18.1826L12.5677 18.1826L12.565 18.1826L12.559 18.1826L12.5445 18.1823C12.5337 18.1821 12.5208 18.1818 12.5058 18.1812C12.4759 18.18 12.4376 18.1778 12.3922 18.1738C12.3017 18.166 12.1806 18.151 12.0388 18.1222C11.7587 18.0655 11.376 17.9507 10.9857 17.7135C10.1409 17.2 9.43998 16.2205 9.43998 14.5931V9.41393C9.43998 8.69249 9.23507 8.33302 9.03889 8.14106C8.52497 9.33888 7.33495 10.1779 5.9489 10.1779C4.09279 10.1779 2.58789 8.67325 2.58789 6.81698ZM19.0502 5.46344C18.2986 5.46344 17.6893 6.07275 17.6893 6.82437C17.6893 7.57599 18.2986 8.1853 19.0502 8.1853C19.8018 8.1853 20.4111 7.57599 20.4111 6.82437C20.4111 6.07275 19.8018 5.46344 19.0502 5.46344ZM18.9149 15.8217C18.1632 15.8217 17.5539 16.431 17.5539 17.1826C17.5539 17.9342 18.1632 18.5436 18.9149 18.5436C19.6665 18.5436 20.2758 17.9342 20.2758 17.1826C20.2758 16.431 19.6665 15.8217 18.9149 15.8217Z",
      fill: "currentColor"
    })
  ]),
  commit: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.4603 10.2661C11.5028 10.2661 10.7266 11.0423 10.7266 11.9998C10.7266 12.9573 11.5028 13.7335 12.4603 13.7335C13.4178 13.7335 14.194 12.9573 14.194 11.9998C14.194 11.0423 13.4178 10.2661 12.4603 10.2661ZM8.86206 10.9998C9.29924 9.42333 10.7446 8.26611 12.4603 8.26611C14.1111 8.26611 15.5117 9.33745 16.0047 10.8228H22.1004C22.6527 10.8228 23.1004 11.2705 23.1004 11.8228C23.1004 12.3751 22.6527 12.8228 22.1004 12.8228H16.1031C15.7283 14.4889 14.2396 15.7335 12.4603 15.7335C10.7446 15.7335 9.29924 14.5763 8.86206 12.9998H2.90039C2.34811 12.9998 1.90039 12.5521 1.90039 11.9998C1.90039 11.4475 2.34811 10.9998 2.90039 10.9998H8.86206Z",
      fill: "currentColor"
    })
  ]),
  "prepaid-history": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.69922 4.8C3.69922 3.39274 4.71582 2 6.25922 2H18.7392C20.2826 2 21.2992 3.39274 21.2992 4.8V21C21.2992 21.3719 21.0928 21.7132 20.7633 21.8858C20.4339 22.0584 20.0358 22.0339 19.73 21.8222L17.6992 20.4163L15.6684 21.8222C15.326 22.0593 14.8725 22.0593 14.53 21.8222L12.4992 20.4163L10.4684 21.8222C10.126 22.0593 9.67245 22.0593 9.33001 21.8222L7.29922 20.4163L5.26843 21.8222C4.96262 22.0339 4.56457 22.0584 4.23511 21.8858C3.90565 21.7132 3.69922 21.3719 3.69922 21V4.8ZM6.25922 4C6.07949 4 5.69922 4.21904 5.69922 4.8V19.0914L6.73001 18.3778C7.07245 18.1407 7.52598 18.1407 7.86843 18.3778L9.89922 19.7837L11.93 18.3778C12.2725 18.1407 12.726 18.1407 13.0684 18.3778L15.0992 19.7837L17.13 18.3778C17.4725 18.1407 17.926 18.1407 18.2684 18.3778L19.2992 19.0914V4.8C19.2992 4.21904 18.9189 4 18.7392 4H6.25922Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.4998 4.54004C13.0521 4.54004 13.4998 4.98775 13.4998 5.54004V6.44655H13.7708C13.7852 6.44655 13.7996 6.44686 13.8139 6.44748C14.3935 6.47251 14.9524 6.67042 15.4186 7.01574C15.8848 7.36106 16.237 7.83799 16.4298 8.38516C16.6134 8.90604 16.3399 9.47712 15.8191 9.6607C15.2982 9.84428 14.7271 9.57084 14.5435 9.04996C14.4834 8.87931 14.3735 8.73056 14.2281 8.62286C14.0875 8.51865 13.9197 8.45748 13.7452 8.44655H11.2288C10.9884 8.44655 10.7578 8.54206 10.5878 8.71206C10.4178 8.88207 10.3223 9.11264 10.3223 9.35306C10.3223 9.59349 10.4178 9.82406 10.5878 9.99407C10.7578 10.1641 10.9884 10.2596 11.2288 10.2596H13.7708C14.5416 10.2596 15.2809 10.5658 15.826 11.1109C16.3711 11.656 16.6773 12.3952 16.6773 13.1661C16.6773 13.9369 16.3711 14.6762 15.826 15.2213C15.2809 15.7664 14.5416 16.0726 13.7708 16.0726H13.4998V16.9791C13.4998 17.5314 13.0521 17.9791 12.4998 17.9791C11.9475 17.9791 11.4998 17.5314 11.4998 16.9791V16.0726H11.2288C11.2144 16.0726 11.2 16.0723 11.1856 16.0717C10.606 16.0466 10.0472 15.8487 9.58098 15.5034C9.1148 15.1581 8.76262 14.6812 8.56978 14.134C8.3862 13.6131 8.65963 13.042 9.18051 12.8585C9.7014 12.6749 10.2725 12.9483 10.4561 13.4692C10.5162 13.6398 10.626 13.7886 10.7714 13.8963C10.9121 14.0005 11.0799 14.0617 11.2543 14.0726H13.7708C14.0112 14.0726 14.2418 13.9771 14.4118 13.8071C14.5818 13.6371 14.6773 13.4065 14.6773 13.1661C14.6773 12.9257 14.5818 12.6951 14.4118 12.5251C14.2418 12.3551 14.0112 12.2596 13.7708 12.2596H11.2288C10.4579 12.2596 9.71864 11.9534 9.17356 11.4083C8.62849 10.8632 8.32227 10.1239 8.32227 9.35306C8.32227 8.58221 8.62849 7.84293 9.17356 7.29785C9.71864 6.75277 10.4579 6.44655 11.2288 6.44655H11.4998V5.54004C11.4998 4.98775 11.9475 4.54004 12.4998 4.54004Z",
      fill: "currentColor"
    })
  ]),
  "cost-approval": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.19931 4.79988C2.19932 2.92212 3.72155 1.3999 5.59931 1.3999H16.3996C18.2773 1.3999 19.7996 2.92213 19.7996 4.7999V11.3999C19.7996 11.9522 19.3519 12.3999 18.7996 12.3999C18.2473 12.3999 17.7996 11.9522 17.7996 11.3999V4.7999C17.7996 4.0267 17.1728 3.3999 16.3996 3.3999H5.59931C4.82612 3.3999 4.19932 4.0267 4.19931 4.7999L4.19922 19.1998C4.19921 19.973 4.82601 20.5998 5.59921 20.5998H10.3992C10.9515 20.5998 11.3992 21.0476 11.3992 21.5998C11.3992 22.1521 10.9515 22.5998 10.3992 22.5998H5.5992C3.72143 22.5998 2.19921 21.0776 2.19922 19.1998L2.19931 4.79988ZM22.4819 13.6688C22.8857 14.0457 22.9075 14.6785 22.5306 15.0822L16.9306 21.0822C16.7456 21.2805 16.488 21.3951 16.2168 21.3998C15.9457 21.4044 15.6842 21.2988 15.4925 21.107L13.2925 18.907C12.902 18.5165 12.902 17.8833 13.2925 17.4928C13.683 17.1023 14.3162 17.1023 14.7067 17.4928L16.1748 18.9609L21.0685 13.7176C21.4454 13.3138 22.0782 13.292 22.4819 13.6688Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.1189 4.92773C11.6712 4.92773 12.1189 5.37545 12.1189 5.92773V6.83425H12.3899C12.4043 6.83425 12.4187 6.83456 12.4331 6.83518C13.0127 6.8602 13.5715 7.05811 14.0377 7.40344C14.5039 7.74876 14.8561 8.22569 15.0489 8.77285C15.2325 9.29373 14.9591 9.86481 14.4382 10.0484C13.9173 10.232 13.3462 9.95854 13.1627 9.43766C13.1025 9.267 12.9927 9.11825 12.8473 9.01055C12.7066 8.90635 12.5389 8.84518 12.3644 8.83425H9.84792C9.6075 8.83425 9.37692 8.92975 9.20692 9.09976C9.03691 9.26976 8.94141 9.50034 8.94141 9.74076C8.94141 9.98118 9.03691 10.2118 9.20692 10.3818C9.37692 10.5518 9.6075 10.6473 9.84792 10.6473H12.3899C13.1608 10.6473 13.9001 10.9535 14.4451 11.4986C14.9902 12.0436 15.2964 12.7829 15.2964 13.5538C15.2964 14.3246 14.9902 15.0639 14.4451 15.609C13.9001 16.1541 13.1608 16.4603 12.3899 16.4603H12.1189V17.3668C12.1189 17.9191 11.6712 18.3668 11.1189 18.3668C10.5666 18.3668 10.1189 17.9191 10.1189 17.3668V16.4603H9.84792C9.83353 16.4603 9.81915 16.46 9.80478 16.4594C9.22517 16.4343 8.66631 16.2364 8.20012 15.8911C7.73394 15.5458 7.38176 15.0689 7.18892 14.5217C7.00534 14.0008 7.27877 13.4297 7.79966 13.2462C8.32054 13.0626 8.89161 13.336 9.0752 13.8569C9.13534 14.0275 9.24518 14.1763 9.39058 14.284C9.53126 14.3882 9.69899 14.4494 9.87346 14.4603H12.3899C12.6304 14.4603 12.8609 14.3648 13.0309 14.1948C13.2009 14.0248 13.2964 13.7942 13.2964 13.5538C13.2964 13.3134 13.2009 13.0828 13.0309 12.9128C12.8609 12.7428 12.6304 12.6473 12.3899 12.6473H9.84792C9.07706 12.6473 8.33778 12.3411 7.7927 11.796C7.24763 11.2509 6.94141 10.5116 6.94141 9.74076C6.94141 8.9699 7.24763 8.23062 7.7927 7.68554C8.33778 7.14047 9.07706 6.83425 9.84792 6.83425H10.1189V5.92773C10.1189 5.37545 10.5666 4.92773 11.1189 4.92773Z",
      fill: "currentColor"
    })
  ]),
  router: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M15.5627 16.0074C15.9532 16.398 15.9532 17.0311 15.5627 17.4217L13.2057 19.7787C12.8152 20.1692 12.182 20.1692 11.7915 19.7787L9.43446 17.4217C9.04394 17.0311 9.04394 16.398 9.43446 16.0074C9.82498 15.6169 10.4581 15.6169 10.8487 16.0074L11.4986 16.6574L11.4986 13.7683C11.4986 13.216 11.9463 12.7683 12.4986 12.7683C13.0509 12.7683 13.4986 13.216 13.4986 13.7683L13.4986 16.6574L14.1485 16.0074C14.539 15.6169 15.1722 15.6169 15.5627 16.0074Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.43533 7.99353C9.0448 7.60301 9.0448 6.96984 9.43533 6.57932L11.7924 4.2223C12.1829 3.83177 12.816 3.83177 13.2066 4.2223L15.5636 6.57932C15.9541 6.96985 15.9541 7.60301 15.5636 7.99353C15.1731 8.38406 14.5399 8.38406 14.1494 7.99353L13.4995 7.34362L13.4995 10.2327C13.4995 10.785 13.0517 11.2327 12.4995 11.2327C11.9472 11.2327 11.4995 10.785 11.4995 10.2327L11.4995 7.34362L10.8495 7.99353C10.459 8.38406 9.82585 8.38406 9.43533 7.99353Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.5055 8.9363C16.896 8.54578 17.5292 8.54578 17.9197 8.93631L20.2767 11.2933C20.6672 11.6839 20.6672 12.317 20.2767 12.7075L17.9197 15.0646C17.5292 15.4551 16.896 15.4551 16.5055 15.0646C16.115 14.674 16.115 14.0409 16.5055 13.6503L17.1554 13.0004L14.2663 13.0004C13.714 13.0004 13.2663 12.5527 13.2663 12.0004C13.2663 11.4481 13.714 11.0004 14.2663 11.0004L17.1554 11.0004L16.5055 10.3505C16.115 9.95999 16.115 9.32683 16.5055 8.9363Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.49256 15.0637C8.10203 15.4542 7.46887 15.4542 7.07834 15.0637L4.72132 12.7067C4.3308 12.3161 4.3308 11.683 4.72132 11.2925L7.07834 8.93544C7.46887 8.54491 8.10203 8.54491 8.49256 8.93544C8.88308 9.32596 8.88308 9.95913 8.49256 10.3497L7.84264 10.9996L10.7317 10.9996C11.284 10.9996 11.7317 11.4473 11.7317 11.9996C11.7317 12.5519 11.284 12.9996 10.7317 12.9996L7.84264 12.9996L8.49256 13.6495C8.88308 14.04 8.88308 14.6732 8.49256 15.0637Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.864 5.63604C15.3492 2.12132 9.65076 2.12132 6.13604 5.63604C2.62132 9.15076 2.62132 14.8492 6.13604 18.364C9.65076 21.8787 15.3492 21.8787 18.864 18.364C22.3787 14.8492 22.3787 9.15076 18.864 5.63604ZM4.72183 4.22183C9.01759 -0.0739419 15.9824 -0.0739419 20.2782 4.22183C24.5739 8.51759 24.5739 15.4824 20.2782 19.7782C15.9824 24.0739 9.01759 24.0739 4.72183 19.7782C0.426058 15.4824 0.426058 8.51759 4.72183 4.22183Z",
      fill: "currentColor"
    })
  ]),
  deployRequest: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 23 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.95867 3.77529C6.61644 3.43306 6.61644 2.87819 6.95867 2.53596L8.87517 0.619457C9.03952 0.455113 9.26242 0.362784 9.49483 0.362785C9.72725 0.362785 9.95015 0.455113 10.1145 0.619457L12.031 2.53596C12.3732 2.87819 12.3732 3.43306 12.031 3.77529C11.6888 4.11752 11.1339 4.11752 10.7917 3.77529L10.3712 3.35478L10.3712 7.91811C10.3712 8.40209 9.97882 8.79444 9.49483 8.79444C9.01085 8.79444 8.6185 8.40209 8.6185 7.91811L8.6185 3.35478L8.19799 3.77529C7.85576 4.11752 7.3009 4.11752 6.95867 3.77529Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.83539 9.08374C2.36789 9.20901 1.88737 8.93158 1.7621 8.46408L1.06061 5.84609C1.00046 5.62159 1.03195 5.38239 1.14816 5.18111C1.26437 4.97983 1.45578 4.83295 1.68028 4.7728L4.29827 4.07131C4.76576 3.94605 5.24629 4.22348 5.37156 4.69097C5.49682 5.15847 5.21939 5.639 4.75189 5.76426L4.17747 5.91818L8.12943 8.19984C8.54857 8.44183 8.69218 8.97779 8.45019 9.39694C8.2082 9.81608 7.67224 9.95969 7.25309 9.7177L3.30114 7.43603L3.45505 8.01046C3.58032 8.47795 3.30288 8.95848 2.83539 9.08374Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.1529 9.08374C16.6204 9.20901 17.1009 8.93158 17.2262 8.46408L17.9277 5.84609C17.9878 5.62159 17.9563 5.38239 17.8401 5.18111C17.7239 4.97983 17.5325 4.83295 17.308 4.7728L14.69 4.07131C14.2225 3.94605 13.742 4.22348 13.6167 4.69097C13.4915 5.15847 13.7689 5.639 14.2364 5.76426L14.8108 5.91818L10.8589 8.19984C10.4397 8.44183 10.2961 8.97779 10.5381 9.39694C10.7801 9.81608 11.316 9.95969 11.7352 9.7177L15.6871 7.43603L15.5332 8.01046C15.408 8.47795 15.6854 8.95848 16.1529 9.08374Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.0296 16.2247C12.3718 16.5669 12.3718 17.1218 12.0296 17.464L10.1131 19.3805C9.94877 19.5449 9.72586 19.6372 9.49345 19.6372C9.26103 19.6372 9.03813 19.5449 8.87378 19.3805L6.95728 17.464C6.61505 17.1218 6.61505 16.5669 6.95728 16.2247C7.29951 15.8825 7.85438 15.8825 8.19661 16.2247L8.61711 16.6452L8.61711 12.0819C8.61711 11.5979 9.00946 11.2056 9.49345 11.2056C9.97743 11.2056 10.3698 11.5979 10.3698 12.0819L10.3698 16.6452L10.7903 16.2247C11.1325 15.8825 11.6874 15.8825 12.0296 16.2247Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.83539 10.9163C2.3679 10.791 1.88737 11.0684 1.7621 11.5359L1.06061 14.1539C1.00046 14.3784 1.03195 14.6176 1.14816 14.8189C1.26437 15.0202 1.45578 15.167 1.68028 15.2272L4.29827 15.9287C4.76576 16.054 5.24629 15.7765 5.37156 15.309C5.49682 14.8415 5.21939 14.361 4.75189 14.2357L4.17747 14.0818L8.12943 11.8002C8.54857 11.5582 8.69218 11.0222 8.45019 10.6031C8.2082 10.1839 7.67224 10.0403 7.25309 10.2823L3.30114 12.564L3.45505 11.9895C3.58032 11.522 3.30289 11.0415 2.83539 10.9163Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M13.4323 11.2623L11.7346 10.2821C11.3154 10.0401 10.7795 10.1837 10.5375 10.6029C10.2955 11.022 10.4391 11.558 10.8582 11.8L12.6558 12.8378C12.8235 12.2646 13.0887 11.733 13.4323 11.2623Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M21.8239 10.5068C22.2802 10.9631 22.2802 11.7029 21.8239 12.1592L17.6175 16.3656C17.1612 16.8219 16.4214 16.8219 15.9651 16.3656L14.5629 14.9635C14.1066 14.5072 14.1066 13.7674 14.5629 13.3111C15.0192 12.8547 15.7591 12.8547 16.2154 13.3111L16.7913 13.887L20.1715 10.5068C20.6278 10.0505 21.3676 10.0505 21.8239 10.5068Z",
      fill: "currentColor"
    })
  ]),
  deploy: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.96453 5.77577C9.6223 5.43354 9.6223 4.87868 9.96453 4.53645L11.881 2.61995C12.0454 2.4556 12.2683 2.36327 12.5007 2.36327C12.7331 2.36327 12.956 2.4556 13.1204 2.61995L15.0369 4.53645C15.3791 4.87868 15.3791 5.43354 15.0369 5.77577C14.6946 6.118 14.1398 6.118 13.7975 5.77577L13.377 5.35527L13.377 9.9186C13.377 10.4026 12.9847 10.7949 12.5007 10.7949C12.0167 10.7949 11.6244 10.4026 11.6244 9.91859L11.6244 5.35527L11.2039 5.77577C10.8616 6.118 10.3068 6.118 9.96453 5.77577Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.84125 11.0842C5.37375 11.2095 4.89323 10.9321 4.76796 10.4646L4.06647 7.84658C4.00632 7.62208 4.03781 7.38288 4.15402 7.1816C4.27023 6.98032 4.46164 6.83344 4.68614 6.77329L7.30413 6.0718C7.77162 5.94654 8.25215 6.22397 8.37742 6.69146C8.50268 7.15896 8.22525 7.63948 7.75775 7.76475L7.18333 7.91867L11.1353 10.2003C11.5544 10.4423 11.698 10.9783 11.456 11.3974C11.2141 11.8166 10.6781 11.9602 10.259 11.7182L6.307 9.43652L6.46091 10.0109C6.58618 10.4784 6.30874 10.959 5.84125 11.0842Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M19.1588 11.0842C19.6262 11.2095 20.1068 10.9321 20.232 10.4646L20.9335 7.84658C20.9937 7.62208 20.9622 7.38288 20.846 7.1816C20.7298 6.98032 20.5384 6.83344 20.3139 6.77329L17.6959 6.0718C17.2284 5.94654 16.7478 6.22397 16.6226 6.69146C16.4973 7.15896 16.7748 7.63948 17.2422 7.76475L17.8167 7.91867L13.8647 10.2003C13.4456 10.4423 13.302 10.9783 13.544 11.3974C13.7859 11.8166 14.3219 11.9602 14.741 11.7182L18.693 9.43652L18.5391 10.0109C18.4138 10.4784 18.6913 10.959 19.1588 11.0842Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M15.0355 18.2247C15.3777 18.5669 15.3777 19.1218 15.0355 19.464L13.119 21.3805C12.9546 21.5449 12.7317 21.6372 12.4993 21.6372C12.2669 21.6372 12.044 21.5449 11.8796 21.3805L9.96314 19.464C9.62091 19.1218 9.62091 18.5669 9.96314 18.2247C10.3054 17.8825 10.8602 17.8825 11.2025 18.2247L11.623 18.6452L11.623 14.0819C11.623 13.5979 12.0153 13.2056 12.4993 13.2056C12.9833 13.2056 13.3756 13.5979 13.3756 14.0819L13.3756 18.6452L13.7961 18.2247C14.1384 17.8825 14.6932 17.8825 15.0355 18.2247Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M19.1588 12.9158C19.6262 12.7905 20.1068 13.0679 20.232 13.5354L20.9335 16.1534C20.9937 16.3779 20.9622 16.6171 20.846 16.8184C20.7298 17.0197 20.5384 17.1666 20.3139 17.2267L17.6959 17.9282C17.2284 18.0535 16.7478 17.776 16.6226 17.3085C16.4973 16.841 16.7748 16.3605 17.2422 16.2353L17.8167 16.0813L13.8647 13.7997C13.4456 13.5577 13.302 13.0217 13.544 12.6026C13.7859 12.1834 14.3219 12.0398 14.741 12.2818L18.693 14.5635L18.5391 13.9891C18.4138 13.5216 18.6913 13.041 19.1588 12.9158Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.84125 12.9158C5.37375 12.7905 4.89323 13.0679 4.76796 13.5354L4.06647 16.1534C4.00632 16.3779 4.03781 16.6171 4.15402 16.8184C4.27023 17.0197 4.46164 17.1666 4.68614 17.2267L7.30413 17.9282C7.77162 18.0535 8.25215 17.776 8.37742 17.3085C8.50268 16.841 8.22525 16.3605 7.75775 16.2353L7.18333 16.0813L11.1353 13.7997C11.5544 13.5577 11.698 13.0217 11.456 12.6026C11.2141 12.1834 10.6781 12.0398 10.259 12.2818L6.307 14.5635L6.46091 13.9891C6.58618 13.5216 6.30874 13.041 5.84125 12.9158Z",
      fill: "currentColor"
    })
  ]),
  network: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.58198 7.36426L8.46571 7.36426C8.55563 5.83552 8.85006 4.42551 9.30428 3.28459C7.88723 4.17769 6.87002 5.64735 6.58198 7.36426ZM12.499 0.364258C8.08075 0.364258 4.49902 3.94598 4.49902 8.36426C4.49902 12.4365 7.54163 15.798 11.4775 16.2997V17.7245C10.5992 18.0374 9.90701 18.7425 9.61155 19.6289H3.48828C2.936 19.6289 2.48828 20.0766 2.48828 20.6289C2.48828 21.1812 2.936 21.6289 3.48828 21.6289H9.63736C10.0615 22.7989 11.1826 23.6348 12.499 23.6348C13.8154 23.6348 14.9366 22.7989 15.3607 21.6289H21.5101C22.0624 21.6289 22.5101 21.1812 22.5101 20.6289C22.5101 20.0766 22.0624 19.6289 21.5101 19.6289H15.3865C15.0862 18.7281 14.3762 18.0146 13.4775 17.7096V16.305C17.4342 15.8225 20.499 12.4513 20.499 8.36426C20.499 3.94598 16.9173 0.364258 12.499 0.364258ZM12.499 2.36426C12.407 2.36426 12.2406 2.40266 12.002 2.6333C11.7586 2.8686 11.4938 3.25735 11.2497 3.81533C10.8537 4.72035 10.564 5.95237 10.4696 7.36426L14.5284 7.36426C14.434 5.95237 14.1443 4.72035 13.7484 3.81533C13.5043 3.25735 13.2394 2.8686 12.996 2.6333C12.7575 2.40266 12.591 2.36426 12.499 2.36426ZM16.5323 7.36426C16.4424 5.83552 16.148 4.42551 15.6938 3.28459C17.1108 4.17769 18.128 5.64735 18.4161 7.36426L16.5323 7.36426ZM10.4696 9.36426C10.564 10.7762 10.8537 12.0082 11.2497 12.9132C11.4938 13.4712 11.7586 13.8599 12.002 14.0952C12.2406 14.3259 12.407 14.3643 12.499 14.3643C12.591 14.3643 12.7575 14.3259 12.996 14.0952C13.2394 13.8599 13.5043 13.4712 13.7484 12.9132C14.1443 12.0082 14.434 10.7762 14.5284 9.36426H10.4696ZM15.6938 13.4439C16.148 12.303 16.4424 10.893 16.5323 9.36426H18.4161C18.128 11.0812 17.1108 12.5508 15.6938 13.4439ZM9.30428 13.4439C8.85006 12.303 8.55563 10.893 8.46571 9.36426H6.58198C6.87002 11.0812 7.88723 12.5508 9.30428 13.4439ZM12.499 19.5488C11.923 19.5488 11.4561 20.0158 11.4561 20.5918C11.4561 21.1678 11.923 21.6348 12.499 21.6348C13.075 21.6348 13.542 21.1678 13.542 20.5918C13.542 20.0158 13.075 19.5488 12.499 19.5488Z",
      fill: "currentColor"
    })
  ]),
  ip: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M21.4604 9.73404C21.3278 8.26865 20.8171 6.86277 19.9782 5.65394C19.1393 4.44512 18.001 3.47476 16.6747 2.83778C15.3483 2.20081 13.8793 1.91905 12.4114 2.02006C10.9435 2.12107 9.52697 2.60139 8.30037 3.41404C7.24957 4.11668 6.36742 5.04334 5.71731 6.12743C5.0672 7.21152 4.66526 8.42614 4.54037 9.68404C4.41785 10.9337 4.57504 12.195 5.00054 13.3763C5.42604 14.5577 6.10917 15.6295 7.00037 16.514L12.3004 21.824C12.3933 21.9178 12.5039 21.9922 12.6258 22.0429C12.7477 22.0937 12.8784 22.1198 13.0104 22.1198C13.1424 22.1198 13.2731 22.0937 13.3949 22.0429C13.5168 21.9922 13.6274 21.9178 13.7204 21.824L19.0004 16.514C19.8916 15.6295 20.5747 14.5577 21.0002 13.3763C21.4257 12.195 21.5829 10.9337 21.4604 9.68404V9.73404ZM17.6004 15.104L13.0004 19.704L8.40037 15.104C7.72246 14.4261 7.20317 13.6064 6.87984 12.7038C6.5565 11.8012 6.43715 10.8382 6.53037 9.88404C6.62419 8.91514 6.93213 7.9792 7.43194 7.14388C7.93175 6.30856 8.61093 5.59474 9.42037 5.05404C10.4813 4.34927 11.7267 3.97333 13.0004 3.97333C14.2741 3.97333 15.5194 4.34927 16.5804 5.05404C17.3874 5.59265 18.065 6.30332 18.5647 7.13498C19.0644 7.96663 19.3737 8.89864 19.4704 9.86404C19.5666 10.8215 19.4488 11.7883 19.1254 12.6946C18.8019 13.6009 18.281 14.4239 17.6004 15.104Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M14.5063 10.4092C14.7863 10.4092 14.9997 10.3459 15.1463 10.2192C15.2997 10.0859 15.3763 9.88587 15.3763 9.6192C15.3763 9.36587 15.2963 9.17253 15.1363 9.0392C14.983 8.8992 14.7563 8.8292 14.4563 8.8292C14.3497 8.8292 14.2597 8.83253 14.1863 8.8392C14.1197 8.8392 14.0497 8.84587 13.9763 8.8592V10.4092H14.5063ZM13.9863 13.6192C13.913 13.6392 13.7963 13.6592 13.6363 13.6792C13.483 13.6992 13.3297 13.7092 13.1763 13.7092C13.023 13.7092 12.8863 13.6959 12.7663 13.6692C12.653 13.6492 12.5563 13.6092 12.4763 13.5492C12.3963 13.4892 12.3363 13.4059 12.2963 13.2992C12.2563 13.1925 12.2363 13.0525 12.2363 12.8792V8.1692C12.2363 8.0292 12.273 7.92253 12.3463 7.8492C12.4263 7.7692 12.533 7.70587 12.6663 7.6592C12.893 7.5792 13.1497 7.52253 13.4363 7.4892C13.7297 7.4492 14.023 7.4292 14.3163 7.4292C15.2363 7.4292 15.9397 7.62587 16.4263 8.0192C16.913 8.41253 17.1563 8.94587 17.1563 9.6192C17.1563 9.94587 17.103 10.2425 16.9963 10.5092C16.8963 10.7692 16.743 10.9959 16.5363 11.1892C16.3363 11.3759 16.0797 11.5225 15.7663 11.6292C15.4597 11.7292 15.103 11.7792 14.6963 11.7792H13.9863V13.6192Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M10.9395 13.6193C10.8661 13.6393 10.7495 13.6593 10.5895 13.6793C10.4361 13.6993 10.2828 13.7093 10.1295 13.7093C9.97612 13.7093 9.83945 13.6959 9.71945 13.6693C9.60612 13.6493 9.50945 13.6093 9.42945 13.5493C9.34945 13.4893 9.28945 13.4059 9.24945 13.2993C9.20945 13.1926 9.18945 13.0526 9.18945 12.8793V7.59928C9.26279 7.58594 9.37945 7.56928 9.53945 7.54928C9.69945 7.52261 9.85279 7.50928 9.99945 7.50928C10.1528 7.50928 10.2861 7.52261 10.3995 7.54928C10.5195 7.56928 10.6195 7.60928 10.6995 7.66928C10.7795 7.72928 10.8395 7.81261 10.8795 7.91928C10.9195 8.02594 10.9395 8.16594 10.9395 8.33928V13.6193Z",
      fill: "currentColor"
    })
  ]),
  instanceManagement: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.52002 3C9.52002 2.44772 9.0723 2 8.52002 2C7.96774 2 7.52002 2.44772 7.52002 3V5.16371C6.65165 5.46369 5.96401 6.15123 5.66388 7.01953L3.5 7.01953C2.94772 7.01953 2.5 7.46725 2.5 8.01953C2.5 8.57182 2.94772 9.01953 3.5 9.01953L5.5 9.01953V11H3.5C2.94772 11 2.5 11.4477 2.5 12C2.5 12.5523 2.94772 13 3.5 13H5.5V14.9805H3.5C2.94772 14.9805 2.5 15.4282 2.5 15.9805C2.5 16.5328 2.94772 16.9805 3.5 16.9805H5.66388C5.96401 17.8488 6.65165 18.5363 7.52002 18.8363V21C7.52002 21.5523 7.96773 22 8.52002 22C9.0723 22 9.52002 21.5523 9.52002 21V19H11.5V21C11.5 21.5523 11.9477 22 12.5 22C13.0523 22 13.5 21.5523 13.5 21V19H13.7709C14.3232 19 14.7709 18.5523 14.7709 18C14.7709 17.4477 14.3232 17 13.7709 17H8.5C7.94772 17 7.5 16.5523 7.5 16V8C7.5 7.44772 7.94772 7 8.5 7H16.5C17.0523 7 17.5 7.44772 17.5 8V13.1831C17.5 13.7354 17.9477 14.1831 18.5 14.1831C19.0523 14.1831 19.5 13.7354 19.5 13.1831V13H21.5C22.0523 13 22.5 12.5523 22.5 12C22.5 11.4477 22.0523 11 21.5 11H19.5V9.02051L21.5 9.02051C22.0523 9.02051 22.5 8.57279 22.5 8.02051C22.5 7.46822 22.0523 7.02051 21.5 7.02051L19.3365 7.02051C19.0365 6.15174 18.3487 5.46381 17.48 5.16371V3C17.48 2.44772 17.0323 2 16.48 2C15.9277 2 15.48 2.44772 15.48 3V5H13.5V3C13.5 2.44772 13.0523 2 12.5 2C11.9477 2 11.5 2.44772 11.5 3V5H9.52002V3ZM9.25 9.85C9.25 9.24249 9.74249 8.75 10.35 8.75H14.65C15.2575 8.75 15.75 9.24249 15.75 9.85V14.15C15.75 14.7575 15.2575 15.25 14.65 15.25H10.35C9.74249 15.25 9.25 14.7575 9.25 14.15V9.85ZM17.9598 14.8388C17.9854 14.6423 18.1554 14.5039 18.3467 14.5039H19.8985C20.0898 14.5039 20.2598 14.6423 20.2855 14.8388L20.4169 15.7554C20.5953 15.8369 20.7628 15.935 20.9207 16.048L21.7836 15.7015C21.8308 15.6826 21.8802 15.6755 21.9236 15.6755C22.0583 15.6755 22.1935 15.7433 22.2668 15.8726L23.0447 17.2183C23.1347 17.3834 23.101 17.5959 22.9467 17.7177L22.946 17.7182L22.215 18.2898C22.2245 18.3832 22.2309 18.48 22.2309 18.582C22.2309 18.684 22.2245 18.7808 22.215 18.8742L22.9467 19.4464C23.101 19.5682 23.1347 19.7806 23.0446 19.9457L23.0422 19.9501L22.2668 21.2914C22.1945 21.4189 22.0606 21.4886 21.9275 21.4886C21.8817 21.4886 21.8373 21.4809 21.7948 21.4667L21.7892 21.4648L20.9197 21.1156C20.7631 21.2261 20.596 21.326 20.417 21.4084L20.2855 22.3253C20.2598 22.5218 20.0898 22.6602 19.8985 22.6602H18.3467C18.1554 22.6602 17.9854 22.5218 17.9598 22.3253L17.8283 21.4086C17.65 21.3272 17.4825 21.229 17.3245 21.1161L16.4616 21.4626C16.4145 21.4815 16.3651 21.4886 16.3217 21.4886C16.1869 21.4886 16.0518 21.4208 15.9785 21.2915L15.2006 19.9458C15.1105 19.7806 15.1443 19.5682 15.2985 19.4464L15.2992 19.4458L16.0303 18.8742C16.0208 18.7796 16.0144 18.6814 16.0144 18.582C16.0144 18.4826 16.0208 18.3845 16.0303 18.2899L15.2992 17.7182L15.2985 17.7177C15.1501 17.6005 15.1013 17.3874 15.2035 17.2133L15.9785 15.8726C16.0508 15.7451 16.1847 15.6755 16.3178 15.6755C16.3635 15.6755 16.408 15.6832 16.4504 15.6973L16.4561 15.6992L17.3256 16.0484C17.4821 15.938 17.6492 15.838 17.8283 15.7557L17.9598 14.8388ZM19.0225 15.6771L18.9702 16.03L18.97 16.0313L18.8921 16.5817L18.3763 16.7909C18.2356 16.8493 18.0904 16.9335 17.9344 17.0495L17.4961 17.3807L16.9886 17.1758L16.6557 17.0421L16.5571 17.2126L16.8402 17.4327L17.2736 17.7736L17.2058 18.3209C17.1942 18.4369 17.1876 18.5162 17.1876 18.582C17.1876 18.648 17.1942 18.7271 17.2058 18.8473L17.2736 19.3943L16.8393 19.7359L16.5571 19.9554L16.6557 20.1258L16.988 19.9924L17.5047 19.7828L17.947 20.123C18.0892 20.2295 18.2296 20.31 18.3798 20.373L18.896 20.5824L19.0237 21.4869H19.2228L19.2751 21.134L19.2753 21.1328L19.3532 20.5824L19.869 20.3732C20.0097 20.3148 20.1548 20.2306 20.3109 20.1145L20.7492 19.7833L21.2567 19.9883L21.5896 20.122L21.6882 19.9515L21.4051 19.7313L20.9717 19.3904L21.0395 18.8431C21.0511 18.7269 21.0577 18.6516 21.0577 18.582C21.0577 18.509 21.0543 18.436 21.0399 18.3243L21.0398 18.3233L20.9717 17.7736L21.4043 17.4333L21.4051 17.4327L21.6852 17.2102L21.5857 17.0382L21.2534 17.1717L20.7367 17.3813L20.2944 17.041C20.1522 16.9346 20.0118 16.854 19.8616 16.791L19.3454 16.5816L19.2177 15.6771H19.0225ZM11.25 10.75V13.25H13.75V10.75H11.25ZM17.3722 18.582C17.3722 17.615 18.1556 16.8316 19.1226 16.8316C20.0897 16.8316 20.8731 17.615 20.8731 18.582C20.8731 19.5491 20.0897 20.3325 19.1226 20.3325C18.1556 20.3325 17.3722 19.5491 17.3722 18.582ZM19.1226 18.0048C18.8056 18.0048 18.5454 18.265 18.5454 18.582C18.5454 18.8991 18.8056 19.1593 19.1226 19.1593C19.4397 19.1593 19.6999 18.8991 19.6999 18.582C19.6999 18.265 19.4397 18.0048 19.1226 18.0048Z",
      fill: "currentColor"
    })
  ]),
  instanceImageManagement: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.52026 3C9.52026 2.44772 9.07255 2 8.52026 2C7.96798 2 7.52026 2.44772 7.52026 3V5.16371C6.65189 5.46369 5.96425 6.15123 5.66412 7.01953L3.54883 7.01953C2.99654 7.01953 2.54883 7.46725 2.54883 8.01953C2.54883 8.57182 2.99654 9.01953 3.54883 9.01953L5.50024 9.01953V11H3.54883C2.99654 11 2.54883 11.4477 2.54883 12C2.54883 12.5523 2.99654 13 3.54883 13H5.50024V14.9805H3.54883C2.99654 14.9805 2.54883 15.4282 2.54883 15.9805C2.54883 16.5328 2.99654 16.9805 3.54883 16.9805H5.66412C5.96425 17.8488 6.65189 18.5363 7.52026 18.8363V21C7.52026 21.5523 7.96798 22 8.52026 22C9.07255 22 9.52026 21.5523 9.52026 21V19H11.5002V21C11.5002 21.5523 11.948 22 12.5002 22C13.0525 22 13.5002 21.5523 13.5002 21V19H15.4802V21C15.4802 21.5523 15.9279 22 16.4802 22C17.0325 22 17.4802 21.5523 17.4802 21V18.8363C18.3486 18.5363 19.0362 17.8488 19.3364 16.9805H21.5488C22.1011 16.9805 22.5488 16.5328 22.5488 15.9805C22.5488 15.4282 22.1011 14.9805 21.5488 14.9805H19.5002V13H21.5488C22.1011 13 22.5488 12.5523 22.5488 12C22.5488 11.4477 22.1011 11 21.5488 11H19.5002V9.02051L21.5488 9.02051C22.1011 9.02051 22.5488 8.57279 22.5488 8.02051C22.5488 7.46822 22.1011 7.02051 21.5488 7.02051L19.3367 7.02051C19.0368 6.15174 18.3489 5.46381 17.4802 5.16371V3C17.4802 2.44772 17.0325 2 16.4802 2C15.9279 2 15.4802 2.44772 15.4802 3V5H13.5002V3C13.5002 2.44772 13.0525 2 12.5002 2C11.948 2 11.5002 2.44772 11.5002 3V5H9.52026V3ZM7.50024 8C7.50024 7.44772 7.94796 7 8.50024 7H16.5002C17.0525 7 17.5002 7.44772 17.5002 8V16C17.5002 16.5523 17.0525 17 16.5002 17H8.50024C7.94796 17 7.50024 16.5523 7.50024 16V8ZM13.7782 9.3792C13.9514 9.38517 14.1091 9.48038 14.1951 9.63084L16.6194 13.8734C16.7079 14.0281 16.7072 14.2183 16.6178 14.3724C16.5283 14.5266 16.3635 14.6215 16.1853 14.6215H8.91235C8.72796 14.6215 8.55853 14.52 8.47152 14.3574C8.38451 14.1948 8.39404 13.9975 8.49633 13.8441L10.3146 11.1168C10.3977 10.9921 10.5323 10.9113 10.6813 10.8965C10.8304 10.8818 10.9782 10.9346 11.0841 11.0406L11.865 11.8214L13.345 9.60156C13.4411 9.45737 13.605 9.37324 13.7782 9.3792Z",
      fill: "currentColor"
    })
  ]),
  instanceDisable: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.52002 2C9.0723 2 9.52002 2.44772 9.52002 3V5H11.5V3C11.5 2.44772 11.9477 2 12.5 2C13.0523 2 13.5 2.44772 13.5 3V5H15.48V3C15.48 2.44772 15.9277 2 16.48 2C17.0323 2 17.48 2.44772 17.48 3V5.16371C18.3487 5.46381 19.0365 6.15174 19.3365 7.02051L21.5 7.02051C22.0523 7.02051 22.5 7.46822 22.5 8.02051C22.5 8.57279 22.0523 9.02051 21.5 9.02051L19.5 9.02051V11H21.5C22.0523 11 22.5 11.4477 22.5 12C22.5 12.5523 22.0523 13 21.5 13H19.5V13.9728C19.5 14.5251 19.0523 14.9728 18.5 14.9728C17.9477 14.9728 17.5 14.5251 17.5 13.9728V8C17.5 7.44772 17.0523 7 16.5 7H8.5C7.94772 7 7.5 7.44772 7.5 8V16C7.5 16.5523 7.94772 17 8.5 17H14.4309C14.9832 17 15.4309 17.4477 15.4309 18C15.4309 18.5523 14.9832 19 14.4309 19H13.5V21C13.5 21.5523 13.0523 22 12.5 22C11.9477 22 11.5 21.5523 11.5 21V19H9.52002V21C9.52002 21.5523 9.0723 22 8.52002 22C7.96773 22 7.52002 21.5523 7.52002 21V18.8363C6.65165 18.5363 5.96401 17.8488 5.66388 16.9805H3.5C2.94772 16.9805 2.5 16.5328 2.5 15.9805C2.5 15.4282 2.94772 14.9805 3.5 14.9805H5.5V13H3.5C2.94772 13 2.5 12.5523 2.5 12C2.5 11.4477 2.94772 11 3.5 11H5.5V9.01953L3.5 9.01953C2.94772 9.01953 2.5 8.57182 2.5 8.01953C2.5 7.46725 2.94772 7.01953 3.5 7.01953L5.66388 7.01953C5.96401 6.15123 6.65165 5.46369 7.52002 5.16371V3C7.52002 2.44772 7.96773 2 8.52002 2ZM21.0541 15.5155C21.4447 15.9061 21.4447 16.5392 21.0541 16.9298L19.852 18.1319L21.054 19.334C21.4446 19.7245 21.4446 20.3577 21.054 20.7482C20.6635 21.1388 20.0304 21.1388 19.6398 20.7482L18.4378 19.5462L17.2358 20.7481C16.8452 21.1387 16.2121 21.1387 15.8216 20.7481C15.431 20.3576 15.431 19.7244 15.8216 19.3339L17.0235 18.1319L15.8215 16.9299C15.4309 16.5393 15.4309 15.9062 15.8215 15.5156C16.212 15.1251 16.8451 15.1251 17.2357 15.5156L18.4378 16.7177L19.6399 15.5155C20.0305 15.125 20.6636 15.125 21.0541 15.5155ZM10.35 8.75C9.74249 8.75 9.25 9.24249 9.25 9.85V14.15C9.25 14.7575 9.74249 15.25 10.35 15.25H14.65C15.2575 15.25 15.75 14.7575 15.75 14.15V9.85C15.75 9.24249 15.2575 8.75 14.65 8.75H10.35ZM11.25 13.25V10.75H13.75V13.25H11.25Z",
      fill: "currentColor"
    })
  ]),
  instance: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.47144 3C9.47144 2.44772 9.02372 2 8.47144 2C7.91915 2 7.47144 2.44772 7.47144 3V5.16371C6.60307 5.46369 5.91542 6.15123 5.61529 7.01953H3.5C2.94772 7.01953 2.5 7.46725 2.5 8.01953C2.5 8.57182 2.94772 9.01953 3.5 9.01953L5.45142 9.01953V11H3.5C2.94772 11 2.5 11.4477 2.5 12C2.5 12.5523 2.94772 13 3.5 13H5.45142V14.9805H3.5C2.94772 14.9805 2.5 15.4282 2.5 15.9805C2.5 16.5328 2.94772 16.9805 3.5 16.9805H5.61529C5.91542 17.8488 6.60307 18.5363 7.47144 18.8363V21C7.47144 21.5523 7.91915 22 8.47144 22C9.02372 22 9.47144 21.5523 9.47144 21V19H11.4514V21C11.4514 21.5523 11.8991 22 12.4514 22C13.0037 22 13.4514 21.5523 13.4514 21V19H15.4314V21C15.4314 21.5523 15.8791 22 16.4314 22C16.9837 22 17.4314 21.5523 17.4314 21V18.8363C18.2998 18.5363 18.9874 17.8488 19.2875 16.9805H21.5C22.0523 16.9805 22.5 16.5328 22.5 15.9805C22.5 15.4282 22.0523 14.9805 21.5 14.9805H19.4514V13H21.5C22.0523 13 22.5 12.5523 22.5 12C22.5 11.4477 22.0523 11 21.5 11H19.4514V9.02051L21.5 9.02051C22.0523 9.02051 22.5 8.57279 22.5 8.02051C22.5 7.46822 22.0523 7.02051 21.5 7.02051L19.2879 7.02051C18.9879 6.15174 18.3001 5.46381 17.4314 5.16371V3C17.4314 2.44772 16.9837 2 16.4314 2C15.8791 2 15.4314 2.44772 15.4314 3V5H13.4514V3C13.4514 2.44772 13.0037 2 12.4514 2C11.8991 2 11.4514 2.44772 11.4514 3V5H9.47144V3ZM9.20142 9.96133C9.20142 9.35382 9.6939 8.86133 10.3014 8.86133H14.6014C15.2089 8.86133 15.7014 9.35382 15.7014 9.96133V14.2613C15.7014 14.8688 15.2089 15.3613 14.6014 15.3613H10.3014C9.6939 15.3613 9.20142 14.8688 9.20142 14.2613V9.96133ZM11.2014 10.8613V13.3613H13.7014V10.8613H11.2014ZM7.45142 8C7.45142 7.44772 7.89913 7 8.45142 7H16.4514C17.0037 7 17.4514 7.44772 17.4514 8V16C17.4514 16.5523 17.0037 17 16.4514 17H8.45142C7.89913 17 7.45142 16.5523 7.45142 16V8Z",
      fill: "currentColor"
    })
  ]),
  mergeRequest: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24023 5C2.24023 3.34315 3.58338 2 5.24023 2H9.24023C9.79252 2 10.2402 2.44772 10.2402 3C10.2402 3.55228 9.79252 4 9.24023 4H5.24023C4.68795 4 4.24023 4.44772 4.24023 5V9C4.24023 9.55228 3.79252 10 3.24023 10C2.68795 10 2.24023 9.55228 2.24023 9V5ZM14.2402 3C14.2402 2.44772 14.6879 2 15.2402 2H19.2402C20.8971 2 22.2402 3.34315 22.2402 5V9C22.2402 9.55228 21.7925 10 21.2402 10C20.688 10 20.2402 9.55228 20.2402 9V5C20.2402 4.44772 19.7925 4 19.2402 4H15.2402C14.6879 4 14.2402 3.55228 14.2402 3ZM3.24023 14C3.79252 14 4.24023 14.4477 4.24023 15V19C4.24023 19.5523 4.68795 20 5.24023 20H9.24023C9.79252 20 10.2402 20.4477 10.2402 21C10.2402 21.5523 9.79252 22 9.24023 22H5.24023C3.58338 22 2.24023 20.6569 2.24023 19V15C2.24023 14.4477 2.68795 14 3.24023 14ZM21.2402 14C21.7925 14 22.2402 14.4477 22.2402 15V19C22.2402 20.6569 20.8971 22 19.2402 22H15.2402C14.6879 22 14.2402 21.5523 14.2402 21C14.2402 20.4477 14.6879 20 15.2402 20H19.2402C19.7925 20 20.2402 19.5523 20.2402 19V15C20.2402 14.4477 20.688 14 21.2402 14Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24023 11.886C2.24025 11.3337 2.68797 10.886 3.24025 10.886L7.7683 10.8861L6.31001 9.42782C5.91948 9.03729 5.91948 8.40413 6.31001 8.01361C6.70053 7.62308 7.3337 7.62308 7.72422 8.0136L10.8897 11.1791C11.0772 11.3666 11.1826 11.6209 11.1826 11.8862C11.1826 12.1514 11.0772 12.4057 10.8897 12.5933L7.49556 15.9874C7.10503 16.3779 6.47187 16.3779 6.08135 15.9874C5.69082 15.5969 5.69082 14.9637 6.08135 14.5732L7.7684 12.8861L3.24021 12.886C2.68793 12.886 2.24022 12.4383 2.24023 11.886Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M22.2402 12.115C22.2402 12.6673 21.7925 13.115 21.2402 13.115L16.7122 13.1149L18.1705 14.5732C18.561 14.9637 18.561 15.5968 18.1705 15.9874C17.7799 16.3779 17.1468 16.3779 16.7562 15.9874L13.5908 12.8219C13.4033 12.6344 13.2979 12.38 13.2979 12.1148C13.2979 11.8496 13.4033 11.5952 13.5908 11.4077L16.9849 8.0136C17.3754 7.62307 18.0086 7.62307 18.3991 8.0136C18.7896 8.40412 18.7896 9.03729 18.3991 9.42781L16.7121 11.1149L21.2403 11.115C21.7925 11.115 22.2402 11.5627 22.2402 12.115Z",
      fill: "currentColor"
    })
  ]),
  vpc: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("g", {
      "clip-path": "url(#clip0_284_11237)"
    }, [
      A("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M11.5259 3.43457C8.93381 3.43457 6.81166 5.56513 6.81166 8.21912C6.81166 8.42303 6.82418 8.62353 6.84837 8.81993C6.8834 9.1043 6.79477 9.39003 6.60496 9.60466C6.50435 9.71843 6.38043 9.80642 6.24352 9.864C6.07631 9.94405 5.88836 9.97688 5.70044 9.95584C5.62003 9.94685 5.53799 9.94219 5.45452 9.94219C4.24309 9.94219 3.24023 10.9397 3.24023 12.196C3.24023 13.357 4.14392 14.2186 5.45452 14.2186C6.0068 14.2186 6.45452 14.6663 6.45452 15.2186C6.45452 15.7709 6.0068 16.2186 5.45452 16.2186C3.21472 16.2186 1.24023 14.6291 1.24023 12.196C1.24023 10.0755 2.78311 8.30205 4.81541 7.99066C4.93454 4.36015 7.88239 1.43457 11.5259 1.43457C13.8073 1.43457 15.8173 2.58383 17.0285 4.33056C17.0988 4.32809 17.1694 4.32684 17.2402 4.32684C20.5654 4.32684 23.2402 7.05222 23.2402 10.3883C23.2402 13.4908 20.9555 15.7432 18.0978 16.157C17.5512 16.2362 17.044 15.8572 16.9648 15.3107C16.8857 14.7641 17.2646 14.2568 17.8112 14.1777C19.7997 13.8898 21.2402 12.3856 21.2402 10.3883C21.2402 8.13367 19.4379 6.32684 17.2402 6.32684C17.0404 6.32684 16.8446 6.34165 16.6536 6.37008C16.242 6.43137 15.8354 6.23132 15.6328 5.86779C14.8199 4.40909 13.2816 3.43457 11.5259 3.43457Z",
        fill: "currentColor"
      }),
      A("path", {
        d: "M17.2071 22.5656C16.7493 22.5656 16.336 22.4634 15.9671 22.2589C15.5982 22.05 15.3093 21.7611 15.1004 21.3923C14.8916 21.0234 14.7871 20.6078 14.7871 20.1456C14.7871 19.6834 14.8916 19.2678 15.1004 18.8989C15.3138 18.53 15.6049 18.2434 15.9738 18.0389C16.3427 17.83 16.756 17.7256 17.2138 17.7256C17.6093 17.7256 17.9671 17.8011 18.2871 17.9523C18.6116 18.0989 18.8782 18.31 19.0871 18.5856L18.3404 19.3056C18.0516 18.9411 17.696 18.7589 17.2738 18.7589C17.0204 18.7589 16.7938 18.8167 16.5938 18.9323C16.3982 19.0478 16.2449 19.2123 16.1338 19.4256C16.0227 19.6345 15.9671 19.8745 15.9671 20.1456C15.9671 20.4167 16.0227 20.6567 16.1338 20.8656C16.2449 21.0745 16.3982 21.2367 16.5938 21.3523C16.7938 21.4678 17.0204 21.5256 17.2738 21.5256C17.7004 21.5256 18.056 21.3434 18.3404 20.9789L19.0871 21.6989C18.8782 21.9789 18.6116 22.1945 18.2871 22.3456C17.9671 22.4923 17.6071 22.5656 17.2071 22.5656Z",
        fill: "currentColor"
      }),
      A("path", {
        d: "M12.5667 17.8125C12.9623 17.8125 13.3067 17.8836 13.6001 18.0258C13.8934 18.1636 14.1201 18.3614 14.2801 18.6192C14.4401 18.8769 14.5201 19.1814 14.5201 19.5325C14.5201 19.8792 14.4401 20.1814 14.2801 20.4392C14.1201 20.6969 13.8934 20.8947 13.6001 21.0325C13.3067 21.1703 12.9623 21.2392 12.5667 21.2392H11.7467V22.4792H10.5801V17.8125H12.5667ZM12.4934 20.2458C12.7734 20.2458 12.9845 20.1836 13.1267 20.0592C13.269 19.9347 13.3401 19.7592 13.3401 19.5325C13.3401 19.3014 13.269 19.1236 13.1267 18.9992C12.9845 18.8703 12.7734 18.8058 12.4934 18.8058H11.7467V20.2458H12.4934Z",
        fill: "currentColor"
      }),
      A("path", {
        d: "M8.44591 22.4792H7.29258L5.39258 17.8125H6.65258L7.91258 20.9725L9.19924 17.8125H10.3526L8.44591 22.4792Z",
        fill: "currentColor"
      })
    ]),
    A("defs", {}, [
      A("clipPath", {
        id: "clip0_284_11237"
      }, [
        A("rect", {
          width: "22",
          height: "21.131",
          fill: "white",
          transform: "translate(1.24023 1.43457)"
        })
      ])
    ])
  ]),
  dataStorage: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M12.2402 2C8.24023 2 4.24023 3.37 4.24023 6V18C4.24023 20.63 8.24023 22 12.2402 22C16.2402 22 20.2402 20.63 20.2402 18V6C20.2402 3.37 16.2402 2 12.2402 2ZM18.2402 18C18.2402 18.71 15.9602 20 12.2402 20C8.52023 20 6.24023 18.71 6.24023 18V14.73C8.1123 15.62 10.1681 16.0551 12.2402 16C14.3123 16.0551 16.3682 15.62 18.2402 14.73V18ZM18.2402 12C18.2402 12.71 15.9602 14 12.2402 14C8.52023 14 6.24023 12.71 6.24023 12V8.73C8.1123 9.61996 10.1681 10.0551 12.2402 10C14.3123 10.0551 16.3682 9.61996 18.2402 8.73V12ZM12.2402 8C8.52023 8 6.24023 6.71 6.24023 6C6.24023 5.29 8.52023 4 12.2402 4C15.9602 4 18.2402 5.29 18.2402 6C18.2402 6.71 15.9602 8 12.2402 8Z",
      fill: "currentColor"
    })
  ]),
  subnet: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M21.2402 17.5602H15.0602C14.9109 17.1408 14.6701 16.7599 14.3553 16.4451C14.0405 16.1303 13.6596 15.8895 13.2402 15.7402L13.2029 14.0321H16.3729C17.4318 14.0669 18.4666 13.7123 19.2816 13.0354C20.0966 12.3585 20.6352 11.4063 20.7953 10.359C20.9555 9.31178 20.7262 8.24215 20.1507 7.35261C19.5753 6.46307 18.6937 5.81535 17.6729 5.53207C17.1381 4.34715 16.233 3.36797 15.0936 2.74189C13.9543 2.11581 12.6425 1.8767 11.3555 2.06055C10.0686 2.2444 8.87617 2.84126 7.95773 3.7613C7.03928 4.68135 6.4445 5.87481 6.2629 7.16207C5.44909 7.39028 4.74535 7.90527 4.28166 8.61192C3.81797 9.31858 3.62566 10.1692 3.74023 11.0065C3.85481 11.8439 4.26855 12.6116 4.90502 13.1677C5.54149 13.7238 6.3577 14.0309 7.2029 14.0321H11.2029L11.2402 15.7402C10.8208 15.8895 10.4399 16.1303 10.1251 16.4451C9.81034 16.7599 9.56955 17.1408 9.42023 17.5602H3.24023C2.97502 17.5602 2.72066 17.6656 2.53313 17.8531C2.34559 18.0406 2.24023 18.295 2.24023 18.5602C2.24023 18.8254 2.34559 19.0798 2.53313 19.2673C2.72066 19.4548 2.97502 19.5602 3.24023 19.5602H9.42023C9.63044 20.1393 10.0139 20.6397 10.5184 20.9934C11.0229 21.347 11.6241 21.5367 12.2402 21.5367C12.8564 21.5367 13.4575 21.347 13.9621 20.9934C14.4666 20.6397 14.85 20.1393 15.0602 19.5602H21.2402C21.5055 19.5602 21.7598 19.4548 21.9473 19.2673C22.1349 19.0798 22.2402 18.8254 22.2402 18.5602C22.2402 18.295 22.1349 18.0406 21.9473 17.8531C21.7598 17.6656 21.5055 17.5602 21.2402 17.5602ZM7.2029 12.0321C6.80507 12.0321 6.42354 11.874 6.14224 11.5927C5.86093 11.3114 5.7029 10.9299 5.7029 10.5321C5.7029 10.1342 5.86093 9.75272 6.14224 9.47141C6.42354 9.19011 6.80507 9.03207 7.2029 9.03207C7.46811 9.03207 7.72247 8.92672 7.91 8.73918C8.09754 8.55164 8.2029 8.29729 8.2029 8.03207C8.20028 7.0826 8.53549 6.16316 9.14859 5.43817C9.76168 4.71318 10.6127 4.22991 11.5494 4.07479C12.4861 3.91967 13.4475 4.10282 14.2615 4.59148C15.0756 5.08014 15.6893 5.84244 15.9929 6.74207C16.0501 6.91391 16.1528 7.067 16.2902 7.18501C16.4276 7.30301 16.5944 7.38149 16.7729 7.41207C17.3142 7.50234 17.8056 7.78234 18.1593 8.20194C18.5129 8.62154 18.7056 9.15333 18.7029 9.70207C18.7003 10.3192 18.4539 10.9103 18.0175 11.3467C17.5812 11.7831 16.99 12.0294 16.3729 12.0321H7.2029ZM12.2402 19.5602C12.0425 19.5602 11.8491 19.5015 11.6847 19.3917C11.5202 19.2818 11.392 19.1256 11.3164 18.9429C11.2407 18.7602 11.2209 18.5591 11.2594 18.3651C11.298 18.1711 11.3933 17.9929 11.5331 17.8531C11.673 17.7132 11.8512 17.618 12.0451 17.5794C12.2391 17.5408 12.4402 17.5606 12.6229 17.6363C12.8056 17.712 12.9618 17.8402 13.0717 18.0046C13.1816 18.1691 13.2402 18.3624 13.2402 18.5602C13.2402 18.8254 13.1349 19.0798 12.9473 19.2673C12.7598 19.4548 12.5055 19.5602 12.2402 19.5602Z",
      fill: "currentColor"
    })
  ]),
  server: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M8.24023 17C8.04245 17 7.84911 17.0586 7.68466 17.1685C7.52022 17.2784 7.39204 17.4346 7.31635 17.6173C7.24067 17.8 7.22086 18.0011 7.25945 18.1951C7.29803 18.3891 7.39328 18.5673 7.53313 18.7071C7.67298 18.847 7.85116 18.9422 8.04514 18.9808C8.23913 19.0194 8.44019 18.9996 8.62292 18.9239C8.80564 18.8482 8.96182 18.72 9.0717 18.5556C9.18159 18.3911 9.24023 18.1978 9.24023 18C9.24023 17.7348 9.13488 17.4804 8.94734 17.2929C8.7598 17.1054 8.50545 17 8.24023 17ZM8.24023 11C8.04245 11 7.84911 11.0586 7.68466 11.1685C7.52022 11.2784 7.39204 11.4346 7.31635 11.6173C7.24067 11.8 7.22086 12.0011 7.25945 12.1951C7.29803 12.3891 7.39328 12.5673 7.53313 12.7071C7.67298 12.847 7.85116 12.9422 8.04514 12.9808C8.23913 13.0194 8.44019 12.9996 8.62292 12.9239C8.80564 12.8482 8.96182 12.72 9.0717 12.5556C9.18159 12.3911 9.24023 12.1978 9.24023 12C9.24023 11.7348 9.13488 11.4804 8.94734 11.2929C8.7598 11.1054 8.50545 11 8.24023 11ZM8.24023 5C8.04245 5 7.84911 5.05865 7.68466 5.16853C7.52022 5.27841 7.39204 5.43459 7.31635 5.61732C7.24067 5.80004 7.22086 6.00111 7.25945 6.19509C7.29803 6.38907 7.39328 6.56725 7.53313 6.70711C7.67298 6.84696 7.85116 6.9422 8.04514 6.98079C8.23913 7.01937 8.44019 6.99957 8.62292 6.92388C8.80564 6.84819 8.96182 6.72002 9.0717 6.55557C9.18159 6.39112 9.24023 6.19778 9.24023 6C9.24023 5.73478 9.13488 5.48043 8.94734 5.29289C8.7598 5.10536 8.50545 5 8.24023 5ZM20.2402 5C20.2402 4.20435 19.9242 3.44129 19.3616 2.87868C18.7989 2.31607 18.0359 2 17.2402 2H7.24023C6.44458 2 5.68152 2.31607 5.11891 2.87868C4.5563 3.44129 4.24023 4.20435 4.24023 5V7C4.24464 7.74005 4.52245 8.45236 5.02023 9C4.52245 9.54764 4.24464 10.2599 4.24023 11V13C4.24464 13.7401 4.52245 14.4524 5.02023 15C4.52245 15.5476 4.24464 16.2599 4.24023 17V19C4.24023 19.7956 4.5563 20.5587 5.11891 21.1213C5.68152 21.6839 6.44458 22 7.24023 22H17.2402C18.0359 22 18.7989 21.6839 19.3616 21.1213C19.9242 20.5587 20.2402 19.7956 20.2402 19V17C20.2358 16.2599 19.958 15.5476 19.4602 15C19.958 14.4524 20.2358 13.7401 20.2402 13V11C20.2358 10.2599 19.958 9.54764 19.4602 9C19.958 8.45236 20.2358 7.74005 20.2402 7V5ZM18.2402 19C18.2402 19.2652 18.1349 19.5196 17.9473 19.7071C17.7598 19.8946 17.5055 20 17.2402 20H7.24023C6.97502 20 6.72066 19.8946 6.53313 19.7071C6.34559 19.5196 6.24023 19.2652 6.24023 19V17C6.24023 16.7348 6.34559 16.4804 6.53313 16.2929C6.72066 16.1054 6.97502 16 7.24023 16H17.2402C17.5055 16 17.7598 16.1054 17.9473 16.2929C18.1349 16.4804 18.2402 16.7348 18.2402 17V19ZM18.2402 13C18.2402 13.2652 18.1349 13.5196 17.9473 13.7071C17.7598 13.8946 17.5055 14 17.2402 14H7.24023C6.97502 14 6.72066 13.8946 6.53313 13.7071C6.34559 13.5196 6.24023 13.2652 6.24023 13V11C6.24023 10.7348 6.34559 10.4804 6.53313 10.2929C6.72066 10.1054 6.97502 10 7.24023 10H17.2402C17.5055 10 17.7598 10.1054 17.9473 10.2929C18.1349 10.4804 18.2402 10.7348 18.2402 11V13ZM18.2402 7C18.2402 7.26522 18.1349 7.51957 17.9473 7.70711C17.7598 7.89464 17.5055 8 17.2402 8H7.24023C6.97502 8 6.72066 7.89464 6.53313 7.70711C6.34559 7.51957 6.24023 7.26522 6.24023 7V5C6.24023 4.73478 6.34559 4.48043 6.53313 4.29289C6.72066 4.10536 6.97502 4 7.24023 4H17.2402C17.5055 4 17.7598 4.10536 17.9473 4.29289C18.1349 4.48043 18.2402 4.73478 18.2402 5V7Z",
      fill: "currentColor"
    })
  ]),
  resourceConfiguration: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24023 14.3078C2.24023 13.3226 3.04344 12.5386 4.0161 12.5386H7.11959C7.88425 12.5386 8.54418 13.0231 8.79146 13.709L9.02011 13.5957L9.46425 14.4917L9.02011 13.5957C9.91254 13.1533 10.8961 12.9232 11.8931 12.9232H12.2113C12.7821 12.9232 13.3505 12.9986 13.9013 13.1476L15.5321 13.5886C16.4065 13.825 16.9662 14.5301 17.0996 15.3127L17.9442 14.4754C18.796 13.6308 20.1268 13.5012 21.1266 14.1621C22.2862 14.9285 22.6455 16.5488 21.7044 17.7008C20.8686 18.7239 19.4592 20.2854 18.0294 20.9772C16.6559 21.6417 15.9065 21.7021 14.7492 21.7954C14.5741 21.8095 14.3897 21.8244 14.1924 21.8422C13.1359 21.9376 11.9161 21.7465 10.9244 21.5911C10.8648 21.5817 10.806 21.5725 10.7481 21.5635C10.2086 21.4795 9.74028 21.4099 9.3403 21.3816C9.15372 21.3684 9.00558 21.3664 8.88999 21.3711C8.81808 22.2894 8.04564 23.0001 7.11959 23.0001H4.0161C3.04344 23.0001 2.24023 22.2161 2.24023 21.2309V14.3078ZM8.89546 19.3698C9.09648 19.3653 9.29458 19.3734 9.48136 19.3866C9.97847 19.4218 10.5285 19.5052 11.0558 19.5873C11.0783 19.5908 11.1008 19.5943 11.1233 19.5978C12.21 19.7672 13.2094 19.9229 14.0125 19.8503C14.2331 19.8304 14.4301 19.8142 14.6092 19.7995C15.709 19.709 16.13 19.6744 17.1583 19.1769C18.1458 18.6991 19.31 17.4705 20.1555 16.4355L20.8487 17.0018L20.1555 16.4355C20.285 16.277 20.2796 15.9996 20.0238 15.8306C19.8122 15.6907 19.5299 15.7195 19.3523 15.8956L17.8158 17.419C17.1911 18.0383 16.3457 18.3847 15.4659 18.3847H14.8788C14.8785 18.3847 14.8782 18.3847 14.8779 18.3847H12.9386C12.3863 18.3847 11.9386 17.937 11.9386 17.3847C11.9386 16.8324 12.3863 16.3847 12.9386 16.3847H14.4666L15.0838 15.7728L15.6744 16.3685L15.0838 15.7728C15.1623 15.695 15.1365 15.5534 15.0101 15.5192L13.3793 15.0783C12.9987 14.9754 12.6059 14.9232 12.2113 14.9232H11.8931C11.2038 14.9232 10.5242 15.0823 9.9084 15.3876L9.46597 14.4951L9.9084 15.3876L8.89546 15.8897V19.3698ZM4.24023 14.5386V21.0001H6.89546V14.5386H4.24023Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M15.5065 3.16553C14.2723 3.16553 13.2083 3.90828 12.7424 4.97577C12.6243 5.24645 12.3925 5.45106 12.1093 5.53475C11.336 5.76328 10.7734 6.47983 10.7734 7.32526C10.7734 8.35606 11.609 9.19177 12.64 9.19177H18.9463C19.6604 9.19177 20.2395 8.61269 20.2395 7.89856C20.2395 7.29112 19.8194 6.77895 19.252 6.64169C18.8483 6.54404 18.5471 6.2071 18.495 5.7951C18.3077 4.31269 17.0399 3.16553 15.5065 3.16553ZM11.1061 3.77497C11.9569 2.22142 13.6078 1.16553 15.5065 1.16553C17.8418 1.16553 19.8038 2.76233 20.3607 4.92435C21.4713 5.45341 22.2395 6.58528 22.2395 7.89856C22.2395 9.71726 20.765 11.1918 18.9463 11.1918H12.64C10.5043 11.1918 8.77344 9.4605 8.77344 7.32526C8.77344 5.73397 9.73397 4.36855 11.1061 3.77497Z",
      fill: "currentColor"
    })
  ]),
  outboundRule: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.81452 5.40952V18.8232C4.61975 18.1016 7.31566 17.6992 10.2754 18.8873V5.4603C10.2754 5.46006 10.2754 5.45982 10.2754 5.45957C7.04155 3.82559 4.16473 4.64531 2.81452 5.40952ZM12.2754 5.57995V20.4864C12.2754 20.8439 12.0846 21.1742 11.7749 21.3527C11.4652 21.5313 11.0837 21.5309 10.7744 21.3518C6.95842 19.1426 3.54786 20.4554 2.40588 21.2928C2.102 21.5157 1.69865 21.5487 1.3625 21.3784C1.02636 21.2081 0.81452 20.8632 0.81452 20.4864V4.90378C0.81452 4.89792 0.814571 4.89207 0.814671 4.88624C0.808107 4.57142 0.949947 4.25847 1.22316 4.05812C2.81711 2.88922 6.89241 1.39852 11.3811 3.77982C13.2542 2.64468 17.2253 1.51529 21.5156 3.9991C21.8846 4.21278 22.066 4.62628 22.002 5.02367C22.0103 5.07525 22.0145 5.12814 22.0145 5.18204V12.8342C22.0145 13.3865 21.5668 13.8342 21.0145 13.8342C20.4622 13.8342 20.0145 13.3865 20.0145 12.8342V5.45957C16.5374 3.70269 13.4731 4.7825 12.2754 5.57995Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.4389 15.0566C16.4389 14.5044 15.9912 14.0566 15.4389 14.0566C13.9075 14.0566 12.666 15.2981 12.666 16.8295C12.666 18.3609 13.9075 19.6024 15.4389 19.6024H20.2599L19.5146 20.3512C19.1251 20.7427 19.1266 21.3758 19.518 21.7654C19.9095 22.155 20.5426 22.1535 20.9322 21.7621L23.3748 19.3078C23.7629 18.9178 23.7631 18.2875 23.3752 17.8973L21.043 15.5516C20.6536 15.1599 20.0205 15.1581 19.6288 15.5475C19.2371 15.9369 19.2353 16.57 19.6247 16.9617L20.2617 17.6024H15.4389C15.012 17.6024 14.666 17.2563 14.666 16.8295C14.666 16.4027 15.012 16.0566 15.4389 16.0566C15.9912 16.0566 16.4389 15.6089 16.4389 15.0566Z",
      fill: "currentColor"
    })
  ]),
  inboundRule: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.81452 5.40952V18.8232C4.61975 18.1016 7.31566 17.6992 10.2754 18.8873V5.4603C10.2754 5.46006 10.2754 5.45982 10.2754 5.45957C7.04155 3.82559 4.16473 4.64531 2.81452 5.40952ZM12.2754 5.57995V20.4864C12.2754 20.8439 12.0846 21.1742 11.7749 21.3527C11.4652 21.5313 11.0837 21.5309 10.7744 21.3518C6.95842 19.1426 3.54786 20.4554 2.40588 21.2928C2.102 21.5157 1.69865 21.5487 1.3625 21.3784C1.02636 21.2081 0.81452 20.8632 0.81452 20.4864V4.90378C0.81452 4.89792 0.814571 4.89207 0.814671 4.88624C0.808107 4.57142 0.949947 4.25847 1.22316 4.05812C2.81711 2.88922 6.89241 1.39852 11.3811 3.77982C13.2542 2.64468 17.2253 1.51529 21.5156 3.9991C21.8846 4.21278 22.066 4.62628 22.002 5.02367C22.0103 5.07525 22.0145 5.12814 22.0145 5.18204V12.8342C22.0145 13.3865 21.5668 13.8342 21.0145 13.8342C20.4622 13.8342 20.0145 13.3865 20.0145 12.8342V5.45957C16.5374 3.70269 13.4731 4.7825 12.2754 5.57995Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M19.8931 15.0566C19.8931 14.5044 20.3409 14.0566 20.8931 14.0566C22.4246 14.0566 23.666 15.2981 23.666 16.8295C23.666 18.3609 22.4246 19.6024 20.8931 19.6024H16.0721L16.8174 20.3512C17.207 20.7427 17.2055 21.3758 16.814 21.7654C16.4226 22.155 15.7894 22.1535 15.3998 21.7621L12.9572 19.3078C12.5691 18.9178 12.5689 18.2875 12.9569 17.8973L15.289 15.5516C15.6784 15.1599 16.3116 15.1581 16.7032 15.5475C17.0949 15.9369 17.0967 16.57 16.7073 16.9617L16.0704 17.6024H20.8931C21.32 17.6024 21.666 17.2563 21.666 16.8295C21.666 16.4027 21.32 16.0566 20.8931 16.0566C20.3409 16.0566 19.8931 15.6089 19.8931 15.0566Z",
      fill: "currentColor"
    })
  ]),
  securityGroupDelete: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.7683 1.91112C17.0384 1.42936 17.6478 1.25773 18.1296 1.52777C19.8045 2.4666 21.0406 4.06418 21.0406 6.00008C21.0406 7.93598 19.8045 9.53356 18.1296 10.4724C17.6478 10.7424 17.0384 10.5708 16.7683 10.089C16.4983 9.60728 16.6699 8.99782 17.1517 8.72777C18.3893 8.03404 19.0406 7.01443 19.0406 6.00008C19.0406 4.98573 18.3893 3.96612 17.1517 3.27239C16.6699 3.00234 16.4983 2.39289 16.7683 1.91112ZM11.0406 3.40008C9.60468 3.40008 8.44062 4.56414 8.44062 6.00008C8.44062 7.43602 9.60468 8.60008 11.0406 8.60008C12.4766 8.60008 13.6406 7.43602 13.6406 6.00008C13.6406 4.56414 12.4766 3.40008 11.0406 3.40008ZM6.44062 6.00008C6.44062 3.45957 8.50011 1.40008 11.0406 1.40008C13.5811 1.40008 15.6406 3.45957 15.6406 6.00008C15.6406 8.54059 13.5811 10.6001 11.0406 10.6001C8.50011 10.6001 6.44062 8.54059 6.44062 6.00008ZM1.64103 17.9996C1.64132 15.4593 3.70072 13.4001 6.24103 13.4001H12.8406C13.3929 13.4001 13.8406 13.8478 13.8406 14.4001C13.8406 14.9524 13.3929 15.4001 12.8406 15.4001H6.24103C4.8052 15.4001 3.64119 16.564 3.64103 17.9998L3.64062 21.6002C3.64056 22.1525 3.1928 22.6001 2.64051 22.6001C2.08823 22.6 1.64056 22.1523 1.64063 21.6L1.64103 17.9996Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M20.7463 15.7382C21.1368 16.1287 21.1368 16.7619 20.7463 17.1524L19.5441 18.3546L20.7462 19.5567C21.1367 19.9472 21.1367 20.5804 20.7462 20.9709C20.3557 21.3614 19.7225 21.3614 19.332 20.9709L18.1299 19.7688L16.9279 20.9708C16.5374 21.3613 15.9042 21.3613 15.5137 20.9708C15.1232 20.5803 15.1232 19.9471 15.5137 19.5566L16.7157 18.3546L15.5136 17.1525C15.1231 16.762 15.1231 16.1288 15.5136 15.7383C15.9041 15.3478 16.5373 15.3478 16.9278 15.7383L18.1299 16.9404L19.3321 15.7382C19.7226 15.3477 20.3558 15.3477 20.7463 15.7382Z",
      fill: "currentColor"
    })
  ]),
  securityGroupCreate: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.7683 1.91112C17.0384 1.42936 17.6478 1.25773 18.1296 1.52777C19.8045 2.4666 21.0406 4.06418 21.0406 6.00008C21.0406 7.93598 19.8045 9.53356 18.1296 10.4724C17.6478 10.7424 17.0384 10.5708 16.7683 10.089C16.4983 9.60728 16.6699 8.99782 17.1517 8.72777C18.3893 8.03404 19.0406 7.01443 19.0406 6.00008C19.0406 4.98573 18.3893 3.96612 17.1517 3.27239C16.6699 3.00234 16.4983 2.39289 16.7683 1.91112ZM11.0406 3.40008C9.60468 3.40008 8.44062 4.56414 8.44062 6.00008C8.44062 7.43602 9.60468 8.60008 11.0406 8.60008C12.4766 8.60008 13.6406 7.43602 13.6406 6.00008C13.6406 4.56414 12.4766 3.40008 11.0406 3.40008ZM6.44062 6.00008C6.44062 3.45957 8.50011 1.40008 11.0406 1.40008C13.5811 1.40008 15.6406 3.45957 15.6406 6.00008C15.6406 8.54059 13.5811 10.6001 11.0406 10.6001C8.50011 10.6001 6.44062 8.54059 6.44062 6.00008ZM1.64103 17.9996C1.64132 15.4593 3.70072 13.4001 6.24103 13.4001H12.8406C13.3929 13.4001 13.8406 13.8478 13.8406 14.4001C13.8406 14.9524 13.3929 15.4001 12.8406 15.4001H6.24103C4.8052 15.4001 3.64119 16.564 3.64103 17.9998L3.64062 21.6002C3.64056 22.1525 3.1928 22.6001 2.64051 22.6001C2.08823 22.6 1.64056 22.1523 1.64063 21.6L1.64103 17.9996Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M19.9635 14.7379C19.2316 14.3719 18.37 14.3719 17.638 14.7379L16.8008 15.1565V17.8835C16.8008 17.9425 16.8452 18.1848 17.2932 18.6457C17.6358 18.9982 18.1362 19.3978 18.8058 19.8485C19.4962 19.4004 19.9904 19.0463 20.3301 18.7177C20.7251 18.3357 20.8008 18.0946 20.8008 17.8835V15.1565L19.9635 14.7379ZM22.8008 14.5385V17.8835C22.8008 18.8273 22.3426 19.5536 21.7207 20.1552C21.126 20.7304 20.287 21.2826 19.3347 21.884C19.0086 22.09 18.593 22.09 18.2668 21.884C17.2753 21.2578 16.4485 20.6461 15.8591 20.0397C15.2902 19.4544 14.8008 18.7294 14.8008 17.8835V14.5385C14.8008 14.1597 15.0148 13.8134 15.3536 13.644L16.7436 12.949C18.0386 12.3015 19.5629 12.3015 20.858 12.949L22.248 13.644C22.5868 13.8134 22.8008 14.1597 22.8008 14.5385Z",
      fill: "currentColor"
    })
  ]),
  roleDelete: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.44062 6.00039C8.44062 4.56445 9.60468 3.40039 11.0406 3.40039C12.4766 3.40039 13.6406 4.56445 13.6406 6.00039C13.6406 7.43633 12.4766 8.60039 11.0406 8.60039C9.60468 8.60039 8.44062 7.43633 8.44062 6.00039ZM11.0406 1.40039C8.50011 1.40039 6.44062 3.45988 6.44062 6.00039C6.44062 8.5409 8.50011 10.6004 11.0406 10.6004C13.5811 10.6004 15.6406 8.5409 15.6406 6.00039C15.6406 3.45988 13.5811 1.40039 11.0406 1.40039ZM6.24103 13.4004C3.70072 13.4004 1.64132 15.4596 1.64103 17.9999L1.64063 21.6003C1.64056 22.1526 2.08823 22.6003 2.64051 22.6004C3.1928 22.6005 3.64056 22.1528 3.64062 21.6005L3.64103 18.0001C3.64119 16.5643 4.8052 15.4004 6.24103 15.4004H13.4405C13.9928 15.4004 14.4405 14.9527 14.4405 14.4004C14.4405 13.8481 13.9928 13.4004 13.4405 13.4004H6.24103ZM20.7477 17.1573C21.1383 16.7668 21.1383 16.1336 20.7478 15.7431C20.3572 15.3526 19.7241 15.3526 19.3335 15.7431L18.1314 16.9453L16.9293 15.7432C16.5388 15.3527 15.9056 15.3527 15.5151 15.7432C15.1245 16.1337 15.1245 16.7669 15.5151 17.1574L16.7171 18.3595L15.5152 19.5615C15.1246 19.952 15.1246 20.5852 15.5152 20.9757C15.9057 21.3662 16.5388 21.3662 16.9294 20.9757L18.1314 19.7737L19.3334 20.9758C19.724 21.3663 20.3571 21.3663 20.7477 20.9758C21.1382 20.5853 21.1382 19.9521 20.7477 19.5616L19.5456 18.3595L20.7477 17.1573Z",
      fill: "currentColor"
    })
  ]),
  roleEdit: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.44062 6.00039C8.44062 4.56445 9.60468 3.40039 11.0406 3.40039C12.4766 3.40039 13.6406 4.56445 13.6406 6.00039C13.6406 7.43633 12.4766 8.60039 11.0406 8.60039C9.60468 8.60039 8.44062 7.43633 8.44062 6.00039ZM11.0406 1.40039C8.50011 1.40039 6.44062 3.45988 6.44062 6.00039C6.44062 8.5409 8.50011 10.6004 11.0406 10.6004C13.5811 10.6004 15.6406 8.5409 15.6406 6.00039C15.6406 3.45988 13.5811 1.40039 11.0406 1.40039ZM6.24103 13.4004C3.70072 13.4004 1.64132 15.4596 1.64103 17.9999L1.64063 21.6003C1.64056 22.1526 2.08823 22.6003 2.64051 22.6004C3.1928 22.6005 3.64056 22.1528 3.64062 21.6005L3.64103 18.0001C3.64119 16.5643 4.8052 15.4004 6.24103 15.4004H13.4405C13.9928 15.4004 14.4405 14.9527 14.4405 14.4004C14.4405 13.8481 13.9928 13.4004 13.4405 13.4004H6.24103ZM19.6869 12.4081C19.2964 12.0176 18.6633 12.0176 18.2727 12.4081L13.1816 17.4993C12.994 17.6868 12.8887 17.9412 12.8887 18.2064V21.6005C12.8887 22.1528 13.3364 22.6005 13.8887 22.6005H17.2828C17.548 22.6005 17.8024 22.4952 17.9899 22.3076L23.0811 17.2165C23.2686 17.0289 23.374 16.7746 23.374 16.5093C23.374 16.2441 23.2686 15.9898 23.0811 15.8022L19.6869 12.4081ZM14.8887 18.6206L18.9798 14.5294L20.9597 16.5093L16.8686 20.6005H14.8887V18.6206Z",
      fill: "currentColor"
    })
  ]),
  roleAssign: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.0406 3.3999C9.60468 3.3999 8.44062 4.56396 8.44062 5.9999C8.44062 7.43584 9.60468 8.5999 11.0406 8.5999C12.4766 8.5999 13.6406 7.43584 13.6406 5.9999C13.6406 4.56396 12.4766 3.3999 11.0406 3.3999ZM6.44062 5.9999C6.44062 3.45939 8.50011 1.3999 11.0406 1.3999C13.5811 1.3999 15.6406 3.45939 15.6406 5.9999C15.6406 8.54041 13.5811 10.5999 11.0406 10.5999C8.50011 10.5999 6.44062 8.54041 6.44062 5.9999ZM1.64103 17.9994C1.64132 15.4591 3.70072 13.3999 6.24103 13.3999H13.4405C13.9928 13.3999 14.4405 13.8476 14.4405 14.3999C14.4405 14.9522 13.9928 15.3999 13.4405 15.3999H6.24103C4.8052 15.3999 3.64119 16.5638 3.64103 17.9996L3.64062 21.6C3.64056 22.1523 3.1928 22.6 2.64051 22.5999C2.08823 22.5998 1.64056 22.1521 1.64063 21.5998L1.64103 17.9994ZM21.1335 13.6928C21.524 13.3023 22.1572 13.3023 22.5477 13.6928C22.9383 14.0833 22.9383 14.7165 22.5477 15.107L18.3477 19.307C17.9572 19.6975 17.324 19.6975 16.9335 19.307L15.7335 18.107C15.343 17.7165 15.343 17.0833 15.7335 16.6928C16.124 16.3023 16.7572 16.3023 17.1477 16.6928L17.6406 17.1857L21.1335 13.6928Z",
      fill: "currentColor"
    })
  ]),
  companyInvite: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M14.1063 20.6006C14.6667 20.6006 15.2832 20.0678 15.2832 19.2006L15.2832 4.80057C15.2832 3.93335 14.6667 3.40057 14.1063 3.40057L5.39852 3.40057C4.83807 3.40057 4.22158 3.93335 4.22158 4.80057L4.22158 19.2006C4.22158 20.0678 4.83807 20.6006 5.39852 20.6006L5.50699 20.6006C5.49388 20.5359 5.48699 20.4691 5.48699 20.4006L5.48699 15.5313C5.48699 15.2661 5.59234 15.0117 5.77988 14.8242C5.96742 14.6367 6.22177 14.5313 6.48699 14.5313L13.0178 14.5313C13.5701 14.5313 14.0178 14.979 14.0178 15.5313L14.0178 20.4006C14.0178 20.4691 14.0109 20.536 13.9978 20.6006L14.1063 20.6006ZM12.0378 20.6006C12.0247 20.536 12.0178 20.4691 12.0178 20.4006L12.0178 16.5313L7.48699 16.5313L7.48699 20.4006C7.48699 20.4691 7.4801 20.536 7.46698 20.6006L12.0378 20.6006ZM17.2832 19.2006C17.2832 20.9843 15.9504 22.6006 14.1063 22.6006L5.39852 22.6006C3.55439 22.6006 2.22158 20.9843 2.22158 19.2006L2.22158 4.80057C2.22159 3.01682 3.5544 1.40057 5.39852 1.40057L14.1063 1.40057C15.9504 1.40057 17.2832 3.01683 17.2832 4.80057L17.2832 19.2006Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M10.5684 15.1064L10.5684 21.2559L9.06836 21.2559L9.06836 15.1064L10.5684 15.1064Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.93555 6.45605C4.93555 5.90377 5.38326 5.45605 5.93555 5.45605H6.84036C7.39265 5.45605 7.84036 5.90377 7.84036 6.45605C7.84036 7.00834 7.39265 7.45605 6.84036 7.45605H5.93555C5.38326 7.45605 4.93555 7.00834 4.93555 6.45605Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.93555 10.418C4.93555 9.86568 5.38326 9.41797 5.93555 9.41797H6.84036C7.39265 9.41797 7.84036 9.86568 7.84036 10.418C7.84036 10.9703 7.39265 11.418 6.84036 11.418H5.93555C5.38326 11.418 4.93555 10.9703 4.93555 10.418Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.29883 6.45605C8.29883 5.90377 8.74654 5.45605 9.29883 5.45605H10.2036C10.7559 5.45605 11.2036 5.90377 11.2036 6.45605C11.2036 7.00834 10.7559 7.45605 10.2036 7.45605H9.29883C8.74654 7.45605 8.29883 7.00834 8.29883 6.45605Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.29883 10.418C8.29883 9.86568 8.74654 9.41797 9.29883 9.41797H10.2036C10.7559 9.41797 11.2036 9.86568 11.2036 10.418C11.2036 10.9703 10.7559 11.418 10.2036 11.418H9.29883C8.74654 11.418 8.29883 10.9703 8.29883 10.418Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.6621 6.45605C11.6621 5.90377 12.1098 5.45605 12.6621 5.45605H13.5669C14.1192 5.45605 14.5669 5.90377 14.5669 6.45605C14.5669 7.00834 14.1192 7.45605 13.5669 7.45605H12.6621C12.1098 7.45605 11.6621 7.00834 11.6621 6.45605Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.6621 10.418C11.6621 9.86568 12.1098 9.41797 12.6621 9.41797H13.5669C14.1192 9.41797 14.5669 9.86568 14.5669 10.418C14.5669 10.9703 14.1192 11.418 13.5669 11.418H12.6621C12.1098 11.418 11.6621 10.9703 11.6621 10.418Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M22.2597 19.8554C22.2597 21.2031 21.3088 22.6006 19.7907 22.6006L14.8009 22.6006C14.2486 22.6006 13.8009 22.1529 13.8009 21.6006C13.8009 21.0483 14.2486 20.6006 14.8009 20.6006L19.7907 20.6006C19.8585 20.6006 19.9592 20.5705 20.0644 20.4455C20.1714 20.3183 20.2597 20.1129 20.2597 19.8554L20.2598 9.38412C20.2598 9.12662 20.1715 8.92119 20.0645 8.79403C19.9592 8.669 19.8586 8.6389 19.7908 8.6389L17.3352 8.6389C16.7829 8.6389 16.3352 8.19119 16.3352 7.6389C16.3352 7.08662 16.7829 6.6389 17.3352 6.6389L19.7908 6.6389C21.3089 6.63891 22.2598 8.03638 22.2598 9.38413L22.2597 19.8554Z",
      fill: "currentColor"
    })
  ]),
  private: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.93327 3.79289C5.3238 3.40237 5.95696 3.40237 6.34749 3.79289L21.3475 18.7929C21.738 19.1834 21.738 19.8166 21.3475 20.2071C20.957 20.5976 20.3238 20.5976 19.9333 20.2071L18.0185 18.2923C16.5082 19.2173 14.5948 19.8514 12.224 19.8126C8.22252 19.7472 5.57345 17.8927 3.94702 16.0641C3.13931 15.156 2.58219 14.2542 2.2259 13.5781C2.04728 13.2391 1.91774 12.9543 1.8314 12.75C1.7882 12.6477 1.7557 12.5654 1.7332 12.5063C1.72194 12.4768 1.71317 12.453 1.70681 12.4354L1.69904 12.4137L1.69648 12.4064L1.69553 12.4036L1.69514 12.4025C1.69496 12.402 1.6948 12.4015 2.64038 12.0761C1.68608 11.7773 1.68618 11.777 1.68629 11.7766L1.68707 11.7741L1.68846 11.7698L1.69247 11.7573L1.70549 11.7181C1.71641 11.6857 1.73191 11.6409 1.75223 11.5851C1.79285 11.4734 1.85288 11.3169 1.93447 11.125C2.09739 10.7417 2.34775 10.2137 2.70335 9.61782C3.34841 8.53686 4.35672 7.20429 5.84356 6.1174L4.93327 5.20711C4.54275 4.81658 4.54275 4.18342 4.93327 3.79289ZM7.27882 7.55266C5.93202 8.46354 5.01142 9.65297 4.4208 10.6427C4.11917 11.1482 3.90868 11.5931 3.77507 11.9074C3.75161 11.9626 3.73057 12.0136 3.71187 12.0602C3.77831 12.2117 3.87184 12.4115 3.99525 12.6457C4.29473 13.214 4.76453 13.9739 5.44144 14.7349C6.78424 16.2447 8.93516 17.7585 12.2567 17.8129C14.0065 17.8415 15.4179 17.434 16.5537 16.8275L14.3378 14.6116C13.7583 15.0575 13.0284 15.3217 12.2404 15.3217C10.3885 15.3217 8.84038 13.8539 8.84038 11.9863C8.84038 11.1849 9.12947 10.4506 9.60496 9.87879L7.27882 7.55266ZM11.0341 11.308C10.9098 11.5082 10.8404 11.7398 10.8404 11.9863C10.8404 12.6982 11.4413 13.3217 12.2404 13.3217C12.4782 13.3217 12.7 13.2657 12.8939 13.1677L11.0341 11.308ZM3.58508 11.7482C3.58493 11.7478 3.58496 11.7478 3.58508 11.7482V11.7482ZM2.64038 12.0761L1.68629 11.7766L1.58789 12.0908L1.6948 12.4015L2.64038 12.0761ZM12.2404 6.1C11.8594 6.1 11.4954 6.12012 11.1479 6.1577C10.5988 6.21707 10.1055 5.82008 10.0462 5.27099C9.9868 4.72191 10.3838 4.22866 10.9329 4.16929C11.3531 4.12385 11.7888 4.1 12.2404 4.1C16.3096 4.1 18.97 6.03063 20.5851 7.9428C21.3867 8.89184 21.9337 9.83744 22.281 10.5459C22.4552 10.9011 22.5807 11.1998 22.664 11.4138C22.7056 11.5208 22.7368 11.6069 22.7583 11.6686C22.7691 11.6995 22.7774 11.7242 22.7834 11.7425L22.7908 11.7649L22.7931 11.7724L22.794 11.7752L22.7944 11.7763C22.7945 11.7768 22.7947 11.7773 21.8404 12.0761C22.7894 12.3913 22.7894 12.3915 22.7893 12.3917L22.7882 12.3948L22.7866 12.3998L22.7817 12.4141C22.7777 12.4256 22.7723 12.4409 22.7655 12.4599C22.7519 12.4978 22.7325 12.5502 22.7071 12.6157C22.6562 12.7465 22.5808 12.9297 22.4782 13.1528C22.2734 13.5981 21.9583 14.2071 21.5107 14.8771C21.2039 15.3364 20.583 15.46 20.1237 15.1532C19.6645 14.8464 19.5409 14.2254 19.8477 13.7662C20.2263 13.1994 20.4917 12.6856 20.661 12.3174C20.7042 12.2235 20.7409 12.1395 20.7716 12.0668C20.7062 11.9039 20.612 11.6847 20.4853 11.4264C20.1913 10.8268 19.7287 10.0283 19.0572 9.23333C17.7261 7.65743 15.5866 6.1 12.2404 6.1ZM21.8404 12.0761L22.7893 12.3917L22.8911 12.0851L22.7947 11.7773L21.8404 12.0761ZM20.8868 12.3772C20.8869 12.3776 20.8869 12.3777 20.8868 12.3772V12.3772Z",
      fill: "currentColor"
    })
  ]),
  public: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.71187 12.1027C3.77709 11.9405 3.8705 11.7238 3.99547 11.4689C4.28946 10.8693 4.75209 10.0709 5.42357 9.27591C6.75464 7.70001 8.8942 6.14258 12.2404 6.14258C15.5866 6.14258 17.7261 7.70001 19.0572 9.27591C19.7287 10.0709 20.1913 10.8693 20.4853 11.4689C20.612 11.7273 20.7062 11.9465 20.7716 12.1094C20.7044 12.2686 20.6082 12.4819 20.4799 12.7327C20.1796 13.3197 19.7095 14.1002 19.0335 14.8739C17.6935 16.4076 15.5568 17.9094 12.2567 17.8554C8.93516 17.8011 6.78424 16.2872 5.44144 14.7775C4.76453 14.0165 4.29473 13.2566 3.99525 12.6883C3.87184 12.4541 3.77831 12.2542 3.71187 12.1027ZM21.8404 12.1187C22.7947 11.8199 22.7944 11.8189 22.7944 11.8189L22.794 11.8177L22.7931 11.815L22.7908 11.8075L22.7834 11.7851C22.7774 11.7668 22.7691 11.742 22.7583 11.7112C22.7368 11.6495 22.7056 11.5634 22.664 11.4563C22.5807 11.2424 22.4552 10.9437 22.281 10.5884C21.9337 9.88002 21.3867 8.93442 20.5851 7.98537C18.97 6.07321 16.3096 4.14258 12.2404 4.14258C8.17118 4.14258 5.51074 6.07321 3.89566 7.98537C3.09405 8.93442 2.54707 9.88002 2.19971 10.5884C2.02552 10.9437 1.90003 11.2424 1.81679 11.4563C1.77514 11.5634 1.74395 11.6495 1.72245 11.7112C1.7117 11.742 1.70336 11.7668 1.69733 11.7851L1.69001 11.8075L1.68763 11.815L1.68675 11.8177L1.68639 11.8189C1.68639 11.8189 1.68608 11.8199 2.64038 12.1187L1.68608 11.8199L1.58789 12.1334L1.6948 12.4441L2.64038 12.1187C1.6948 12.4441 1.69514 12.4451 1.69514 12.4451L1.69553 12.4462L1.69648 12.449L1.69904 12.4562L1.70681 12.478C1.71317 12.4956 1.72194 12.5193 1.7332 12.5489C1.7557 12.608 1.7882 12.6903 1.8314 12.7925C1.91774 12.9968 2.04728 13.2817 2.2259 13.6207C2.58219 14.2968 3.13931 15.1986 3.94702 16.1067C5.57345 17.9353 8.22252 19.7897 12.224 19.8552C16.2471 19.921 18.9104 18.0545 20.5396 16.1899C21.3482 15.2645 21.905 14.3384 22.2605 13.6436C22.4387 13.2951 22.5679 13.0018 22.6539 12.7916C22.6969 12.6863 22.7292 12.6017 22.7515 12.541C22.7627 12.5106 22.7714 12.4862 22.7777 12.4682L22.7853 12.4461L22.7878 12.4387L22.7887 12.436L22.7891 12.4348C22.7891 12.4348 22.7894 12.4339 21.8404 12.1187ZM21.8404 12.1187L22.7894 12.4339L22.8911 12.1277L22.7947 11.8199L21.8404 12.1187ZM12.2404 10.6935C11.4413 10.6935 10.8404 11.317 10.8404 12.0289C10.8404 12.7408 11.4413 13.3642 12.2404 13.3642C13.0395 13.3642 13.6404 12.7408 13.6404 12.0289C13.6404 11.317 13.0395 10.6935 12.2404 10.6935ZM8.84038 12.0289C8.84038 10.1613 10.3885 8.69353 12.2404 8.69353C14.0922 8.69353 15.6404 10.1613 15.6404 12.0289C15.6404 13.8965 14.0922 15.3642 12.2404 15.3642C10.3885 15.3642 8.84038 13.8965 8.84038 12.0289Z",
      fill: "currentColor"
    })
  ]),
  tagManagement: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M13.8861 3.40217C13.6629 3.385 13.4434 3.46622 13.2851 3.6245L3.86521 13.0444C3.56576 13.3438 3.56576 13.8293 3.86521 14.1288L10.1118 20.3753C10.4112 20.6748 10.8967 20.6748 11.1962 20.3753L20.616 10.9554C20.7743 10.7972 20.8555 10.5776 20.8384 10.3544L20.3922 4.55407C20.3632 4.17698 20.0635 3.87736 19.6865 3.84835L13.8861 3.40217ZM11.8709 2.21029C12.442 1.63916 13.2342 1.34611 14.0395 1.40806L19.8398 1.85424C21.2005 1.95891 22.2816 3.04003 22.3863 4.40068L22.8325 10.201C22.8944 11.0064 22.6014 11.7985 22.0302 12.3697L12.6104 21.7895C11.5299 22.87 9.77804 22.87 8.69754 21.7895L2.451 15.543C1.3705 14.4625 1.3705 12.7107 2.451 11.6302L11.8709 2.21029ZM15.5882 7.64726C15.591 7.09498 16.041 6.64955 16.5933 6.65237L16.5997 6.6524C17.1519 6.65521 17.5974 7.1052 17.5946 7.65748C17.5918 8.20976 17.1418 8.65519 16.5895 8.65237L16.5831 8.65234C16.0308 8.64953 15.5854 8.19954 15.5882 7.64726Z",
      fill: "currentColor"
    })
  ]),
  disconnect: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.69865 0.449787C10.2482 0.504334 10.6495 0.99408 10.595 1.54366L10.414 3.36719C10.3595 3.91678 9.86971 4.31808 9.32013 4.26354C8.77055 4.20899 8.36924 3.71924 8.42379 3.16966L8.60477 1.34613C8.65932 0.796548 9.14907 0.395241 9.69865 0.449787ZM12.0916 4.57161C13.1214 3.5418 14.5167 2.99024 15.9682 3.00091C17.4166 3.01155 18.8088 3.58084 19.8436 4.61269C20.912 5.65104 21.483 7.0492 21.4937 8.49942C21.5045 9.96667 20.9145 11.3571 19.8958 12.3758L17.6623 14.6092C17.2718 14.9998 16.6386 14.9998 16.2481 14.6092C15.8576 14.2187 15.8576 13.5856 16.2481 13.195L18.4816 10.9616C19.1311 10.312 19.5005 9.4325 19.4937 8.51412C19.4869 7.58127 19.1215 6.69801 18.4461 6.04345L18.4349 6.03245C17.7773 5.37484 16.8881 5.00772 15.9535 5.00085C15.0194 4.99399 14.1443 5.34733 13.5058 5.98583C13.5058 5.98583 13.5058 5.98584 13.5058 5.98584L11.2724 8.21928C10.8818 8.60981 10.2487 8.60981 9.85815 8.21928C9.46763 7.82876 9.46763 7.19559 9.85815 6.80507L12.0916 4.57162L12.0916 4.57161ZM3.76398 3.40376C4.15451 3.01324 4.78767 3.01324 5.17819 3.40376L6.2845 4.51007C6.67502 4.90059 6.67502 5.53376 6.2845 5.92428C5.89398 6.3148 5.26081 6.3148 4.87029 5.92428L3.76398 4.81797C3.37346 4.42745 3.37346 3.79428 3.76398 3.40376ZM16.3543 8.01238C16.7448 8.4029 16.7448 9.03607 16.3543 9.42659L9.65394 16.127C9.26342 16.5175 8.63025 16.5175 8.23973 16.127C7.8492 15.7364 7.8492 15.1033 8.23973 14.7127L14.9401 8.01238C15.3306 7.62185 15.9638 7.62185 16.3543 8.01238ZM4.84873 8.79507C4.90328 9.34465 4.50197 9.8344 3.95239 9.88894L2.06173 10.0766C1.51215 10.1311 1.0224 9.72983 0.967854 9.18025C0.913307 8.63066 1.31461 8.14092 1.8642 8.08637L3.75486 7.89872C4.30444 7.84418 4.79419 8.24548 4.84873 8.79507ZM8.41935 9.57611C8.80987 9.96664 8.80987 10.5998 8.41935 10.9903L6.18589 13.2238C5.53632 13.8734 5.16696 14.7529 5.17371 15.6712C5.18057 16.6041 5.54592 17.4874 6.22134 18.1419C6.22885 18.1492 6.23626 18.1566 6.24354 18.1641C6.89801 18.8395 7.78147 19.2049 8.71418 19.2117C9.67206 19.2188 10.5211 18.8675 11.1618 18.2267L13.3953 15.9933C13.7858 15.6028 14.419 15.6028 14.8095 15.9933C15.2 16.3838 15.2 17.017 14.8095 17.4075L12.5761 19.6409L11.8689 18.9338L12.576 19.641C11.5485 20.6685 10.1813 21.2225 8.69949 21.2117C7.25205 21.201 5.85598 20.632 4.8182 19.5672C3.75344 18.5294 3.1844 17.1336 3.17377 15.6859C3.16298 14.2187 3.75299 12.8283 4.77168 11.8096L5.47879 12.5167L4.77168 11.8096L7.00514 9.57611C7.39566 9.18559 8.02883 9.18559 8.41935 9.57611ZM23.7916 14.5427C23.8461 15.0923 23.4448 15.582 22.8952 15.6366L21.0046 15.8242C20.455 15.8788 19.9652 15.4775 19.9107 14.9279C19.8561 14.3783 20.2575 13.8886 20.807 13.834L22.6977 13.6464C23.2473 13.5918 23.737 13.9931 23.7916 14.5427ZM18.4749 17.7987C18.8655 17.4082 19.4986 17.4082 19.8891 17.7987L20.9954 18.905C21.386 19.2955 21.386 19.9287 20.9954 20.3192C20.6049 20.7097 19.9718 20.7097 19.5812 20.3192L18.4749 19.2129C18.0844 18.8224 18.0844 18.1892 18.4749 17.7987ZM15.4393 19.4594C15.9889 19.514 16.3902 20.0037 16.3356 20.5533L16.1547 22.3768C16.1001 22.9264 15.6104 23.3277 15.0608 23.2732C14.5112 23.2186 14.1099 22.7289 14.1644 22.1793L14.3454 20.3558C14.4 19.8062 14.8897 19.4049 15.4393 19.4594Z",
      fill: "currentColor"
    })
  ]),
  link: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M16.1551 14.5166C16.5456 14.9071 17.1788 14.9071 17.5693 14.5166L19.8028 12.2832C20.8215 11.2645 21.4115 9.87405 21.4007 8.4068C21.39 6.95655 20.819 5.55838 19.7506 4.52002C18.7158 3.4882 17.3236 2.91893 15.8752 2.90828C14.4237 2.89762 13.0284 3.44918 11.9986 4.47899L9.76514 6.71245C9.37462 7.10297 9.37462 7.73613 9.76514 8.12666C10.1557 8.51718 10.7888 8.51718 11.1794 8.12666L13.4128 5.89322C14.0513 5.25471 14.9263 4.90136 15.8605 4.90823C16.7951 4.9151 17.6843 5.28221 18.3419 5.93982L18.3531 5.95082C19.0285 6.60539 19.3939 7.48864 19.4007 8.4215C19.4075 9.33987 19.0381 10.2194 18.3886 10.869L16.1551 13.1024C15.7646 13.4929 15.7646 14.1261 16.1551 14.5166ZM13.3023 15.9007L11.0688 18.1341C11.0688 18.1341 11.0688 18.1341 11.0688 18.1341C10.4281 18.7749 9.57905 19.1261 8.62118 19.1191C7.68846 19.1122 6.805 18.7469 6.15053 18.0715C6.14325 18.064 6.13584 18.0566 6.12833 18.0493C5.45291 17.3947 5.08756 16.5115 5.0807 15.5786C5.07395 14.6602 5.44331 13.7807 6.09288 13.1312L8.32634 10.8977C8.71687 10.5072 8.71687 9.87401 8.32634 9.48349C7.93582 9.09297 7.30265 9.09297 6.91213 9.48349L4.67867 11.7169C3.65998 12.7356 3.06997 14.1261 3.08076 15.5933C3.0914 17.041 3.66044 18.4368 4.7252 19.4746C5.76299 20.5394 7.15905 21.1084 8.60648 21.119C10.0883 21.1299 11.4555 20.5759 12.483 19.5483L14.7165 17.3149C15.107 16.9243 15.107 16.2912 14.7165 15.9007C14.326 15.5101 13.6928 15.5101 13.3023 15.9007ZM8.14672 16.0343C8.53724 16.4249 9.17041 16.4249 9.56093 16.0343L16.2613 9.33396C16.6518 8.94344 16.6518 8.31028 16.2613 7.91975C15.8708 7.52923 15.2376 7.52923 14.8471 7.91975L8.14672 14.6201C7.7562 15.0106 7.7562 15.6438 8.14672 16.0343Z",
      fill: "currentColor"
    })
  ]),
  snapshot: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.04062 3.3999C4.31514 3.3999 3.64062 4.0343 3.64062 4.92622V19.0736C3.64062 19.9655 4.31514 20.5999 5.04062 20.5999H19.4406C20.1661 20.5999 20.8406 19.9655 20.8406 19.0736V4.92622C20.8406 4.0343 20.1661 3.3999 19.4406 3.3999H5.04062ZM1.64062 4.92622C1.64062 3.02764 3.11514 1.3999 5.04062 1.3999H19.4406C21.3661 1.3999 22.8406 3.02764 22.8406 4.92622V19.0736C22.8406 20.9722 21.3661 22.5999 19.4406 22.5999H5.04062C3.11514 22.5999 1.64062 20.9722 1.64062 19.0736V4.92622Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.55273 9.04053C8.17304 9.04053 7.86523 9.34833 7.86523 9.72803C7.86523 10.1077 8.17304 10.4155 8.55273 10.4155C8.93243 10.4155 9.24023 10.1077 9.24023 9.72803C9.24023 9.34833 8.93243 9.04053 8.55273 9.04053ZM5.86523 9.72803C5.86523 8.24376 7.06847 7.04053 8.55273 7.04053C10.037 7.04053 11.2402 8.24376 11.2402 9.72803C11.2402 11.2123 10.037 12.4155 8.55273 12.4155C7.06847 12.4155 5.86523 11.2123 5.86523 9.72803ZM15.7206 12.9584C16.1112 12.5679 16.7443 12.5679 17.1348 12.9584L21.6348 17.4584C22.0254 17.8489 22.0254 18.4821 21.6348 18.8726C21.2443 19.2632 20.6112 19.2632 20.2206 18.8726L16.4277 15.0797L12.0723 19.4351C11.6818 19.8257 11.0487 19.8257 10.6581 19.4351L9.11523 17.8922L5.32234 21.6851C4.93182 22.0757 4.29865 22.0757 3.90813 21.6851C3.5176 21.2946 3.5176 20.6614 3.90813 20.2709L8.40813 15.7709C8.79865 15.3804 9.43182 15.3804 9.82234 15.7709L11.3652 17.3138L15.7206 12.9584Z",
      fill: "currentColor"
    })
  ]),
  calendar: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.79976 2C7.35204 2 7.79976 2.44772 7.79976 3V3.54285H15.9902V3C15.9902 2.44772 16.4379 2 16.9902 2C17.5425 2 17.9902 2.44772 17.9902 3V3.6709C19.73 4.12672 20.9902 5.74416 20.9902 7.62855L20.9902 15.084C20.9902 15.0846 20.9902 15.0851 20.9902 15.0857C20.9902 15.0863 20.9902 15.0868 20.9902 15.0874V17.9143C20.9902 20.144 19.2257 22 16.9902 22H6.99023C4.75473 22 2.99023 20.144 2.99023 17.9143V7.62855C2.99023 5.81365 4.15925 4.24637 5.79976 3.72603V3C5.79976 2.44772 6.24747 2 6.79976 2ZM4.99023 16.0857V17.9143C4.99023 19.0929 5.91203 20 6.99023 20H8.49023V16.0857H4.99023ZM8.49023 14.0857H4.99023V9.91425H8.49023V14.0857ZM10.4902 16.0857V20H13.4902V16.0857H10.4902ZM13.4902 14.0857H10.4902V9.91425H13.4902V14.0857ZM15.4902 16.0857V20H16.9902C18.0684 20 18.9902 19.0929 18.9902 17.9143V16.0857H15.4902ZM18.9902 14.0857H15.4902V9.91425H18.9902L18.9902 14.0857ZM18.9902 7.91425V7.62855C18.9902 6.44991 18.0684 5.54285 16.9902 5.54285H6.99023C5.91203 5.54285 4.99023 6.44991 4.99023 7.62855V7.91425H18.9902Z",
      fill: "currentColor"
    })
  ]),
  cloud: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.5259 6.60791C8.93381 6.60791 6.81166 8.73847 6.81166 11.3925C6.81166 11.5964 6.82418 11.7969 6.84837 11.9933C6.8834 12.2776 6.79477 12.5634 6.60496 12.778C6.50435 12.8918 6.38043 12.9798 6.24352 13.0373C6.07631 13.1174 5.88836 13.1502 5.70044 13.1292C5.62003 13.1202 5.53799 13.1155 5.45452 13.1155C4.24309 13.1155 3.24023 14.113 3.24023 15.3693C3.24023 16.5303 4.14392 17.392 5.45452 17.392H17.8502C19.799 17.0797 21.2402 15.5412 21.2402 13.5617C21.2402 11.307 19.4379 9.50018 17.2402 9.50018C17.0404 9.50018 16.8446 9.51499 16.6536 9.54342C16.242 9.60471 15.8354 9.40466 15.6328 9.04113C14.8199 7.58243 13.2816 6.60791 11.5259 6.60791ZM4.81541 11.164C4.93454 7.53349 7.88239 4.60791 11.5259 4.60791C13.8073 4.60791 15.8173 5.75717 17.0285 7.5039C17.0988 7.50143 17.1694 7.50018 17.2402 7.50018C20.5654 7.50018 23.2402 10.2256 23.2402 13.5617C23.2402 16.6591 20.9322 18.9671 18.0691 19.3816C18.0216 19.3885 17.9738 19.392 17.9258 19.392H5.45452C3.21472 19.392 1.24023 17.8024 1.24023 15.3693C1.24023 13.2489 2.78311 11.4754 4.81541 11.164Z",
      fill: "currentColor"
    })
  ]),
  update: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M12.2402 4.00003V2.21003C12.2402 1.76003 11.7002 1.54003 11.3902 1.86003L8.59023 4.65003C8.39023 4.85003 8.39023 5.16003 8.59023 5.36003L11.3802 8.15003C11.7002 8.46003 12.2402 8.24003 12.2402 7.79003V6.00003C15.5502 6.00003 18.2402 8.69003 18.2402 12C18.2402 12.79 18.0902 13.56 17.8002 14.25C17.6502 14.61 17.7602 15.02 18.0302 15.29C18.5402 15.8 19.4002 15.62 19.6702 14.95C20.0402 14.04 20.2402 13.04 20.2402 12C20.2402 7.58003 16.6602 4.00003 12.2402 4.00003ZM12.2402 18C8.93023 18 6.24023 15.31 6.24023 12C6.24023 11.21 6.39023 10.44 6.68023 9.75003C6.83023 9.39003 6.72023 8.98003 6.45023 8.71003C5.94023 8.20003 5.08023 8.38003 4.81023 9.05003C4.44023 9.96003 4.24023 10.96 4.24023 12C4.24023 16.42 7.82023 20 12.2402 20V21.79C12.2402 22.24 12.7802 22.46 13.0902 22.14L15.8802 19.35C16.0802 19.15 16.0802 18.84 15.8802 18.64L13.0902 15.85C12.7802 15.54 12.2402 15.76 12.2402 16.21V18Z",
      fill: "currentColor"
    })
  ]),
  updateProgress: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M12.2402 0C5.61623 0 0.240234 5.376 0.240234 12C0.240234 18.624 5.61623 24 12.2402 24C18.8642 24 24.2402 18.624 24.2402 12C24.2402 5.376 18.8642 0 12.2402 0ZM13.3322 19.38C12.9602 19.752 12.3122 19.488 12.3122 18.96V18C12.2882 18 12.2642 18 12.2402 18C10.7042 18 9.16823 17.412 7.99223 16.248C6.27623 14.532 5.82023 12.024 6.62423 9.888C6.85223 9.276 7.65624 9.12 8.11224 9.588C8.37624 9.852 8.43623 10.236 8.31623 10.572C7.76423 12.06 8.07623 13.788 9.27623 14.988C10.1162 15.828 11.2202 16.224 12.3242 16.2V15.072C12.3242 14.532 12.9722 14.268 13.3442 14.652L15.2882 16.596C15.5282 16.836 15.5282 17.208 15.2882 17.448L13.3322 19.38ZM16.3682 14.424C16.1042 14.16 16.0442 13.776 16.1642 13.44C16.7162 11.952 16.4042 10.224 15.2042 9.024C14.3642 8.184 13.2602 7.776 12.1682 7.8V8.928C12.1682 9.468 11.5202 9.732 11.1482 9.348L9.19223 7.416C8.95224 7.176 8.95224 6.804 9.19223 6.564L11.1362 4.62C11.5082 4.248 12.1562 4.512 12.1562 5.04V6.012C13.7162 5.988 15.2882 6.552 16.4762 7.752C18.1922 9.468 18.6482 11.976 17.8442 14.112C17.6162 14.736 16.8242 14.892 16.3682 14.424Z",
      fill: "currentColor"
    })
  ]),
  search: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.6798 4.6001C7.90222 4.6001 4.83984 7.66247 4.83984 11.4401C4.83984 15.2177 7.90222 18.2801 11.6798 18.2801C13.5424 18.2801 15.2311 17.5356 16.4646 16.328C16.4663 16.3264 16.468 16.3247 16.4696 16.3231C17.7349 15.0818 18.5198 13.3526 18.5198 11.4401C18.5198 7.66247 15.4575 4.6001 11.6798 4.6001ZM18.5575 16.9942C19.7848 15.4764 20.5198 13.5441 20.5198 11.4401C20.5198 6.5579 16.562 2.6001 11.6798 2.6001C6.79765 2.6001 2.83984 6.5579 2.83984 11.4401C2.83984 16.3223 6.79765 20.2801 11.6798 20.2801C13.7373 20.2801 15.6305 19.5772 17.1326 18.3985L19.9445 21.1188C20.3415 21.5028 20.9746 21.4923 21.3586 21.0954C21.7426 20.6985 21.7321 20.0654 21.3351 19.6814L18.5575 16.9942Z",
      fill: "currentColor"
    })
  ]),
  check: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M17.7446 7.6908C18.1362 8.08023 18.138 8.71339 17.7486 9.10501L10.589 16.305C10.4013 16.4938 10.1461 16.5999 9.87994 16.5999C9.61374 16.5999 9.35853 16.4938 9.17084 16.305L6.73036 13.8507C6.34093 13.4591 6.34272 12.8259 6.73434 12.4365C7.12597 12.0471 7.75913 12.0489 8.14855 12.4405L9.87994 14.1817L16.3304 7.69479C16.7198 7.30317 17.3529 7.30138 17.7446 7.6908Z",
      fill: "currentColor"
    })
  ]),
  checkCircle: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24023 12C2.24023 6.47715 6.71739 2 12.2402 2C17.7631 2 22.2402 6.47715 22.2402 12C22.2402 17.5228 17.7631 22 12.2402 22C6.71739 22 2.24023 17.5228 2.24023 12ZM12.2402 4C7.82196 4 4.24023 7.58172 4.24023 12C4.24023 16.4183 7.82196 20 12.2402 20C16.6585 20 20.2402 16.4183 20.2402 12C20.2402 7.58172 16.6585 4 12.2402 4ZM16.0893 9.27589C16.4799 9.66641 16.4799 10.2996 16.0893 10.6901L11.8223 14.9571C11.4318 15.3476 10.7987 15.3476 10.4081 14.9571L8.95362 13.5026C8.5631 13.1121 8.5631 12.4789 8.95362 12.0884C9.34415 11.6979 9.97731 11.6979 10.3678 12.0884L11.1152 12.8358L14.6751 9.27589C15.0657 8.88536 15.6988 8.88536 16.0893 9.27589Z",
      fill: "currentColor"
    })
  ]),
  download: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.2414 2C12.7936 2 13.2414 2.44772 13.2414 3V12.5313L16.1063 9.67155C16.4972 9.28138 17.1304 9.28195 17.5205 9.67283C17.9107 10.0637 17.9101 10.6969 17.5192 11.087L12.9478 15.6502C12.5574 16.0399 11.9253 16.0399 11.5349 15.6502L6.96345 11.087C6.57258 10.6969 6.572 10.0637 6.96218 9.67283C7.35235 9.28195 7.98551 9.28138 8.37639 9.67155L11.2414 12.5313V3C11.2414 2.44772 11.6891 2 12.2414 2ZM20.2402 14.2044C20.7925 14.2044 21.2402 14.6521 21.2402 15.2044V18.8925C21.2402 19.7003 20.9362 20.4848 20.3798 21.0711C19.8217 21.6592 19.0533 22 18.2402 22H6.24023C5.42719 22 4.65874 21.6592 4.10066 21.0711C3.54426 20.4848 3.24023 19.7003 3.24023 18.8925L3.24023 15.2044C3.24023 14.6521 3.68795 14.2044 4.24023 14.2044C4.79252 14.2044 5.24023 14.6521 5.24023 15.2044V18.8925C5.24023 19.2026 5.35764 19.4902 5.55138 19.6944C5.74344 19.8967 5.99241 20 6.24023 20H18.2402C18.4881 20 18.737 19.8967 18.9291 19.6944C19.1228 19.4902 19.2402 19.2026 19.2402 18.8925V15.2044C19.2402 14.6521 19.688 14.2044 20.2402 14.2044Z",
      fill: "currentColor"
    })
  ]),
  next: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.8839 4.27586C13.2838 3.89498 13.9168 3.91042 14.2977 4.31035L20.9644 11.3103C21.3322 11.6966 21.3322 12.3034 20.9644 12.6897L14.2977 19.6897C13.9168 20.0896 13.2838 20.105 12.8839 19.7241C12.484 19.3433 12.4685 18.7103 12.8494 18.3103L17.9069 13L4.24023 13C3.68795 13 3.24023 12.5523 3.24023 12C3.24023 11.4477 3.68795 11 4.24023 11L17.9069 11L12.8494 5.68966C12.4685 5.28973 12.484 4.65675 12.8839 4.27586Z",
      fill: "currentColor"
    })
  ]),
  prev: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.5966 4.27586C11.9965 4.65675 12.0119 5.28973 11.631 5.68966L6.57357 11L20.2402 11C20.7925 11 21.2402 11.4477 21.2402 12C21.2402 12.5523 20.7925 13 20.2402 13L6.57357 13L11.631 18.3103C12.0119 18.7103 11.9965 19.3433 11.5966 19.7241C11.1966 20.105 10.5637 20.0896 10.1828 19.6897L3.5161 12.6897C3.14828 12.3034 3.14828 11.6966 3.5161 11.3103L10.1828 4.31035C10.5636 3.91042 11.1966 3.89498 11.5966 4.27586Z",
      fill: "currentColor"
    })
  ]),
  close: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M18.5409 5.71022C18.1509 5.32022 17.5209 5.32022 17.1309 5.71022L12.2409 10.5902L7.35094 5.70021C6.96094 5.31021 6.33094 5.31021 5.94094 5.70021C5.55094 6.09021 5.55094 6.72022 5.94094 7.11022L10.8309 12.0002L5.94094 16.8902C5.55094 17.2802 5.55094 17.9102 5.94094 18.3002C6.33094 18.6902 6.96094 18.6902 7.35094 18.3002L12.2409 13.4102L17.1309 18.3002C17.5209 18.6902 18.1509 18.6902 18.5409 18.3002C18.9309 17.9102 18.9309 17.2802 18.5409 16.8902L13.6509 12.0002L18.5409 7.11022C18.9209 6.73022 18.9209 6.09022 18.5409 5.71022Z",
      fill: "currentColor"
    })
  ]),
  add: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M18.2402 13H13.2402V18C13.2402 18.55 12.7902 19 12.2402 19C11.6902 19 11.2402 18.55 11.2402 18V13H6.24023C5.69023 13 5.24023 12.55 5.24023 12C5.24023 11.45 5.69023 11 6.24023 11H11.2402V6C11.2402 5.45 11.6902 5 12.2402 5C12.7902 5 13.2402 5.45 13.2402 6V11H18.2402C18.7902 11 19.2402 11.45 19.2402 12C19.2402 12.55 18.7902 13 18.2402 13Z",
      fill: "currentColor"
    })
  ]),
  fullscreen: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.53313 3.29289C3.72066 3.10536 3.97502 3 4.24023 3L8.24023 3C8.79252 3 9.24023 3.44772 9.24023 4C9.24023 4.55228 8.79252 5 8.24023 5H6.65445L9.44734 7.79289C9.83787 8.18342 9.83787 8.81658 9.44734 9.20711C9.05682 9.59763 8.42365 9.59763 8.03313 9.20711L5.24023 6.41421V8C5.24023 8.55228 4.79252 9 4.24023 9C3.68795 9 3.24023 8.55228 3.24023 8L3.24023 4C3.24023 3.73478 3.34559 3.48043 3.53313 3.29289ZM17.826 5H16.2402C15.6879 5 15.2402 4.55228 15.2402 4C15.2402 3.44772 15.6879 3 16.2402 3H20.2402C20.7925 3 21.2402 3.44772 21.2402 4V8C21.2402 8.55228 20.7925 9 20.2402 9C19.688 9 19.2402 8.55228 19.2402 8V6.41421L16.4473 9.20711C16.0568 9.59763 15.4237 9.59763 15.0331 9.20711C14.6426 8.81658 14.6426 8.18342 15.0331 7.79289L17.826 5ZM9.44734 14.7929C9.83787 15.1834 9.83787 15.8166 9.44734 16.2071L6.65445 19H8.24023C8.79252 19 9.24023 19.4477 9.24023 20C9.24023 20.5523 8.79252 21 8.24023 21H4.24023C3.68795 21 3.24023 20.5523 3.24023 20V16C3.24023 15.4477 3.68795 15 4.24023 15C4.79252 15 5.24023 15.4477 5.24023 16V17.5858L8.03313 14.7929C8.42365 14.4024 9.05682 14.4024 9.44734 14.7929ZM15.0331 14.7929C15.4237 14.4024 16.0568 14.4024 16.4473 14.7929L19.2402 17.5858V16C19.2402 15.4477 19.688 15 20.2402 15C20.7925 15 21.2402 15.4477 21.2402 16L21.2402 20C21.2402 20.5523 20.7925 21 20.2402 21H16.2402C15.6879 21 15.2402 20.5523 15.2402 20C15.2402 19.4477 15.6879 19 16.2402 19H17.826L15.0331 16.2071C14.6426 15.8166 14.6426 15.1834 15.0331 14.7929Z",
      fill: "currentColor"
    })
  ]),
  syncCheck: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.93955 4.79988C1.93956 2.92212 3.46179 1.3999 5.33955 1.3999H16.1398C18.0176 1.3999 19.5398 2.92213 19.5398 4.7999V11.3999C19.5398 11.9522 19.0921 12.3999 18.5398 12.3999C17.9875 12.3999 17.5398 11.9522 17.5398 11.3999V4.7999C17.5398 4.0267 16.913 3.3999 16.1398 3.3999H5.33955C4.56635 3.3999 3.93955 4.0267 3.93955 4.7999L3.93945 19.1998C3.93945 19.973 4.56625 20.5998 5.33945 20.5998H10.1395C10.6917 20.5998 11.1395 21.0476 11.1395 21.5998C11.1395 22.1521 10.6917 22.5998 10.1395 22.5998H5.33944C3.46167 22.5998 1.93944 21.0776 1.93945 19.1998L1.93955 4.79988ZM22.2221 13.6688C22.6259 14.0457 22.6477 14.6785 22.2709 15.0822L16.6709 21.0822C16.4858 21.2805 16.2282 21.3951 15.9571 21.3998C15.6859 21.4044 15.4245 21.2988 15.2327 21.107L13.0327 18.907C12.6422 18.5165 12.6422 17.8833 13.0327 17.4928C13.4232 17.1023 14.0564 17.1023 14.4469 17.4928L15.915 18.9609L20.8088 13.7176C21.1856 13.3138 21.8184 13.292 22.2221 13.6688Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.1803 5.05905C11.1803 4.55126 10.5663 4.29317 10.2087 4.65943L8.41851 6.44319C8.19293 6.66877 8.19293 7.02537 8.41851 7.25095L10.2033 9.03579L10.2062 9.03855C10.5646 9.38582 11.1803 9.14411 11.1803 8.62869V7.7422C13.0434 7.87087 14.5186 9.42655 14.5186 11.3219C14.5186 11.7961 14.4282 12.2563 14.2563 12.6651C14.1162 13.0016 14.2233 13.3692 14.4575 13.6034C14.9119 14.0578 15.6758 13.8953 15.915 13.3033C16.1639 12.691 16.298 12.0193 16.298 11.3219C16.298 8.44008 14.0297 6.09035 11.1803 5.95986V5.05905ZM7.40306 9.04046C6.9486 8.586 6.1847 8.74854 5.94555 9.34058C5.69662 9.95281 5.5625 10.6245 5.5625 11.3219C5.5625 14.2038 7.8308 16.5535 10.6803 16.684V17.5848C10.6803 18.0927 11.2945 18.3508 11.652 17.9842L13.4356 16.2006C13.6612 15.9751 13.6612 15.6185 13.4356 15.3929L11.6508 13.6081C11.2934 13.2507 10.6803 13.5068 10.6803 14.0151V14.9016C8.81715 14.773 7.34194 13.2173 7.34194 11.3219C7.34194 10.8477 7.43234 10.3876 7.60419 9.9787C7.74437 9.64226 7.63723 9.27463 7.40306 9.04046Z",
      fill: "currentColor"
    })
  ]),
  copy: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.24024 4C6.58338 4 5.24024 5.34314 5.24024 7L5.24023 13.125C5.24023 13.6773 4.79252 14.125 4.24023 14.125C3.68795 14.125 3.24023 13.6773 3.24023 13.125L3.24024 7C3.24024 4.23858 5.47881 2 8.24024 2L14.3652 2C14.9175 2 15.3652 2.44772 15.3652 3C15.3652 3.55229 14.9175 4 14.3652 4L8.24024 4ZM6.99024 9C6.99024 7.20507 8.44531 5.75 10.2402 5.75L16.9902 5.75C18.7852 5.75 20.2402 7.20508 20.2402 9L20.2402 18.75C20.2402 20.5449 18.7852 22 16.9902 22L10.2402 22C8.44531 22 6.99023 20.5449 6.99023 18.75L6.99024 9ZM10.2402 7.75C9.54988 7.75 8.99024 8.30964 8.99024 9L8.99023 18.75C8.99023 19.4404 9.54988 20 10.2402 20L16.9902 20C17.6806 20 18.2402 19.4404 18.2402 18.75L18.2402 9C18.2402 8.30964 17.6806 7.75 16.9902 7.75L10.2402 7.75Z",
      fill: "currentColor"
    })
  ]),
  create: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.44541 4.79988C2.44542 2.92212 3.96764 1.3999 5.84541 1.3999H16.6457C18.5234 1.3999 20.0457 2.92213 20.0457 4.7999V11.3999C20.0457 11.9522 19.598 12.3999 19.0457 12.3999C18.4934 12.3999 18.0457 11.9522 18.0457 11.3999V4.7999C18.0457 4.02671 17.4189 3.3999 16.6457 3.3999H5.84541C5.07221 3.3999 4.44541 4.0267 4.44541 4.7999L4.44531 19.1998C4.44531 19.973 5.07211 20.5998 5.84531 20.5998H10.6453C11.1976 20.5998 11.6453 21.0476 11.6453 21.5998C11.6453 22.1521 11.1976 22.5998 10.6453 22.5998H5.8453C3.96753 22.5998 2.4453 21.0776 2.44531 19.1998L2.44541 4.79988ZM6.64569 7.1999C6.64569 6.64762 7.0934 6.1999 7.64569 6.1999H14.8457C15.398 6.1999 15.8457 6.64762 15.8457 7.1999C15.8457 7.75219 15.398 8.1999 14.8457 8.1999H7.64569C7.0934 8.1999 6.64569 7.75219 6.64569 7.1999ZM6.64569 10.7999C6.64569 10.2476 7.0934 9.7999 7.64569 9.7999H14.8457C15.398 9.7999 15.8457 10.2476 15.8457 10.7999C15.8457 11.3522 15.398 11.7999 14.8457 11.7999H7.64569C7.0934 11.7999 6.64569 11.3522 6.64569 10.7999ZM6.64569 14.3999C6.64569 13.8476 7.0934 13.3999 7.64569 13.3999H11.2457C11.798 13.3999 12.2457 13.8476 12.2457 14.3999C12.2457 14.9522 11.798 15.3999 11.2457 15.3999H7.64569C7.0934 15.3999 6.64569 14.9522 6.64569 14.3999ZM17.6394 13.3999C18.1917 13.3999 18.6394 13.8476 18.6394 14.3999V16.794L21.0336 16.794C21.5858 16.794 22.0336 17.2417 22.0336 17.794C22.0336 18.3463 21.5858 18.794 21.0336 18.794H18.6394V21.1881C18.6394 21.7404 18.1917 22.1881 17.6394 22.1881C17.0872 22.1881 16.6394 21.7404 16.6394 21.1881V18.794H14.2453C13.693 18.794 13.2453 18.3463 13.2453 17.794C13.2453 17.2417 13.693 16.794 14.2453 16.794L16.6394 16.794V14.3999C16.6394 13.8476 17.0872 13.3999 17.6394 13.3999Z",
      fill: "currentColor"
    })
  ]),
  file: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M8.63983 7.1999H15.8398M8.63983 10.7999H15.8398M8.63983 14.3999H12.2398M6.83955 2.3999H17.6398C18.9653 2.3999 20.0398 3.47445 20.0398 4.79995L20.0395 19.2C20.0395 20.5254 18.965 21.5999 17.6395 21.5999L6.83944 21.5998C5.51396 21.5998 4.43944 20.5253 4.43945 19.1998L4.43955 4.79989C4.43955 3.47441 5.51407 2.3999 6.83955 2.3999Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  folder: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M2.64165 8.41649L2.64156 17.9408C2.64155 19.0454 3.53698 19.9408 4.64156 19.9408L19.8403 19.9409C20.9448 19.9409 21.8403 19.0455 21.8403 17.9409L21.8406 8.01226C21.8406 7.45996 21.3929 7.01223 20.8406 7.01223H12.3243L9.55929 4.05859H3.641C3.08857 4.05859 2.64079 4.50581 2.64097 5.05824C2.64127 6.00905 2.64166 7.43597 2.64165 8.41649Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  fileSearch: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.84067 5.05859C3.72937 5.05859 3.64059 5.14825 3.64062 5.25798C3.64092 6.20053 3.64126 7.5024 3.64125 8.4165L3.64116 17.5408C3.64115 18.314 4.26796 18.9408 5.04116 18.9408H12.3239C12.8762 18.9408 13.3239 19.3885 13.3239 19.9408C13.3239 20.4931 12.8762 20.9408 12.3239 20.9408H5.04116C3.16338 20.9408 1.64114 19.4186 1.64116 17.5408L1.64125 8.41648C1.64126 7.50274 1.64092 6.20114 1.64063 5.2586C1.64025 4.04249 2.62614 3.05859 3.84067 3.05859H9.55889C9.83555 3.05859 10.0998 3.17321 10.2889 3.37518L12.7576 6.01223H20.6402C21.8553 6.01223 22.8402 6.9972 22.8402 8.21223V11.3998C22.8402 11.9521 22.3925 12.3998 21.8402 12.3998C21.2879 12.3998 20.8402 11.9521 20.8402 11.3998V8.21223C20.8402 8.10177 20.7507 8.01223 20.6402 8.01223H12.3239C12.0473 8.01223 11.783 7.89762 11.5939 7.69564L9.12523 5.05859H3.84067ZM17.6402 14.1998C16.5357 14.1998 15.6402 15.0952 15.6402 16.1998C15.6402 17.3044 16.5357 18.1998 17.6402 18.1998C18.7448 18.1998 19.6402 17.3044 19.6402 16.1998C19.6402 15.0952 18.7448 14.1998 17.6402 14.1998ZM13.6402 16.1998C13.6402 13.9907 15.4311 12.1998 17.6402 12.1998C19.8494 12.1998 21.6402 13.9907 21.6402 16.1998C21.6402 16.9416 21.4383 17.6363 21.0864 18.2318L21.9473 19.0927C22.3379 19.4832 22.3379 20.1164 21.9473 20.5069C21.5568 20.8974 20.9236 20.8974 20.5331 20.5069L19.6722 19.646C19.0767 19.9979 18.382 20.1998 17.6402 20.1998C15.4311 20.1998 13.6402 18.4089 13.6402 16.1998Z",
      fill: "currentColor"
    })
  ]),
  computer: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.64062 6.0001C1.64062 4.12233 3.16286 2.6001 5.04062 2.6001H19.4406C21.3184 2.6001 22.8406 4.12233 22.8406 6.0001V14.4001C22.8406 16.2779 21.3184 17.8001 19.4406 17.8001H13.2406V19.2001C13.2406 19.2686 13.2337 19.3355 13.2206 19.4001H15.8406C16.3929 19.4001 16.8406 19.8478 16.8406 20.4001C16.8406 20.9524 16.3929 21.4001 15.8406 21.4001H8.64062C8.08834 21.4001 7.64062 20.9524 7.64062 20.4001C7.64062 19.8478 8.08834 19.4001 8.64062 19.4001H11.2606C11.2475 19.3355 11.2406 19.2686 11.2406 19.2001V17.8001H5.04062C3.16286 17.8001 1.64062 16.2779 1.64062 14.4001V6.0001ZM19.4406 15.8001C20.2138 15.8001 20.8406 15.1733 20.8406 14.4001V6.0001C20.8406 5.2269 20.2138 4.6001 19.4406 4.6001H5.04062C4.26743 4.6001 3.64062 5.2269 3.64062 6.0001V14.4001C3.64062 15.1733 4.26743 15.8001 5.04062 15.8001H19.4406Z",
      fill: "currentColor"
    })
  ]),
  duplicateCheck: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M7.87922 4.31989C7.87923 2.70722 9.18655 1.3999 10.7992 1.3999H18.055C18.6079 1.3999 19.1247 1.63251 19.4938 2.02079C19.7675 2.30883 20.1891 2.73933 20.5862 3.09466C20.9532 3.42302 21.5047 3.98771 21.8154 4.30996C22.1684 4.67619 22.3594 5.16221 22.3594 5.6622L22.3592 15.84C22.3591 17.4526 21.0518 18.7599 19.4392 18.7599H16.5992L16.5992 19.68C16.5991 21.2926 15.2918 22.5999 13.6792 22.5999L5.03913 22.5999C3.42645 22.5999 2.11913 21.2925 2.11914 19.6798L2.11921 8.15989C2.11923 6.54722 3.42655 5.2399 5.03922 5.2399H7.87922V4.31989ZM5.03922 7.2399C4.53112 7.2399 4.11922 7.6518 4.11921 8.1599L4.11914 19.6799C4.11914 20.188 4.53103 20.5999 5.03914 20.5999L13.6792 20.5999C14.1873 20.5999 14.5992 20.188 14.5992 19.6799L14.5992 17.7729C14.5992 17.7686 14.5991 17.7642 14.5991 17.7599C14.5991 17.7555 14.5992 17.7512 14.5992 17.7468L14.5994 11.0799H12.7194C11.637 11.0799 10.7594 10.2024 10.7594 9.1199V7.2399H5.03922ZM9.87922 5.2399V4.3199C9.87922 3.8118 10.2911 3.3999 10.7992 3.3999H16.5194V5.2799C16.5194 6.36238 17.397 7.2399 18.4794 7.2399H20.3594L20.3592 15.8399C20.3592 16.348 19.9473 16.7599 19.4392 16.7599H16.5993L16.5994 10.0868C16.5994 10.0845 16.5994 10.0822 16.5994 10.0799C16.5994 10.0776 16.5994 10.0753 16.5994 10.0731L16.5994 9.50219C16.5994 9.0022 16.4084 8.51619 16.0554 8.14996C15.7447 7.82771 15.1932 7.26303 14.8262 6.93466C14.4291 6.57933 14.0075 6.14883 13.7337 5.8608C13.3647 5.47252 12.8479 5.2399 12.295 5.2399H9.87922ZM12.7594 7.72679C12.9852 7.95282 13.2401 8.1992 13.4926 8.42514C13.674 8.58738 13.9263 8.83566 14.1682 9.0799H12.7594V7.72679ZM19.9282 5.2399C19.6863 4.99566 19.434 4.74738 19.2526 4.58514C19.0001 4.3592 18.7452 4.11282 18.5194 3.88679V5.2399H19.9282Z",
      fill: "currentColor"
    })
  ]),
  undo: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M17.5442 8H16.3614C15.8092 8 15.3614 8.44772 15.3614 9C15.3614 9.55228 15.8092 10 16.3614 10H20.2402C20.7925 10 21.2402 9.55228 21.2402 9V5C21.2402 4.44772 20.7925 4 20.2402 4C19.6879 4 19.2402 4.44772 19.2402 5V6.93861C17.67 4.57029 15.0187 3 11.9978 3C7.13235 3 3.24023 7.05867 3.24023 12C3.24023 16.9413 7.13235 21 11.9978 21C15.9003 21 19.1808 18.3837 20.3219 14.8037C20.4896 14.2775 20.199 13.7149 19.6728 13.5472C19.1465 13.3795 18.584 13.6701 18.4163 14.1963C17.5214 17.0042 14.9709 19 11.9978 19C8.29449 19 5.24023 15.8952 5.24023 12C5.24023 8.10478 8.29449 5 11.9978 5C14.2839 5 16.3171 6.17758 17.5442 8Z",
      fill: "currentColor"
    })
  ]),
  restore: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.54111 4.79988C2.54112 2.92212 4.06335 1.3999 5.94111 1.3999H16.7414C18.6191 1.3999 20.1414 2.92213 20.1414 4.7999V10.1999C20.1414 10.7522 19.6937 11.1999 19.1414 11.1999C18.5891 11.1999 18.1414 10.7522 18.1414 10.1999V4.7999C18.1414 4.0267 17.5146 3.3999 16.7414 3.3999H5.94111C5.16791 3.3999 4.54111 4.0267 4.54111 4.7999L4.54102 19.1998C4.54101 19.973 5.16781 20.5998 5.94101 20.5998H10.141C10.6933 20.5998 11.141 21.0476 11.141 21.5998C11.141 22.1521 10.6933 22.5998 10.141 22.5998H5.941C4.06323 22.5998 2.541 21.0776 2.54102 19.1998L2.54111 4.79988ZM15.7414 14.3999C15.7414 13.8476 16.1891 13.3999 16.7414 13.3999H19.1685C20.6999 13.3999 21.9414 14.6414 21.9414 16.1728C21.9414 17.7042 20.6999 18.9456 19.1685 18.9456H14.3475L15.0928 19.6945C15.4823 20.0859 15.4808 20.7191 15.0894 21.1087C14.6979 21.4983 14.0648 21.4968 13.6752 21.1053L11.2326 18.6511C10.8445 18.2611 10.8443 17.6308 11.2322 17.2406L13.5644 14.8948C13.9538 14.5032 14.587 14.5014 14.9786 14.8907C15.3703 15.2801 15.3721 15.9133 14.9827 16.305L14.3457 16.9456H19.1685C19.5954 16.9456 19.9414 16.5996 19.9414 16.1728C19.9414 15.7459 19.5954 15.3999 19.1685 15.3999H16.7414C16.1891 15.3999 15.7414 14.9522 15.7414 14.3999Z",
      fill: "currentColor"
    })
  ]),
  import: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.83994 4.79988C2.83995 2.92212 4.36218 1.3999 6.23994 1.3999H17.0402C18.918 1.3999 20.4402 2.92213 20.4402 4.7999V11.3999C20.4402 11.9522 19.9925 12.3999 19.4402 12.3999C18.8879 12.3999 18.4402 11.9522 18.4402 11.3999V4.7999C18.4402 4.0267 17.8134 3.3999 17.0402 3.3999H6.23994C5.46674 3.3999 4.83994 4.0267 4.83994 4.7999L4.83984 19.1998C4.83984 19.973 5.46664 20.5998 6.23984 20.5998H11.0398C11.5921 20.5998 12.0398 21.0476 12.0398 21.5998C12.0398 22.1521 11.5921 22.5998 11.0398 22.5998H6.23983C4.36206 22.5998 2.83983 21.0776 2.83984 19.1998L2.83994 4.79988Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M13.041 17.8008C13.041 17.2485 13.4887 16.8008 14.041 16.8008L17.6349 16.8008L16.8896 16.0519C16.5001 15.6604 16.5016 15.0273 16.893 14.6377C17.2845 14.2481 17.9176 14.2496 18.3072 14.6411L20.7498 17.0953C21.1379 17.4853 21.1381 18.1156 20.7502 18.5058L18.418 20.8515C18.0286 21.2432 17.3955 21.245 17.0038 20.8556C16.6121 20.4662 16.6103 19.8331 16.9997 19.4414L17.6367 18.8008L14.041 18.8008C13.4887 18.8008 13.041 18.353 13.041 17.8008Z",
      fill: "currentColor"
    })
  ]),
  csv: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M23.4921 19.1996C23.4921 21.0774 21.9699 22.5996 20.0921 22.5996L9.29183 22.5996C7.41406 22.5996 5.89182 21.0774 5.89182 19.1996L5.89182 18.529C5.89182 17.9767 6.33954 17.529 6.89182 17.529C7.44411 17.529 7.89182 17.9767 7.89182 18.529L7.89182 19.1996C7.89182 19.9728 8.51863 20.5996 9.29183 20.5996L20.0921 20.5996C20.8653 20.5996 21.4921 19.9728 21.4921 19.1996L21.4922 4.79967C21.4922 4.02647 20.8654 3.39967 20.0922 3.39967L9.29184 3.39967C8.51863 3.39967 7.89182 4.02647 7.89182 4.79968L7.89182 5.60181C7.89182 6.1541 7.44411 6.60181 6.89182 6.60181C6.33954 6.60181 5.89182 6.1541 5.89182 5.60181L5.89182 4.79968C5.89182 2.9219 7.41406 1.39967 9.29184 1.39967L20.0922 1.39967C21.97 1.39967 23.4922 2.92191 23.4922 4.79968L23.4921 19.1996Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M15.1861 14.3322H14.0328L12.1328 9.66553H13.3928L14.6528 12.8255L15.9395 9.66553H17.0928L15.1861 14.3322Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M10.4603 14.4191C10.1092 14.4191 9.76695 14.3724 9.43362 14.2791C9.10029 14.1813 8.8314 14.0547 8.62695 13.8991L9.01362 12.9791C9.21362 13.1169 9.44251 13.2302 9.70029 13.3191C9.96251 13.4035 10.2203 13.4458 10.4736 13.4458C10.7403 13.4458 10.9358 13.408 11.0603 13.3324C11.1892 13.2569 11.2536 13.1547 11.2536 13.0258C11.2536 12.888 11.1803 12.7858 11.0336 12.7191C10.8914 12.648 10.6647 12.5769 10.3536 12.5058C10.007 12.4213 9.72473 12.3369 9.50695 12.2524C9.29362 12.1635 9.10695 12.0258 8.94695 11.8391C8.78695 11.648 8.70695 11.3924 8.70695 11.0724C8.70695 10.7924 8.77806 10.5391 8.92029 10.3124C9.06695 10.0858 9.28473 9.90799 9.57362 9.7791C9.86251 9.64577 10.2158 9.5791 10.6336 9.5791C10.927 9.5791 11.2092 9.61466 11.4803 9.68577C11.7558 9.75244 11.9981 9.85244 12.207 9.98577L11.8603 10.9124C11.4336 10.6724 11.0203 10.5524 10.6203 10.5524C10.3581 10.5524 10.1647 10.5947 10.0403 10.6791C9.92029 10.7635 9.86029 10.8747 9.86029 11.0124C9.86029 11.1458 9.92918 11.2458 10.067 11.3124C10.2092 11.3791 10.4358 11.448 10.747 11.5191C11.0847 11.5947 11.3647 11.6769 11.587 11.7658C11.8136 11.8502 12.007 11.9858 12.167 12.1724C12.327 12.3591 12.407 12.6124 12.407 12.9324C12.407 13.208 12.3336 13.4591 12.187 13.6858C12.0403 13.908 11.8203 14.0858 11.527 14.2191C11.2336 14.3524 10.8781 14.4191 10.4603 14.4191Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M6.66219 14.4191C6.20441 14.4191 5.79108 14.3169 5.42219 14.1124C5.0533 13.9035 4.76441 13.6147 4.55552 13.2458C4.34663 12.8769 4.24219 12.4613 4.24219 11.9991C4.24219 11.5369 4.34663 11.1213 4.55552 10.7524C4.76885 10.3835 5.05997 10.0969 5.42885 9.89244C5.79774 9.68355 6.21108 9.5791 6.66885 9.5791C7.06441 9.5791 7.42219 9.65466 7.74219 9.80577C8.06663 9.95244 8.3333 10.1635 8.54219 10.4391L7.79552 11.1591C7.50663 10.7947 7.15108 10.6124 6.72885 10.6124C6.47552 10.6124 6.24885 10.6702 6.04885 10.7858C5.8533 10.9013 5.69997 11.0658 5.58885 11.2791C5.47774 11.488 5.42219 11.728 5.42219 11.9991C5.42219 12.2702 5.47774 12.5102 5.58885 12.7191C5.69997 12.928 5.8533 13.0902 6.04885 13.2058C6.24885 13.3213 6.47552 13.3791 6.72885 13.3791C7.15552 13.3791 7.51108 13.1969 7.79552 12.8324L8.54219 13.5524C8.3333 13.8324 8.06663 14.048 7.74219 14.1991C7.42219 14.3458 7.06219 14.4191 6.66219 14.4191Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.96875 8.91113V15.0879H18.3645V8.91113H2.96875ZM1.96875 6.91113C1.41647 6.91113 0.96875 7.35885 0.96875 7.91113V16.0879C0.96875 16.6402 1.41646 17.0879 1.96875 17.0879H19.3645C19.9168 17.0879 20.3645 16.6402 20.3645 16.0879V7.91113C20.3645 7.35885 19.9168 6.91113 19.3645 6.91113H1.96875Z",
      fill: "currentColor"
    })
  ]),
  detail: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.24033 4.79988C2.24034 2.92212 3.76257 1.3999 5.64033 1.3999H16.4406C18.3184 1.3999 19.8406 2.92213 19.8406 4.7999V9.5999C19.8406 10.1522 19.3929 10.5999 18.8406 10.5999C18.2883 10.5999 17.8406 10.1522 17.8406 9.5999V4.7999C17.8406 4.0267 17.2138 3.3999 16.4406 3.3999H5.64033C4.86713 3.3999 4.24033 4.0267 4.24033 4.7999L4.24023 19.1998C4.24023 19.973 4.86703 20.5998 5.64023 20.5998H11.6402C12.1925 20.5998 12.6402 21.0476 12.6402 21.5998C12.6402 22.1521 12.1925 22.5998 11.6402 22.5998H5.64022C3.76245 22.5998 2.24022 21.0776 2.24023 19.1998L2.24033 4.79988ZM6.44061 7.1999C6.44061 6.64762 6.88832 6.1999 7.44061 6.1999H14.6406C15.1929 6.1999 15.6406 6.64762 15.6406 7.1999C15.6406 7.75219 15.1929 8.1999 14.6406 8.1999H7.44061C6.88832 8.1999 6.44061 7.75219 6.44061 7.1999ZM6.44061 10.7999C6.44061 10.2476 6.88832 9.7999 7.44061 9.7999H14.6406C15.1929 9.7999 15.6406 10.2476 15.6406 10.7999C15.6406 11.3522 15.1929 11.7999 14.6406 11.7999H7.44061C6.88832 11.7999 6.44061 11.3522 6.44061 10.7999ZM6.44061 14.3999C6.44061 13.8476 6.88832 13.3999 7.44061 13.3999H11.0406C11.5929 13.3999 12.0406 13.8476 12.0406 14.3999C12.0406 14.9522 11.5929 15.3999 11.0406 15.3999H7.44061C6.88832 15.3999 6.44061 14.9522 6.44061 14.3999ZM17.6402 15.3999C16.5357 15.3999 15.6402 16.2953 15.6402 17.3999C15.6402 18.5045 16.5357 19.3999 17.6402 19.3999C18.7448 19.3999 19.6402 18.5045 19.6402 17.3999C19.6402 16.2953 18.7448 15.3999 17.6402 15.3999ZM13.6402 17.3999C13.6402 15.1908 15.4311 13.3999 17.6402 13.3999C19.8494 13.3999 21.6402 15.1908 21.6402 17.3999C21.6402 18.1417 21.4383 18.8364 21.0864 19.4319L21.9473 20.2928C22.3379 20.6833 22.3379 21.3165 21.9473 21.707C21.5568 22.0975 20.9237 22.0975 20.5331 21.707L19.6722 20.8461C19.0767 21.198 18.382 21.3999 17.6402 21.3999C15.4311 21.3999 13.6402 19.609 13.6402 17.3999Z",
      fill: "currentColor"
    })
  ]),
  policyDelete: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.44541 4.79988C2.44542 2.92212 3.96764 1.3999 5.84541 1.3999H16.6457C18.5234 1.3999 20.0457 2.92213 20.0457 4.7999V11.3999C20.0457 11.9522 19.598 12.3999 19.0457 12.3999C18.4934 12.3999 18.0457 11.9522 18.0457 11.3999V4.7999C18.0457 4.02671 17.4189 3.3999 16.6457 3.3999H5.84541C5.07221 3.3999 4.44541 4.0267 4.44541 4.7999L4.44531 19.1998C4.44531 19.973 5.07211 20.5998 5.84531 20.5998H10.6453C11.1976 20.5998 11.6453 21.0476 11.6453 21.5998C11.6453 22.1521 11.1976 22.5998 10.6453 22.5998H5.8453C3.96753 22.5998 2.4453 21.0776 2.44531 19.1998L2.44541 4.79988ZM6.64569 7.1999C6.64569 6.64762 7.0934 6.1999 7.64569 6.1999H14.8457C15.398 6.1999 15.8457 6.64762 15.8457 7.1999C15.8457 7.75219 15.398 8.1999 14.8457 8.1999H7.64569C7.0934 8.1999 6.64569 7.75219 6.64569 7.1999ZM6.64569 10.7999C6.64569 10.2476 7.0934 9.7999 7.64569 9.7999H14.8457C15.398 9.7999 15.8457 10.2476 15.8457 10.7999C15.8457 11.3522 15.398 11.7999 14.8457 11.7999H7.64569C7.0934 11.7999 6.64569 11.3522 6.64569 10.7999ZM6.64569 14.3999C6.64569 13.8476 7.0934 13.3999 7.64569 13.3999H11.2457C11.798 13.3999 12.2457 13.8476 12.2457 14.3999C12.2457 14.9522 11.798 15.3999 11.2457 15.3999H7.64569C7.0934 15.3999 6.64569 14.9522 6.64569 14.3999Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M20.3049 15.3051C20.6954 15.6956 20.6954 16.3288 20.3049 16.7193L19.1027 17.9215L20.3048 19.1236C20.6953 19.5141 20.6953 20.1473 20.3048 20.5378C19.9143 20.9283 19.2811 20.9283 18.8906 20.5378L17.6885 19.3357L16.4865 20.5377C16.096 20.9282 15.4628 20.9282 15.0723 20.5377C14.6818 20.1472 14.6818 19.514 15.0723 19.1235L16.2743 17.9215L15.0722 16.7194C14.6817 16.3289 14.6817 15.6957 15.0722 15.3052C15.4627 14.9147 16.0959 14.9147 16.4864 15.3052L17.6885 16.5073L18.8907 15.3051C19.2812 14.9146 19.9144 14.9146 20.3049 15.3051Z",
      fill: "currentColor"
    })
  ]),
  payment: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M1.90039 7.50019C1.90034 5.62239 3.42259 4.1001 5.30039 4.1001H19.7C21.5773 4.1001 23.0999 5.62104 23.1 7.49919L23.1003 16.5011C23.1003 18.3794 21.5775 19.9001 19.7003 19.9001L5.30061 19.8999C3.4229 19.8999 1.9007 18.3777 1.90065 16.5L1.90039 7.50019ZM5.30039 6.1001C4.52718 6.1001 3.90037 6.72692 3.90039 7.50014L3.90041 8.29995H21.1L21.1 7.49926C21.1 6.72651 20.4736 6.1001 19.7 6.1001H5.30039ZM21.1001 10.2999H3.90047L3.90065 16.5C3.90067 17.2731 4.52746 17.8999 5.30063 17.8999L19.7003 17.9001C20.4741 17.9001 21.1003 17.2738 21.1003 16.5011L21.1001 10.2999Z",
      fill: "currentColor"
    })
  ]),
  reissue: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.69922 4.8C3.69922 3.39274 4.71582 2 6.25922 2H18.7392C20.2826 2 21.2992 3.39274 21.2992 4.8L21.2992 11.3316C21.2992 11.8839 20.8515 12.3316 20.2992 12.3316C19.7469 12.3316 19.2992 11.8839 19.2992 11.3316L19.2992 4.8C19.2992 4.21904 18.9189 4 18.7392 4H6.25922C6.07949 4 5.69922 4.21904 5.69922 4.8V19.0914L6.73001 18.3778C7.07245 18.1407 7.52598 18.1407 7.86843 18.3778L9.89922 19.7837L11.93 18.3778C12.3841 18.0634 13.007 18.1767 13.3214 18.6308C13.6358 19.0849 13.5225 19.7078 13.0684 20.0222L10.4684 21.8222C10.126 22.0593 9.67245 22.0593 9.33001 21.8222L7.29922 20.4163L5.26843 21.8222C4.96262 22.0339 4.56457 22.0584 4.23511 21.8858C3.90565 21.7132 3.69922 21.3719 3.69922 21V4.8ZM7.29922 7.8C7.29922 7.24772 7.74693 6.8 8.29922 6.8H16.6992C17.2515 6.8 17.6992 7.24772 17.6992 7.8C17.6992 8.35228 17.2515 8.8 16.6992 8.8H8.29922C7.74693 8.8 7.29922 8.35228 7.29922 7.8ZM7.29922 12.6C7.29922 12.0477 7.74693 11.6 8.29922 11.6H14.8684C15.4207 11.6 15.8684 12.0477 15.8684 12.6C15.8684 13.1523 15.4207 13.6 14.8684 13.6H8.29922C7.74693 13.6 7.29922 13.1523 7.29922 12.6Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.1047 13.8267C18.1047 13.2744 18.5524 12.8267 19.1047 12.8267H21.5318C23.0632 12.8267 24.3047 14.0681 24.3047 15.5995C24.3047 17.1309 23.0632 18.3724 21.5318 18.3724H16.7108L17.4561 19.1212C17.8456 19.5127 17.8441 20.1459 17.4527 20.5355C17.0612 20.925 16.4281 20.9235 16.0385 20.5321L13.5959 18.0778C13.2078 17.6878 13.2076 17.0575 13.5955 16.6673L15.9277 14.3216C16.3171 13.93 16.9502 13.9281 17.3419 14.3175C17.7336 14.7069 17.7354 15.3401 17.346 15.7317L16.709 16.3724H21.5318C21.9587 16.3724 22.3047 16.0264 22.3047 15.5995C22.3047 15.1727 21.9587 14.8267 21.5318 14.8267H19.1047C18.5524 14.8267 18.1047 14.3789 18.1047 13.8267Z",
      fill: "currentColor"
    })
  ]),
  "manual-billing": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M2.36133 4.8C2.36133 3.39274 3.37793 2 4.92133 2H17.4013C18.9447 2 19.9613 3.39274 19.9613 4.8L19.9613 8.78252C19.9613 9.33481 19.5136 9.78252 18.9613 9.78252C18.409 9.78252 17.9613 9.33481 17.9613 8.78252L17.9613 4.8C17.9613 4.21904 17.5811 4 17.4013 4H4.92133C4.7416 4 4.36133 4.21904 4.36133 4.8V19.0914L5.39212 18.3778C5.73456 18.1407 6.18809 18.1407 6.53054 18.3778L8.56133 19.7837L10.5921 18.3778C11.0462 18.0634 11.6692 18.1767 11.9835 18.6308C12.2979 19.0849 12.1846 19.7078 11.7305 20.0222L9.13054 21.8222C8.78809 22.0593 8.33456 22.0593 7.99212 21.8222L5.96133 20.4163L3.93054 21.8222C3.62473 22.0339 3.22668 22.0584 2.89722 21.8858C2.56776 21.7132 2.36133 21.3719 2.36133 21V4.8Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.3841 10.8075C18.7746 10.417 19.4078 10.417 19.7983 10.8075L23.1924 14.2017C23.3799 14.3892 23.4853 14.6435 23.4853 14.9088C23.4853 15.174 23.3799 15.4283 23.1924 15.6159L18.1012 20.707C17.9137 20.8946 17.6593 20.9999 17.3941 20.9999H14C13.4477 20.9999 13 20.5522 13 19.9999V16.6058C13 16.3406 13.1054 16.0862 13.2929 15.8987L18.3841 10.8075ZM19.0912 12.9289L15 17.02V18.9999H16.9799L21.0711 14.9088L19.0912 12.9289Z",
      fill: "currentColor"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.96094 7.25098C5.96094 6.69869 6.40865 6.25098 6.96094 6.25098H15.3609C15.9132 6.25098 16.3609 6.69869 16.3609 7.25098C16.3609 7.80326 15.9132 8.25098 15.3609 8.25098H6.96094C6.40865 8.25098 5.96094 7.80326 5.96094 7.25098ZM5.96094 12.051C5.96094 11.4987 6.40865 11.051 6.96094 11.051H13.6158C14.168 11.051 14.6158 11.4987 14.6158 12.051C14.6158 12.6033 14.168 13.051 13.6158 13.051H6.96094C6.40865 13.051 5.96094 12.6033 5.96094 12.051Z",
      fill: "currentColor"
    })
  ]),
  "billing-history": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.69922 4.8C3.69922 3.39274 4.71582 2 6.25922 2H18.7392C20.2826 2 21.2992 3.39274 21.2992 4.8V21C21.2992 21.3719 21.0928 21.7132 20.7633 21.8858C20.4339 22.0584 20.0358 22.0339 19.73 21.8222L17.6992 20.4163L15.6684 21.8222C15.326 22.0593 14.8725 22.0593 14.53 21.8222L12.4992 20.4163L10.4684 21.8222C10.126 22.0593 9.67245 22.0593 9.33001 21.8222L7.29922 20.4163L5.26843 21.8222C4.96262 22.0339 4.56457 22.0584 4.23511 21.8858C3.90565 21.7132 3.69922 21.3719 3.69922 21V4.8ZM6.25922 4C6.07949 4 5.69922 4.21904 5.69922 4.8V19.0914L6.73001 18.3778C7.07245 18.1407 7.52598 18.1407 7.86843 18.3778L9.89922 19.7837L11.93 18.3778C12.2725 18.1407 12.726 18.1407 13.0684 18.3778L15.0992 19.7837L17.13 18.3778C17.4725 18.1407 17.926 18.1407 18.2684 18.3778L19.2992 19.0914V4.8C19.2992 4.21904 18.9189 4 18.7392 4H6.25922ZM7.29922 7.8C7.29922 7.24772 7.74693 6.8 8.29922 6.8H16.6992C17.2515 6.8 17.6992 7.24772 17.6992 7.8C17.6992 8.35228 17.2515 8.8 16.6992 8.8H8.29922C7.74693 8.8 7.29922 8.35228 7.29922 7.8ZM7.29922 12.6C7.29922 12.0477 7.74693 11.6 8.29922 11.6H16.6992C17.2515 11.6 17.6992 12.0477 17.6992 12.6C17.6992 13.1523 17.2515 13.6 16.6992 13.6H8.29922C7.74693 13.6 7.29922 13.1523 7.29922 12.6Z",
      fill: "currentColor"
    })
  ]),
  manage: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M11.3386 3.80369H5.65213C3.76779 3.80369 2.24023 5.3312 2.24023 7.21548V18.5882C2.24023 20.4725 3.76779 22 5.65213 22H17.0251C18.9095 22 20.437 20.4725 20.437 18.5882L20.437 12.9018M7.92673 16.3136L12.0646 15.4799C12.2843 15.4356 12.4859 15.3274 12.6444 15.1689L21.9073 5.90116C22.3515 5.45682 22.3512 4.73657 21.9067 4.2926L19.9444 2.33264C19.5001 1.88886 18.7802 1.88916 18.3363 2.33332L9.07233 11.6021C8.91423 11.7602 8.80628 11.9615 8.76198 12.1807L7.92673 16.3136Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  "bucket-manage": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M12.9848 18.7203H10.1048C10.1048 18.7203 8.97227 18.7203 8.18477 18.7203C5.53352 18.7203 3.38477 16.5711 3.38477 13.9203C3.38477 11.7429 4.83414 9.90355 6.82164 9.31621C7.85852 6.94059 10.2285 5.28027 12.9848 5.28027C16.4066 5.28027 19.2323 7.83918 19.6504 11.1481C21.3341 11.5554 22.5848 13.0718 22.5848 14.8803",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    A("path", {
      d: "M17.1769 20.3298C16.7306 20.3298 16.3384 20.0341 16.2155 19.6051L15.2909 16.3758C15.108 15.7369 15.5877 15.1006 16.2523 15.1006H22.0038C22.6661 15.1006 23.1455 15.7329 22.9666 16.3706L22.0611 19.5998C21.94 20.0315 21.5465 20.3298 21.0982 20.3298H17.1769Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  "access-key-manage": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M11.925 18.7198H10.1048C10.1048 18.7198 8.97227 18.7198 8.18477 18.7198C5.53352 18.7198 3.38477 16.5706 3.38477 13.9198C3.38477 11.7424 4.83414 9.90307 6.82164 9.31572C7.85852 6.9401 10.2285 5.27979 12.9848 5.27979C16.4066 5.27979 19.2323 7.83869 19.6504 11.1476C21.3341 11.5549 22.5848 13.0713 22.5848 14.8798",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    A("circle", {
      cx: "17.6331",
      cy: "15.7913",
      r: "2.14062",
      transform: "rotate(30 17.6331 15.7913)",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    A("path", {
      d: "M13.1808 21.5022C12.9047 21.9805 13.0686 22.5921 13.5469 22.8682C14.0252 23.1443 14.6368 22.9805 14.9129 22.5022L13.1808 21.5022ZM16.4824 17.7837L15.6164 17.2837L13.1808 21.5022L14.0469 22.0022L14.9129 22.5022L17.3484 18.2837L16.4824 17.7837Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M16.2373 22.018C16.7156 22.2941 17.3272 22.1303 17.6033 21.652C17.8794 21.1737 17.7156 20.5621 17.2373 20.286L16.2373 22.018ZM15.0879 20.1997L14.5879 21.0657L16.2373 22.018L16.7373 21.152L17.2373 20.286L15.5879 19.3337L15.0879 20.1997Z",
      fill: "currentColor"
    })
  ]),
  "file-storage-manage": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M11.9789 19.5145H5.28725C3.96176 19.5145 2.88724 18.44 2.88725 17.1145L2.88734 7.99022C2.88735 7.0763 2.88701 5.77457 2.88672 4.83202C2.88651 4.1691 3.42385 3.63232 4.08677 3.63232H9.80498L12.57 6.58596H20.8863C21.5491 6.58596 22.0863 7.12322 22.0863 7.78596V10.9735",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    A("path", {
      d: "M20.5351 19.873C19.9506 19.873 19.0383 19.873 19.0383 19.873H17.7553C17.7553 19.873 17.2508 19.873 16.9 19.873C15.7189 19.873 14.7617 18.9156 14.7617 17.7347C14.7617 16.7647 15.4074 15.9453 16.2928 15.6837C16.7547 14.6254 17.8105 13.8857 19.0383 13.8857C20.5627 13.8857 21.8215 15.0257 22.0077 16.4997C22.7578 16.6812 23.3149 17.3567 23.3149 18.1624C23.3149 19.1071 22.549 19.873 21.6043 19.873C21.1917 19.873 20.9527 19.873 20.5351 19.873Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  firewall: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M3.70212 15.0205H9.438M21.2402 15.0205H17.0281M3.70212 9.01018H17.0281M21.2402 9.01018H17.0281M9.438 21H5.18245C4.10979 21 3.24023 20.1168 3.24023 19.0274L3.24023 4.9726C3.24023 3.88316 4.10979 3 5.18245 3L9.09611 3M9.438 21H19.0207C20.0934 21 20.963 20.1168 20.963 19.0274V4.9726C20.963 3.88316 20.0934 3 19.0207 3L9.09611 3M9.438 21V15.0205M9.438 15.0205H17.0281M17.0281 15.0205V9.01018M9.09611 8.51822V3",
      stroke: "currentColor",
      "stroke-width": "2"
    })
  ]),
  "firewall-policy-manage": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M3.70212 15.5205H9.438M3.70212 9.51018H17.0281M20.5994 9.51018H17.0281M9.438 21.5H5.18245C4.10979 21.5 3.24023 20.6168 3.24023 19.5274L3.24023 5.4726C3.24023 4.38316 4.10979 3.5 5.18245 3.5L9.09611 3.5M9.438 21.5V15.5205M9.438 21.5H14.2294M9.438 15.5205H14.2294M17.0281 9.51018V13.8082M9.09611 9.51018V3.5M9.09611 3.5L19.0207 3.5C20.0934 3.5 20.963 4.38316 20.963 5.4726V14.8572",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    A("path", {
      d: "M20.3145 17.0705C19.4845 16.6555 18.5075 16.6555 17.6775 17.0705L16.5391 17.6397V20.3792C16.5391 21.1204 17.4134 21.9636 18.996 22.963C20.5785 21.9636 21.4529 21.3251 21.4529 20.3792C21.4529 19.4333 21.4529 17.6397 21.4529 17.6397L20.3145 17.0705Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  "firewall-rule-manage": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M3.70212 15.5205H9.438M3.70212 9.51018H17.0281M20.5994 9.51018H17.0281M9.438 21.5H5.18245C4.10979 21.5 3.24023 20.6168 3.24023 19.5274L3.24023 5.4726C3.24023 4.38316 4.10979 3.5 5.18245 3.5L9.09611 3.5M9.438 21.5V15.5205M9.438 21.5H11.4066M9.438 15.5205H14.2294M17.0281 9.51018V12.8385M9.09611 9.51018V3.5M9.09611 3.5L19.0207 3.5C20.0934 3.5 20.963 4.38316 20.963 5.4726V11.7269",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    A("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.7968 13.8869C19.1473 13.5364 19.7156 13.5364 20.066 13.8869L23.1121 16.933C23.2804 17.1013 23.375 17.3296 23.375 17.5676C23.375 17.8056 23.2804 18.0339 23.1121 18.2022L18.543 22.7713C18.3747 22.9396 18.1464 23.0342 17.9084 23.0342H14.8623C14.3667 23.0342 13.9648 22.6324 13.9648 22.1367V19.0906C13.9648 18.8526 14.0594 18.6243 14.2277 18.456L18.7968 13.8869ZM19.4314 15.7907L15.7598 19.4624V21.2392H17.5367L21.2083 17.5676L19.4314 15.7907Z",
      fill: "currentColor"
    })
  ]),
  "security-group-manage": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M12.9617 21.9671C8.32412 19.0383 5.76172 18.0775 5.76172 14.3951V5.16709C8.57452 5.16709 10.2649 5.05989 12.9617 2.76709C15.6585 5.05989 17.3489 5.16709 20.1617 5.16709C20.1617 5.16709 20.1617 9.61129 20.1617 13.2937",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    A("path", {
      d: "M18.6477 14.4053C18.839 14.4053 19.0088 14.5437 19.0344 14.7402L19.1662 15.6572C19.3445 15.7387 19.5122 15.8363 19.6701 15.9492L20.5324 15.6025C20.5796 15.5837 20.6296 15.5771 20.6731 15.5771C20.8077 15.5772 20.9426 15.6452 21.0158 15.7744L21.7942 17.1201C21.8839 17.2852 21.8496 17.4975 21.6955 17.6191L20.9641 18.1914C20.9735 18.2848 20.9797 18.3815 20.9797 18.4834C20.9797 18.5853 20.9735 18.682 20.9641 18.7754L21.6955 19.3477C21.8496 19.4693 21.8839 19.6816 21.7942 19.8467L21.7912 19.8516L21.0158 21.1924C20.9436 21.3198 20.81 21.3896 20.677 21.3896C20.6313 21.3896 20.5866 21.3823 20.5442 21.3682L20.5383 21.3662L19.6692 21.0166C19.5127 21.127 19.3453 21.2272 19.1662 21.3096L19.0344 22.2266C19.0088 22.423 18.839 22.5615 18.6477 22.5615H17.0959C16.9047 22.5615 16.7348 22.423 16.7092 22.2266L16.5774 21.3096C16.3991 21.2281 16.2313 21.1305 16.0735 21.0176L15.2112 21.3643C15.164 21.3831 15.114 21.3896 15.0705 21.3896C14.9359 21.3895 14.801 21.3216 14.7278 21.1924L13.9494 19.8467C13.8597 19.6816 13.894 19.4693 14.0481 19.3477L14.7795 18.7754C14.77 18.6809 14.7639 18.5828 14.7639 18.4834C14.7639 18.384 14.77 18.2859 14.7795 18.1914L14.0481 17.6191L13.9973 17.5713C13.8896 17.4496 13.8628 17.2667 13.9524 17.1143L14.7278 15.7744C14.8 15.6471 14.9337 15.5773 15.0666 15.5771C15.1123 15.5771 15.1571 15.5845 15.1994 15.5986L15.2053 15.6006L16.0744 15.9502C16.2309 15.8398 16.3984 15.7396 16.5774 15.6572L16.7092 14.7402C16.7348 14.5438 16.9047 14.4053 17.0959 14.4053H18.6477ZM17.719 15.9316V15.9326L17.6408 16.4834L17.1252 16.6924C16.9846 16.7508 16.8397 16.8352 16.6838 16.9512L16.2453 17.2822L15.7375 17.0771L15.4045 16.9434L15.3059 17.1143L15.5891 17.334L16.0227 17.6748L15.9553 18.2227C15.9437 18.3385 15.9367 18.4176 15.9367 18.4834C15.9367 18.5494 15.9437 18.6288 15.9553 18.749L16.0227 19.2959L15.5881 19.6377L15.3059 19.8564L15.4045 20.0273L15.7375 19.8936L16.2541 19.6846L16.6965 20.0244C16.8386 20.1308 16.9789 20.2115 17.1291 20.2744L17.6457 20.4834L17.7727 21.3887H17.9719L18.0246 21.0352V21.0342L18.1028 20.4834L18.6184 20.2744C18.759 20.216 18.9039 20.1316 19.0598 20.0156L19.4983 19.6846L20.0061 19.8896L20.3391 20.0234L20.4377 19.8525L20.1545 19.6328L19.7209 19.292L19.7883 18.7441C19.7999 18.6281 19.8069 18.5529 19.8069 18.4834C19.8069 18.4103 19.8037 18.3373 19.7893 18.2256V18.2246L19.7209 17.6748L20.1545 17.334L20.4348 17.1113L20.3352 16.9395L20.0031 17.0732L19.4856 17.2822L19.0432 16.9424C18.9012 16.836 18.7607 16.7553 18.6106 16.6924L18.0949 16.4834L17.967 15.5781H17.7717L17.719 15.9316ZM17.8723 16.7334C18.8392 16.7336 19.6223 17.5165 19.6223 18.4834C19.6223 19.4503 18.8392 20.2332 17.8723 20.2334C16.9052 20.2334 16.1213 19.4505 16.1213 18.4834C16.1213 17.5163 16.9052 16.7334 17.8723 16.7334ZM17.8723 17.9062C17.5553 17.9062 17.2942 18.1664 17.2942 18.4834C17.2942 18.8004 17.5553 19.0605 17.8723 19.0605C18.1891 19.0603 18.4494 18.8003 18.4494 18.4834C18.4494 18.1665 18.1891 17.9065 17.8723 17.9062Z",
      fill: "currentColor"
    })
  ]),
  "load-balancer": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M13.01 16.1883H11.6527C11.1529 16.1883 10.7478 16.5934 10.7478 17.0932V19.8078C10.7478 20.3075 11.1529 20.7126 11.6527 20.7126H14.3673C14.867 20.7126 15.2721 20.3075 15.2721 19.8078V17.0932C15.2721 16.5934 14.867 16.1883 14.3673 16.1883H13.01ZM13.01 16.1883V8.65479M13.01 8.65479L20.2992 16.1883M13.01 8.65479L5.62348 16.1883M20.2992 16.1883H18.9419C18.4421 16.1883 18.037 16.5934 18.037 17.0932V19.8078C18.037 20.3075 18.4421 20.7126 18.9419 20.7126H21.6565C22.1562 20.7126 22.5613 20.3075 22.5613 19.8078V17.0932C22.5613 16.5934 22.1562 16.1883 21.6565 16.1883H20.2992ZM5.62348 16.1883H4.26619C3.76645 16.1883 3.36133 16.5934 3.36133 17.0932V19.8078C3.36133 20.3075 3.76645 20.7126 4.26619 20.7126H6.98077C7.48051 20.7126 7.88563 20.3075 7.88563 19.8078V17.0932C7.88563 16.5934 7.48051 16.1883 6.98077 16.1883H5.62348Z",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    A("rect", {
      x: "7.21484",
      y: "4.02197",
      width: "11.4932",
      height: "4.16895",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  tokenRegister: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M6.76951 9.30234H6.90954M12.2406 9.30234H12.3806M17.5701 9.30234H17.7101M11.6406 14.7023H4.77396C3.59575 14.7023 2.64062 13.7472 2.64062 12.569V6.03568C2.64062 4.85747 3.59575 3.90234 4.77396 3.90234H19.7073C20.8855 3.90234 21.8406 4.85747 21.8406 6.03568V9.30234M15.6518 13.5974L17.0418 12.9024C18.0553 12.3957 19.2483 12.3957 20.2618 12.9024L21.6518 13.5974C21.6518 13.5974 21.6518 15.7874 21.6518 16.9424C21.6518 18.0974 20.5841 18.8771 18.6518 20.0974C16.7195 18.8771 15.6518 17.8474 15.6518 16.9424V13.5974Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  buildRequest: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M14.243 2.20557C14.4929 2.20557 14.7032 2.38551 14.7332 2.62549L14.8933 3.74463L13.1512 5.75537L12.9334 4.20557H11.5428L11.3426 5.55518L11.1834 6.68604L10.1228 7.11572C9.71292 7.28571 9.30275 7.52529 8.87283 7.84521L7.97342 8.52588L6.93338 8.10596L5.66287 7.59521L4.96268 8.80518L6.04276 9.646L6.93338 10.3452L6.79276 11.4751C6.76276 11.7751 6.74295 12.0056 6.74295 12.2056C6.74295 12.4056 6.76276 12.6358 6.79276 12.9458L6.93338 14.0757L6.04276 14.7759L4.96268 15.6157L5.66287 16.8257L6.93338 16.3159L7.99295 15.8853L8.90311 16.5854C9.30298 16.8854 9.70275 17.1154 10.1326 17.2954L11.1931 17.7251L11.5428 20.2056H12.9431L13.1433 18.856L13.3025 17.7251L14.3631 17.2954C14.773 17.1254 15.1832 16.8858 15.6131 16.5659L16.5125 15.8853L17.5525 16.3052L18.823 16.8159L19.5232 15.606L18.4431 14.7651L17.5525 14.0659L17.6931 12.936C17.7231 12.636 17.743 12.4156 17.743 12.2056C17.743 11.9956 17.7331 11.7851 17.6931 11.4751L17.6658 11.2612L21.5213 8.2749L21.9031 8.93604C22.0228 9.15596 21.9729 9.42578 21.783 9.57568L19.6726 11.2251C19.7126 11.5451 19.743 11.8656 19.743 12.2056C19.743 12.5456 19.7126 12.866 19.6726 13.186L21.783 14.8354C21.9729 14.9854 22.0228 15.2552 21.9031 15.4751L19.9031 18.936C19.8131 19.0957 19.6432 19.1859 19.4734 19.186C19.4134 19.186 19.3528 19.1758 19.2928 19.1558L16.8025 18.1558C16.2827 18.5456 15.7228 18.8853 15.1131 19.1353L14.7332 21.7856C14.7032 22.0256 14.4929 22.2056 14.243 22.2056H10.243C9.99297 22.2056 9.78274 22.0256 9.75272 21.7856L9.37283 19.1353C8.76306 18.8853 8.20322 18.5556 7.68338 18.1558L5.19315 19.1558C5.14322 19.1757 5.08314 19.186 5.02322 19.186C4.84333 19.186 4.67284 19.0959 4.5828 18.936L2.5828 15.4751C2.46309 15.2552 2.51304 14.9854 2.70291 14.8354L4.81326 13.186C4.77326 12.866 4.74295 12.5356 4.74295 12.2056C4.74295 11.8756 4.77326 11.5451 4.81326 11.2251L2.70291 9.57568C2.51303 9.42578 2.45312 9.15596 2.5828 8.93604L4.5828 5.4751C4.67275 5.31543 4.84274 5.22527 5.01248 5.2251C5.07248 5.2251 5.13315 5.23537 5.19315 5.25537L7.68338 6.25537C8.20322 5.86553 8.76306 5.52581 9.37283 5.27588L9.75272 2.62549C9.78274 2.38551 9.99297 2.20557 10.243 2.20557H14.243Z",
      fill: "currentColor"
    }),
    A("path", {
      d: "M8.31573 12.3835C8.3265 12.508 8.60444 12.7472 8.72206 12.7898C8.83998 12.8328 8.97198 12.8035 9.06069 12.7153L10.8401 10.9359L13.1514 13.2472L11.3364 15.0554C11.2475 15.1438 11.2186 15.2753 11.2614 15.3926C11.3046 15.5101 11.5896 15.759 11.7148 15.7698C12.8171 15.8644 13.8972 15.4723 14.678 14.6943C15.7475 13.6287 16.0308 12.0727 15.5292 10.7464C15.584 10.7004 15.6381 10.6517 15.6915 10.5991L21.7501 4.9037C21.7522 4.90163 21.7543 4.89935 21.7566 4.89731C22.4691 4.18745 22.4691 3.03246 21.7566 2.32248C21.044 1.61268 19.8931 1.62131 19.1807 2.33117C19.1777 2.33403 19.1748 2.33688 19.172 2.34006L13.505 8.42284C13.4533 8.47453 13.4053 8.52862 13.3601 8.58413C12.0285 8.08359 10.4656 8.36508 9.39516 9.43132C8.61446 10.2094 8.22064 11.2855 8.31573 12.3835Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  recall: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M10.7398 21.5998H4.73983C3.41435 21.5998 2.33984 20.5253 2.33984 19.1998L2.33994 4.79989C2.33995 3.47441 3.41446 2.3999 4.73994 2.3999H15.5402C16.8657 2.3999 17.9402 3.47442 17.9402 4.7999V9.5999M6.54022 7.1999H13.7402M6.54022 10.7999H13.7402M6.54022 14.3999H10.1402M15.5828 20.3999L13.1402 17.9456M13.1402 17.9456L15.4724 15.5999M13.1402 17.9456H20.3674C21.3465 17.9456 22.1402 17.1519 22.1402 16.1728C22.1402 15.1936 21.3465 14.3999 20.3674 14.3999H17.9402",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  list: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M8.95984 6H21.8398M8.95984 12.48H21.8398M8.95984 18.96H21.8398M3.83984 6V6.0128M3.83984 12.48V12.4928M3.83984 18.96V18.9728",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  approvalHistory: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M7.43985 16.7999L12.4219 16.7999M7.43985 11.9999L16.7005 11.9999M7.43985 7.1999L17.0398 7.1999M21.8398 11.9999L21.8398 4.7999C21.8398 3.47442 20.7653 2.3999 19.4398 2.3999L5.03985 2.3999C3.71436 2.3999 2.63985 3.47442 2.63985 4.7999L2.63985 19.1999C2.63985 20.5254 3.71436 21.5999 5.03985 21.5999L16.7005 21.5999",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    A("path", {
      d: "M18.3086 17.3901L19.5086 18.5901L23.7086 14.3901",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  share: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M21.2404 11.4591L11.6404 5.1001L11.6404 8.7001C3.24023 10.5001 3.24023 18.9001 3.24023 18.9001C3.24023 18.9001 6.84023 14.1001 11.6404 14.7001L11.6404 18.4201L21.2404 11.4591Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linejoin": "round"
    })
  ]),
  "share-network": () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("circle", {
      cx: "6.85693",
      cy: "12.7656",
      r: "2.37061",
      transform: "rotate(-90 6.85693 12.7656)",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    A("circle", {
      cx: "17.6245",
      cy: "5.46387",
      r: "2.37061",
      transform: "rotate(-90 17.6245 5.46387)",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    A("circle", {
      cx: "17.6245",
      cy: "18.8647",
      r: "2.37061",
      transform: "rotate(-90 17.6245 18.8647)",
      stroke: "currentColor",
      "stroke-width": "2"
    }),
    A("path", {
      d: "M8.64844 11.2163L15.791 6.48096M8.64844 14.3218L15.791 18.4456",
      stroke: "currentColor",
      "stroke-width": "2"
    })
  ]),
  exchange: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M14.5029 10.1387C14.4071 9.86184 14.2322 9.62051 14.0005 9.44577C13.7689 9.27103 13.4913 9.17089 13.2033 9.15823H11.278C10.895 9.15823 10.5277 9.31318 10.2569 9.58899C9.98612 9.86481 9.83398 10.2389 9.83398 10.629C9.83398 11.019 9.98612 11.3931 10.2569 11.6689C10.5277 11.9447 10.895 12.0997 11.278 12.0997H13.2033C13.5863 12.0997 13.9536 12.2546 14.2244 12.5304C14.4952 12.8063 14.6473 13.1803 14.6473 13.5704C14.6473 13.9605 14.4952 14.3345 14.2244 14.6104C13.9536 14.8862 13.5863 15.0411 13.2033 15.0411H11.278C10.99 15.0285 10.7124 14.9283 10.4808 14.7536C10.2492 14.5788 10.0742 14.3375 9.97838 14.0606M12.2407 7.6875V9.15823M12.2407 15.0411V16.5119",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }),
    A("path", {
      d: "M19.1624 8.08567C17.7724 5.68616 15.1745 4.07178 12.199 4.07178C8.82536 4.07178 5.9371 6.14713 4.74457 9.08914M17.4159 9.08914H20.7402V6.00006M5.31811 16.1134C6.70805 18.513 9.30596 20.1273 12.2814 20.1273C15.6551 20.1273 18.5434 18.052 19.7359 15.11M6.90391 15.11H3.74023V17.9455",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    })
  ]),
  discount: () => A("svg", {
    width: "100%",
    height: "100%",
    viewBox: "0 0 25 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    A("path", {
      d: "M8.90039 15.5999L16.1004 8.3999M9.45429 8.94924L9.44014 8.93495M15.5648 15.1226L15.5507 15.1083M8.42325 4.38723L7.40534 4.44922C6.0839 4.5297 5.03019 5.58342 4.94971 6.90485L4.88772 7.92276C4.85215 8.50667 4.62218 9.06187 4.23444 9.4999L3.55851 10.2635C2.68102 11.2548 2.68102 12.745 3.55851 13.7363L4.23444 14.4999C4.62218 14.9379 4.85215 15.4931 4.88772 16.077L4.94971 17.0949C5.03019 18.4164 6.0839 19.4701 7.40534 19.5506L8.42325 19.6126C9.00716 19.6481 9.56236 19.8781 10.0004 20.2658L10.764 20.9418C11.7553 21.8193 13.2455 21.8193 14.2368 20.9418L15.0004 20.2658C15.4384 19.8781 15.9936 19.6481 16.5775 19.6126L17.5954 19.5506C18.9169 19.4701 19.9706 18.4164 20.0511 17.0949L20.1131 16.077C20.1486 15.4931 20.3786 14.9379 20.7663 14.4999L21.4423 13.7363C22.3198 12.745 22.3198 11.2548 21.4423 10.2635L20.7663 9.4999C20.3786 9.06187 20.1486 8.50667 20.1131 7.92276L20.0511 6.90485C19.9706 5.58341 18.9169 4.5297 17.5954 4.44922L16.5775 4.38723C15.9936 4.35167 15.4384 4.12169 15.0004 3.73395L14.2368 3.05802C13.2455 2.18053 11.7553 2.18053 10.764 3.05802L10.0004 3.73395C9.56236 4.12169 9.00716 4.35167 8.42325 4.38723Z",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round"
    })
  ])
}, ru = {
  __name: "SIcon",
  props: {
    name: {
      type: String,
      required: !0,
      validator: (e) => Object.keys(Kc).includes(e)
    },
    size: {
      type: [String, Number],
      default: 24
    },
    color: {
      type: String,
      default: "currentColor"
    },
    className: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e, n = C(() => {
      const a = Kc[t.name] || Kc["expand-more"];
      return a ? a() : null;
    }), i = C(() => ({
      width: typeof t.size == "number" ? `${t.size}px` : t.size,
      height: typeof t.size == "number" ? `${t.size}px` : t.size,
      color: t.color
    })), l = C(() => {
      const a = ["s-icon"];
      return t.className && a.push(t.className), a.join(" ");
    });
    return (a, r) => (j(), xe(j9(n.value), q({
      class: l.value,
      style: i.value
    }, a.$attrs), null, 16, ["class", "style"]));
  }
}, IA = {
  __name: "SConfirm",
  props: {
    contents: {
      type: String,
      default: "",
      description: " "
    },
    modelValue: {
      type: Boolean,
      default: !1,
      description: "  "
    },
    teleportId: {
      type: String,
      default: "destination",
      description: "Teleport ID"
    },
    confirmButtonText: {
      type: String,
      default: "",
      description: "  "
    },
    cancelButtonText: {
      type: String,
      default: "",
      description: "  "
    },
    noCancel: {
      type: Boolean,
      default: !1,
      description: "  "
    }
  },
  emits: ["update:model-value", "click:confirm", "click:cancel"],
  setup(e, { emit: t }) {
    const n = t, i = (r) => {
      n("update:model-value", r);
    }, l = () => n("click:confirm"), a = () => n("click:cancel", !1);
    return (r, s) => {
      const o = ae("v-card-text"), u = ae("v-card-actions"), c = ae("v-card"), d = ae("v-dialog");
      return j(), xe(fu, {
        to: `#${e.teleportId}`
      }, [
        m(d, {
          class: "s-confirm-modal",
          width: "446",
          persistent: "",
          "model-value": e.modelValue,
          "onUpdate:modelValue": i
        }, {
          default: W(() => [
            m(c, { "modal-height": "210" }, {
              default: W(() => [
                m(o, { class: "s-confirm-modal__text" }, {
                  default: W(() => [
                    ke(he(e.contents), 1)
                  ]),
                  _: 1
                }),
                m(u, { class: "button-wrapper" }, {
                  default: W(() => [
                    m(Me(rn), {
                      variant: "elevated",
                      color: "blue",
                      onClick: _t(l, ["stop"])
                    }, {
                      default: W(() => [
                        m(Me(ru), {
                          name: "check",
                          size: 16,
                          class: "mr-1"
                        }),
                        ke(" " + he(e.confirmButtonText), 1)
                      ]),
                      _: 1
                    }),
                    e.noCancel ? _e("", !0) : (j(), xe(Me(rn), {
                      key: 0,
                      variant: "outlined",
                      color: "blue",
                      onClick: a
                    }, {
                      default: W(() => [
                        m(Me(ru), {
                          name: "close",
                          size: 16,
                          class: "mr-1"
                        }),
                        ke(" " + he(e.cancelButtonText), 1)
                      ]),
                      _: 1
                    }))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["model-value"])
      ], 8, ["to"]);
    };
  }
}, DA = /* @__PURE__ */ bt(IA, [["__scopeId", "data-v-fe676b23"]]), BA = { class: "button-wrapper" }, EA = { class: "s-modal__content-wrapper" }, zA = { class: "s-modal__content" }, HA = { class: "s-modal__footer" }, jA = {
  __name: "SModal",
  props: {
    title: {
      type: String,
      default: "",
      description: "  "
    },
    className: {
      type: [Object, String],
      default: "",
      description: " "
    },
    modalWidth: {
      type: String,
      default: "",
      description: " "
    },
    modalHeight: {
      type: String,
      default: "",
      description: " "
    },
    modelValue: {
      type: Boolean,
      default: !1,
      description: "  "
    },
    isWhite: {
      type: Boolean,
      default: !1,
      description: "   "
    },
    bodyStyle: {
      type: Object,
      default: () => {
      },
      description: "card-body Div  "
    },
    popupCardClass: {
      type: String,
      default: "",
      description: "card  "
    },
    hideHeader: {
      type: Boolean,
      default: !1,
      description: " "
    },
    teleportId: {
      type: String,
      default: "destination",
      description: "Teleport ID"
    },
    size: {
      type: String,
      default: "medium",
      description: "modal size x-small, small, medium, large, x-large"
    }
  },
  emits: ["update:model-value", "on-fetch"],
  setup(e, { emit: t }) {
    const n = e, i = t, l = z(n.modelValue), a = (o) => {
      o ? (document.body.style.overflow = "hidden", document.body.style.paddingRight = "var(--v-scrollbar-offset)") : (document.body.style.overflow = "", document.body.style.paddingRight = "");
    };
    ee(() => n.modelValue, (o) => {
      o && i("on-fetch"), l.value = o, a(o);
    }), Wt(() => {
      a(!1);
    });
    const r = () => {
      l.value = !1, i("update:model-value", !1);
    }, s = (o) => {
      l.value = o, i("update:model-value", o);
    };
    return (o, u) => {
      const c = ae("v-icon"), d = ae("v-card"), f = ae("v-dialog");
      return j(), xe(fu, {
        to: `#${e.teleportId}`
      }, [
        m(f, {
          "model-value": l.value,
          width: e.modalWidth,
          "scroll-strategy": "block",
          class: ct(["s-modal", e.className]),
          size: e.size,
          persistent: "",
          scrim: "",
          "onUpdate:modelValue": s
        }, {
          activator: W(({ props: h }) => [
            Ae(o.$slots, "buttons", p7(h, !0), void 0, !0)
          ]),
          default: W(() => [
            m(d, {
              class: ct(["card-box", e.popupCardClass]),
              height: e.modalHeight,
              "min-height": e.modalHeight,
              "no-line": ""
            }, Gi({
              append: W(() => [
                G("div", HA, [
                  Ae(o.$slots, "footer", {}, void 0, !0)
                ])
              ]),
              _: 2
            }, [
              e.hideHeader ? void 0 : {
                name: "prepend",
                fn: W(() => [
                  G("div", {
                    class: ct(["s-modal__title", { "s-modal__title--light": e.isWhite, "s-modal__title--dark": !e.isWhite }])
                  }, [
                    G("span", null, he(e.title), 1),
                    G("div", BA, [
                      Ae(o.$slots, "header-btn-append", {}, void 0, !0),
                      m(Me(rn), {
                        class: "modal--cancel",
                        elevation: "0",
                        dense: "",
                        variant: "text",
                        "max-width": "24px",
                        height: "24px",
                        onClick: r
                      }, {
                        default: W(() => [
                          m(c, {
                            color: e.isWhite ? "#1A3350" : "#fff",
                            size: "x-large"
                          }, {
                            default: W(() => u[0] || (u[0] = [
                              ke("mdi-close")
                            ])),
                            _: 1
                          }, 8, ["color"])
                        ]),
                        _: 1
                      })
                    ])
                  ], 2)
                ]),
                key: "0"
              },
              e.modelValue ? {
                name: "item",
                fn: W(() => [
                  G("div", EA, [
                    G("div", zA, [
                      Ae(o.$slots, "default", {}, void 0, !0)
                    ])
                  ])
                ]),
                key: "1"
              } : void 0
            ]), 1032, ["class", "height", "min-height"])
          ]),
          _: 3
        }, 8, ["model-value", "width", "class", "size"])
      ], 8, ["to"]);
    };
  }
}, XA = /* @__PURE__ */ bt(jA, [["__scopeId", "data-v-31ba379c"]]), NA = {
  style: { width: "0", height: "0", position: "absolute" },
  "aria-hidden": "true",
  focusable: "false"
}, qA = ["viewBox"], no = 20, D6 = {
  __name: "SProgressCircular",
  props: {
    size: {
      type: Number,
      default: 50
    },
    width: {
      type: Number,
      default: 6
    }
  },
  setup(e) {
    const t = e, n = C(() => Math.max(0, Math.min(100, parseFloat(0)))), i = 2 * Math.PI * no, l = (o, u = "px") => {
      if (!(o === null || o === ""))
        return isNaN(o) ? String(o) : isFinite(o) ? `${Number(o)}${u}` : void 0;
    }, a = C(() => no / (1 - t.width / t.size) * 2), r = C(() => t.width / t.size * a.value), s = C(() => l((100 - n.value) / 100 * i));
    return it(() => {
    }), (o, u) => (j(), ne("div", {
      class: "s-progress-circular",
      style: on({ height: e.size + "px", width: e.size + "px", "--stroke-width": e.width + "px" })
    }, [
      (j(), ne("svg", NA, u[0] || (u[0] = [
        G("linearGradient", { id: "gradientColor" }, [
          G("stop", {
            offset: "0%",
            "stop-color": "#1B75BB"
          }),
          G("stop", {
            offset: "100%",
            "stop-color": "#7C0F80"
          })
        ], -1)
      ]))),
      (j(), ne("svg", {
        class: "s-progress-circular__wrapper",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${a.value} ${a.value}`
      }, [
        G("circle", {
          class: "s-progress-circular__underlay",
          cx: "50%",
          cy: "50%",
          fill: "transparent",
          r: no,
          style: on({
            strokeWidth: r.value,
            strokeDasharray: i,
            strokeDashoffset: 0
          })
        }, null, 4),
        G("circle", {
          class: "s-progress-circular__overlay",
          fill: "transparent",
          cx: "50%",
          cy: "50%",
          r: no,
          style: on({
            strokeWidth: r.value,
            strokeDasharray: i,
            strokeDashoffset: s.value
          })
        }, null, 4)
      ], 8, qA))
    ], 4));
  }
}, YA = { class: "s-loading" }, FA = { class: "s-loading__message" }, WA = { class: "s-loading__spinner" }, UA = {
  __name: "SGlobalProgress",
  props: {
    loadingMessage: {
      type: String,
      default: "Check-loading",
      description: "  "
    },
    modelValue: {
      type: Boolean,
      default: !1,
      description: "  "
    },
    teleportId: {
      type: String,
      default: "destination",
      description: "Teleport ID"
    }
  },
  setup(e) {
    return (t, n) => (j(), xe(fu, {
      to: `#${e.teleportId}`
    }, [
      m(Me(Fn), {
        "model-value": e.modelValue,
        class: "custom-overlay",
        contained: "",
        persistent: "",
        "no-click-animation": "",
        scrim: "transparent",
        "z-index": "9999",
        offset: [0, 50]
      }, {
        default: W(() => [
          G("div", YA, [
            G("div", FA, he(e.loadingMessage), 1),
            G("div", WA, [
              m(D6)
            ]),
            n[0] || (n[0] = G("div", { class: "s-loading__text" }, "Please wait...", -1))
          ])
        ]),
        _: 1
      }, 8, ["model-value"])
    ], 8, ["to"]));
  }
}, GA = { class: "s-card-table__wrapper" }, KA = {
  key: 0,
  class: "s-card-table__header"
}, JA = { class: "s-card-table__header-item" }, eR = {
  key: 0,
  class: "s-card-table__header-item-title",
  style: { width: "50px" }
}, tR = ["data-sorted", "onClick"], nR = { class: "s-card-table__body-row" }, iR = {
  key: 0,
  class: "s-card__body-icon--expand"
}, lR = {
  key: 1,
  style: { width: "50px" }
}, aR = {
  key: 0,
  class: "s-card-table__body-row-expand"
}, rR = {
  __name: "SCardTable",
  props: {
    itemValue: {
      type: String,
      default: "id",
      description: "selected item value"
    },
    itemTitle: {
      type: String,
      default: void 0,
      description: "title  item "
    },
    outlined: {
      type: Boolean,
      default: !1,
      description: ""
    },
    shadowed: {
      type: Boolean,
      default: !1,
      description: ""
    },
    items: {
      type: Array,
      default: () => []
    },
    headers: {
      type: Array,
      default: () => [],
      description: "key, title   Array(Object)"
    },
    itemsPerPage: {
      type: [Number, String],
      default: 5,
      description: "per page"
    },
    noDataText: {
      type: String,
      default: "no data.",
      description: "       "
    },
    page: {
      type: [Number, String],
      default: 1,
      description: "   ( 1)"
    },
    isPageRender: {
      type: Boolean,
      default: !1,
      description: "    "
    },
    search: {
      type: [String, Array],
      default: void 0,
      description: "     key:value Object    "
    },
    smartSearch: {
      type: Array,
      default: () => [],
      description: "smart search "
    },
    showSelect: {
      type: Boolean,
      default: !1,
      description: "     (   )."
    },
    options: {
      type: Object,
      default: () => ({
        strongs: [],
        pageCnt: 0,
        totalElements: 0
      }),
      description: ""
    },
    selected: {
      type: Array,
      default: () => []
    },
    width: {
      type: [Number, String],
      default: "100%"
    },
    showExpand: {
      type: Boolean,
      default: !1
    },
    hiddenHeader: {
      type: Boolean,
      default: !1
    },
    scrolled: {
      type: Boolean,
      default: !1
    },
    class: {
      type: String,
      default: ""
    },
    setTotal: {
      type: Function,
      default: () => {
      },
      description: "  ( )"
    },
    showSelect: {
      type: Boolean,
      default: !1
    },
    selectStrategy: {
      type: String,
      default: "single",
      description: "select strategy   single, all (page    .)"
    },
    disableSort: {
      type: Boolean,
      default: !1,
      description: "   "
    },
    sortBy: {
      type: Array,
      default: () => [],
      description: "   "
    }
  },
  emits: [
    "update:page",
    "update:selected",
    "update:filtered-cnt",
    "update:sort-by"
  ],
  setup(e, { emit: t }) {
    const { isEmpty: n } = q9, i = e, l = t, a = z(1), r = C({
      get: () => i.page,
      set: ($) => l("update:page", $)
    }), s = C(() => i.headers.filter(($) => $.key !== i.itemTitle)), o = ($) => {
      if (i.disableSort) return;
      let x = [...i.sortBy];
      const Q = x.find((M) => M.key === $.key);
      Q ? Q.order === "asc" ? Q.order = "desc" : Q.order === "desc" && (x = x.filter((M) => M.key !== $.key)) : x = [{ key: $.key, order: "asc" }], l("update:sort-by", x);
    }, u = C(() => {
      var $;
      if (i.search) {
        const x = i.headers.map((M) => M.key), Q = i.items.filter(
          (M) => x.some((w) => M[w] ? typeof M[w] == typeof {} || typeof M[w] == typeof [] ? JSON.stringify(M[w]).toLowerCase().indexOf(i.search.toLowerCase()) > -1 : M[w].toString().toLowerCase().indexOf(i.search.toLowerCase()) > -1 : !1)
        );
        return l("update:filtered-cnt", Q.length), Q;
      }
      if (i.smartSearch.length) {
        const x = i.items.filter((Q) => {
          const M = i.smartSearch.reduce((w, y) => (w[y.key] || (w[y.key] = []), w[y.key].push(y), w), {});
          return Object.entries(M).every(([w, y]) => {
            var L;
            return w === "undefinedTag" ? !((L = Q.tagList) != null && L.length) : y.some((k) => {
              var S;
              return k.value ? k.type === "tag" && ((S = Q.tagList) != null && S.length) ? Q.tagList.some(
                (P) => P.tagKey.toLowerCase() === k.key.toLowerCase() && P.tagValue.toLowerCase() === k.value.toLowerCase()
              ) : k.type !== "tag" ? typeof Q[k.key] == "object" ? JSON.stringify(Q[k.key]).toLowerCase() === k.value.toLowerCase() : typeof Q[k.key] == "number" ? Q[k.key].toString() === k.value : Q[k.key].toLowerCase() === k.value.toLowerCase() : !1 : !0;
            });
          });
        });
        return l("update:filtered-cnt", x.length), x;
      }
      return l("update:filtered-cnt", (($ = i.items) == null ? void 0 : $.length) || 0), i.items || [];
    }), c = C(() => !u.value.length || !i.sortBy.length ? u.value : [...u.value].sort(($, x) => {
      const Q = i.sortBy[0], M = Q.key, w = $[M], y = x[M];
      if (w == null) return 1;
      if (y == null) return -1;
      if (typeof w == "number" && typeof y == "number")
        return Q.order === "asc" ? w - y : y - w;
      const L = String(w).toLowerCase(), k = String(y).toLowerCase();
      return Q.order === "asc" ? L.localeCompare(k) : k.localeCompare(L);
    })), d = C(() => {
      var $;
      if (!(($ = i.options) != null && $.pageCnt)) {
        const x = (i.page - 1) * i.itemsPerPage, Q = x + i.itemsPerPage;
        return c.value.slice(x, Q);
      }
      return c.value;
    }), f = z([]), h = ($) => {
      i.selectStrategy === "single" ? f.value.includes($[i.itemValue]) ? f.value = [] : f.value = [$[i.itemValue]] : f.value.includes($[i.itemValue]) ? f.value = f.value.filter((x) => x !== $[i.itemValue]) : f.value.push($[i.itemValue]), l("update:selected", f.value);
    }, g = ($) => {
      r.value = $, a.value = $;
    }, v = ($) => {
      g($);
    }, p = C(() => {
      var $, x;
      return i.itemsPerPage !== -1 ? (($ = i.options) == null ? void 0 : $.pageCnt) || Math.ceil(u.value.length / i.itemsPerPage) : ((x = i.options) == null ? void 0 : x.pageCnt) || Math.ceil(u.value.length);
    }), O = C(() => ($) => typeof $ == "number" ? `${$}%` : $ || "100px"), b = ($) => {
      $.showExpandRow = !$.showExpandRow;
    };
    ee(
      () => [i.search, i.smartSearch],
      () => {
        g(1);
      },
      { deep: !0 }
    ), ee(
      () => u.value,
      ($) => {
        i.setTotal($.length);
      }
    ), it(() => {
      a.value = i.page;
    });
    const V = ($) => {
      const x = i.sortBy.find((Q) => Q.key === $.key);
      return x ? x.order === "asc" ? "mdi-arrow-up" : "mdi-arrow-down" : "mdi-arrow-up";
    };
    return ($, x) => {
      var L;
      const Q = ae("v-icon"), M = ae("v-btn"), w = ae("v-checkbox-btn"), y = ae("v-pagination");
      return j(), ne("div", {
        class: ct(`s-card-table ${i.class}`)
      }, [
        G("div", GA, [
          e.hiddenHeader ? _e("", !0) : (j(), ne("div", KA, [
            G("ul", JA, [
              e.showSelect ? (j(), ne("li", eR)) : _e("", !0),
              (j(!0), ne(le, null, vt(s.value, (k, S) => (j(), ne("li", {
                key: "header-key--" + S,
                class: ct(["s-card-table__header-item-title", { sortable: !k.disableSort }]),
                "data-sorted": !!i.sortBy.find((P) => P.key === k.key),
                style: on({
                  width: O.value(k.width),
                  justifyContent: k.align
                }),
                onClick: (P) => !k.disableSort && o(k)
              }, [
                ke(he(k.title) + " ", 1),
                k.disableSort ? _e("", !0) : (j(), xe(Q, {
                  key: 0,
                  icon: V(k),
                  size: "small",
                  class: "ml-1 sort-icon"
                }, null, 8, ["icon"]))
              ], 14, tR))), 128))
            ])
          ])),
          d.value.length ? (j(!0), ne(le, { key: 1 }, vt(d.value, (k, S) => (j(), ne("ul", {
            key: "content-row--" + S,
            class: "s-card-table__body"
          }, [
            G("li", nR, [
              G("div", {
                class: ct(`s-card-table__body-item ${e.showExpand ? "table-expand_header" : "table-expand_body"}`)
              }, [
                e.showExpand ? (j(), ne("div", iR, [
                  Ae($.$slots, "table-expand", {
                    item: k,
                    expanded: k.showExpandRow,
                    onClickExpand: b
                  }, () => [
                    m(M, {
                      density: "comfortable",
                      variant: "text",
                      icon: k.showExpandRow ? "mdi-chevron-up" : "mdi-chevron-down",
                      onClick: _t((P) => b(k), ["stop", "prevent"])
                    }, null, 8, ["icon", "onClick"])
                  ])
                ])) : _e("", !0),
                e.showSelect ? (j(), ne("div", lR, [
                  Ae($.$slots, "table-select", { item: k }, () => [
                    m(w, {
                      "model-value": f.value.includes(k[e.itemValue]),
                      "onUpdate:modelValue": (P) => h(k)
                    }, null, 8, ["model-value", "onUpdate:modelValue"])
                  ])
                ])) : _e("", !0),
                (j(!0), ne(le, null, vt(s.value, (P, T) => {
                  var _, D;
                  return j(), ne("div", {
                    key: "content-row--" + S + "__col--" + T,
                    class: ct(["s-card-table__body-wrapper", { "strong-text": (D = (_ = e.options) == null ? void 0 : _.strongs) == null ? void 0 : D.includes(P.key) }]),
                    style: on({
                      width: O.value(P.width),
                      justifyContent: P.align === "d-none" ? "center" : P.align || "center"
                    })
                  }, [
                    Ae($.$slots, `${P.key}`, { item: k }, () => [
                      ke(he(Me(n)(k[P.key]) ? "-" : k[P.key]), 1)
                    ])
                  ], 6);
                }), 128))
              ], 2),
              k.showExpandRow ? (j(), ne("div", aR, [
                Ae($.$slots, "expanded-row", {
                  item: k,
                  columns: s.value
                })
              ])) : _e("", !0)
            ])
          ]))), 128)) : (j(), xe(s3, {
            key: 2,
            description: e.noDataText,
            class: "s-card-table__empty"
          }, {
            default: W(() => [
              Ae($.$slots, "empty-content")
            ]),
            _: 3
          }, 8, ["description"]))
        ]),
        e.scrolled ? _e("", !0) : (j(), xe(y, {
          key: 0,
          "model-value": r.value,
          class: "s-card-table__pagination",
          size: "small",
          rounded: "",
          "active-color": "#0D69D4",
          variant: "flat",
          "total-visible": 10,
          length: ((L = e.options) == null ? void 0 : L.pageCnt) || p.value,
          "onUpdate:modelValue": v
        }, null, 8, ["model-value", "length"]))
      ], 2);
    };
  }
}, sR = { key: 1 }, oR = { class: "text-center no-data" }, uR = { key: 0 }, cR = { class: "v-data-table__tr" }, dR = ["width"], fR = {
  key: 0,
  class: "text-center s-data-table-pagination"
}, hR = {
  __name: "SDataTable",
  props: {
    // search: String,
    options: {
      type: Object,
      default: () => {
      }
    },
    getChipColors: {
      type: Function,
      default: void 0
    },
    // onClickChips: Function,
    customFilter: {
      type: [Number, Boolean, Array],
      default: void 0,
      description: "  "
    },
    customKeyFilter: {
      type: Object,
      default: void 0,
      description: ""
    },
    expanded: {
      type: Array,
      default: () => [],
      description: ""
    },
    expandOnClick: {
      type: Boolean,
      default: !1,
      description: ""
    },
    filterKeys: {
      type: [String, Array],
      default: void 0,
      description: ""
    },
    filterMode: {
      type: String,
      default: "intersection",
      description: ""
    },
    fixedFooter: {
      type: Boolean,
      default: !1,
      description: ""
    },
    fixedHeader: {
      type: Boolean,
      default: !1,
      description: "  . (deprecated)"
    },
    groupBy: {
      type: Array,
      default: () => [],
      description: "       .     : group [group].       . .sync     ."
    },
    headers: {
      type: Array,
      default: () => [],
      description: "     ."
    },
    height: {
      type: [String, Number],
      default: void 0,
      description: "   "
    },
    hideNoData: {
      type: Boolean,
      default: !1,
      description: ""
    },
    itemProps: {
      type: [Boolean, String, Array, Function],
      default: "props",
      description: "     props . true    props     ."
    },
    items: {
      type: Array,
      default: () => [],
      description: "          "
    },
    itemsPerPage: {
      type: [String, Number],
      default: 10,
      description: "    . .sync     .  prop -1     ."
    },
    itemValue: {
      type: [Boolean, String, Array, Function],
      default: "id",
      description: ""
    },
    modelValue: {
      type: Array,
      default: () => [],
      description: "  v-model .         ."
    },
    multiSort: {
      type: Boolean,
      default: !1,
      description: "true       ."
    },
    mustSort: {
      type: Boolean,
      default: !1,
      description: "true          ."
    },
    noDataText: {
      type: String,
      default: "no data.",
      description: "       "
    },
    noFilter: {
      type: Boolean,
      default: !1,
      description: ""
    },
    page: {
      type: [String, Number],
      default: 1,
      description: "   ( 1)"
    },
    returnObject: {
      type: Boolean,
      default: !1,
      description: ""
    },
    search: {
      type: String,
      default: void 0,
      description: "    "
    },
    showExpand: {
      type: Boolean,
      default: !1,
      description: "    ."
    },
    showSelect: {
      type: Boolean,
      default: !1,
      description: "     (   )."
    },
    sortBy: {
      type: Array,
      default: () => [],
      description: "      . .sync     ."
    },
    selectStrategy: {
      type: String,
      default: "page"
    },
    width: {
      type: [String, Number],
      default: void 0,
      description: "   ."
    },
    // custom
    single: {
      type: Boolean,
      default: !1,
      description: "select model  / ."
    },
    hideFooter: {
      type: Boolean,
      default: !1,
      description: "footer hide"
    },
    footers: {
      type: Object,
      default: () => {
      },
      description: "tfoot   "
    },
    customSlotFooter: {
      type: Object,
      default: () => {
      },
      description: "custom footer"
    },
    smartSearch: {
      type: Array,
      default: () => [],
      description: "Smart Search  "
    },
    fixedTable: {
      type: Boolean,
      default: !1
    },
    setTotal: {
      type: Function,
      default: () => {
      },
      description: "  ( )"
    },
    density: {
      type: String,
      default: "default",
      description: "default | comfortable | compact "
    },
    tooltip: {
      type: Boolean,
      default: !1,
      description: "  (   class fixed-table   .)"
    },
    itemSelectable: {
      type: String,
      default: null,
      description: " checkbox         . (: selectable)"
    },
    disableSort: {
      type: Boolean,
      default: !1,
      description: "  "
    },
    loading: {
      type: Boolean,
      default: !1,
      description: " "
    },
    hover: {
      type: Boolean,
      default: !1,
      description: "hover "
    },
    fixedTable: {
      type: Boolean,
      default: !1,
      description: "  "
    }
  },
  emits: [
    "update:page",
    "update:filter",
    "update:search",
    "update:sort-by",
    "update:sort-desc",
    "update:group-by",
    "update:expanded",
    "update:options",
    "update:model-value",
    "get-checkedbox-item",
    "update:filtered-cnt"
  ],
  setup(e, { emit: t }) {
    const { isEmpty: n } = q9, i = t, l = e, a = z([]), r = z([]), s = z([]), o = z([]), u = (V) => {
      i("get-checkedbox-item", V), a.value = V, i("update:model-value", a.value);
    }, c = C(() => {
      if (l.search) {
        const $ = l.headers.map((M) => M.key), x = l.search, Q = l.items.filter(
          (M) => $.some((w) => {
            var L, k;
            const y = M[w];
            return (x === "-" || x === "null" || x === "undefined" || x === "") && n(y) ? !0 : n(y) ? !1 : typeof y == typeof {} || typeof y == typeof [] ? ((L = JSON.stringify(y)) == null ? void 0 : L.indexOf(x)) > -1 : ((k = y == null ? void 0 : y.toString()) == null ? void 0 : k.indexOf(x)) > -1;
          })
        );
        return i("update:filtered-cnt", Q.length), Q;
      }
      if (l.smartSearch.length) {
        const $ = l.items.filter((x) => {
          const Q = l.smartSearch.reduce((M, w) => (M[w.key] || (M[w.key] = []), M[w.key].push(w), M), {});
          return Object.entries(Q).every(([M, w]) => {
            var y;
            return M === "undefinedTag" ? !((y = x.tagList) != null && y.length) : w.some((L) => {
              var k, S;
              return L.value ? L.type === "tag" && ((k = x.tagList) != null && k.length) ? x.tagList.some((P) => {
                const T = P.tagKey === L.key;
                return L.value === "-" || L.value === "null" || L.value === "undefined" || L.value === "" ? T && n(P.tagValue) : T && P.tagValue === L.value;
              }) : L.type !== "tag" ? L.value === "-" || L.value === "null" || L.value === "undefined" || L.value === "" ? n(x[L.key]) : typeof x[L.key] == "object" ? JSON.stringify(x[L.key]) === L.value : typeof x[L.key] == "number" ? ((S = x[L.key]) == null ? void 0 : S.toString()) === L.value : x[L.key] === L.value : !1 : !0;
            });
          });
        });
        return i("update:filtered-cnt", $.length), $;
      }
      let V = l.items || [];
      return i("update:filtered-cnt", V.length), r.value.length > 0 && (V = [...V].sort(($, x) => {
        for (let Q = 0; Q < r.value.length; Q++) {
          const M = r.value[Q], w = M.key || M, y = s.value[Q] || !1, L = l.headers.find((_) => _.key === w || _.value === w), k = (L == null ? void 0 : L.sortKey) || w;
          let S = $[k], P = x[k];
          if (((L == null ? void 0 : L.type) || (L != null && L.sortKey ? "number" : "string")) === "number") {
            if (S = Number(String(S).replace(/,/g, "")), P = Number(String(P).replace(/,/g, "")), isNaN(S) && (S = 0), isNaN(P) && (P = 0), console.log(`Sorting ${k}: aValue=${S}, bValue=${P}, desc=${y}`), S < P) return y ? 1 : -1;
            if (S > P) return y ? -1 : 1;
          } else {
            S == null && (S = ""), P == null && (P = "");
            const _ = S.toString().localeCompare(P.toString(), void 0, { numeric: !0 });
            if (_ !== 0) return y ? -_ : _;
          }
        }
        return 0;
      })), V;
    }), d = C(() => {
      var V, $;
      return l.itemsPerPage !== -1 ? ((V = l.options) == null ? void 0 : V.pageCnt) || Math.ceil(c.value.length / l.itemsPerPage) : (($ = l.options) == null ? void 0 : $.pageCnt) || Math.ceil(c.value.length);
    }), f = z(), h = (V) => {
      i("update:page", V);
    }, g = (V) => {
      if (Array.isArray(V) && V.length > 0) {
        console.log("e[0]:", V[0]);
        const $ = V[0], x = r.value.find((M) => M.key === $.key);
        let Q = "asc";
        x ? x.order === "asc" ? Q = "desc" : x.order === "desc" && (Q = null) : Q = "asc", Q === null ? (r.value = [], s.value = []) : (r.value = [{ key: $.key, order: Q }], s.value = [Q === "desc"]);
      } else
        r.value = [], s.value = [];
      i("update:sort-by", []), i("update:page", 1);
    }, v = (V) => {
      if (!l.disableSort) {
        if (Array.isArray(V) && V.length > 0) {
          const $ = V[0], x = l.headers.find((Q) => Q.key === $.key);
          if (x && x.sortable === !1)
            return;
        }
        g(V);
      }
    }, p = C({
      get: () => l.page,
      set: (V) => i("update:page", V)
    });
    ee(
      () => l.headers,
      (V) => {
        o.value = V.filter(($) => $.align !== "d-none");
      },
      { immediate: !0 }
    ), ee(
      () => l.modelValue,
      (V) => {
        a.value = V;
      },
      { immediate: !0 }
    ), ee(
      () => l.smartSearch,
      () => {
        i("update:page", 1);
      },
      {
        deep: !0
      }
    ), ee(
      () => l.itemsPerPage,
      () => {
        i("update:page", 1);
      }
    ), it(() => {
    });
    const O = (V) => V.highlight || "", b = (V) => {
      var $, x;
      return V && (($ = V == null ? void 0 : V.toString()) != null && $.endsWith("%") || (x = V == null ? void 0 : V.toString()) != null && x.endsWith("px")) ? V : V ? `${V}px` : "250px";
    };
    return (V, $) => {
      const x = ae("v-tooltip"), Q = ae("v-checkbox-btn"), M = ae("v-pagination"), w = ae("v-data-table");
      return j(), xe(w, q({
        ref_key: "sDataTableRef",
        ref: f,
        class: ["s-data-table", { "disable-sort": e.disableSort, "fixed-table": e.fixedTable }]
      }, V.$attrs, {
        headers: o.value,
        "fixed-header": e.fixedHeader,
        height: e.height,
        items: c.value,
        page: p.value,
        "items-per-page": e.itemsPerPage,
        search: e.search,
        "item-value": e.itemValue,
        "show-select": e.showSelect,
        "return-object": e.returnObject,
        "model-value": a.value,
        "select-strategy": e.selectStrategy,
        loading: e.loading,
        hover: e.hover,
        "show-expand": e.showExpand,
        "disable-sort": e.disableSort,
        expanded: e.expanded,
        "expand-on-click": e.expandOnClick,
        "item-class": O,
        "sort-by": [],
        "onUpdate:sortBy": v,
        "onUpdate:modelValue": u,
        "onUpdate:options": $[0] || ($[0] = (y) => V.$emit("update:options", y)),
        "onUpdate:expanded": $[1] || ($[1] = (y) => V.$emit("update:expanded", y))
      }), Gi({
        "no-data": W(() => [
          G("div", oR, he(e.noDataText), 1)
        ]),
        tfoot: W((y) => [
          Ae(V.$slots, "tfoot", Hn(jn(y)), () => [
            e.footers && Object.keys(e.footers).length ? (j(), ne("tfoot", uR, [
              G("tr", cR, [
                (j(!0), ne(le, null, vt(o.value, (L, k) => (j(), ne(le, {
                  key: "foot__" + k
                }, [
                  L.align !== "d-none" ? (j(), ne("td", {
                    key: 0,
                    class: "v-data-table__td",
                    width: L.width,
                    style: on({ textAlign: L.align || "start" })
                  }, [
                    V.$slots[`footer.${L.key}`] ? (j(), ne("span", {
                      key: 0,
                      class: ct([e.footers.highlight])
                    }, [
                      Ae(V.$slots, `footer.${L.key}`, { props: e.footers }, void 0, !0)
                    ], 2)) : (j(), ne("span", {
                      key: 1,
                      class: ct([e.footers.highlight])
                    }, he(e.footers[L.key]), 3))
                  ], 12, dR)) : _e("", !0)
                ], 64))), 128))
              ])
            ])) : _e("", !0)
          ], !0)
        ]),
        bottom: W(() => {
          var y;
          return [
            Ae(V.$slots, "append-content", {}, void 0, !0),
            e.hideFooter ? _e("", !0) : (j(), ne("div", fR, [
              m(M, {
                "model-value": p.value,
                size: "small",
                rounded: "",
                "active-color": "#1B75BB",
                variant: "flat",
                "total-visible": 10,
                length: ((y = e.options) == null ? void 0 : y.pageCnt) || d.value,
                "onUpdate:modelValue": h
              }, null, 8, ["model-value", "length"])
            ]))
          ];
        }),
        _: 2
      }, [
        V.$slots.headers ? {
          name: "headers",
          fn: W((y) => [
            Ae(V.$slots, "headers", Hn(jn(y)), void 0, !0)
          ]),
          key: "0"
        } : void 0,
        vt(o.value, (y, L) => ({
          name: `item.${y.key}`,
          fn: W((k) => [
            e.tooltip ? (j(), xe(x, {
              key: 0,
              location: "bottom"
            }, {
              activator: W(({ props: S }) => [
                V.$slots[`item.${y.key}`] ? (j(), ne("span", sR, [
                  Ae(V.$slots, `item.${y.key}`, Hn(jn(k)), () => [
                    ke(he(Me(n)(k.item[y.key]) ? "-" : k.item[y.key]), 1)
                  ], !0)
                ])) : (j(), ne("span", q({ key: 0 }, S, {
                  class: ["d-inline-block text-truncate s-table-column__text", [
                    k.item.highlight
                  ]],
                  style: {
                    maxWidth: b(y.width)
                  }
                }), he(Me(n)(k.item[y.key]) ? "-" : k.item[y.key]), 17))
              ]),
              default: W(() => [
                G("span", null, he(Me(n)(k.item[y.key]) ? "-" : k.item[y.key]), 1)
              ]),
              _: 2
            }, 1024)) : (j(), ne("div", {
              key: 1,
              class: ct([
                k.item.highlight
              ])
            }, [
              Ae(V.$slots, `item.${y.key}`, Hn(jn(k)), () => [
                ke(he(Me(n)(k.item[y.key]) ? "-" : k.item[y.key]), 1)
              ], !0)
            ], 2))
          ])
        })),
        V.$slots["header.data-table-select"] ? {
          name: "header.data-table-select",
          fn: W((y) => [
            Ae(V.$slots, "header.data-table-select", Hn(jn(y)), () => [
              m(Q, {
                indeterminate: y.someSelected && !y.allSelected,
                "model-value": y.allSelected,
                "onUpdate:modelValue": (L) => y.selectAll(!y.allSelected)
              }, null, 8, ["indeterminate", "model-value", "onUpdate:modelValue"])
            ], !0)
          ]),
          key: "1"
        } : void 0,
        V.$slots["item.data-table-select"] ? {
          name: "item.data-table-select",
          fn: W((y) => [
            Ae(V.$slots, "item.data-table-select", Hn(jn(y)), () => [
              y.item.selectable ? (j(), xe(Q, {
                key: 0,
                "model-value": y.isSelected(y.item),
                "onUpdate:modelValue": (L) => y.toggleSelect(y.item)
              }, null, 8, ["model-value", "onUpdate:modelValue"])) : (j(), ne(le, { key: 1 }, [], 64))
            ], !0)
          ]),
          key: "2"
        } : void 0,
        V.$slots.item ? {
          name: "item",
          fn: W((y) => [
            Ae(V.$slots, "item", Hn(jn(y)), void 0, !0)
          ]),
          key: "3"
        } : void 0,
        V.$slots.body ? {
          name: "body",
          fn: W((y) => [
            Ae(V.$slots, "body", Hn(jn(y)), void 0, !0)
          ]),
          key: "4"
        } : void 0,
        V.$slots["body.append"] ? {
          name: "body.append",
          fn: W((y) => [
            Ae(V.$slots, "body.append", Hn(jn(y)), void 0, !0)
          ]),
          key: "5"
        } : void 0,
        V.$slots.tbody ? {
          name: "tbody",
          fn: W((y) => [
            Ae(V.$slots, "tbody", Hn(jn(y)), void 0, !0)
          ]),
          key: "6"
        } : void 0,
        V.$slots["expanded-row"] ? {
          name: "expanded-row",
          fn: W((y) => [
            Ae(V.$slots, "expanded-row", Hn(jn(y)), void 0, !0)
          ]),
          key: "7"
        } : void 0
      ]), 1040, ["class", "headers", "fixed-header", "height", "items", "page", "items-per-page", "search", "item-value", "show-select", "return-object", "model-value", "select-strategy", "loading", "hover", "show-expand", "disable-sort", "expanded", "expand-on-click"]);
    };
  }
}, mR = /* @__PURE__ */ bt(hR, [["__scopeId", "data-v-4786c003"]]), gR = {}, vR = {
  width: "190",
  height: "33",
  viewBox: "0 0 190 33",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function pR(e, t) {
  return j(), ne("svg", vR, t[0] || (t[0] = [
    O7('<g clip-path="url(#clip0_1478_17785)"><path d="M49.0053 0H33.0018C28.5846 0 25 3.58456 25 8.00176V24.0053C25 28.4225 28.5846 32.0071 33.0018 32.0071H49.0053C53.4225 32.0071 57.0071 28.4225 57.0071 24.0053V8.00176C57 3.58456 53.4225 0 49.0053 0ZM31.1389 20.2867C28.7751 20.2867 26.8558 18.3674 26.8558 16.0035C26.8558 13.6397 28.7751 11.7204 31.1389 11.7204C33.5028 11.7204 35.4221 13.6397 35.4221 16.0035C35.4221 18.3674 33.5028 20.2867 31.1389 20.2867ZM49.6827 20.2867C48.2573 20.2867 46.9943 19.5881 46.2181 18.5155C45.4701 17.7394 44.7292 18.1204 44.3694 18.4238C43.6002 19.5528 42.3019 20.2937 40.8342 20.2937C38.4703 20.2937 36.551 18.3744 36.551 16.0106C36.551 13.6467 38.4703 11.7275 40.8342 11.7275C42.2948 11.7275 43.5861 12.4613 44.3623 13.5832C44.7222 13.8867 45.4701 14.2889 46.2322 13.4845C47.0084 12.419 48.2644 11.7275 49.6827 11.7275C52.0465 11.7275 53.9658 13.6467 53.9658 16.0106C53.9658 18.3744 52.0465 20.2937 49.6827 20.2937V20.2867ZM54.3045 20.1032C53.8318 20.1032 53.4507 19.7222 53.4507 19.2494C53.4507 18.7766 53.8318 18.3956 54.3045 18.3956C54.7773 18.3956 55.1583 18.7766 55.1583 19.2494C55.1583 19.7222 54.7773 20.1032 54.3045 20.1032Z" fill="white"></path><path d="M106.935 3.85976C106.865 1.71466 105.101 0 102.941 0H99.6884C99.2721 0 98.9404 0.338699 98.9404 0.74796V7.24675C98.9404 7.66307 99.2791 7.99471 99.6884 7.99471H102.941C105.15 7.99471 106.942 6.20243 106.942 3.99383C106.942 3.97971 106.942 3.9656 106.942 3.95149C106.942 3.91621 106.942 3.88798 106.942 3.8527L106.935 3.85976ZM102.941 6.49879H100.443V1.50298H102.941C104.324 1.50298 105.439 2.62492 105.439 4.00088C105.439 5.37685 104.317 6.49879 102.941 6.49879Z" fill="white"></path><path d="M71.8443 6.83043C72.1548 6.51996 72.1548 6.01191 71.8443 5.70143C71.5339 5.39096 71.0399 5.39096 70.7224 5.69438C70.7224 5.69438 70.7224 5.69438 70.7153 5.70143C70.7153 5.70143 70.7153 5.70849 70.7083 5.71555C70.2778 6.14598 69.6781 6.40706 69.0218 6.40706C68.3656 6.40706 67.7588 6.13892 67.3213 5.70143C66.8908 5.26395 66.6157 4.67122 66.6157 4.00088C66.6157 3.33054 66.8767 2.74487 67.3072 2.31444C67.3072 2.31444 67.3072 2.31444 67.3213 2.30739L67.3283 2.29327C67.7588 1.86284 68.3585 1.60176 69.0148 1.60176C69.671 1.60176 70.2567 1.86284 70.6871 2.28622C70.6942 2.28622 70.7012 2.30033 70.7083 2.30739C70.7153 2.31444 70.7224 2.3215 70.7294 2.32856C71.0399 2.61786 71.5338 2.61081 71.8373 2.30739C72.1407 2.00397 72.1477 1.51709 71.8584 1.19956C71.8584 1.1925 71.8443 1.18545 71.8373 1.17839C71.8302 1.17133 71.8232 1.16428 71.809 1.15017C71.0893 0.437486 70.1014 0 69.0077 0C67.914 0 66.9261 0.437486 66.2064 1.15017C66.1993 1.15722 66.1923 1.16428 66.1782 1.17839C66.1782 1.17839 66.1641 1.1925 66.157 1.19956C65.4443 1.91929 65.0068 2.90717 65.0068 4.00088C65.0068 5.0946 65.4514 6.10364 66.1782 6.83043C66.905 7.55722 67.8999 8.00176 69.0077 8.00176C70.1155 8.00176 71.1105 7.55722 71.8373 6.83043H71.8443Z" fill="white"></path><path d="M85.9779 0C83.7693 0 81.9771 1.79228 81.9771 4.00088C81.9771 6.20948 83.7693 8.00176 85.9779 8.00176C88.1865 8.00176 89.9788 6.20948 89.9788 4.00088C89.9788 1.79228 88.1865 0 85.9779 0ZM85.9779 6.4C84.6514 6.4 83.5788 5.32745 83.5788 4.00088C83.5788 2.67431 84.6514 1.60176 85.9779 1.60176C87.3045 1.60176 88.3771 2.67431 88.3771 4.00088C88.3771 5.32745 87.3045 6.4 85.9779 6.4Z" fill="white"></path><path d="M80.7 6.4H77.4965C76.8332 6.4 76.2334 6.13186 75.7959 5.69438C75.3655 5.25689 75.0903 4.66417 75.0903 3.99383V0.797354C75.0903 0.352811 74.7304 0 74.293 0C74.0742 0 73.8696 0.091731 73.7285 0.232856C73.5803 0.37398 73.4956 0.578611 73.4956 0.797354V4.00088C73.4956 5.10871 73.9402 6.10364 74.6669 6.83043C75.3937 7.55722 76.3887 8.00176 77.4965 8.00176H80.7C80.9188 8.00176 81.1234 7.91003 81.2645 7.76891C81.4127 7.62778 81.4974 7.42315 81.4974 7.20441C81.4974 6.75987 81.1375 6.40706 80.7 6.40706V6.4Z" fill="white"></path><path d="M98.2206 0.232856C98.0794 0.0846748 97.8748 0 97.6561 0C97.2115 0 96.8587 0.359868 96.8587 0.797354V4.00088C96.8587 4.66417 96.5906 5.26395 96.1531 5.70143C95.7156 6.13186 95.1158 6.40706 94.4525 6.40706C93.7893 6.40706 93.1895 6.13892 92.752 5.70143C92.3216 5.26395 92.0464 4.67122 92.0464 4.00088V1.60176V0.80441C92.0464 0.359868 91.6865 0.00705623 91.249 0.00705623C91.0303 0.00705623 90.8256 0.0987872 90.6845 0.239912C90.5363 0.381036 90.4517 0.585667 90.4517 0.80441V4.00794C90.4517 5.11577 90.8962 6.11069 91.623 6.83749C92.3498 7.56428 93.3447 8.00882 94.4525 8.00882C95.5604 8.00882 96.5553 7.56428 97.2821 6.83749C98.0089 6.11069 98.4534 5.11577 98.4534 4.00794V0.797354C98.4534 0.578611 98.3617 0.37398 98.2206 0.232856Z" fill="white"></path><path d="M114.471 16.4689C114.182 16.1796 113.779 15.9961 113.342 15.9961H106.942C104.733 15.9961 102.736 16.8922 101.29 18.3388C99.8434 19.7853 98.9473 21.7822 98.9473 23.9908V30.3908C98.9473 30.8353 99.1237 31.2305 99.42 31.5198C99.7093 31.8091 100.112 31.9926 100.549 31.9926C101.431 31.9926 102.151 31.2728 102.151 30.3908V23.9908C102.151 22.6642 102.687 21.4647 103.555 20.5968C104.423 19.7288 105.622 19.1926 106.949 19.1926H113.349C114.231 19.1926 114.951 18.4728 114.951 17.5908C114.951 17.1463 114.774 16.7511 114.478 16.4618L114.471 16.4689Z" fill="white"></path><path d="M129.557 18.3458C129.557 18.3458 129.522 18.3106 129.501 18.2964C128.061 16.8781 126.086 16.0032 123.898 16.0032C121.711 16.0032 119.735 16.8781 118.296 18.2964C118.274 18.3106 118.26 18.3317 118.239 18.3458C118.218 18.36 118.204 18.3811 118.197 18.3952C116.779 19.8347 115.896 21.8175 115.896 24.0049C115.896 26.1924 116.793 28.2105 118.239 29.664C119.686 31.1106 121.683 32.0067 123.898 32.0067C125.698 32.0067 127.363 31.414 128.696 30.4049V30.1086C128.696 30.1086 128.718 30.1086 128.725 30.1086C128.704 30.2074 128.696 30.3062 128.696 30.412C128.696 31.3011 129.416 32.0138 130.298 32.0138C131.18 32.0138 131.9 31.294 131.9 30.412V24.012C131.9 21.8246 131.025 19.8418 129.6 18.4023C129.586 18.3882 129.571 18.367 129.557 18.3529V18.3458ZM127.321 27.3778C127.321 27.3778 127.292 27.406 127.278 27.4202C126.41 28.274 125.218 28.8032 123.905 28.8032C122.593 28.8032 121.379 28.2669 120.511 27.399C119.643 26.5311 119.107 25.3315 119.107 24.0049C119.107 22.6925 119.636 21.5 120.49 20.6321C120.504 20.6179 120.518 20.6038 120.532 20.5897C121.4 19.7359 122.593 19.2067 123.905 19.2067C125.218 19.2067 126.389 19.7218 127.257 20.5686C127.285 20.5968 127.313 20.625 127.342 20.6532C128.188 21.5211 128.704 22.6995 128.704 24.0049C128.704 25.3103 128.174 26.517 127.321 27.3778Z" fill="white"></path><path d="M157.825 16.0032C153.407 16.0032 149.823 19.5877 149.823 24.0049C149.823 28.4221 153.407 32.0067 157.825 32.0067C162.242 32.0067 165.826 28.4221 165.826 24.0049C165.826 19.5877 162.242 16.0032 157.825 16.0032ZM157.825 28.8032C155.171 28.8032 153.026 26.6581 153.026 24.0049C153.026 21.3518 155.171 19.2067 157.825 19.2067C160.478 19.2067 162.623 21.3589 162.623 24.0049C162.623 26.651 160.471 28.8032 157.825 28.8032Z" fill="white"></path><path d="M96.3788 16.0032H83.5788C82.6968 16.0032 81.9771 16.7229 81.9771 17.6049C81.9771 18.487 82.6968 19.2067 83.5788 19.2067H88.3771V30.4049C88.3771 31.287 89.0968 32.0067 89.9788 32.0067C90.8608 32.0067 91.5806 31.287 91.5806 30.4049V19.2067H96.3788C97.2608 19.2067 97.9806 18.487 97.9806 17.6049C97.9806 16.7229 97.2608 16.0032 96.3788 16.0032Z" fill="white"></path><path d="M147.261 16.0032H134.461C133.579 16.0032 132.859 16.7229 132.859 17.6049C132.859 18.487 133.579 19.2067 134.461 19.2067H139.259V30.4049C139.259 31.287 139.979 32.0067 140.861 32.0067C141.743 32.0067 142.463 31.287 142.463 30.4049V19.2067H147.261C148.143 19.2067 148.863 18.487 148.863 17.6049C148.863 16.7229 148.143 16.0032 147.261 16.0032Z" fill="white"></path><path d="M77.8139 20.8226C77.0024 20.3992 76.0781 20.1593 75.0902 20.1593H68.6902C68.4221 20.1593 68.2104 19.9476 68.2104 19.6794C68.2104 19.4113 68.4221 19.1996 68.6902 19.1996H76.2121C77.0942 19.1996 77.8139 18.4799 77.8139 17.5979C77.8139 16.7158 77.0942 15.9961 76.2121 15.9961H68.6902C66.8203 15.9961 65.275 17.3932 65.0421 19.1996C65.028 19.3125 65.0139 19.4325 65.0139 19.5524C65.0139 19.5948 65.0139 19.6371 65.0139 19.6794C65.0139 19.7218 65.0139 19.7641 65.0139 19.8065C65.0139 19.9264 65.028 20.0464 65.0421 20.1593C65.275 21.9657 66.8203 23.3628 68.6902 23.3628H75.0902C76.572 23.3628 77.7786 24.5553 77.8139 26.0301V26.1359C77.7857 27.6177 76.572 28.8032 75.0902 28.8032H66.6086C65.7266 28.8032 65.0068 29.5229 65.0068 30.4049C65.0068 31.2869 65.7266 32.0067 66.6086 32.0067H75.0902C76.071 32.0067 76.9954 31.7668 77.8139 31.3434C78.9006 30.7859 79.7896 29.8969 80.3541 28.8032C80.7775 27.9917 81.0174 27.0673 81.0174 26.0794C81.0174 25.0916 80.7775 24.1743 80.3541 23.3557C79.7896 22.2691 78.9006 21.38 77.8139 20.8155V20.8226Z" fill="white"></path></g><defs><clipPath id="clip0_1478_17785"><rect width="165.826" height="32.0137" fill="white"></rect></clipPath></defs>', 2)
  ]));
}
const OR = /* @__PURE__ */ bt(gR, [["render", pR]]), yR = { class: "s-logo" }, bR = ["src"], CR = {
  key: 0,
  class: "s-item-group"
}, SR = {
  key: 1,
  class: "s-item-group"
}, wR = { class: "s-avater__border" }, kR = { id: "side_menu_background" }, xR = { class: "text-right" }, PR = { id: "side_menu_wrapper" }, $R = {
  key: 0,
  class: "side-menu-footer"
}, VR = {
  __name: "SHeader",
  props: {
    isLoggedIn: {
      type: Boolean,
      default: !1
    },
    userInfo: {
      type: Object,
      default: () => ({
        name: "-",
        picture: {
          format: "png"
        }
      })
    },
    logoSrc: {
      type: String,
      default: null,
      description: "   "
    },
    serviceMenus: {
      type: Array,
      default: () => [],
      description: "  items"
    },
    userMenus: {
      type: Array,
      default: () => [],
      description: "  items (:  ,  , )"
    },
    showMenuBtn: {
      type: Boolean,
      default: !0
    },
    showMenu: {
      type: Boolean,
      default: !1
    },
    loginText: {
      type: String,
      default: ""
    },
    joinText: {
      type: String,
      default: ""
    },
    teleportId: {
      type: String,
      default: "destination",
      description: "Teleport Id"
    },
    activeMenuCode: {
      type: String,
      default: "",
      description: " "
    },
    lang: {
      type: String,
      default: "ko"
    },
    logoStyle: {
      type: Object,
      default: () => ({
        height: "30px",
        paddingLeft: "20px"
      }),
      description: "  "
    },
    serviceBtnText: {
      type: String,
      default: ""
    },
    loading: {
      type: Boolean,
      default: !1
    }
  },
  emits: [
    "click:menu",
    "click:log-in",
    "click:sign-up",
    "click:menu-item",
    "click:logo",
    "click:service-item"
  ],
  setup(e, { emit: t }) {
    const n = e, i = t, l = z(n.showMenu), a = () => {
      l.value = !l.value, i("click:menu", l.value);
    }, r = () => {
      l.value = !1, i("click:menu", !1);
    }, s = (c) => {
      i("click:menu-item", c);
    }, o = (c) => {
      i("click:service-item", c);
    }, u = (c) => {
      var d;
      return ((d = n.lang) == null ? void 0 : d.toLowerCase()) === "en" ? c.menuNameEn || c.menuName : c.menuNameKr || c.menuName;
    };
    return ee(
      () => n.showMenu,
      (c, d) => {
        c !== d && (l.value = c);
      }
    ), (c, d) => {
      const f = ae("v-icon"), h = ae("v-btn"), g = ae("v-app-bar-title"), v = ae("v-avatar"), p = ae("v-app-bar"), O = ae("v-list-item");
      return j(), ne(le, null, [
        m(p, {
          class: "s-header",
          color: "#1C2536",
          height: 68,
          elevation: 0
        }, Gi({
          prepend: W(() => [
            G("div", yR, [
              G("a", {
                "href.prevent.stop": "#",
                onClick: d[0] || (d[0] = (b) => c.$emit("click:logo"))
              }, [
                d[5] || (d[5] = G("span", { class: "d-none" }, "main-logo", -1)),
                e.logoSrc ? (j(), ne("img", {
                  key: 0,
                  class: "s-logo__img",
                  src: e.logoSrc,
                  alt: "logo",
                  style: on(e.logoStyle)
                }, null, 12, bR)) : (j(), xe(OR, {
                  key: 1,
                  class: "s-logo__img"
                }))
              ])
            ]),
            m(g, {
              density: "compact",
              variant: "flat",
              size: "small",
              "background-color": "white"
            }, {
              default: W(() => [
                e.showMenuBtn ? (j(), xe(h, {
                  key: 0,
                  class: ct(["s-btn__menu", { "s-btn__menu--active": l.value }]),
                  text: e.serviceBtnText,
                  onClick: a
                }, {
                  prepend: W(() => [
                    m(f, {
                      class: "s-btn__menu__icon",
                      variant: "text",
                      density: "compact",
                      icon: "mdi-menu"
                    })
                  ]),
                  _: 1
                }, 8, ["class", "text"])) : _e("", !0)
              ]),
              _: 1
            })
          ]),
          _: 2
        }, [
          e.loading ? void 0 : {
            name: "append",
            fn: W(() => [
              e.isLoggedIn ? (j(), ne("div", SR, [
                Ae(c.$slots, "inner-append", {}, void 0, !0),
                m(Me(I6), {
                  user: e.userInfo,
                  "menu-items": e.userMenus,
                  "class-name": { fontWhite: !0 },
                  "onClick:menuItem": s
                }, {
                  badge: W(() => [
                    m(v, null, {
                      default: W(() => [
                        G("div", wR, [
                          e.userInfo.picture ? (j(), xe(Me(Nd), {
                            key: 0,
                            "lazy-src": "profile.svg",
                            "src-url": `data:image/${e.userInfo.picture.format};base64,${e.userInfo.picture.data}`
                          }, null, 8, ["src-url"])) : (j(), xe(Me(Nd), {
                            key: 1,
                            "lazy-src": "profile.svg",
                            src: "profile.svg"
                          }))
                        ])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["user", "menu-items"])
              ])) : (j(), ne("div", CR, [
                G("a", {
                  class: "s-sign__btn",
                  onKeypress: d[1] || (d[1] = Pr(_t((b) => c.$emit("click:log-in"), ["ctrl"]), ["i"])),
                  onClick: d[2] || (d[2] = _t((b) => c.$emit("click:log-in"), ["stop"]))
                }, he(e.loginText), 33),
                G("a", {
                  class: "s-sign__btn",
                  onKeypress: d[3] || (d[3] = Pr(_t((b) => c.$emit("click:sign-up"), ["ctrl"]), ["i"])),
                  onClick: d[4] || (d[4] = _t((b) => c.$emit("click:sign-up"), ["stop"]))
                }, he(e.joinText), 33)
              ]))
            ]),
            key: "0"
          }
        ]), 1024),
        G("div", {
          class: ct(["menu-back-ground", { show: l.value, hide: !l.value }])
        }, [
          G("div", kR, [
            G("div", xR, [
              m(f, {
                icon: "mdi-close",
                onClick: r
              })
            ]),
            G("div", PR, [
              (j(!0), ne(le, null, vt(e.serviceMenus, (b, V) => (j(), ne(le, null, [
                b.accessible ? (j(), xe(O, {
                  key: V,
                  class: "side-menu",
                  active: b.menuCode === e.activeMenuCode,
                  title: u(b),
                  onClick: ($) => o(b)
                }, null, 8, ["active", "title", "onClick"])) : _e("", !0)
              ], 64))), 256))
            ]),
            c.$slots["side-menu-footer"] ? (j(), ne("div", $R, [
              Ae(c.$slots, "side-menu-footer", {}, void 0, !0)
            ])) : _e("", !0)
          ])
        ], 2)
      ], 64);
    };
  }
}, QR = /* @__PURE__ */ bt(VR, [["__scopeId", "data-v-01d46e44"]]), LR = {}, MR = { class: "footer-wrapper" };
function TR(e, t) {
  const n = ae("v-footer");
  return j(), ne("div", MR, [
    m(n, { class: "footer-contents" }, {
      default: W(() => t[0] || (t[0] = [
        ke("Powered by STRATO Cloud Management Platform")
      ])),
      _: 1
    })
  ]);
}
const _R = /* @__PURE__ */ bt(LR, [["render", TR], ["__scopeId", "data-v-018a6e7c"]]), AR = { class: "s-title-area__content" }, RR = { class: "s-title-area__title" }, ZR = {
  key: 0,
  class: "s-title-area__number"
}, IR = { class: "s-title-area__buttons button-wrapper" }, DR = {
  __name: "SSubHeader",
  props: {
    className: {
      type: String,
      default: "",
      description: " custom class"
    },
    title: {
      type: String,
      required: !0
    },
    showCnt: {
      type: Boolean,
      required: !1,
      default: !0
    },
    listCnt: {
      type: Number,
      default: 0
    }
  },
  setup(e) {
    return (t, n) => (j(), ne("div", {
      class: ct(["s-title-area", e.className])
    }, [
      G("div", AR, [
        G("div", RR, [
          ke(he(e.title) + " ", 1),
          Ae(t.$slots, "title-append", {}, () => [
            e.showCnt ? (j(), ne("span", ZR, "(" + he(e.listCnt) + ")", 1)) : _e("", !0)
          ], !0)
        ]),
        G("div", IR, [
          Ae(t.$slots, "default", {}, void 0, !0)
        ])
      ])
    ], 2));
  }
}, BR = /* @__PURE__ */ bt(DR, [["__scopeId", "data-v-9f760a1f"]]), ER = { class: "s-accordion-wrapper" }, zR = {
  __name: "SAccordionMenu",
  props: {
    title: {
      type: String,
      required: !0
    },
    titleBold: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = z(null), n = z(!1), i = z("0px"), l = () => {
      n.value ? (i.value = `${t.value.scrollHeight}px`, requestAnimationFrame(() => {
        i.value = "0px", n.value = !1;
      })) : (i.value = `${t.value.scrollHeight}px`, n.value = !0);
    }, a = () => {
      n.value && (i.value = "auto");
    };
    return (r, s) => {
      const o = ae("v-icon");
      return j(), ne("div", ER, [
        G("div", {
          class: ct(["title", { "title-bold": e.titleBold }])
        }, [
          ke(he(e.title) + " ", 1),
          m(o, {
            class: "float-right",
            style: { top: "10px" },
            icon: n.value ? "mdi-chevron-down" : "mdi-chevron-right",
            onClick: l
          }, null, 8, ["icon"])
        ], 2),
        G("div", {
          ref_key: "accordion",
          ref: t,
          class: "s-accordion-contents",
          style: on({ height: i.value }),
          onTransitionend: a
        }, [
          Ae(r.$slots, "default", {}, void 0, !0)
        ], 36)
      ]);
    };
  }
}, HR = /* @__PURE__ */ bt(zR, [["__scopeId", "data-v-691469ff"]]), jR = { id: "s-navi" }, XR = { id: "s-menu-title-wrapper" }, NR = { id: "s-menu-title" }, qR = {
  key: 0,
  id: "project_select_wrapper"
}, YR = { class: "project_select" }, FR = { id: "s-menu-wrapper" }, WR = {
  key: 1,
  class: "s-navi-inner-menu-title"
}, UR = {
  __name: "SNavi",
  props: {
    useProject: {
      type: Boolean,
      default: !1
    },
    projectList: {
      type: Array,
      default: () => []
    },
    selectedProject: {
      type: Object,
      default: () => {
      }
    },
    menuPath: {
      type: Object,
      default: () => ({
        menuUrl: "",
        menuName: "",
        menuNameKr: "",
        subMenus: []
      })
    },
    serviceName: {
      type: String,
      default: ""
    },
    dependencyTooltipMessage: {
      type: String,
      default: "   "
    },
    routerPath: {
      type: String,
      default: ""
    },
    firstMenuPath: {
      type: String,
      default: "",
      description: "Service Name     path"
    },
    lang: {
      type: String,
      default: "ko"
    }
  },
  emits: ["change:project", "click:service-name"],
  setup(e, { emit: t }) {
    const n = { projectName: "", projectId: 0 }, i = e, l = t, a = z([]), r = C(() => [{ ...n }, ...i.projectList]), s = (v) => {
      var p;
      return !i.useProject || i.useProject && (((p = i.selectedProject) == null ? void 0 : p.projectId) > 0 || v.dependency !== "PROJECT");
    }, o = (v) => {
      l("change:project", v);
    }, u = () => {
      if (i.firstMenuPath)
        try {
          const v = new URL(i.firstMenuPath);
          l("click:service-name", { path: v.pathname });
        } catch {
          l("click:service-name", { path: i.firstMenuPath });
        }
      else
        l("click:service-name", { path: "/" });
    }, c = (v) => {
      var p;
      return ((p = i.lang) == null ? void 0 : p.toLowerCase()) === "en" ? v.menuNameEn || v.menuName : v.menuNameKr || v.menuName;
    }, d = C(() => i.serviceName || c(i.menuPath)), f = (v, p) => {
      if (!v || !p) return !1;
      if (v === p) return !0;
      const O = v.split("/").filter(Boolean), b = p.split("/").filter(Boolean);
      return O.length !== b.length ? !1 : O.every((V, $) => V.startsWith(":") ? !0 : V === b[$]);
    };
    ee(
      () => i.routerPath,
      () => {
        var O;
        const v = ((O = i.menuPath) == null ? void 0 : O.subMenus) || [], p = i.routerPath;
        for (const b in v) {
          if (f(v[b].menuUrl, p)) {
            a.value = [v[b].idx];
            break;
          }
          if (v[b].subMenus && v[b].subMenus.some(
            ($) => f($.menuUrl, p)
          )) {
            a.value = [v[b].idx];
            break;
          }
        }
      },
      { immediate: !0 }
    );
    const h = (v) => f(v, i.routerPath), g = (v, p) => {
      if (s(p)) {
        const O = v.currentTarget.querySelector(".s-navi-inner-menu-title");
        O && O.click();
      }
    };
    return (v, p) => {
      const O = ae("v-select"), b = ae("RouterLink"), V = ae("v-list-item"), $ = ae("v-tooltip"), x = ae("v-list-group"), Q = ae("v-list");
      return j(), ne("div", jR, [
        G("div", XR, [
          G("a", {
            "href.stop": "#",
            onClick: u
          }, [
            G("div", NR, he(d.value), 1)
          ])
        ]),
        Ae(v.$slots, "default", {}, () => [
          e.useProject ? (j(), ne("div", qR, [
            G("div", YR, [
              m(O, {
                width: "238px",
                "model-value": e.selectedProject,
                variant: "outlined",
                density: "comfortable",
                items: r.value,
                "item-title": "projectName",
                "item-value": "projectId",
                label: "Select",
                "hide-details": "",
                "persistent-hint": "",
                "return-object": "",
                "single-line": "",
                "onUpdate:modelValue": o
              }, null, 8, ["model-value", "items"])
            ])
          ])) : _e("", !0)
        ], !0),
        G("div", FR, [
          e.menuPath && e.menuPath.subMenus && e.menuPath.subMenus.length ? (j(), xe(Q, {
            key: 0,
            opened: a.value,
            "onUpdate:opened": p[0] || (p[0] = (M) => a.value = M),
            class: "navi-menu"
          }, {
            default: W(() => [
              (j(!0), ne(le, null, vt(e.menuPath.subMenus, (M) => (j(), xe(x, {
                key: M.idx,
                value: M.idx
              }, Gi({
                default: W(() => [
                  (j(!0), ne(le, null, vt(M.subMenus, (w, y) => {
                    var L;
                    return j(), ne(le, { key: y }, [
                      w.accessible ? (j(), xe(V, {
                        key: 0,
                        class: ct(["s-navi-inner-menu", {
                          disabled: !s(w),
                          active: ((L = e.selectedProject) == null ? void 0 : L.projectId) > 0 || w.dependency !== "PROJECT"
                        }]),
                        value: w.idx,
                        "active-class": "menu-active",
                        active: h(w.menuUrl),
                        "prepend-icon": "mdi-circle-small",
                        onClick: (k) => g(k, w)
                      }, {
                        title: W(() => [
                          s(w) ? (j(), xe(b, {
                            key: 0,
                            class: "s-navi-inner-menu-title",
                            to: w.menuUrl,
                            ref_for: !0,
                            ref: "menuLink"
                          }, {
                            default: W(() => [
                              ke(he(c(w)), 1)
                            ]),
                            _: 2
                          }, 1032, ["to"])) : (j(), ne("span", WR, [
                            ke(he(c(w)) + " ", 1),
                            w.dependency === "PROJECT" ? (j(), xe($, {
                              key: 0,
                              activator: "parent",
                              location: "start"
                            }, {
                              default: W(() => [
                                ke(he(e.dependencyTooltipMessage), 1)
                              ]),
                              _: 1
                            })) : _e("", !0)
                          ]))
                        ]),
                        _: 2
                      }, 1032, ["class", "value", "active", "onClick"])) : _e("", !0)
                    ], 64);
                  }), 128))
                ]),
                _: 2
              }, [
                M.accessible ? {
                  name: "activator",
                  fn: W(({ props: w }) => [
                    m(V, q({ ref_for: !0 }, w, {
                      height: "50px",
                      "active-class": "menu-active",
                      active: h(M.menuUrl),
                      title: c(M),
                      "append-icon": !M.subMenus || M.subMenus.length === 0 ? "" : a.value.includes(M.idx) ? "mdi-chevron-up" : "mdi-chevron-down",
                      onClick: (y) => g(y, M)
                    }), Gi({ _: 2 }, [
                      !M.subMenus || M.subMenus.length === 0 ? {
                        name: "title",
                        fn: W(() => [
                          m(b, {
                            class: "navi-inner-menu-title",
                            to: M.menuUrl
                          }, {
                            default: W(() => [
                              ke(he(c(M)), 1)
                            ]),
                            _: 2
                          }, 1032, ["to"])
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["active", "title", "append-icon", "onClick"])
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["value"]))), 128))
            ]),
            _: 1
          }, 8, ["opened"])) : _e("", !0)
        ])
      ]);
    };
  }
}, GR = /* @__PURE__ */ bt(UR, [["__scopeId", "data-v-c464c187"]]);
var B6 = typeof global == "object" && global && global.Object === Object && global, KR = typeof self == "object" && self && self.Object === Object && self, Si = B6 || KR || Function("return this")(), Zn = Si.Symbol, E6 = Object.prototype, JR = E6.hasOwnProperty, eZ = E6.toString, dr = Zn ? Zn.toStringTag : void 0;
function tZ(e) {
  var t = JR.call(e, dr), n = e[dr];
  try {
    e[dr] = void 0;
    var i = !0;
  } catch {
  }
  var l = eZ.call(e);
  return i && (t ? e[dr] = n : delete e[dr]), l;
}
var nZ = Object.prototype, iZ = nZ.toString;
function lZ(e) {
  return iZ.call(e);
}
var aZ = "[object Null]", rZ = "[object Undefined]", d9 = Zn ? Zn.toStringTag : void 0;
function tr(e) {
  return e == null ? e === void 0 ? rZ : aZ : d9 && d9 in Object(e) ? tZ(e) : lZ(e);
}
function rl(e) {
  return e != null && typeof e == "object";
}
var sZ = "[object Symbol]";
function ts(e) {
  return typeof e == "symbol" || rl(e) && tr(e) == sZ;
}
function bo(e, t) {
  for (var n = -1, i = e == null ? 0 : e.length, l = Array(i); ++n < i; )
    l[n] = t(e[n], n, e);
  return l;
}
var In = Array.isArray, oZ = 1 / 0, f9 = Zn ? Zn.prototype : void 0, h9 = f9 ? f9.toString : void 0;
function z6(e) {
  if (typeof e == "string")
    return e;
  if (In(e))
    return bo(e, z6) + "";
  if (ts(e))
    return h9 ? h9.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -oZ ? "-0" : t;
}
function nr(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function ac(e) {
  return e;
}
var uZ = "[object AsyncFunction]", cZ = "[object Function]", dZ = "[object GeneratorFunction]", fZ = "[object Proxy]";
function H6(e) {
  if (!nr(e))
    return !1;
  var t = tr(e);
  return t == cZ || t == dZ || t == uZ || t == fZ;
}
var Jc = Si["__core-js_shared__"], m9 = function() {
  var e = /[^.]+$/.exec(Jc && Jc.keys && Jc.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function hZ(e) {
  return !!m9 && m9 in e;
}
var mZ = Function.prototype, gZ = mZ.toString;
function na(e) {
  if (e != null) {
    try {
      return gZ.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var vZ = /[\\^$.*+?()[\]{}|]/g, pZ = /^\[object .+?Constructor\]$/, OZ = Function.prototype, yZ = Object.prototype, bZ = OZ.toString, CZ = yZ.hasOwnProperty, SZ = RegExp(
  "^" + bZ.call(CZ).replace(vZ, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function wZ(e) {
  if (!nr(e) || hZ(e))
    return !1;
  var t = H6(e) ? SZ : pZ;
  return t.test(na(e));
}
function kZ(e, t) {
  return e == null ? void 0 : e[t];
}
function ia(e, t) {
  var n = kZ(e, t);
  return wZ(n) ? n : void 0;
}
var qd = ia(Si, "WeakMap"), g9 = Object.create, xZ = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!nr(t))
      return {};
    if (g9)
      return g9(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function PZ(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var $Z = 800, VZ = 16, QZ = Date.now;
function LZ(e) {
  var t = 0, n = 0;
  return function() {
    var i = QZ(), l = VZ - (i - n);
    if (n = i, l > 0) {
      if (++t >= $Z)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function MZ(e) {
  return function() {
    return e;
  };
}
var su = function() {
  try {
    var e = ia(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), TZ = su ? function(e, t) {
  return su(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: MZ(t),
    writable: !0
  });
} : ac, _Z = LZ(TZ);
function AZ(e, t) {
  for (var n = -1, i = e == null ? 0 : e.length; ++n < i && t(e[n], n, e) !== !1; )
    ;
  return e;
}
var RZ = 9007199254740991, ZZ = /^(?:0|[1-9]\d*)$/;
function jh(e, t) {
  var n = typeof e;
  return t = t ?? RZ, !!t && (n == "number" || n != "symbol" && ZZ.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function IZ(e, t, n) {
  t == "__proto__" && su ? su(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function rc(e, t) {
  return e === t || e !== e && t !== t;
}
var DZ = Object.prototype, BZ = DZ.hasOwnProperty;
function EZ(e, t, n) {
  var i = e[t];
  (!(BZ.call(e, t) && rc(i, n)) || n === void 0 && !(t in e)) && IZ(e, t, n);
}
var v9 = Math.max;
function zZ(e, t, n) {
  return t = v9(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var i = arguments, l = -1, a = v9(i.length - t, 0), r = Array(a); ++l < a; )
      r[l] = i[t + l];
    l = -1;
    for (var s = Array(t + 1); ++l < t; )
      s[l] = i[l];
    return s[t] = n(r), PZ(e, this, s);
  };
}
function HZ(e, t) {
  return _Z(zZ(e, t, ac), e + "");
}
var jZ = 9007199254740991;
function Xh(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= jZ;
}
function sc(e) {
  return e != null && Xh(e.length) && !H6(e);
}
function p9(e, t, n) {
  if (!nr(n))
    return !1;
  var i = typeof t;
  return (i == "number" ? sc(n) && jh(t, n.length) : i == "string" && t in n) ? rc(n[t], e) : !1;
}
var XZ = Object.prototype;
function j6(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || XZ;
  return e === n;
}
function NZ(e, t) {
  for (var n = -1, i = Array(e); ++n < e; )
    i[n] = t(n);
  return i;
}
var qZ = "[object Arguments]";
function O9(e) {
  return rl(e) && tr(e) == qZ;
}
var X6 = Object.prototype, YZ = X6.hasOwnProperty, FZ = X6.propertyIsEnumerable, Nh = O9(/* @__PURE__ */ function() {
  return arguments;
}()) ? O9 : function(e) {
  return rl(e) && YZ.call(e, "callee") && !FZ.call(e, "callee");
};
function WZ() {
  return !1;
}
var N6 = typeof exports == "object" && exports && !exports.nodeType && exports, y9 = N6 && typeof module == "object" && module && !module.nodeType && module, UZ = y9 && y9.exports === N6, b9 = UZ ? Si.Buffer : void 0, GZ = b9 ? b9.isBuffer : void 0, ou = GZ || WZ, KZ = "[object Arguments]", JZ = "[object Array]", eI = "[object Boolean]", tI = "[object Date]", nI = "[object Error]", iI = "[object Function]", lI = "[object Map]", aI = "[object Number]", rI = "[object Object]", sI = "[object RegExp]", oI = "[object Set]", uI = "[object String]", cI = "[object WeakMap]", dI = "[object ArrayBuffer]", fI = "[object DataView]", hI = "[object Float32Array]", mI = "[object Float64Array]", gI = "[object Int8Array]", vI = "[object Int16Array]", pI = "[object Int32Array]", OI = "[object Uint8Array]", yI = "[object Uint8ClampedArray]", bI = "[object Uint16Array]", CI = "[object Uint32Array]", rt = {};
rt[hI] = rt[mI] = rt[gI] = rt[vI] = rt[pI] = rt[OI] = rt[yI] = rt[bI] = rt[CI] = !0;
rt[KZ] = rt[JZ] = rt[dI] = rt[eI] = rt[fI] = rt[tI] = rt[nI] = rt[iI] = rt[lI] = rt[aI] = rt[rI] = rt[sI] = rt[oI] = rt[uI] = rt[cI] = !1;
function SI(e) {
  return rl(e) && Xh(e.length) && !!rt[tr(e)];
}
function oc(e) {
  return function(t) {
    return e(t);
  };
}
var q6 = typeof exports == "object" && exports && !exports.nodeType && exports, xr = q6 && typeof module == "object" && module && !module.nodeType && module, wI = xr && xr.exports === q6, e1 = wI && B6.process, ja = function() {
  try {
    var e = xr && xr.require && xr.require("util").types;
    return e || e1 && e1.binding && e1.binding("util");
  } catch {
  }
}(), C9 = ja && ja.isTypedArray, Y6 = C9 ? oc(C9) : SI, kI = Object.prototype, xI = kI.hasOwnProperty;
function PI(e, t) {
  var n = In(e), i = !n && Nh(e), l = !n && !i && ou(e), a = !n && !i && !l && Y6(e), r = n || i || l || a, s = r ? NZ(e.length, String) : [], o = s.length;
  for (var u in e)
    xI.call(e, u) && !(r && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    l && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    jh(u, o))) && s.push(u);
  return s;
}
function F6(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var $I = F6(Object.keys, Object), VI = Object.prototype, QI = VI.hasOwnProperty;
function LI(e) {
  if (!j6(e))
    return $I(e);
  var t = [];
  for (var n in Object(e))
    QI.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function qh(e) {
  return sc(e) ? PI(e) : LI(e);
}
var MI = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, TI = /^\w*$/;
function Yh(e, t) {
  if (In(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || ts(e) ? !0 : TI.test(e) || !MI.test(e) || t != null && e in Object(t);
}
var ns = ia(Object, "create");
function _I() {
  this.__data__ = ns ? ns(null) : {}, this.size = 0;
}
function AI(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var RI = "__lodash_hash_undefined__", ZI = Object.prototype, II = ZI.hasOwnProperty;
function DI(e) {
  var t = this.__data__;
  if (ns) {
    var n = t[e];
    return n === RI ? void 0 : n;
  }
  return II.call(t, e) ? t[e] : void 0;
}
var BI = Object.prototype, EI = BI.hasOwnProperty;
function zI(e) {
  var t = this.__data__;
  return ns ? t[e] !== void 0 : EI.call(t, e);
}
var HI = "__lodash_hash_undefined__";
function jI(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = ns && t === void 0 ? HI : t, this;
}
function Xl(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
Xl.prototype.clear = _I;
Xl.prototype.delete = AI;
Xl.prototype.get = DI;
Xl.prototype.has = zI;
Xl.prototype.set = jI;
function XI() {
  this.__data__ = [], this.size = 0;
}
function uc(e, t) {
  for (var n = e.length; n--; )
    if (rc(e[n][0], t))
      return n;
  return -1;
}
var NI = Array.prototype, qI = NI.splice;
function YI(e) {
  var t = this.__data__, n = uc(t, e);
  if (n < 0)
    return !1;
  var i = t.length - 1;
  return n == i ? t.pop() : qI.call(t, n, 1), --this.size, !0;
}
function FI(e) {
  var t = this.__data__, n = uc(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function WI(e) {
  return uc(this.__data__, e) > -1;
}
function UI(e, t) {
  var n = this.__data__, i = uc(n, e);
  return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this;
}
function Di(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
Di.prototype.clear = XI;
Di.prototype.delete = YI;
Di.prototype.get = FI;
Di.prototype.has = WI;
Di.prototype.set = UI;
var is = ia(Si, "Map");
function GI() {
  this.size = 0, this.__data__ = {
    hash: new Xl(),
    map: new (is || Di)(),
    string: new Xl()
  };
}
function KI(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function cc(e, t) {
  var n = e.__data__;
  return KI(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function JI(e) {
  var t = cc(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function eD(e) {
  return cc(this, e).get(e);
}
function tD(e) {
  return cc(this, e).has(e);
}
function nD(e, t) {
  var n = cc(this, e), i = n.size;
  return n.set(e, t), this.size += n.size == i ? 0 : 1, this;
}
function Bi(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
Bi.prototype.clear = GI;
Bi.prototype.delete = JI;
Bi.prototype.get = eD;
Bi.prototype.has = tD;
Bi.prototype.set = nD;
var iD = "Expected a function";
function Fh(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(iD);
  var n = function() {
    var i = arguments, l = t ? t.apply(this, i) : i[0], a = n.cache;
    if (a.has(l))
      return a.get(l);
    var r = e.apply(this, i);
    return n.cache = a.set(l, r) || a, r;
  };
  return n.cache = new (Fh.Cache || Bi)(), n;
}
Fh.Cache = Bi;
var lD = 500;
function aD(e) {
  var t = Fh(e, function(i) {
    return n.size === lD && n.clear(), i;
  }), n = t.cache;
  return t;
}
var rD = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, sD = /\\(\\)?/g, oD = aD(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(rD, function(n, i, l, a) {
    t.push(l ? a.replace(sD, "$1") : i || n);
  }), t;
});
function uD(e) {
  return e == null ? "" : z6(e);
}
function W6(e, t) {
  return In(e) ? e : Yh(e, t) ? [e] : oD(uD(e));
}
var cD = 1 / 0;
function dc(e) {
  if (typeof e == "string" || ts(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -cD ? "-0" : t;
}
function Wh(e, t) {
  t = W6(t, e);
  for (var n = 0, i = t.length; e != null && n < i; )
    e = e[dc(t[n++])];
  return n && n == i ? e : void 0;
}
function dD(e, t, n) {
  var i = e == null ? void 0 : Wh(e, t);
  return i === void 0 ? n : i;
}
function U6(e, t) {
  for (var n = -1, i = t.length, l = e.length; ++n < i; )
    e[l + n] = t[n];
  return e;
}
var S9 = Zn ? Zn.isConcatSpreadable : void 0;
function fD(e) {
  return In(e) || Nh(e) || !!(S9 && e && e[S9]);
}
function hD(e, t, n, i, l) {
  var a = -1, r = e.length;
  for (n || (n = fD), l || (l = []); ++a < r; ) {
    var s = e[a];
    n(s) ? U6(l, s) : l[l.length] = s;
  }
  return l;
}
var mD = F6(Object.getPrototypeOf, Object);
function gD() {
  this.__data__ = new Di(), this.size = 0;
}
function vD(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function pD(e) {
  return this.__data__.get(e);
}
function OD(e) {
  return this.__data__.has(e);
}
var yD = 200;
function bD(e, t) {
  var n = this.__data__;
  if (n instanceof Di) {
    var i = n.__data__;
    if (!is || i.length < yD - 1)
      return i.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Bi(i);
  }
  return n.set(e, t), this.size = n.size, this;
}
function hi(e) {
  var t = this.__data__ = new Di(e);
  this.size = t.size;
}
hi.prototype.clear = gD;
hi.prototype.delete = vD;
hi.prototype.get = pD;
hi.prototype.has = OD;
hi.prototype.set = bD;
var G6 = typeof exports == "object" && exports && !exports.nodeType && exports, w9 = G6 && typeof module == "object" && module && !module.nodeType && module, CD = w9 && w9.exports === G6, k9 = CD ? Si.Buffer : void 0;
k9 && k9.allocUnsafe;
function SD(e, t) {
  return e.slice();
}
function wD(e, t) {
  for (var n = -1, i = e == null ? 0 : e.length, l = 0, a = []; ++n < i; ) {
    var r = e[n];
    t(r, n, e) && (a[l++] = r);
  }
  return a;
}
function kD() {
  return [];
}
var xD = Object.prototype, PD = xD.propertyIsEnumerable, x9 = Object.getOwnPropertySymbols, $D = x9 ? function(e) {
  return e == null ? [] : (e = Object(e), wD(x9(e), function(t) {
    return PD.call(e, t);
  }));
} : kD;
function VD(e, t, n) {
  var i = t(e);
  return In(e) ? i : U6(i, n(e));
}
function Yd(e) {
  return VD(e, qh, $D);
}
var Fd = ia(Si, "DataView"), Wd = ia(Si, "Promise"), Ud = ia(Si, "Set"), P9 = "[object Map]", QD = "[object Object]", $9 = "[object Promise]", V9 = "[object Set]", Q9 = "[object WeakMap]", L9 = "[object DataView]", LD = na(Fd), MD = na(is), TD = na(Wd), _D = na(Ud), AD = na(qd), Xn = tr;
(Fd && Xn(new Fd(new ArrayBuffer(1))) != L9 || is && Xn(new is()) != P9 || Wd && Xn(Wd.resolve()) != $9 || Ud && Xn(new Ud()) != V9 || qd && Xn(new qd()) != Q9) && (Xn = function(e) {
  var t = tr(e), n = t == QD ? e.constructor : void 0, i = n ? na(n) : "";
  if (i)
    switch (i) {
      case LD:
        return L9;
      case MD:
        return P9;
      case TD:
        return $9;
      case _D:
        return V9;
      case AD:
        return Q9;
    }
  return t;
});
var RD = Object.prototype, ZD = RD.hasOwnProperty;
function ID(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && ZD.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var uu = Si.Uint8Array;
function Uh(e) {
  var t = new e.constructor(e.byteLength);
  return new uu(t).set(new uu(e)), t;
}
function DD(e, t) {
  var n = Uh(e.buffer);
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var BD = /\w*$/;
function ED(e) {
  var t = new e.constructor(e.source, BD.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var M9 = Zn ? Zn.prototype : void 0, T9 = M9 ? M9.valueOf : void 0;
function zD(e) {
  return T9 ? Object(T9.call(e)) : {};
}
function HD(e, t) {
  var n = Uh(e.buffer);
  return new e.constructor(n, e.byteOffset, e.length);
}
var jD = "[object Boolean]", XD = "[object Date]", ND = "[object Map]", qD = "[object Number]", YD = "[object RegExp]", FD = "[object Set]", WD = "[object String]", UD = "[object Symbol]", GD = "[object ArrayBuffer]", KD = "[object DataView]", JD = "[object Float32Array]", eB = "[object Float64Array]", tB = "[object Int8Array]", nB = "[object Int16Array]", iB = "[object Int32Array]", lB = "[object Uint8Array]", aB = "[object Uint8ClampedArray]", rB = "[object Uint16Array]", sB = "[object Uint32Array]";
function oB(e, t, n) {
  var i = e.constructor;
  switch (t) {
    case GD:
      return Uh(e);
    case jD:
    case XD:
      return new i(+e);
    case KD:
      return DD(e);
    case JD:
    case eB:
    case tB:
    case nB:
    case iB:
    case lB:
    case aB:
    case rB:
    case sB:
      return HD(e);
    case ND:
      return new i();
    case qD:
    case WD:
      return new i(e);
    case YD:
      return ED(e);
    case FD:
      return new i();
    case UD:
      return zD(e);
  }
}
function uB(e) {
  return typeof e.constructor == "function" && !j6(e) ? xZ(mD(e)) : {};
}
var cB = "[object Map]";
function dB(e) {
  return rl(e) && Xn(e) == cB;
}
var _9 = ja && ja.isMap, fB = _9 ? oc(_9) : dB, hB = "[object Set]";
function mB(e) {
  return rl(e) && Xn(e) == hB;
}
var A9 = ja && ja.isSet, gB = A9 ? oc(A9) : mB, K6 = "[object Arguments]", vB = "[object Array]", pB = "[object Boolean]", OB = "[object Date]", yB = "[object Error]", J6 = "[object Function]", bB = "[object GeneratorFunction]", CB = "[object Map]", SB = "[object Number]", e7 = "[object Object]", wB = "[object RegExp]", kB = "[object Set]", xB = "[object String]", PB = "[object Symbol]", $B = "[object WeakMap]", VB = "[object ArrayBuffer]", QB = "[object DataView]", LB = "[object Float32Array]", MB = "[object Float64Array]", TB = "[object Int8Array]", _B = "[object Int16Array]", AB = "[object Int32Array]", RB = "[object Uint8Array]", ZB = "[object Uint8ClampedArray]", IB = "[object Uint16Array]", DB = "[object Uint32Array]", et = {};
et[K6] = et[vB] = et[VB] = et[QB] = et[pB] = et[OB] = et[LB] = et[MB] = et[TB] = et[_B] = et[AB] = et[CB] = et[SB] = et[e7] = et[wB] = et[kB] = et[xB] = et[PB] = et[RB] = et[ZB] = et[IB] = et[DB] = !0;
et[yB] = et[J6] = et[$B] = !1;
function Co(e, t, n, i, l, a) {
  var r;
  if (r !== void 0)
    return r;
  if (!nr(e))
    return e;
  var s = In(e);
  if (s)
    r = ID(e);
  else {
    var o = Xn(e), u = o == J6 || o == bB;
    if (ou(e))
      return SD(e);
    if (o == e7 || o == K6 || u && !l)
      r = u ? {} : uB(e);
    else {
      if (!et[o])
        return l ? e : {};
      r = oB(e, o);
    }
  }
  a || (a = new hi());
  var c = a.get(e);
  if (c)
    return c;
  a.set(e, r), gB(e) ? e.forEach(function(h) {
    r.add(Co(h, t, n, h, e, a));
  }) : fB(e) && e.forEach(function(h, g) {
    r.set(g, Co(h, t, n, g, e, a));
  });
  var d = Yd, f = s ? void 0 : d(e);
  return AZ(f || e, function(h, g) {
    f && (g = h, h = e[g]), EZ(r, g, Co(h, t, n, g, e, a));
  }), r;
}
var BB = 1, EB = 4;
function t7(e) {
  return Co(e, BB | EB);
}
var zB = "__lodash_hash_undefined__";
function HB(e) {
  return this.__data__.set(e, zB), this;
}
function jB(e) {
  return this.__data__.has(e);
}
function cu(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Bi(); ++t < n; )
    this.add(e[t]);
}
cu.prototype.add = cu.prototype.push = HB;
cu.prototype.has = jB;
function XB(e, t) {
  for (var n = -1, i = e == null ? 0 : e.length; ++n < i; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function NB(e, t) {
  return e.has(t);
}
var qB = 1, YB = 2;
function n7(e, t, n, i, l, a) {
  var r = n & qB, s = e.length, o = t.length;
  if (s != o && !(r && o > s))
    return !1;
  var u = a.get(e), c = a.get(t);
  if (u && c)
    return u == t && c == e;
  var d = -1, f = !0, h = n & YB ? new cu() : void 0;
  for (a.set(e, t), a.set(t, e); ++d < s; ) {
    var g = e[d], v = t[d];
    if (i)
      var p = r ? i(v, g, d, t, e, a) : i(g, v, d, e, t, a);
    if (p !== void 0) {
      if (p)
        continue;
      f = !1;
      break;
    }
    if (h) {
      if (!XB(t, function(O, b) {
        if (!NB(h, b) && (g === O || l(g, O, n, i, a)))
          return h.push(b);
      })) {
        f = !1;
        break;
      }
    } else if (!(g === v || l(g, v, n, i, a))) {
      f = !1;
      break;
    }
  }
  return a.delete(e), a.delete(t), f;
}
function FB(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(i, l) {
    n[++t] = [l, i];
  }), n;
}
function WB(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(i) {
    n[++t] = i;
  }), n;
}
var UB = 1, GB = 2, KB = "[object Boolean]", JB = "[object Date]", eE = "[object Error]", tE = "[object Map]", nE = "[object Number]", iE = "[object RegExp]", lE = "[object Set]", aE = "[object String]", rE = "[object Symbol]", sE = "[object ArrayBuffer]", oE = "[object DataView]", R9 = Zn ? Zn.prototype : void 0, t1 = R9 ? R9.valueOf : void 0;
function uE(e, t, n, i, l, a, r) {
  switch (n) {
    case oE:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case sE:
      return !(e.byteLength != t.byteLength || !a(new uu(e), new uu(t)));
    case KB:
    case JB:
    case nE:
      return rc(+e, +t);
    case eE:
      return e.name == t.name && e.message == t.message;
    case iE:
    case aE:
      return e == t + "";
    case tE:
      var s = FB;
    case lE:
      var o = i & UB;
      if (s || (s = WB), e.size != t.size && !o)
        return !1;
      var u = r.get(e);
      if (u)
        return u == t;
      i |= GB, r.set(e, t);
      var c = n7(s(e), s(t), i, l, a, r);
      return r.delete(e), c;
    case rE:
      if (t1)
        return t1.call(e) == t1.call(t);
  }
  return !1;
}
var cE = 1, dE = Object.prototype, fE = dE.hasOwnProperty;
function hE(e, t, n, i, l, a) {
  var r = n & cE, s = Yd(e), o = s.length, u = Yd(t), c = u.length;
  if (o != c && !r)
    return !1;
  for (var d = o; d--; ) {
    var f = s[d];
    if (!(r ? f in t : fE.call(t, f)))
      return !1;
  }
  var h = a.get(e), g = a.get(t);
  if (h && g)
    return h == t && g == e;
  var v = !0;
  a.set(e, t), a.set(t, e);
  for (var p = r; ++d < o; ) {
    f = s[d];
    var O = e[f], b = t[f];
    if (i)
      var V = r ? i(b, O, f, t, e, a) : i(O, b, f, e, t, a);
    if (!(V === void 0 ? O === b || l(O, b, n, i, a) : V)) {
      v = !1;
      break;
    }
    p || (p = f == "constructor");
  }
  if (v && !p) {
    var $ = e.constructor, x = t.constructor;
    $ != x && "constructor" in e && "constructor" in t && !(typeof $ == "function" && $ instanceof $ && typeof x == "function" && x instanceof x) && (v = !1);
  }
  return a.delete(e), a.delete(t), v;
}
var mE = 1, Z9 = "[object Arguments]", I9 = "[object Array]", io = "[object Object]", gE = Object.prototype, D9 = gE.hasOwnProperty;
function vE(e, t, n, i, l, a) {
  var r = In(e), s = In(t), o = r ? I9 : Xn(e), u = s ? I9 : Xn(t);
  o = o == Z9 ? io : o, u = u == Z9 ? io : u;
  var c = o == io, d = u == io, f = o == u;
  if (f && ou(e)) {
    if (!ou(t))
      return !1;
    r = !0, c = !1;
  }
  if (f && !c)
    return a || (a = new hi()), r || Y6(e) ? n7(e, t, n, i, l, a) : uE(e, t, o, n, i, l, a);
  if (!(n & mE)) {
    var h = c && D9.call(e, "__wrapped__"), g = d && D9.call(t, "__wrapped__");
    if (h || g) {
      var v = h ? e.value() : e, p = g ? t.value() : t;
      return a || (a = new hi()), l(v, p, n, i, a);
    }
  }
  return f ? (a || (a = new hi()), hE(e, t, n, i, l, a)) : !1;
}
function Gh(e, t, n, i, l) {
  return e === t ? !0 : e == null || t == null || !rl(e) && !rl(t) ? e !== e && t !== t : vE(e, t, n, i, Gh, l);
}
var pE = 1, OE = 2;
function yE(e, t, n, i) {
  var l = n.length, a = l;
  if (e == null)
    return !a;
  for (e = Object(e); l--; ) {
    var r = n[l];
    if (r[2] ? r[1] !== e[r[0]] : !(r[0] in e))
      return !1;
  }
  for (; ++l < a; ) {
    r = n[l];
    var s = r[0], o = e[s], u = r[1];
    if (r[2]) {
      if (o === void 0 && !(s in e))
        return !1;
    } else {
      var c = new hi(), d;
      if (!(d === void 0 ? Gh(u, o, pE | OE, i, c) : d))
        return !1;
    }
  }
  return !0;
}
function i7(e) {
  return e === e && !nr(e);
}
function bE(e) {
  for (var t = qh(e), n = t.length; n--; ) {
    var i = t[n], l = e[i];
    t[n] = [i, l, i7(l)];
  }
  return t;
}
function l7(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function CE(e) {
  var t = bE(e);
  return t.length == 1 && t[0][2] ? l7(t[0][0], t[0][1]) : function(n) {
    return n === e || yE(n, e, t);
  };
}
function SE(e, t) {
  return e != null && t in Object(e);
}
function wE(e, t, n) {
  t = W6(t, e);
  for (var i = -1, l = t.length, a = !1; ++i < l; ) {
    var r = dc(t[i]);
    if (!(a = e != null && n(e, r)))
      break;
    e = e[r];
  }
  return a || ++i != l ? a : (l = e == null ? 0 : e.length, !!l && Xh(l) && jh(r, l) && (In(e) || Nh(e)));
}
function kE(e, t) {
  return e != null && wE(e, t, SE);
}
var xE = 1, PE = 2;
function $E(e, t) {
  return Yh(e) && i7(t) ? l7(dc(e), t) : function(n) {
    var i = dD(n, e);
    return i === void 0 && i === t ? kE(n, e) : Gh(t, i, xE | PE);
  };
}
function VE(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function QE(e) {
  return function(t) {
    return Wh(t, e);
  };
}
function LE(e) {
  return Yh(e) ? VE(dc(e)) : QE(e);
}
function ME(e) {
  return typeof e == "function" ? e : e == null ? ac : typeof e == "object" ? In(e) ? $E(e[0], e[1]) : CE(e) : LE(e);
}
function TE(e) {
  return function(t, n, i) {
    for (var l = -1, a = Object(t), r = i(t), s = r.length; s--; ) {
      var o = r[++l];
      if (n(a[o], o, a) === !1)
        break;
    }
    return t;
  };
}
var _E = TE();
function AE(e, t) {
  return e && _E(e, t, qh);
}
function RE(e, t) {
  return function(n, i) {
    if (n == null)
      return n;
    if (!sc(n))
      return e(n, i);
    for (var l = n.length, a = -1, r = Object(n); ++a < l && i(r[a], a, r) !== !1; )
      ;
    return n;
  };
}
var ZE = RE(AE);
function IE(e, t) {
  var n = -1, i = sc(e) ? Array(e.length) : [];
  return ZE(e, function(l, a, r) {
    i[++n] = t(l, a, r);
  }), i;
}
function DE(e, t) {
  var n = e.length;
  for (e.sort(t); n--; )
    e[n] = e[n].value;
  return e;
}
function BE(e, t) {
  if (e !== t) {
    var n = e !== void 0, i = e === null, l = e === e, a = ts(e), r = t !== void 0, s = t === null, o = t === t, u = ts(t);
    if (!s && !u && !a && e > t || a && r && o && !s && !u || i && r && o || !n && o || !l)
      return 1;
    if (!i && !a && !u && e < t || u && n && l && !i && !a || s && n && l || !r && l || !o)
      return -1;
  }
  return 0;
}
function EE(e, t, n) {
  for (var i = -1, l = e.criteria, a = t.criteria, r = l.length, s = n.length; ++i < r; ) {
    var o = BE(l[i], a[i]);
    if (o) {
      if (i >= s)
        return o;
      var u = n[i];
      return o * (u == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
function zE(e, t, n) {
  t.length ? t = bo(t, function(a) {
    return In(a) ? function(r) {
      return Wh(r, a.length === 1 ? a[0] : a);
    } : a;
  }) : t = [ac];
  var i = -1;
  t = bo(t, oc(ME));
  var l = IE(e, function(a, r, s) {
    var o = bo(t, function(u) {
      return u(a);
    });
    return { criteria: o, index: ++i, value: a };
  });
  return DE(l, function(a, r) {
    return EE(a, r, n);
  });
}
var HE = HZ(function(e, t) {
  if (e == null)
    return [];
  var n = t.length;
  return n > 1 && p9(e, t[0], t[1]) ? t = [] : n > 2 && p9(t[0], t[1], t[2]) && (t = [t[0]]), zE(e, hD(t), []);
});
const jE = { class: "s-smart-search" }, XE = {
  __name: "SSmartSearch",
  props: {
    headers: {
      type: Array,
      default: () => [],
      description: 'data table  header  .  : { title: "", key: "" }'
    },
    excludeSearchHeaders: {
      type: Array,
      default: () => [],
      description: "    "
    },
    multiple: {
      type: Boolean,
      default: !0
    },
    placeholder: {
      type: String,
      default: " . (Key:Value)"
    },
    items: {
      type: Array,
      default: () => []
    },
    density: {
      type: String,
      default: "comfortable"
    },
    variant: {
      type: String,
      default: "outlined"
    },
    width: {
      type: [Number, String],
      default: 350
    },
    searchTag: {
      type: Boolean,
      default: !1,
      description: "tag     . true  items  tag  headers ."
    },
    prependInnerIcon: {
      type: String,
      default: "mdi-magnify"
    },
    modelValue: {
      type: Array,
      default: () => []
    }
  },
  emits: ["update:model-value", "update:key", "update:target-item"],
  setup(e, { emit: t }) {
    const n = e, i = t, l = z(null), a = z(!1), r = z(!1), s = z(null), o = Xt(n.modelValue), u = z(null), c = Xt({
      closeOnClick: !1,
      closeOnContentClick: !1
    }), d = () => {
      l.value = null, a.value = !1, r.value = !1;
    }, f = (w) => {
      w || d(), l.value = w;
    }, h = (w) => {
      var L;
      const y = /* @__PURE__ */ new Set();
      return (L = n.items) != null && L.length && n.items.forEach((k) => {
        var S;
        (S = k.tagList) != null && S.length && k.tagList.forEach((P) => {
          const T = P[w];
          T == null || T === "" || T === "-" ? y.add("-") : y.add(T);
        });
      }), Array.from(y);
    }, g = (w, y) => {
      var k;
      const L = /* @__PURE__ */ new Map();
      return (k = n.items) != null && k.length && n.items.forEach((S) => {
        var P;
        (P = S.tagList) != null && P.length && S.tagList.forEach((T) => {
          const _ = T[w], D = T[y], N = _ == null || _ === "" || _ === "-" ? "-" : _, K = D == null || D === "" || D === "-" ? "-" : D, E = L.get(N) || [];
          E.push(K), L.set(N, E);
        });
      }), Object.fromEntries(L);
    }, v = (w, y) => {
      const L = [], k = /* @__PURE__ */ new Set();
      return w.forEach((S) => {
        let P = S;
        S == null || S === "" || S === "-" ? P = "-" : (typeof S == "object" || Array.isArray(S)) && (P = JSON.stringify(S)), k.has(P) || (k.add(P), L.push({
          title: String(P),
          value: String(P),
          type: y
        }));
      }), L;
    }, p = C(() => {
      var y, L;
      let w = [];
      if (r.value) {
        const k = (y = l.value) == null ? void 0 : y.split(":")[0];
        k && w.push({
          subheader: k,
          title: ""
        });
        const S = g("tagKey", "tagValue");
        return w = w.concat(
          v(S[k], "tag")
        ), w;
      }
      if (a.value) {
        if (!n.items.length)
          return [];
        const k = /* @__PURE__ */ new Set();
        n.items.forEach((T) => {
          const _ = T[s.value];
          _ == null || _ === "" || _ === "-" ? k.add("-") : k.add(_);
        });
        const S = t7(k), P = (L = l.value) == null ? void 0 : L.split(":")[0];
        return P && w.push({
          subheader: P,
          title: ""
        }), w = w.concat(v(S)), w;
      }
      return w.push({ subheader: "", title: "" }), n.headers.forEach((k) => {
        k.title && !n.excludeSearchHeaders.includes(k.key) && w.push(k);
      }), n.searchTag && (w.push({ subheader: "", title: "" }), w = w.concat(
        v(h("tagKey"), "tag")
      )), w;
    }), O = (w, y, L) => {
      var T, _, D;
      const k = y.toLowerCase(), S = (k == null ? void 0 : k.split(":")) || [];
      let P = "";
      return L.raw.subheader ? !0 : ((S == null ? void 0 : S.length) > 1 ? P = S[1].trim().toLowerCase() : P = k.trim().toLowerCase(), typeof (L == null ? void 0 : L.value) == "string" ? ((T = L == null ? void 0 : L.value) == null ? void 0 : T.toLowerCase().indexOf(P.toLowerCase())) > -1 : ((D = (_ = L == null ? void 0 : L.value) == null ? void 0 : _.value) == null ? void 0 : D.toLowerCase().indexOf(P.toLowerCase())) > -1);
    }, b = (w) => {
      var T, _, D;
      if (!w)
        return { result: !1, findTitle: "", findKey: "" };
      let y = "", L = "";
      const k = (T = w.toString()) == null ? void 0 : T.split(":")[0].trim().toLowerCase(), S = [...n.headers];
      let P = !1;
      return P = S.some((N) => {
        const K = typeof N.title == typeof {} ? N.title.value : N.title, E = typeof N.key == typeof {} ? N.key.value : N.key;
        return K.toLowerCase() === k ? (y = K, L = E, !0) : !1;
      }), P || (P = S.some((N) => {
        const K = typeof N.title == typeof {} ? N.title.value : N.title, E = typeof N.key == typeof {} ? N.key.value : N.key;
        return K.toLowerCase().indexOf(k) > -1 && k.length >= 2 ? (y = K, L = E, !0) : !1;
      })), P || (y = (_ = w.toString()) == null ? void 0 : _.split(":")[0].trim(), L = (D = w.toString()) == null ? void 0 : D.split(":")[0].trim(), r.value = !0), { result: P, findTitle: y, findKey: L };
    }, V = (w) => {
      w || d();
    }, $ = (w) => {
      const { findKey: y, findTitle: L } = b(w);
      s.value = y, i("update:key", y), l.value = `${L}:`, a.value = !0;
    }, x = (w, y, L, k) => {
      var K, E, I;
      console.log(w.key, y, L, k);
      let S = "";
      if (!y)
        return;
      const P = ((K = l.value) == null ? void 0 : K.split(":")) || [], T = k || (y == null ? void 0 : y.toString().trim());
      a.value ? S = P.length ? `${P[0]}: ${T}` : "" : S = P.length && P[0].trim() ? P[0] : y == null ? void 0 : y.toString().trim();
      const _ = ((E = l.value) == null ? void 0 : E.split(":")) || [], { findTitle: D, findKey: N } = b(_[0]);
      if (a.value && T) {
        if (T) {
          const Z = {
            title: D,
            value: T,
            //  options value 
            key: N,
            type: r.value ? "tag" : null
          };
          o.push(Z), i("update:model-value", o), i("update:target-item", Z), setTimeout(() => {
            c.closeOnClick = !1, c.closeOnContentClick = !1;
          }, 500), d();
          return;
        }
      } else {
        if (c.closeOnClick = !0, c.closeOnContentClick = !0, s.value = (I = n.headers.find((Z) => Z.title === y)) == null ? void 0 : I.key, a.value = !0, L === "tag" && (r.value = !0), S) {
          $(S);
          return;
        }
        setTimeout(() => {
          c.closeOnClick = !1, c.closeOnContentClick = !1;
        }, 500);
      }
      u.value && (u.value.search = "");
    }, Q = () => {
      o.push({ title: " ", value: "-", key: "undefinedTag", type: "tag" }), i("update:model-value", o), u.value && (u.value.search = "");
    }, M = (w) => {
      o.splice(w, 1), i("update:model-value", o);
    };
    return (w, y) => {
      const L = ae("v-list-subheader"), k = ae("v-list-item"), S = ae("v-autocomplete"), P = ae("v-chip"), T = ae("v-chip-group");
      return j(), ne("div", jE, [
        m(S, {
          ref_key: "autoComp",
          ref: u,
          class: "s-smart-search",
          style: on({ width: e.width + "px" }),
          "closable-chips": "",
          multiple: e.multiple,
          density: e.density,
          variant: e.variant,
          items: p.value,
          search: l.value,
          "custom-filter": O,
          placeholder: e.placeholder,
          "menu-props": c,
          "hide-details": "",
          "prepend-inner-icon": e.prependInnerIcon,
          onInput: V,
          "onUpdate:search": f,
          onKeyup: Pr(_t(x, ["stop"]), ["enter"])
        }, Gi({
          item: W(({ item: _ }) => {
            var D;
            return [
              _.raw.subheader ? (j(), ne(le, { key: 0 }, [
                m(L, { class: "s-list-subheader" }, {
                  default: W(() => [
                    ke(he(_.raw.subheader), 1)
                  ]),
                  _: 2
                }, 1024),
                y[1] || (y[1] = G("hr", null, null, -1))
              ], 64)) : (j(), xe(k, {
                key: 1,
                title: (D = _ == null ? void 0 : _.props) == null ? void 0 : D.title,
                onClick: (N) => x(N, _ == null ? void 0 : _.raw.title, _ == null ? void 0 : _.raw.type, _ == null ? void 0 : _.raw.value)
              }, null, 8, ["title", "onClick"]))
            ];
          }),
          _: 2
        }, [
          e.searchTag ? {
            name: "append-item",
            fn: W(() => [
              Ae(w.$slots, "null-tag", {}, () => [
                m(L, null, {
                  default: W(() => y[2] || (y[2] = [
                    ke("  ")
                  ])),
                  _: 1
                }),
                y[4] || (y[4] = G("hr", null, null, -1)),
                m(k, { onClick: Q }, {
                  default: W(() => y[3] || (y[3] = [
                    ke(" ")
                  ])),
                  _: 1
                })
              ], !0)
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["style", "multiple", "density", "variant", "items", "search", "placeholder", "menu-props", "prepend-inner-icon", "onKeyup"]),
        Je(m(T, null, {
          default: W(() => [
            (j(!0), ne(le, null, vt(o, (_, D) => (j(), xe(P, {
              key: "smart-search__value--" + _.title + "__" + _.value,
              closable: "",
              onMousedown: y[0] || (y[0] = _t(() => {
              }, ["prevent"])),
              "onClick:close": (N) => M(D)
            }, {
              default: W(() => [
                G("strong", null, he(_.title), 1),
                ke(" : " + he(_.value), 1)
              ]),
              _: 2
            }, 1032, ["onClick:close"]))), 128))
          ]),
          _: 1
        }, 512), [
          [xn, o.length]
        ])
      ]);
    };
  }
}, NE = /* @__PURE__ */ bt(XE, [["__scopeId", "data-v-75f1b0e8"]]), qE = { class: "s-smart-search" }, YE = {
  __name: "SSmartSearchServer",
  props: {
    headers: {
      type: Array,
      default: () => [],
      description: 'data table  header  .  : { title: "", key: "" }'
    },
    excludeSearchHeaders: {
      type: Array,
      default: () => [],
      description: "    "
    },
    multiple: {
      type: Boolean,
      default: !0
    },
    placeholder: {
      type: String,
      default: " . (Key:Value)"
    },
    density: {
      type: String,
      default: "default",
      description: "input "
    },
    variant: {
      type: String,
      default: "filled",
      description: "input "
    },
    width: {
      type: [Number, String],
      default: 350,
      description: "input "
    },
    searchTag: {
      type: Boolean,
      default: !1,
      description: "tag     . true  items  tag  headers ."
    },
    prependInnerIcon: {
      type: String,
      default: void 0,
      description: "prependInnerIcon "
    },
    modelValue: {
      type: Array,
      default: () => [],
      description: "  "
    },
    valueItems: {
      type: Array,
      default: () => [],
      description: "      "
    },
    tagItems: {
      type: Array,
      default: () => [],
      description: "    "
    }
  },
  emits: ["update:model-value", "update:key", "update:target-item"],
  setup(e, { emit: t }) {
    const n = e, i = t, l = z(null), a = z(!1), r = z(!1), s = z(null), o = Xt(n.modelValue), u = z(null), c = Xt({
      closeOnClick: !1,
      closeOnContentClick: !1
    }), d = () => {
      l.value = null, a.value = !1, r.value = !1;
    }, f = (y) => {
      y || d(), l.value = y;
    }, h = (y) => {
      var k;
      const L = /* @__PURE__ */ new Set();
      return (k = n.tagItems) != null && k.length && n.tagItems.forEach((S) => {
        var P;
        (P = S.tagList) != null && P.length && S.tagList.forEach((T) => {
          T[y] !== null && L.add(T[y]);
        });
      }), Array.from(L);
    }, g = (y, L) => {
      var S;
      const k = /* @__PURE__ */ new Map();
      return (S = n.tagItems) != null && S.length && n.tagItems.forEach((P) => {
        var T;
        (T = P.tagList) != null && T.length && P.tagList.forEach((_) => {
          const D = k.get(_[y]) || [];
          _[L] !== null && D.push(_[L]), k.set(_[y], D);
        });
      }), Object.fromEntries(k);
    }, v = (y, L) => {
      const k = [];
      return y.forEach((S) => {
        let P = S;
        (typeof S == "object" || Array.isArray(S)) && (P = JSON.stringify(S)), console.log("formattedValue", P), k.push({
          title: String(P),
          value: String(P),
          type: L
        });
      }), k;
    }, p = (y) => {
      if (y.length === 2 && (y[0].title === "Y" || y[0].title === "N"))
        return items.sort((S, P) => P.title.localeCompare(S.title));
      const L = y.filter((S) => typeof S.title == "string"), k = y.filter((S) => typeof S.title == "number");
      return L.sort(
        (S, P) => S.title.localeCompare(P.title, void 0, { sensitivity: "base" })
      ), k.sort((S, P) => P.title - S.title), [...L, ...k];
    }, O = C(() => {
      var L, k;
      let y = [];
      if (r.value) {
        const S = (L = l.value) == null ? void 0 : L.split(":")[0];
        S && y.push({
          subheader: S,
          title: ""
        });
        const P = g("tagKey", "tagValue");
        return y = y.concat(
          v(P[S], "tag")
        ), y;
      }
      if (a.value) {
        if (!n.valueItems.length)
          return [];
        const S = /* @__PURE__ */ new Set();
        n.valueItems.forEach((D) => {
          S.add(D.value);
        });
        const P = (k = l.value) == null ? void 0 : k.split(":")[0];
        P && y.push({
          subheader: P,
          title: ""
        }), console.log("setFilterDatas", S);
        const T = t7(S), _ = p(v(T));
        return y = y.concat(_), y;
      }
      return y.push({ subheader: "", title: "" }), n.headers.forEach((S) => {
        S.align !== "d-none" && S.title && !n.excludeSearchHeaders.includes(S.key) && y.push(S);
      }), n.searchTag && (y.push({ subheader: "", title: "" }), y = y.concat(
        v(h("tagKey"), "tag")
      )), console.log(y), y;
    }), b = (y, L, k) => {
      var _, D, N;
      const S = L.toLowerCase(), P = (S == null ? void 0 : S.split(":")) || [];
      let T = "";
      return k.raw.subheader ? !0 : ((P == null ? void 0 : P.length) > 1 ? T = P[1].trim().toLowerCase() : T = S.trim().toLowerCase(), typeof (k == null ? void 0 : k.value) == "string" ? ((_ = k == null ? void 0 : k.value) == null ? void 0 : _.toLowerCase().indexOf(T.toLowerCase())) > -1 : ((N = (D = k == null ? void 0 : k.value) == null ? void 0 : D.value) == null ? void 0 : N.toLowerCase().indexOf(T.toLowerCase())) > -1);
    }, V = (y) => {
      var T;
      if (!y)
        return { result: !1, findTitle: "", findKey: "" };
      let L = "", k = "";
      y = (T = y.toString()) == null ? void 0 : T.split(":")[0].trim().toLowerCase();
      const S = n.headers;
      HE(S, "title");
      const P = S.some((_) => {
        const D = typeof _.title == typeof {} ? _.title.value : _.title, N = typeof _.key == typeof {} ? _.key.value : _.key;
        return D.toLowerCase() === y || D.toLowerCase().indexOf(y) > -1 ? (L = D, k = N, _) : !1;
      });
      return P || (L = y, k = y, r.value = !0), { result: P, findTitle: L, findKey: k };
    }, $ = (y) => {
      y || d();
    }, x = (y) => {
      const { findKey: L, findTitle: k } = V(y);
      s.value = L, i("update:key", L), l.value = `${k}:`, a.value = !0;
    }, Q = (y, L, k) => {
      var K, E, I, Z, Y;
      console.log(y.key, L, k);
      let S = "";
      if (!L)
        return;
      const P = ((K = l.value) == null ? void 0 : K.split(":")) || [], T = (P == null ? void 0 : P.length) > 1 && ((E = P[1]) != null && E.trim()) ? l.value.replace(`${(I = l.value) == null ? void 0 : I.split(":")[0]}:`, "") : L == null ? void 0 : L.toString().trim();
      a.value ? S = P.length ? `${P[0]}: ${T}` : "" : S = P.length && P[0].trim() ? P[0] : L == null ? void 0 : L.toString().trim();
      const _ = ((Z = l.value) == null ? void 0 : Z.split(":")) || [], { findTitle: D, findKey: N } = V(_[0]);
      if (a.value && T) {
        if (T) {
          const ce = {
            title: D,
            value: T.trim(),
            key: N,
            type: r.value ? "tag" : null
          };
          o.push(ce), i("update:model-value", o), i("update:target-item", ce), setTimeout(() => {
            c.closeOnClick = !1, c.closeOnContentClick = !1;
          }, 500), d();
          return;
        }
      } else {
        if (c.closeOnClick = !0, c.closeOnContentClick = !0, s.value = (Y = n.headers.find((ce) => ce.title === L)) == null ? void 0 : Y.key, a.value = !0, k === "tag" && (r.value = !0), S) {
          x(S);
          return;
        }
        setTimeout(() => {
          c.closeOnClick = !1, c.closeOnContentClick = !1;
        }, 500);
      }
      u.value && (u.value.search = "");
    }, M = () => {
      o.push({ title: " ", value: "-", key: "undefinedTag", type: "tag" }), i("update:model-value", o), u.value && (u.value.search = "");
    }, w = (y) => {
      o.splice(y, 1), i("update:model-value", o);
    };
    return (y, L) => {
      const k = ae("v-list-subheader"), S = ae("v-list-item"), P = ae("v-autocomplete"), T = ae("v-chip"), _ = ae("v-chip-group");
      return j(), ne("div", qE, [
        m(P, {
          ref_key: "autoComp",
          ref: u,
          class: "s-smart-search",
          style: on({ width: e.width + "px" }),
          "closable-chips": "",
          multiple: e.multiple,
          density: e.density,
          variant: e.variant,
          items: O.value,
          search: l.value,
          "custom-filter": b,
          placeholder: e.placeholder,
          "menu-props": c,
          "hide-details": "",
          "prepend-inner-icon": e.prependInnerIcon,
          onInput: $,
          "onUpdate:search": f,
          onKeyup: Pr(_t(Q, ["stop"]), ["enter"])
        }, Gi({
          item: W(({ item: D }) => {
            var N;
            return [
              D.raw.subheader ? (j(), ne(le, { key: 0 }, [
                m(k, { class: "s-list-subheader" }, {
                  default: W(() => [
                    ke(he(D.raw.subheader), 1)
                  ]),
                  _: 2
                }, 1024),
                L[0] || (L[0] = G("hr", null, null, -1))
              ], 64)) : (j(), xe(S, {
                key: 1,
                title: (N = D == null ? void 0 : D.props) == null ? void 0 : N.title,
                onClick: (K) => Q(K, D == null ? void 0 : D.raw.title, D == null ? void 0 : D.raw.type)
              }, null, 8, ["title", "onClick"]))
            ];
          }),
          _: 2
        }, [
          e.searchTag ? {
            name: "append-item",
            fn: W(() => [
              Ae(y.$slots, "null-tag", {}, () => [
                m(k, null, {
                  default: W(() => L[1] || (L[1] = [
                    ke("  ")
                  ])),
                  _: 1
                }),
                L[3] || (L[3] = G("hr", null, null, -1)),
                m(S, { onClick: M }, {
                  default: W(() => L[2] || (L[2] = [
                    ke(" ")
                  ])),
                  _: 1
                })
              ], !0)
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["style", "multiple", "density", "variant", "items", "search", "placeholder", "menu-props", "prepend-inner-icon", "onKeyup"]),
        Je(m(_, null, {
          default: W(() => [
            (j(!0), ne(le, null, vt(o, (D, N) => (j(), xe(T, {
              key: "smart-search__value--" + D.title + "__" + D.value,
              closable: "",
              "onClick:close": (K) => w(N)
            }, {
              default: W(() => [
                G("strong", null, he(D.title), 1),
                ke(" : " + he(D.value), 1)
              ]),
              _: 2
            }, 1032, ["onClick:close"]))), 128))
          ]),
          _: 1
        }, 512), [
          [xn, o.length]
        ])
      ]);
    };
  }
}, FE = /* @__PURE__ */ bt(YE, [["__scopeId", "data-v-b7c8a9ed"]]), WE = { class: "progress-stages" }, UE = { class: "d-flex align-center" }, GE = { class: "stage-title" }, KE = { class: "sub-stages" }, JE = { class: "d-flex align-center justify-space-between" }, ez = {
  key: 0,
  class: "sub-stage-children"
}, tz = {
  __name: "SProgressStages",
  props: {
    stages: {
      type: Array,
      required: !0
    }
  },
  setup(e) {
    const t = z([]), n = (o) => {
      const u = t.value.indexOf(o);
      u === -1 ? t.value.push(o) : t.value.splice(u, 1);
    }, i = (o) => ({
      "stage-header--completed": o.status === "completed",
      "stage-header--in-progress": o.status === "in-progress",
      "stage-header--pending": o.status === "pending",
      "stage-header--delayed": o.status === "delayed"
    }), l = (o) => ({
      "sub-stage-item--completed": o.status === "completed",
      "sub-stage-item--in-progress": o.status === "in-progress",
      "sub-stage-item--pending": o.status === "pending",
      "sub-stage-item--delayed": o.status === "delayed"
    }), a = (o) => {
      switch (o) {
        case "completed":
          return "mdi-check-circle";
        case "in-progress":
          return "mdi-progress-clock";
        default:
          return "mdi-circle-outline";
      }
    }, r = (o) => {
      switch (o) {
        case "completed":
          return "success";
        case "in-progress":
          return "primary";
        default:
          return "grey";
      }
    }, s = (o) => {
      switch (o) {
        case "completed":
          return "#00BA88";
        case "in-progress":
          return "#1297F2";
        default:
          return "#6C6C6C";
      }
    };
    return (o, u) => {
      const c = ae("v-icon"), d = ae("v-expand-transition");
      return j(), ne("div", WE, [
        (j(!0), ne(le, null, vt(e.stages, (f, h) => (j(), ne("div", {
          key: h,
          class: "stage-item"
        }, [
          G("div", {
            class: ct(["stage-header", i(f)])
          }, [
            G("div", UE, [
              m(c, {
                icon: a(f.status),
                color: r(f.status),
                size: "small",
                class: "mr-2"
              }, null, 8, ["icon", "color"]),
              G("span", GE, he(f.title), 1)
            ])
          ], 2),
          G("div", KE, [
            (j(!0), ne(le, null, vt(f.subStages, (g, v) => {
              var p;
              return j(), ne("div", {
                key: `${h}-${v}`,
                class: ct(["sub-stage-item", l(g)])
              }, [
                G("div", JE, [
                  G("span", {
                    style: on({ color: s(g.status) })
                  }, he(g.title), 5),
                  (p = g.children) != null && p.length ? (j(), xe(c, {
                    key: 0,
                    icon: t.value.includes(`${h}-${v}`) ? "mdi-chevron-up" : "mdi-chevron-down",
                    size: "small",
                    onClick: _t((O) => n(`${h}-${v}`), ["stop"])
                  }, null, 8, ["icon", "onClick"])) : _e("", !0)
                ]),
                m(d, null, {
                  default: W(() => {
                    var O;
                    return [
                      t.value.includes(`${h}-${v}`) && ((O = g.children) != null && O.length) ? (j(), ne("div", ez, [
                        (j(!0), ne(le, null, vt(g.children, (b, V) => (j(), ne("div", {
                          key: V,
                          class: ct(["sub-stage-child", l(b)])
                        }, he(b.title), 3))), 128))
                      ])) : _e("", !0)
                    ];
                  }),
                  _: 2
                }, 1024)
              ], 2);
            }), 128))
          ])
        ]))), 128))
      ]);
    };
  }
}, nz = /* @__PURE__ */ bt(tz, [["__scopeId", "data-v-23d6b697"]]), iz = { class: "s-notification__header-box" }, lz = ["onMouseenter", "onClick", "onKeyup"], az = { class: "s-notification__prefix" }, rz = { class: "s-notification__title-wrapper" }, sz = { class: "title--left" }, oz = { class: "s-notification__title" }, uz = { class: "created" }, cz = { class: "s-notification__message-box" }, dz = { class: "s-notification__message" }, fz = { class: "s-notification__delete-box" }, hz = ["onClick"], mz = { class: "s-notification__additional-box" }, gz = {
  key: 1,
  class: "s-notification-no-item"
}, vz = {
  __name: "SNotification",
  props: {
    notificationName: {
      type: String,
      default: "Notifications"
    },
    items: {
      type: Array,
      default: () => []
    },
    noItemText: {
      type: String,
      default: "  ."
    },
    languageCode: {
      type: String,
      default: "ko"
    }
  },
  emits: ["click:delete", "click:content"],
  setup(e, { emit: t }) {
    const n = t, i = e, l = z(!1), a = z(""), r = C(() => (h) => h), s = (h) => {
      switch (h.notificationType) {
        case "SUCCESS":
          return "mdi-check-circle";
        case "ERROR":
          return "mdi-close-octagon";
        default:
          return "mdi-alert-circle";
      }
    }, o = () => {
      l.value = !0;
    }, u = (h) => {
      a.value = h;
    }, c = (h) => {
      n("click:content", h);
    }, d = (h) => {
      n("click:delete", h);
    }, f = (h, g) => {
      if (i.languageCode === "en") {
        const v = `${g}En`;
        return h[v] || h[g];
      }
      return h[g];
    };
    return (h, g) => {
      const v = ae("v-icon");
      return j(), ne("div", {
        class: ct(["s-notification", l.value ? "more" : ""])
      }, [
        G("div", iz, he(e.notificationName), 1),
        e.items.length ? (j(), ne(le, { key: 0 }, [
          G("div", {
            class: ct(["s-notification__contents-box", l.value ? "more" : ""])
          }, [
            (j(!0), ne(le, null, vt(e.items, (p) => (j(), ne("div", {
              class: "s-notification__content",
              key: p.idx,
              onMouseenter: (O) => u(p.notificationIdx),
              onMouseleave: g[0] || (g[0] = (O) => a.value = ""),
              onClick: (O) => c(p),
              onKeyup: Pr((O) => c(p), ["enter"])
            }, [
              G("div", az, [
                m(v, null, {
                  default: W(() => [
                    ke(he(s(p)), 1)
                  ]),
                  _: 2
                }, 1024)
              ]),
              G("div", rz, [
                G("div", sz, [
                  G("div", oz, [
                    G("span", null, he(f(p, "msgTitle")), 1),
                    G("span", uz, he(r.value(p.createdAt) || "-"), 1)
                  ]),
                  G("div", cz, [
                    G("div", dz, [
                      G("div", null, [
                        G("span", null, he(f(p, "msgContent")), 1)
                      ])
                    ]),
                    G("div", fz, [
                      a.value === p.notificationIdx ? (j(), ne("div", {
                        key: 0,
                        class: "s-notification__delete-wrapper",
                        onClick: _t((O) => d(p), ["stop"])
                      }, [
                        m(v, {
                          class: "s-notification__delete-icon",
                          contain: ""
                        }, {
                          default: W(() => g[1] || (g[1] = [
                            ke("mdi-close")
                          ])),
                          _: 1
                        })
                      ], 8, hz)) : _e("", !0)
                    ])
                  ]),
                  G("div", mz, [
                    G("p", null, he(f(p, "msgAdditional")), 1)
                  ])
                ])
              ])
            ], 40, lz))), 128))
          ], 2),
          l.value ? _e("", !0) : (j(), ne("div", {
            key: 0,
            class: "s-notification__footer-box",
            onClick: o,
            onKeypress: o
          }, " ... ", 32))
        ], 64)) : (j(), ne("div", gz, he(e.noItemText), 1))
      ], 2);
    };
  }
}, pz = { class: "s-filter-select__filter" }, Oz = { class: "v-virtual-scroll__item" }, yz = {
  __name: "SFilterSelect",
  props: {
    itemTitle: {
      type: String,
      default: ""
    },
    itemValue: {
      type: String,
      default: ""
    },
    items: {
      type: Array,
      default: () => []
    },
    label: {
      type: String,
      default: ""
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    displayText: {
      type: String,
      default: ""
    },
    hasNullValue: {
      type: Boolean,
      default: !1
    },
    nullTitle: {
      type: String,
      default: "Value is NULL"
    },
    nullValue: {
      type: String,
      default: "NULL"
    },
    density: {
      type: String,
      default: "default"
    },
    variant: {
      type: String,
      default: "filled"
    },
    hideDetails: {
      type: Boolean,
      default: !1
    },
    placeholder: {
      type: String,
      default: ""
    },
    width: {
      type: [String, Number],
      default: 316
    }
  },
  emits: ["update:model-value"],
  setup(e, { emit: t }) {
    const n = e, i = t, l = z(null), a = z([]), r = z([]), s = z(!1), o = () => {
      let v = !1;
      r.value.length && (v = r.value.length === a.value.length), s.value = v;
    };
    ee(
      () => n.items,
      () => {
        a.value = n.items.map((v) => v[n.itemValue] === null ? {
          ...v,
          [n.itemTitle]: n.nullTitle,
          [n.itemValue]: n.nullValue
        } : v), o();
      },
      {
        immediate: !0
      }
    );
    const u = () => {
      n.hasNullValue ? r.value = n.modelValue.filter((v) => v === n.nullValue || v === n.nullValue ? n.hasNullValue ? n.nullValue.includes(l.value.trim().toLowerCase()) : !1 : v !== n.nullValue || v !== n.nullValue ? a.value.map(
        (O) => O[n.itemValue]
      ).includes(v) : !1) : r.value = n.modelValue;
    };
    ee(
      () => l.value,
      () => {
        l.value ? (a.value = n.items.filter((v) => v[n.itemTitle] === n.nullTitle || v[n.itemTitle] === n.nullValue && v[n.itemValue] === n.nullValue ? n.hasNullValue ? n.nullTitle.includes(l.value.trim().toLowerCase()) : !1 : v[n.itemTitle] !== n.nullValue && v[n.itemTitle].toLowerCase().includes(l.value.trim().toLowerCase()) ? !0 : v[n.itemValue] !== n.nullValue ? v[n.itemValue].toLowerCase().includes(l.value.trim().toLowerCase()) : !1), u()) : (a.value = n.items, u()), o();
      }
    ), ee(
      () => n.modelValue,
      () => {
        n.modelValue.length ? r.value = n.modelValue : r.value = [], o();
      }
    );
    const c = (v) => {
      const p = new Map(
        a.value.map((O) => [O[n.itemValue], O])
      );
      r.value = v.filter((O) => p.has(O) || O === n.nullValue);
    }, d = C(() => r.value.length > 0), f = (v) => v.map((p) => p === n.nullValue ? null : p), h = () => {
      const v = new Set(r.value);
      if (s.value)
        r.value.forEach((O) => {
          O !== null ? v.delete(O) : v.delete(n.nullValue);
        });
      else
        try {
          a.value.forEach((O) => {
            O[n.itemValue] ? v.add(O[n.itemValue]) : v.add(n.nullValue);
          });
        } catch (O) {
          console.warn(O);
        }
      const p = Array.from(v);
      c(p), i("update:model-value", f(p));
    }, g = (v) => {
      c(v), i("update:model-value", f(v));
    };
    return (v, p) => {
      const O = ae("v-btn"), b = ae("v-tooltip"), V = ae("v-text-field"), $ = ae("v-divider"), x = ae("v-checkbox-btn"), Q = ae("v-list-item-action"), M = ae("v-list-item"), w = ae("v-list-item-title"), y = ae("v-virtual-scroll"), L = ae("v-list"), k = ae("v-menu");
      return j(), xe(k, {
        class: "s-filter-select",
        "close-on-content-click": !1
      }, {
        activator: W(({ props: S, isActive: P }) => [
          m(b, {
            text: e.displayText,
            location: "end"
          }, {
            activator: W(({ props: T }) => [
              m(O, q({ ...S, ...T }, {
                width: e.width,
                class: "s-filter-select__button",
                variant: "outlined",
                density: e.density,
                "append-icon": P ? "mdi-menu-up" : "mdi-menu-down"
              }), {
                default: W(() => [
                  ke(he(e.displayText), 1)
                ]),
                _: 2
              }, 1040, ["width", "density", "append-icon"])
            ]),
            _: 2
          }, 1032, ["text"])
        ]),
        default: W(() => [
          m(L, {
            "select-strategy": "classic",
            "item-title": n.itemTitle,
            "item-value": n.itemValue,
            items: a.value,
            selected: r.value,
            density: e.density,
            "min-width": "360px",
            "onUpdate:selected": g
          }, {
            default: W(() => [
              G("div", pz, [
                m(V, {
                  class: "s-input__inner my-1 pl-3",
                  density: e.density,
                  variant: "plain",
                  "hide-details": "",
                  placeholder: e.placeholder,
                  modelValue: l.value,
                  "onUpdate:modelValue": p[0] || (p[0] = (S) => l.value = S),
                  "prepend-icon": "mdi-filter"
                }, null, 8, ["density", "placeholder", "modelValue"]),
                m($, { class: "mb-1" }),
                m(M, {
                  title: l.value ? `   ${a.value.length} ` : " ",
                  density: e.density,
                  onClick: h
                }, {
                  prepend: W(() => [
                    m(Q, { start: "" }, {
                      default: W(() => [
                        m(x, {
                          class: "s-filter-select__checkbox-btn",
                          indeterminate: d.value && !s.value,
                          "model-value": s.value,
                          density: e.density
                        }, null, 8, ["indeterminate", "model-value", "density"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["title", "density"]),
                m($, { class: "my-1" })
              ]),
              m(y, {
                items: a.value,
                "max-height": "350"
              }, {
                default: W(({ item: S }) => [
                  G("div", Oz, [
                    e.hasNullValue ? Ae(v.$slots, "null-data", { key: 0 }, () => [
                      [null, n.nullValue].includes(S[n.itemValue]) ? (j(), xe(M, {
                        key: 0,
                        value: e.nullValue,
                        density: e.density
                      }, {
                        prepend: W(({ isActive: P }) => [
                          m(Q, { start: "" }, {
                            default: W(() => [
                              m(x, {
                                class: "s-filter-select__checkbox-btn",
                                "model-value": P,
                                density: e.density
                              }, null, 8, ["model-value", "density"])
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        default: W(() => [
                          m(w, {
                            title: e.nullTitle,
                            density: e.density
                          }, {
                            default: W(() => [
                              ke(he(e.nullTitle), 1)
                            ]),
                            _: 1
                          }, 8, ["title", "density"])
                        ]),
                        _: 1
                      }, 8, ["value", "density"])) : _e("", !0)
                    ], !0) : _e("", !0),
                    [null, n.nullValue].includes(S[n.itemValue]) ? _e("", !0) : (j(), xe(M, {
                      key: 1,
                      value: S[n.itemValue],
                      density: e.density
                    }, {
                      prepend: W(({ isActive: P }) => [
                        m(Q, { start: "" }, {
                          default: W(() => [
                            m(x, {
                              "model-value": P,
                              density: e.density
                            }, null, 8, ["model-value", "density"])
                          ]),
                          _: 2
                        }, 1024)
                      ]),
                      default: W(() => [
                        m(w, {
                          title: S[n.itemTitle],
                          density: e.density
                        }, {
                          default: W(() => [
                            ke(he(S[n.itemTitle]), 1)
                          ]),
                          _: 2
                        }, 1032, ["title", "density"])
                      ]),
                      _: 2
                    }, 1032, ["value", "density"]))
                  ])
                ]),
                _: 3
              }, 8, ["items"])
            ]),
            _: 3
          }, 8, ["item-title", "item-value", "items", "selected", "density"])
        ]),
        _: 3
      });
    };
  }
}, bz = /* @__PURE__ */ bt(yz, [["__scopeId", "data-v-8d69c2ea"]]), Cz = { class: "s-user-setting" }, Sz = { class: "s-user-setting__header-box" }, wz = { class: "s-user-setting__contents-box" }, kz = { class: "s-user-setting__content" }, xz = { class: "s-user-setting__title-wrapper" }, Pz = { class: "s-user-setting__select-wrapper" }, $z = { class: "s-user-setting__content" }, Vz = { class: "s-user-setting__title-wrapper" }, Qz = { class: "s-user-setting__title" }, Lz = { class: "s-user-setting__select-wrapper" }, Mz = { class: "s-user-setting__content" }, Tz = { class: "s-user-setting__title-wrapper" }, _z = { class: "s-user-setting__title" }, Az = { class: "s-user-setting__checkbox-wrapper" }, Rz = {
  __name: "SUserSettings",
  props: {
    languageCode: {
      type: String,
      default: "ko"
    },
    languageList: {
      type: Array,
      default: () => [
        { value: "ko", name: "" },
        { value: "en", name: "English" }
      ]
    },
    costCurrencyCode: {
      type: String,
      default: "krw"
    },
    costCurrencyList: {
      type: Array,
      default: () => [
        { value: "krw", name: "KRW" },
        { value: "usd", name: "USD" }
      ]
    },
    isEmailAlertEnabled: {
      type: Boolean,
      default: !1
    },
    isSlackAlertEnabled: {
      type: Boolean,
      default: !1
    },
    companySlackEnabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:language", "update:currency", "update:email", "update:slack", "get-company-slack-enabled"],
  setup(e, { emit: t }) {
    const n = t, i = e, l = z({
      languageCode: "ko",
      costCurrencyCode: "krw",
      isEmailAlertEnabled: !1,
      isSlackAlertEnabled: !1
    }), a = z({
      title: " ",
      costCurrency: "  ",
      alert: " "
    }), r = () => {
      n("update:language", l.value.languageCode);
    }, s = () => {
      n("update:currency", l.value.costCurrencyCode);
    }, o = () => {
      n("update:email", l.value.isEmailAlertEnabled);
    }, u = () => {
      n("update:slack", l.value.isSlackAlertEnabled);
    }, c = (f) => {
      f === "en" ? (a.value.title = "User Settings", a.value.costCurrency = "Cost Currency Settings", a.value.alert = "Alert Settings") : (a.value.title = " ", a.value.costCurrency = "  ", a.value.alert = " ");
    }, d = () => {
      n("get-company-slack-enabled"), console.log("checkCompanySlackEnabled");
    };
    return it(() => {
      l.value = {
        languageCode: i.languageCode || "ko",
        costCurrencyCode: i.costCurrencyCode || "krw",
        isEmailAlertEnabled: i.isEmailAlertEnabled || !1,
        isSlackAlertEnabled: i.isSlackAlertEnabled || !1
      }, c(i.languageCode), d();
    }), (f, h) => {
      const g = ae("v-select"), v = ae("v-checkbox");
      return j(), ne("div", Cz, [
        G("div", Sz, [
          G("span", null, he(a.value.title), 1)
        ]),
        G("div", wz, [
          G("div", kz, [
            G("div", xz, [
              h[4] || (h[4] = G("div", { class: "s-user-setting__title" }, [
                G("span", null, " /Language ")
              ], -1)),
              G("div", Pz, [
                m(g, {
                  variant: "outlined",
                  itemTitle: "name",
                  itemValue: "value",
                  items: e.languageList,
                  modelValue: l.value.languageCode,
                  "onUpdate:modelValue": [
                    h[0] || (h[0] = (p) => l.value.languageCode = p),
                    r
                  ]
                }, null, 8, ["items", "modelValue"])
              ])
            ])
          ]),
          G("div", $z, [
            G("div", Vz, [
              G("div", Qz, [
                G("span", null, he(a.value.costCurrency), 1)
              ]),
              G("div", Lz, [
                m(g, {
                  variant: "outlined",
                  itemTitle: "name",
                  itemValue: "value",
                  items: e.costCurrencyList,
                  modelValue: l.value.costCurrencyCode,
                  "onUpdate:modelValue": [
                    h[1] || (h[1] = (p) => l.value.costCurrencyCode = p),
                    s
                  ]
                }, null, 8, ["items", "modelValue"])
              ])
            ])
          ]),
          G("div", Mz, [
            G("div", Tz, [
              G("div", _z, [
                G("span", null, he(a.value.alert), 1)
              ]),
              G("div", Az, [
                m(v, {
                  class: "table-checkbox",
                  "hide-details": "",
                  modelValue: l.value.isEmailAlertEnabled,
                  "onUpdate:modelValue": h[2] || (h[2] = (p) => l.value.isEmailAlertEnabled = p),
                  label: "Email",
                  onChange: o
                }, null, 8, ["modelValue"]),
                m(v, {
                  class: "table-checkbox",
                  "hide-details": "",
                  disabled: !e.companySlackEnabled,
                  modelValue: l.value.isSlackAlertEnabled,
                  "onUpdate:modelValue": h[3] || (h[3] = (p) => l.value.isSlackAlertEnabled = p),
                  label: "Slack",
                  onChange: u
                }, null, 8, ["disabled", "modelValue"])
              ])
            ])
          ])
        ])
      ]);
    };
  }
}, Zz = { class: "text-break" }, a7 = {
  __name: "SSimpleTooltip",
  props: {
    title: {
      type: String,
      default: null
    },
    text: {
      type: String,
      default: null
    },
    titleWidth: {
      type: [Number, String],
      default: null
    },
    maxWidth: {
      type: [Number, String],
      default: 500
    }
  },
  setup(e) {
    const t = e, n = C(() => t.text || t.title), i = C(
      () => t.titleWidth ? `${t.titleWidth}px` : ""
    );
    return (l, a) => {
      const r = ae("v-tooltip");
      return j(), xe(r, {
        location: "bottom",
        "max-width": t.maxWidth
      }, {
        activator: W(({ props: s }) => [
          G("span", q(s, {
            class: "d-inline-block text-truncate",
            style: { width: i.value }
          }), he(t.title), 17)
        ]),
        default: W(() => [
          G("span", Zz, he(n.value), 1)
        ]),
        _: 1
      }, 8, ["max-width"]);
    };
  }
}, Iz = { class: "s-detail-tooltip" }, Dz = { class: "label" }, Bz = {
  class: "label--text",
  variant: "plain"
}, Ez = { key: 1 }, zz = { class: "detail-item mr-2" }, Hz = {
  __name: "SDetailTooltip",
  props: {
    label: { type: String, default: "Label" },
    //   
    itemId: { type: String, default: "" },
    // v-for key  Item  
    itemName: { type: String, default: "" },
    // Item  
    list: { type: Array, default: () => [] },
    //   
    icon: { type: String, default: "" },
    //     
    itemClick: { type: Function, default: () => {
    } },
    //    
    copyText: { type: Function, default: (e) => {
      new Function(e);
    } }
    //      
  },
  setup(e) {
    const t = (/* @__PURE__ */ new Date()).getTime().toString(), n = e, i = z(!1), l = () => {
      i.value = !i.value, i.value && He(() => {
        a();
      });
    }, a = () => {
      const o = document.querySelector(".s-detail-tooltip__content");
      if (!o) return;
      const u = o.getBoundingClientRect(), c = window.innerWidth, d = window.innerHeight;
      let f = 0, h = 0;
      u.right > c - 20 && (f = c - u.right - 20), u.left < 20 && (f = 20 - u.left), u.bottom > d - 20 && (h = d - u.bottom - 20), o.style.transform = `translate(${f}px, ${h}px)`;
    };
    ee(i, (o, u) => {
      var c;
      o && !((c = n.list) != null && c.length) && (i.value = u);
    });
    const r = () => {
      i.value && a();
    };
    it(() => {
      window.addEventListener("resize", r);
    }), ef(() => {
      window.removeEventListener("resize", r);
    });
    const s = C(() => (o) => typeof o == typeof {} ? `${o[n.itemName] || "-"} / ${o[n.itemId]}` : o);
    return (o, u) => {
      const c = ae("v-icon"), d = ae("v-chip"), f = ae("v-card"), h = ae("v-overlay");
      return j(), ne("section", Iz, [
        G("div", Dz, [
          G("a", Bz, [
            n.label === "Label" ? (j(), xe(c, {
              key: 0,
              icon: "mdi-dots-vertical"
            })) : (j(), ne("span", Ez, he(n.label), 1)),
            m(h, {
              absolute: "",
              modelValue: i.value,
              "onUpdate:modelValue": u[0] || (u[0] = (g) => i.value = g),
              activator: "parent",
              scrim: "",
              "location-strategy": "connected",
              "scroll-strategy": "reposition"
            }, {
              default: W(() => [
                i.value ? (j(), xe(f, {
                  key: 0,
                  class: "s-detail-tooltip__content"
                }, {
                  default: W(() => [
                    m(c, {
                      class: "close-Btn",
                      icon: "mdi-close",
                      onClick: l
                    }),
                    (j(!0), ne(le, null, vt(n.list, (g, v) => (j(), xe(d, {
                      key: n.keyId || v,
                      variant: "text",
                      size: "small"
                    }, {
                      default: W(() => [
                        G("span", zz, [
                          m(a7, {
                            uuid: Me(t),
                            title: s.value(g),
                            text: s.value(g),
                            titleWidth: "360"
                          }, null, 8, ["uuid", "title", "text"])
                        ]),
                        n.icon !== "" ? (j(), xe(c, {
                          key: 0,
                          icon: n.icon,
                          onClick: (p) => n.icon === "mdi-content-copy" ? e.copyText(g) : n.itemClick(g)
                        }, null, 8, ["icon", "onClick"])) : _e("", !0)
                      ]),
                      _: 2
                    }, 1024))), 128))
                  ]),
                  _: 1
                })) : _e("", !0)
              ]),
              _: 1
            }, 8, ["modelValue"])
          ])
        ])
      ]);
    };
  }
}, jz = { class: "list-input-wrapper" }, Xz = { key: 0 }, Nz = {
  __name: "SListInput",
  props: /* @__PURE__ */ So({
    headers: {
      type: Array,
      default: () => []
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    errorMessages: {
      type: Array,
      default: () => []
    }
  }, {
    modelValue: {
      type: Array,
      default: []
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ So(["update:model-value"], ["update:modelValue"]),
  setup(e, { expose: t, emit: n }) {
    const i = n, l = e, a = z(0), r = tf(e, "modelValue"), s = C(() => ({
      gridTemplateColumns: `${Array.from({ length: l.headers.length }, () => "1fr").join(" ")} 40px`
    })), o = C(() => {
      const g = l.headers.map((p) => p.key), v = {};
      return g.forEach((p) => {
        v[p] = null;
      }), {
        idx: a.value,
        ...v
      };
    }), u = (g, v) => typeof g.items == "function" ? g.items(v) : g.items, c = (g) => {
      const v = r.value.findIndex((p) => p.idx === g);
      r.value.splice(v, 1);
    }, d = () => {
      r.value.push(o.value), a.value += 1;
    }, f = z(null), h = async () => {
      const { valid: g, errors: v } = await f.value.validate();
      return { valid: g, errors: v };
    };
    return it(() => {
      r.value = l.modelValue;
    }), ee(
      () => r.value,
      (g) => {
        i("update:model-value", g);
      },
      { deep: !0 }
    ), t({ validate: h }), (g, v) => {
      const p = ae("v-col"), O = ae("v-icon"), b = ae("v-row"), V = ae("v-select"), $ = ae("v-text-field"), x = ae("v-form");
      return j(), ne("div", jz, [
        m(b, {
          class: "list-input-header list-input-row",
          dense: "",
          "no-gutters": "",
          style: on(s.value)
        }, {
          default: W(() => [
            (j(!0), ne(le, null, vt(e.headers, (Q, M) => (j(), xe(p, {
              key: M,
              class: "list-input-col"
            }, {
              default: W(() => [
                ke(he(Q.title), 1)
              ]),
              _: 2
            }, 1024))), 128)),
            e.readonly ? _e("", !0) : (j(), xe(p, {
              key: 0,
              class: "list-input-col icon-col"
            }, {
              default: W(() => [
                m(O, {
                  icon: "mdi-plus-circle",
                  color: "#666666",
                  onClick: d
                })
              ]),
              _: 1
            }))
          ]),
          _: 1
        }, 8, ["style"]),
        m(x, {
          ref_key: "formRef",
          ref: f
        }, {
          default: W(() => [
            (j(!0), ne(le, null, vt(r.value, (Q, M) => (j(), xe(b, {
              key: Q.idx,
              class: "list-input-row list-input-content",
              style: on(s.value),
              dense: "",
              "no-gutters": ""
            }, {
              default: W(() => [
                (j(!0), ne(le, null, vt(e.headers, (w, y) => (j(), xe(p, {
                  key: "row-" + Q.idx + "col-" + y,
                  class: "list-input-col"
                }, {
                  default: W(() => [
                    e.readonly ? (j(), ne("span", Xz, he(Q[w.key] || "-"), 1)) : (j(), ne(le, { key: 1 }, [
                      w.type === "select" ? (j(), xe(V, {
                        key: 0,
                        modelValue: Q[w.key],
                        "onUpdate:modelValue": (L) => Q[w.key] = L,
                        density: "compact",
                        variant: "outlined",
                        "hide-details": "",
                        "item-title": w.itemTitle,
                        "item-value": w.itemValue,
                        items: u(w, M),
                        placeholder: w.placeholder,
                        rules: w.rules
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "item-title", "item-value", "items", "placeholder", "rules"])) : (j(), xe($, {
                        key: 1,
                        modelValue: Q[w.key],
                        "onUpdate:modelValue": (L) => Q[w.key] = L,
                        density: "compact",
                        variant: "outlined",
                        "hide-details": "",
                        rules: w.rules,
                        placeholder: w.placeholder
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "rules", "placeholder"]))
                    ], 64))
                  ]),
                  _: 2
                }, 1024))), 128)),
                e.readonly ? _e("", !0) : (j(), xe(p, {
                  key: 0,
                  class: "list-input-col icon-col"
                }, {
                  default: W(() => [
                    m(O, {
                      icon: "mdi-minus-circle",
                      color: "#999999",
                      onClick: (w) => c(Q.idx)
                    }, null, 8, ["onClick"])
                  ]),
                  _: 2
                }, 1024))
              ]),
              _: 2
            }, 1032, ["style"]))), 128))
          ]),
          _: 1
        }, 512)
      ]);
    };
  }
}, qz = /* @__PURE__ */ bt(Nz, [["__scopeId", "data-v-d9a0ebe8"]]), Yz = { class: "list-controls" }, Fz = {
  __name: "SListControl",
  props: {
    list: { type: Array, default: () => [] },
    perPages: { type: Number, default: 10 },
    perPageList: { type: Array, default: () => null },
    refreshDateTitle: { type: String, default: "Date" },
    density: { type: String, default: "comfortable" }
  },
  emits: ["on-refresh", "set-per-pages"],
  setup(e, { emit: t }) {
    const n = Object.freeze([
      { text: "10", value: 10 },
      { text: "15", value: 15 },
      { text: "20", value: 20 }
    ]), i = t, l = e, a = z(/* @__PURE__ */ new Date()), r = () => {
      i("on-refresh");
    }, s = (u) => {
      i("set-per-pages", u);
    };
    return ee(() => l.list, () => {
      a.value = /* @__PURE__ */ new Date();
    }), (u, c) => {
      const d = ae("v-select");
      return j(), ne("div", Yz, [
        m(r3, {
          "on-click-refresh": r,
          "refresh-date": a.value,
          "refresh-date-title": e.refreshDateTitle
        }, null, 8, ["refresh-date", "refresh-date-title"]),
        m(d, {
          "model-value": e.perPages,
          items: e.perPageList || Me(n),
          "item-title": "text",
          "item-value": "value",
          variant: "outlined",
          density: e.density,
          hideDetails: "auto",
          "onUpdate:modelValue": s
        }, null, 8, ["model-value", "items", "density"])
      ]);
    };
  }
}, Wz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SAccordionMenu: HR,
  SAlert: Zx,
  SAvatar: I6,
  SBtn: rn,
  SCardTable: rR,
  SConfirm: DA,
  SDataTable: mR,
  SDetailTooltip: Hz,
  SEmpty: s3,
  SFileInputBtn: xx,
  SFilterSelect: bz,
  SFooter: _R,
  SFormItem: _A,
  SFormTable: $A,
  SGlobalProgress: UA,
  SHeader: QR,
  SIcon: ru,
  SImg: Nd,
  SKeyValueSelect: Ax,
  SListControl: Fz,
  SListInput: qz,
  SModal: XA,
  SNavi: GR,
  SNotification: vz,
  SProgressCircular: D6,
  SProgressStages: nz,
  SRefreshBtn: r3,
  SScriptEditor: wA,
  SShellScriptInput: wx,
  SSimpleTooltip: a7,
  SSmartSearch: NE,
  SSmartSearchServer: FE,
  SSubHeader: BR,
  STextCheckBoxInput: bx,
  SUserSettings: Rz,
  customTheme: a3
}, Symbol.toStringTag, { value: "Module" })), ua = {
  variant: "outlined",
  density: "compact",
  hideDetails: "auto"
}, iH = _g({
  components: { ...cx, ...Wz },
  directives: Cy,
  icons: {
    defaultSet: "mdi",
    aliases: Pg,
    sets: { mdi: $g }
  },
  theme: { ...a3 },
  defaults: {
    VTextField: { ...ua },
    VSelect: { ...ua },
    VTextarea: { ...ua },
    VSwitch: { ...ua },
    VCheckbox: { ...ua },
    VRadio: { ...ua }
  }
});
export {
  Jh as LOCALSTORAGE_KEY,
  Q7 as PER_PAGES,
  Kz as SESSIONSTORAGE_KEY,
  iH as StratoVuetify,
  Jz as TOKEN_KEY,
  iH as Vuetify,
  k7 as regexUtil,
  q9 as stringUtil,
  Gz as useModal,
  eH as useTablePage
};
